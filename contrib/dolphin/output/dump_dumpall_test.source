create database table_test dbcompatibility 'B';
\c table_test
/*
 * establish objects
 */
-- test for table created by like
drop table if exists table_like_test_1;
NOTICE:  table "table_like_test_1" does not exist, skipping
drop table if exists table_like_test_2;
NOTICE:  table "table_like_test_2" does not exist, skipping
create table table_like_test_1(a int, b text);
create table table_like_test_2 like table_like_test_1;
-- test for table created with index
drop table if exists table_created_with_index_test;
NOTICE:  table "table_created_with_index_test" does not exist, skipping
create table table_created_with_index_test(c1 int, c2 int, c3 int, index create_table_idx_1 using btree(c1 desc, c2 asc) comment 'test_message');
select count(*) from pg_indexes where indexname = 'create_table_idx_1' and tablename = 'table_created_with_index_test';
 count 
-------
     1
(1 row)

-- test for create table with compression option
drop table if exists table_created_with_compression_option_pglz;
NOTICE:  table "table_created_with_compression_option_pglz" does not exist, skipping
drop table if exists table_created_with_compression_option_zstd;
NOTICE:  table "table_created_with_compression_option_zstd" does not exist, skipping
drop table if exists table_created_with_compression_option_none;
NOTICE:  table "table_created_with_compression_option_none" does not exist, skipping
create table table_created_with_compression_option_pglz(c1 int, c2 text) compression = pglz;
create table table_created_with_compression_option_zstd(c1 int, c2 text) compression = zstd;
create table table_created_with_compression_option_none(c1 int, c2 text) compression = none;
select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_pglz';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_pglz | {orientation=row,compresstype=1}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_zstd';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_zstd | {orientation=row,compresstype=2}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_none';
                  relname                   |                   reloptions                    
--------------------------------------------+-------------------------------------------------
 table_created_with_compression_option_none | {orientation=row,compresstype=0,compression=no}
(1 row)

-- test for create list partition table with VALUES IN
drop table if exists table_list_partition_values_in;
NOTICE:  table "table_list_partition_values_in" does not exist, skipping
CREATE TABLE table_list_partition_values_in (col1 int, col2 int)
PARTITION BY list(col1)
(
PARTITION p1 VALUES IN (2000),
PARTITION p2 VALUES IN (3000),
PARTITION p3 VALUES IN (4000),
PARTITION p4 VALUES IN (5000)
);
insert into table_list_partition_values_in values(2000);
select * from table_list_partition_values_in;
 col1 | col2 
------+------
 2000 |     
(1 row)

\d+ table_list_partition_values_in
            Table "public.table_list_partition_values_in"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Partition By LIST(col1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

-- test for create table timestamp column with on update current_timestamp
drop table if exists table_timestamp_on_update;
NOTICE:  table "table_timestamp_on_update" does not exist, skipping
create table table_timestamp_on_update(c1 int, c2 timestamp on update current_timestamp);
\d+ table_timestamp_on_update
                                         Table "public.table_timestamp_on_update"
 Column |            Type             |                  Modifiers                  | Storage | Stats target | Description 
--------+-----------------------------+---------------------------------------------+---------+--------------+-------------
 c1     | integer                     |                                             | plain   |              | 
 c2     | timestamp(0) with time zone | on update b_db_statement_start_timestamp(0) | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- test for view created with definer
drop view if exists view_created_with_definer_test;
NOTICE:  view "view_created_with_definer_test" does not exist, skipping
drop user if exists Test_User;
NOTICE:  role "test_user" does not exist, skipping
CREATE USER "Test_User" with password 'openGauss@123';
NOTICE:  The iteration value of password is not recommended.Setting the iteration value too small reduces the security of the password, and setting it too large results in performance degradation.
GRANT ALL PRIVILEGES TO "Test_User";
CREATE DEFINER="Test_User" VIEW view_created_with_definer_test AS SELECT log(10, 100);
SELECT c.relname as view_name, u.usename as rolname FROM pg_class c, pg_user u WHERE u.usesysid = c.relowner AND relname like '%view_created_with_definer_test%' ORDER BY rolname;
           view_name            |  rolname  
--------------------------------+-----------
 view_created_with_definer_test | Test_User
(1 row)

-- test for functionality of select distinctrow on
drop table if exists normal_test_table;
NOTICE:  table "normal_test_table" does not exist, skipping
create table normal_test_table(c1 int, c2 int);
insert into normal_test_table values(1, 3),(1, 3),(2, 1),(3, 1),(3, 2);
select distinctrow on (c1 % 2) * from normal_test_table;
 c1 | c2 
----+----
  2 |  1
  1 |  3
(2 rows)

select distinctrow on (c1, c2) * from normal_test_table;
 c1 | c2 
----+----
  1 |  3
  2 |  1
  3 |  1
  3 |  2
(4 rows)

-- test for min/max function used by type inet/cidr
drop table if exists table_inet;
NOTICE:  table "table_inet" does not exist, skipping
create table table_inet(c inet, name text);
insert into table_inet values('192.168.1.0', 'server00');
insert into table_inet values('192.168.1.1', 'server01');
insert into table_inet values('192.168.1.2', 'server02');
drop table if exists table_cidr;
NOTICE:  table "table_cidr" does not exist, skipping
create table table_cidr(c cidr, name text);
insert into table_cidr values('192.168.1.0/32', 'server00');
insert into table_cidr values('192.168.1.0/31', 'server00');
insert into table_cidr values('192.168.1.0/30', 'server00');
-- test for comments
create schema test_b_comments;
set search_path to 'test_b_comments';
create table comment_test_row(a int not null comment 'comment_test_row.a', b int not null comment 'comment_test_row.b') comment 'comment_test_row';
create index on comment_test_row(a,b) comment 'comment_test_row_index';
create table comment_test_column(a int comment 'comment_test_column.a', b int comment 'comment_test_column.b') with (orientation='column') comment 'comment_test_column';
create function comment_test_function(a int) returns void as $$ begin end; $$ language plpgsql comment 'comment_test_function';
create procedure comment_test_procedure(int,int) comment 'comment_test_procedure' as begin select $1 + $2;end;
/
reset search_path;
-- test for drop index .. on table
create table test_drop_index_on_table(a int);
create index test_drop_on_index on test_drop_index_on_table using btree(a);
drop index test_drop_on_index on test_drop_index_on_table;
-- test for insert statement with no INTO
create table test_insert_no_into(c1 int, c2 text);
insert test_insert_no_into values(1, 'one');
insert test_insert_no_into values(2, 'two');
-- test for insert statement with VALUE
create table test_insert_value(c1 int, c2 text);
insert test_insert_value value(1, 'one');
insert test_insert_value value(2, 'two');
-- test for insert with empty value list
set dolphin.sql_mode = '';
drop table if exists test_insert_empty_value_with_not_null;
NOTICE:  table "test_insert_empty_value_with_not_null" does not exist, skipping
create table test_insert_empty_value_with_not_null(c1 int not null, c2 date not null);
insert into test_insert_empty_value_with_not_null values();
drop table if exists test_insert_empty_value_with_unique;
NOTICE:  table "test_insert_empty_value_with_unique" does not exist, skipping
create table test_insert_empty_value_with_unique(c1 int unique, c2 date unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_insert_empty_value_with_unique_c1_key" for table "test_insert_empty_value_with_unique"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_insert_empty_value_with_unique_c2_key" for table "test_insert_empty_value_with_unique"
insert into test_insert_empty_value_with_unique values();
insert into test_insert_empty_value_with_unique values();
drop table if exists test_insert_value_with_no_constraint;
NOTICE:  table "test_insert_value_with_no_constraint" does not exist, skipping
create table test_insert_value_with_no_constraint(c1 int, c2 text);
insert into test_insert_value_with_no_constraint values(), (), ();
drop table if exists test_insert_empty_value_types_1;
NOTICE:  table "test_insert_empty_value_types_1" does not exist, skipping
create table test_insert_empty_value_types_1(c1 tinyint, c2 smallint, c3 integer, c4 mediumint, c5 bigint, c6 tinyint unsigned, c7 smallint unsigned,
                                           c8 integer unsigned, c9 mediumint unsigned, c10 bigint unsigned, c11 numeric, c12 number, c13 float, c14 float8,
                                           c15 char(10), c16 text,
                                           c17 date, c18 time, c19 datetime, c20 timestamp, c21 year, c22 time, c23 datetime,
                                           c24 bit(10),
                                           c25 ENUM('a', 'b'));
insert into test_insert_empty_value_types_1 values();
drop table if exists test_insert_empty_value_types_2;
NOTICE:  table "test_insert_empty_value_types_2" does not exist, skipping
create table test_insert_empty_value_types_2(c1 smallserial, c2 serial, c3 bigserial, c4 money, c5 boolean,
                                             c6 varchar(10), c7 name, c8 blob, c9 raw, c10 bytea,
                                             c11 smalldatetime, c12 interval, c13 reltime, c14 abstime,
                                             c15 point, c16 lseg, c17 box, c18 box, c19 path, c20 polygon, c21 circle,
                                             c22 cidr, c23 inet, c24 macaddr);
NOTICE:  CREATE TABLE will create implicit sequence "test_insert_empty_value_types_2_c1_seq" for serial column "test_insert_empty_value_types_2.c1"
NOTICE:  CREATE TABLE will create implicit sequence "test_insert_empty_value_types_2_c2_seq" for serial column "test_insert_empty_value_types_2.c2"
NOTICE:  CREATE TABLE will create implicit sequence "test_insert_empty_value_types_2_c3_seq" for serial column "test_insert_empty_value_types_2.c3"
insert into test_insert_empty_value_types_2 values();
drop table if exists test_insert_empty_value_types_3;
NOTICE:  table "test_insert_empty_value_types_3" does not exist, skipping
create table test_insert_empty_value_types_3(c1 uuid, c2 json, c3 jsonb, c4 int4range, c5 int8range, c6 numrange, c7 tsrange,
                                             c8 tstzrange, c9 daterange, c10 xml, c11 hash16, c12 hash32, c13 set('a', 'b', 'c'));
NOTICE:  CREATE TABLE will create implicit set "test_insert_empty_value_types_3_c13_set" for column "test_insert_empty_value_types_3.c13"
insert into test_insert_empty_value_types_3 values();
-- test for IGNORE
set sql_ignore_strategy = 'overwrite_null';
drop table if exists test_ignore_not_null;
NOTICE:  table "test_ignore_not_null" does not exist, skipping
create table test_ignore_not_null(c1 int not null);
insert ignore into test_ignore_not_null values(null);
WARNING:  null value in column "c1" violates not-null constraint
DETAIL:  Failing row contains (null).
update ignore test_ignore_not_null set c1 = null;
WARNING:  null value in column "c1" violates not-null constraint
DETAIL:  Failing row contains (null).
drop table if exists test_ignore_unique;
NOTICE:  table "test_ignore_unique" does not exist, skipping
create table test_ignore_unique(c1 int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_ignore_unique_c1_key" for table "test_ignore_unique"
insert into test_ignore_unique values(1),(2);
insert ignore into test_ignore_unique values(1);
WARNING:  duplicate key value violates unique constraint in table "test_ignore_unique"
update ignore test_ignore_unique set c1 = 1 where c1 =2;
WARNING:  duplicate key value violates unique constraint in table "test_ignore_unique"
drop table if exists test_ignore_normal;
NOTICE:  table "test_ignore_normal" does not exist, skipping
create table test_ignore_normal(c1 int, c2 text);
insert ignore into test_ignore_normal values(1, 'a');
-- test for keywords
reset dolphin.sql_mode;
CREATE TABLE allshortestpath_splitprovince (
enprov varchar(50) NOT NULL,
exprov varchar(50) NOT NULL,
"version" varchar(50) NOT NULL,
"index" varchar(50) NOT NULL,
"now" varchar(50) NULL,
count int4 NULL,
"group" text NULL,
m int8 NOT NULL,
mver varchar(50) NULL,
pver varchar(50) NULL,
CONSTRAINT pk_allshortestpath_splitprovince PRIMARY KEY (enprov, exprov, version, "index")
)
WITH (
orientation=row,
compression=no
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pk_allshortestpath_splitprovince" for table "allshortestpath_splitprovince"
drop table if exists test_ignore_invalid_input;
NOTICE:  table "test_ignore_invalid_input" does not exist, skipping
create table test_ignore_invalid_input(c1 int, c2 char(5), c3 timestamp, c4 bit(5), c5 boolean, c6 point, c7 uuid,
                                         c8 json, c9 jsonb, c10 xml);
insert ignore into test_ignore_invalid_input values('invalid input', 'invalid input', 'invalid input', b'100001', 1000, 'invalid input',
                                                    'invalid input', 'invalid input', 'invalid input', 'invalid input');
WARNING:  invalid input syntax for type integer: "invalid input"
LINE 1: ...sert ignore into test_ignore_invalid_input values('invalid i...
                                                             ^
CONTEXT:  referenced column: c1
WARNING:  invalid input syntax for type timestamp: "invalid input"
LINE 1: ...id_input values('invalid input', 'invalid input', 'invalid i...
                                                             ^
CONTEXT:  referenced column: c3
WARNING:  invalid input syntax for type point: "invalid input"
LINE 1: ...invalid input', 'invalid input', b'100001', 1000, 'invalid i...
                                                             ^
CONTEXT:  referenced column: c6
WARNING:  invalid input syntax for uuid: "invalid input"
LINE 2: ...                                                  'invalid i...
                                                             ^
CONTEXT:  referenced column: c7
WARNING:  invalid input syntax for type json
LINE 2: ...                                 'invalid input', 'invalid i...
                                                             ^
CONTEXT:  referenced column: c8
WARNING:  invalid input syntax for type json
LINE 2: ...                'invalid input', 'invalid input', 'invalid i...
                                                             ^
CONTEXT:  referenced column: c9
WARNING:  value too long for type character(5)
CONTEXT:  referenced column: c2
WARNING:  bit string length 6 does not match type bit(5)
CONTEXT:  referenced column: c4
/*
 * test for restore by gs_restore
 */
set dolphin.b_compatibility_mode to off;
drop database if exists table_test_restore;
NOTICE:  database "table_test_restore" does not exist, skipping
create database table_test_restore dbcompatibility 'B';
\! @abs_bindir@/gs_dump table_test -p @portstring@ -f @abs_bindir@/table_test.tar -F t >/dev/null 2>&1; echo $?
0
\! @abs_bindir@/gs_restore -d table_test_restore -p @portstring@ @abs_bindir@/table_test.tar >/dev/null 2>&1; echo $?
0
\c table_test_restore
-- test for table created by like
select * from table_like_test_2;
 a | b 
---+---
(0 rows)

-- test for table created with index
\d table_created_with_index_test
Table "public.table_created_with_index_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 c1     | integer | 
 c2     | integer | 
 c3     | integer | 
Indexes:
    "create_table_idx_1" btree (c1 DESC, c2) TABLESPACE pg_default

select count(*) from pg_indexes where indexname = 'create_table_idx_1' and tablename = 'table_created_with_index_test';
 count 
-------
     1
(1 row)

-- test for create table with compression option
select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_pglz';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_pglz | {orientation=row,compresstype=1}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_zstd';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_zstd | {orientation=row,compresstype=2}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_none';
                  relname                   |                   reloptions                    
--------------------------------------------+-------------------------------------------------
 table_created_with_compression_option_none | {orientation=row,compresstype=0,compression=no}
(1 row)

-- test for create list partition table with VALUES IN
select * from table_list_partition_values_in;
 col1 | col2 
------+------
 2000 |     
(1 row)

\d+ table_list_partition_values_in
            Table "public.table_list_partition_values_in"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Partition By LIST(col1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

-- test for create table timestamp column with on update current_timestamp
\d+ table_timestamp_on_update
                                         Table "public.table_timestamp_on_update"
 Column |            Type             |                  Modifiers                  | Storage | Stats target | Description 
--------+-----------------------------+---------------------------------------------+---------+--------------+-------------
 c1     | integer                     |                                             | plain   |              | 
 c2     | timestamp(0) with time zone | on update b_db_statement_start_timestamp(0) | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- test for view created with definer
SELECT c.relname as view_name, u.usename as rolname FROM pg_class c, pg_user u WHERE u.usesysid = c.relowner AND relname like '%view_created_with_definer_test%' ORDER BY rolname;
           view_name            |  rolname  
--------------------------------+-----------
 view_created_with_definer_test | Test_User
(1 row)

-- test for functionality of select distinctrow on
select distinctrow on (c1 % 2) * from normal_test_table;
 c1 | c2 
----+----
  2 |  1
  1 |  3
(2 rows)

select distinctrow on (c1, c2) * from normal_test_table;
 c1 | c2 
----+----
  1 |  3
  2 |  1
  3 |  1
  3 |  2
(4 rows)

-- test for functionality of functions
select log(10);
        log        
-------------------
 2.302585092994046
(1 row)

select log(10, 100);
        log         
--------------------
 2.0000000000000000
(1 row)

select log10(100);
 log10 
-------
     2
(1 row)

select log2(16);
 log2 
------
    4
(1 row)

select mod(16, 7);
 mod 
-----
   2
(1 row)

select mod(0.0::float8, 0.0::numeric);
 mod 
-----
    
(1 row)

select sqrt(64::numeric);
       sqrt        
-------------------
 8.000000000000000
(1 row)

select sqrt(b'10000');
       sqrt        
-------------------
 4.000000000000000
(1 row)

select ascii('你');
 ascii 
-------
   228
(1 row)

select instr(null,'bc');
 instr 
-------
      
(1 row)

select instr('abcd12abc',null);
 instr 
-------
      
(1 row)

select instr('abcd12abc','bc');
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2);
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2, 2);
 instr 
-------
     8
(1 row)

select left('abcdefg', 3);
 left 
------
 abc
(1 row)

select left('abcdefg', -3);
 left 
------
 
(1 row)

select right('abcdefg', 3);
 right 
-------
 efg
(1 row)

select right('abcdefg', -3);
 right 
-------
 
(1 row)

select locate('test','testgood');
 locate 
--------
      1
(1 row)

select locate('','testgood');
 locate 
--------
      1
(1 row)

select locate(NULL,'testgood');
 locate 
--------
       
(1 row)

select locate(true,'testgood');
 locate 
--------
      0
(1 row)

select locate(false,'testgood');
 locate 
--------
      0
(1 row)

select ltrim('') is null;
 ?column? 
----------
 f
(1 row)

select ltrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,10);
   mid    
----------
 \xadbeef
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,0);
 mid 
-----
 \x
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,-1);
 mid 
-----
 \x
(1 row)

select quote('O\hello');
    quote    
-------------
 E'O\\hello'
(1 row)

SELECT right('abcdefg', 3);
 right 
-------
 efg
(1 row)

SELECT right('abcdefg', -3);
 right 
-------
 
(1 row)

select rtrim('ab  ');
 rtrim 
-------
 ab
(1 row)

select rtrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select rtrim('') is null;
 ?column? 
----------
 f
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,-1);
 substr 
--------
 \x
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,2);
 substr 
--------
 \xadbe
(1 row)

select hex(-1);
       hex        
------------------
 FFFFFFFFFFFFFFFF
(1 row)

select hex(9223372036854775807);
       hex        
------------------
 7FFFFFFFFFFFFFFF
(1 row)

set dolphin.b_compatibility_mode = 1;
select format(1234.456, 2);
  format  
----------
 1,234.46
(1 row)

set dolphin.b_compatibility_mode = 0;
select format('%1s %1s!', 'Hello', 'world');
    format    
--------------
 Hello world!
(1 row)

select uuid();
                 uuid                 
--------------------------------------
--?.*
(1 row)

select if(true,'A','B');
 case 
------
 A
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_cidr;
 max_ip_addr 
-------------
 192.168.1.0
(1 row)

select min(c) as min_ip_addr from table_cidr;
  min_ip_addr   
----------------
 192.168.1.0/30
(1 row)

-- test for comments
select description
from pg_description
where objoid in (select relfilenode
                 from pg_class
                 where relnamespace in (select oid from pg_catalog.pg_namespace where nspname = 'test_b_comments'))
order by description;
      description       
------------------------
 comment_test_column
 comment_test_column.a
 comment_test_column.b
 comment_test_row
 comment_test_row.a
 comment_test_row.b
 comment_test_row_index
(7 rows)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_procedure';
        comment         
------------------------
 comment_test_procedure
(1 row)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_function';
        comment        
-----------------------
 comment_test_function
(1 row)

-- test for drop index .. on table
\d test_drop_index_on_table
Table "public.test_drop_index_on_table"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

-- test for insert statement with no INTO
select * from test_insert_no_into;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert statement with VALUE
select * from test_insert_value;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert with empty value list
select * from test_insert_empty_value_with_not_null;
 c1 |     c2     
----+------------
  0 | 1970-01-01
(1 row)

select * from test_insert_empty_value_with_unique;
 c1 | c2 
----+----
    | 
    | 
(2 rows)

select * from test_insert_value_with_no_constraint;
 c1 | c2 
----+----
    | 
    | 
    | 
(3 rows)

select * from test_insert_empty_value_types_1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 | c25 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_2;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
  1 |  1 |  1 |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_3;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     | 
(1 row)

-- test for IGNORE
select * from test_ignore_not_null;
 c1 
----
  0
(1 row)

select * from test_ignore_unique;
 c1 
----
  1
  2
(2 rows)

select * from test_ignore_normal;
 c1 | c2 
----+----
  1 | a
(1 row)

-- test for keywords
select * from allshortestpath_splitprovince;
 enprov | exprov | version | index | now | count | group | m | mver | pver 
--------+--------+---------+-------+-----+-------+-------+---+------+------
(0 rows)

/*
 * test for restore by gsql
 */
drop database if exists table_test_gsql;
NOTICE:  database "table_test_gsql" does not exist, skipping
create database table_test_gsql dbcompatibility 'B';
\! @abs_bindir@/gs_dump table_test -p @portstring@ -f @abs_bindir@/gsql_table_test.sql >/dev/null 2>&1; echo $?
0
\! @abs_bindir@/gsql -d table_test_gsql -p @portstring@ -f @abs_bindir@/gsql_table_test.sql >/dev/null 2>&1; echo $?
0
\c table_test_gsql
-- test for table created by like
select * from table_like_test_2;
 a | b 
---+---
(0 rows)

-- test for table created with index
\d table_created_with_index_test
Table "public.table_created_with_index_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 c1     | integer | 
 c2     | integer | 
 c3     | integer | 
Indexes:
    "create_table_idx_1" btree (c1 DESC, c2) TABLESPACE pg_default

select count(*) from pg_indexes where indexname = 'create_table_idx_1' and tablename = 'table_created_with_index_test';
 count 
-------
     1
(1 row)

-- test for create table with compression option
select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_pglz';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_pglz | {orientation=row,compresstype=1}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_zstd';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_zstd | {orientation=row,compresstype=2}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_none';
                  relname                   |                   reloptions                    
--------------------------------------------+-------------------------------------------------
 table_created_with_compression_option_none | {orientation=row,compresstype=0,compression=no}
(1 row)

-- test for create list partition table with VALUES IN
select * from table_list_partition_values_in;
 col1 | col2 
------+------
 2000 |     
(1 row)

\d+ table_list_partition_values_in
            Table "public.table_list_partition_values_in"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Partition By LIST(col1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

-- test for create table timestamp column with on update current_timestamp
\d+ table_timestamp_on_update
                                         Table "public.table_timestamp_on_update"
 Column |            Type             |                  Modifiers                  | Storage | Stats target | Description 
--------+-----------------------------+---------------------------------------------+---------+--------------+-------------
 c1     | integer                     |                                             | plain   |              | 
 c2     | timestamp(0) with time zone | on update b_db_statement_start_timestamp(0) | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- test for view created with definer
SELECT c.relname as view_name, u.usename as rolname FROM pg_class c, pg_user u WHERE u.usesysid = c.relowner AND relname like '%view_created_with_definer_test%' ORDER BY rolname;
           view_name            |  rolname  
--------------------------------+-----------
 view_created_with_definer_test | Test_User
(1 row)

-- test for functionality of select distinctrow on
select distinctrow on (c1 % 2) * from normal_test_table;
 c1 | c2 
----+----
  2 |  1
  1 |  3
(2 rows)

select distinctrow on (c1, c2) * from normal_test_table;
 c1 | c2 
----+----
  1 |  3
  2 |  1
  3 |  1
  3 |  2
(4 rows)

-- test for functionality of functions
select log(10);
        log        
-------------------
 2.302585092994046
(1 row)

select log(10, 100);
        log         
--------------------
 2.0000000000000000
(1 row)

select log10(100);
 log10 
-------
     2
(1 row)

select log2(16);
 log2 
------
    4
(1 row)

select mod(16, 7);
 mod 
-----
   2
(1 row)

select mod(0.0::float8, 0.0::numeric);
 mod 
-----
    
(1 row)

select sqrt(64::numeric);
       sqrt        
-------------------
 8.000000000000000
(1 row)

select sqrt(b'10000');
       sqrt        
-------------------
 4.000000000000000
(1 row)

select ascii('你');
 ascii 
-------
   228
(1 row)

select instr(null,'bc');
 instr 
-------
      
(1 row)

select instr('abcd12abc',null);
 instr 
-------
      
(1 row)

select instr('abcd12abc','bc');
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2);
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2, 2);
 instr 
-------
     8
(1 row)

select left('abcdefg', 3);
 left 
------
 abc
(1 row)

select left('abcdefg', -3);
 left 
------
 
(1 row)

select right('abcdefg', 3);
 right 
-------
 efg
(1 row)

select right('abcdefg', -3);
 right 
-------
 
(1 row)

select locate('test','testgood');
 locate 
--------
      1
(1 row)

select locate('','testgood');
 locate 
--------
      1
(1 row)

select locate(NULL,'testgood');
 locate 
--------
       
(1 row)

select locate(true,'testgood');
 locate 
--------
      0
(1 row)

select locate(false,'testgood');
 locate 
--------
      0
(1 row)

select ltrim('') is null;
 ?column? 
----------
 f
(1 row)

select ltrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,10);
   mid    
----------
 \xadbeef
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,0);
 mid 
-----
 \x
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,-1);
 mid 
-----
 \x
(1 row)

select quote('O\hello');
    quote    
-------------
 E'O\\hello'
(1 row)

SELECT right('abcdefg', 3);
 right 
-------
 efg
(1 row)

SELECT right('abcdefg', -3);
 right 
-------
 
(1 row)

select rtrim('ab  ');
 rtrim 
-------
 ab
(1 row)

select rtrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select rtrim('') is null;
 ?column? 
----------
 f
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,-1);
 substr 
--------
 \x
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,2);
 substr 
--------
 \xadbe
(1 row)

select hex(-1);
       hex        
------------------
 FFFFFFFFFFFFFFFF
(1 row)

select hex(9223372036854775807);
       hex        
------------------
 7FFFFFFFFFFFFFFF
(1 row)

set dolphin.b_compatibility_mode = 1;
select format(1234.456, 2);
  format  
----------
 1,234.46
(1 row)

set dolphin.b_compatibility_mode = 0;
select format('%1s %1s!', 'Hello', 'world');
    format    
--------------
 Hello world!
(1 row)

select uuid();
                 uuid                 
--------------------------------------
--?.*
(1 row)

select if(true,'A','B');
 case 
------
 A
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_cidr;
 max_ip_addr 
-------------
 192.168.1.0
(1 row)

select min(c) as min_ip_addr from table_cidr;
  min_ip_addr   
----------------
 192.168.1.0/30
(1 row)

-- test for comments
select description
from pg_description
where objoid in (select relfilenode
                 from pg_class
                 where relnamespace in (select oid from pg_catalog.pg_namespace where nspname = 'test_b_comments'))
order by description;
      description       
------------------------
 comment_test_column
 comment_test_column.a
 comment_test_column.b
 comment_test_row
 comment_test_row.a
 comment_test_row.b
 comment_test_row_index
(7 rows)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_procedure';
        comment         
------------------------
 comment_test_procedure
(1 row)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_function';
        comment        
-----------------------
 comment_test_function
(1 row)

-- test for drop index .. on table
\d test_drop_index_on_table
Table "public.test_drop_index_on_table"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

-- test for insert statement with no INTO
select * from test_insert_no_into;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert statement with VALUE
select * from test_insert_value;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert with empty value list
select * from test_insert_empty_value_with_not_null;
 c1 |     c2     
----+------------
  0 | 1970-01-01
(1 row)

select * from test_insert_empty_value_with_unique;
 c1 | c2 
----+----
    | 
    | 
(2 rows)

select * from test_insert_value_with_no_constraint;
 c1 | c2 
----+----
    | 
    | 
    | 
(3 rows)

select * from test_insert_empty_value_types_1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 | c25 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_2;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
  1 |  1 |  1 |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_3;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     | 
(1 row)

-- test for IGNORE
select * from test_ignore_not_null;
 c1 
----
  0
(1 row)

select * from test_ignore_unique;
 c1 
----
  1
  2
(2 rows)

select * from test_ignore_normal;
 c1 | c2 
----+----
  1 | a
(1 row)

-- test for keywords
select * from allshortestpath_splitprovince;
 enprov | exprov | version | index | now | count | group | m | mver | pver 
--------+--------+---------+-------+-----+-------+-------+---+------+------
(0 rows)

/*
 * test for restore by gs_dumpall
 */
drop database if exists table_test_restore;
drop database if exists table_test_gsql;
ERROR:  cannot drop the currently open database
\! @abs_bindir@/gs_dumpall -p @portstring@ -f @abs_bindir@/dumpall_table_test.sql >/dev/null 2>&1; echo $?
0
drop database if exists table_test;
\! @abs_bindir@/gsql -d postgres -p @portstring@ -f @abs_bindir@/dumpall_table_test.sql >/dev/null 2>&1; echo $?
0
\c table_test
-- test for table created by like
select * from table_like_test_2;
 a | b 
---+---
(0 rows)

-- test for table created with index
\d table_created_with_index_test
Table "public.table_created_with_index_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 c1     | integer | 
 c2     | integer | 
 c3     | integer | 
Indexes:
    "create_table_idx_1" btree (c1 DESC, c2) TABLESPACE pg_default

select count(*) from pg_indexes where indexname = 'create_table_idx_1' and tablename = 'table_created_with_index_test';
 count 
-------
     1
(1 row)

-- test for create table with compression option
select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_pglz';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_pglz | {orientation=row,compresstype=1}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_zstd';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_zstd | {orientation=row,compresstype=2}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_none';
                  relname                   |                   reloptions                    
--------------------------------------------+-------------------------------------------------
 table_created_with_compression_option_none | {orientation=row,compresstype=0,compression=no}
(1 row)

-- test for create list partition table with VALUES IN
select * from table_list_partition_values_in;
 col1 | col2 
------+------
 2000 |     
(1 row)

\d+ table_list_partition_values_in
            Table "public.table_list_partition_values_in"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Partition By LIST(col1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

-- test for create table timestamp column with on update current_timestamp
\d+ table_timestamp_on_update
                                         Table "public.table_timestamp_on_update"
 Column |            Type             |                  Modifiers                  | Storage | Stats target | Description 
--------+-----------------------------+---------------------------------------------+---------+--------------+-------------
 c1     | integer                     |                                             | plain   |              | 
 c2     | timestamp(0) with time zone | on update b_db_statement_start_timestamp(0) | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- test for view created with definer
SELECT c.relname as view_name, u.usename as rolname FROM pg_class c, pg_user u WHERE u.usesysid = c.relowner AND relname like '%view_created_with_definer_test%' ORDER BY rolname;
           view_name            |  rolname  
--------------------------------+-----------
 view_created_with_definer_test | Test_User
(1 row)

-- test for functionality of select distinctrow on
select distinctrow on (c1 % 2) * from normal_test_table;
 c1 | c2 
----+----
  2 |  1
  1 |  3
(2 rows)

select distinctrow on (c1, c2) * from normal_test_table;
 c1 | c2 
----+----
  1 |  3
  2 |  1
  3 |  1
  3 |  2
(4 rows)

-- test for functionality of functions
select log(10);
        log        
-------------------
 2.302585092994046
(1 row)

select log(10, 100);
        log         
--------------------
 2.0000000000000000
(1 row)

select log10(100);
 log10 
-------
     2
(1 row)

select log2(16);
 log2 
------
    4
(1 row)

select mod(16, 7);
 mod 
-----
   2
(1 row)

select mod(0.0::float8, 0.0::numeric);
 mod 
-----
    
(1 row)

select sqrt(64::numeric);
       sqrt        
-------------------
 8.000000000000000
(1 row)

select sqrt(b'10000');
       sqrt        
-------------------
 4.000000000000000
(1 row)

select ascii('你');
 ascii 
-------
   228
(1 row)

select instr(null,'bc');
 instr 
-------
      
(1 row)

select instr('abcd12abc',null);
 instr 
-------
      
(1 row)

select instr('abcd12abc','bc');
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2);
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2, 2);
 instr 
-------
     8
(1 row)

select left('abcdefg', 3);
 left 
------
 abc
(1 row)

select left('abcdefg', -3);
 left 
------
 
(1 row)

select right('abcdefg', 3);
 right 
-------
 efg
(1 row)

select right('abcdefg', -3);
 right 
-------
 
(1 row)

select locate('test','testgood');
 locate 
--------
      1
(1 row)

select locate('','testgood');
 locate 
--------
      1
(1 row)

select locate(NULL,'testgood');
 locate 
--------
       
(1 row)

select locate(true,'testgood');
 locate 
--------
      0
(1 row)

select locate(false,'testgood');
 locate 
--------
      0
(1 row)

select ltrim('') is null;
 ?column? 
----------
 f
(1 row)

select ltrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,10);
   mid    
----------
 \xadbeef
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,0);
 mid 
-----
 \x
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,-1);
 mid 
-----
 \x
(1 row)

select quote('O\hello');
    quote    
-------------
 E'O\\hello'
(1 row)

SELECT right('abcdefg', 3);
 right 
-------
 efg
(1 row)

SELECT right('abcdefg', -3);
 right 
-------
 
(1 row)

select rtrim('ab  ');
 rtrim 
-------
 ab
(1 row)

select rtrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select rtrim('') is null;
 ?column? 
----------
 f
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,-1);
 substr 
--------
 \x
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,2);
 substr 
--------
 \xadbe
(1 row)

select hex(-1);
       hex        
------------------
 FFFFFFFFFFFFFFFF
(1 row)

select hex(9223372036854775807);
       hex        
------------------
 7FFFFFFFFFFFFFFF
(1 row)

set dolphin.b_compatibility_mode = 1;
select format(1234.456, 2);
  format  
----------
 1,234.46
(1 row)

set dolphin.b_compatibility_mode = 0;
select format('%1s %1s!', 'Hello', 'world');
    format    
--------------
 Hello world!
(1 row)

select uuid();
                 uuid                 
--------------------------------------
--?.*
(1 row)

select if(true,'A','B');
 case 
------
 A
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_cidr;
 max_ip_addr 
-------------
 192.168.1.0
(1 row)

select min(c) as min_ip_addr from table_cidr;
  min_ip_addr   
----------------
 192.168.1.0/30
(1 row)

-- test for comments
select description
from pg_description
where objoid in (select relfilenode
                 from pg_class
                 where relnamespace in (select oid from pg_catalog.pg_namespace where nspname = 'test_b_comments'))
order by description;
      description       
------------------------
 comment_test_column
 comment_test_column.a
 comment_test_column.b
 comment_test_row
 comment_test_row.a
 comment_test_row.b
 comment_test_row_index
(7 rows)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_procedure';
        comment         
------------------------
 comment_test_procedure
(1 row)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_function';
        comment        
-----------------------
 comment_test_function
(1 row)

-- test for drop index .. on table
\d test_drop_index_on_table
Table "public.test_drop_index_on_table"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

-- test for insert statement with no INTO
select * from test_insert_no_into;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert statement with VALUE
select * from test_insert_value;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert with empty value list
select * from test_insert_empty_value_with_not_null;
 c1 |     c2     
----+------------
  0 | 1970-01-01
(1 row)

select * from test_insert_empty_value_with_unique;
 c1 | c2 
----+----
    | 
    | 
(2 rows)

select * from test_insert_value_with_no_constraint;
 c1 | c2 
----+----
    | 
    | 
    | 
(3 rows)

select * from test_insert_empty_value_types_1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 | c25 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_2;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
  1 |  1 |  1 |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_3;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     | 
(1 row)

-- test for IGNORE
select * from test_ignore_not_null;
 c1 
----
  0
(1 row)

select * from test_ignore_unique;
 c1 
----
  1
  2
(2 rows)

select * from test_ignore_normal;
 c1 | c2 
----+----
  1 | a
(1 row)

-- test for keywords
select * from allshortestpath_splitprovince;
 enprov | exprov | version | index | now | count | group | m | mver | pver 
--------+--------+---------+-------+-----+-------+-------+---+------+------
(0 rows)

/*
 * test for quote-all-identifiers
 */
drop database if exists table_test_gsql;
create database table_test_gsql dbcompatibility 'B';
\! @abs_bindir@/gs_dump table_test --quote-all-identifiers -p @portstring@ -f @abs_bindir@/gsql_table_test.sql >/dev/null 2>&1; echo $?
0
\! @abs_bindir@/gsql -d table_test_gsql -p @portstring@ -f @abs_bindir@/gsql_table_test.sql >/dev/null 2>&1; echo $?
0
\c table_test_gsql
-- test for table created by like
select * from table_like_test_2;
 a | b 
---+---
(0 rows)

-- test for table created with index
\d table_created_with_index_test
Table "public.table_created_with_index_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 c1     | integer | 
 c2     | integer | 
 c3     | integer | 
Indexes:
    "create_table_idx_1" btree (c1 DESC, c2) TABLESPACE pg_default

select count(*) from pg_indexes where indexname = 'create_table_idx_1' and tablename = 'table_created_with_index_test';
 count 
-------
     1
(1 row)

-- test for create table with compression option
select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_pglz';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_pglz | {orientation=row,compresstype=1}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_zstd';
                  relname                   |            reloptions            
--------------------------------------------+----------------------------------
 table_created_with_compression_option_zstd | {orientation=row,compresstype=2}
(1 row)

select relname, reloptions from pg_class where relname = 'table_created_with_compression_option_none';
                  relname                   |                   reloptions                    
--------------------------------------------+-------------------------------------------------
 table_created_with_compression_option_none | {orientation=row,compresstype=0,compression=no}
(1 row)

-- test for create list partition table with VALUES IN
select * from table_list_partition_values_in;
 col1 | col2 
------+------
 2000 |     
(1 row)

\d+ table_list_partition_values_in
            Table "public.table_list_partition_values_in"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Partition By LIST(col1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

-- test for create table timestamp column with on update current_timestamp
\d+ table_timestamp_on_update
                                         Table "public.table_timestamp_on_update"
 Column |            Type             |                  Modifiers                  | Storage | Stats target | Description 
--------+-----------------------------+---------------------------------------------+---------+--------------+-------------
 c1     | integer                     |                                             | plain   |              | 
 c2     | timestamp(0) with time zone | on update b_db_statement_start_timestamp(0) | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

-- test for view created with definer
SELECT c.relname as view_name, u.usename as rolname FROM pg_class c, pg_user u WHERE u.usesysid = c.relowner AND relname like '%view_created_with_definer_test%' ORDER BY rolname;
           view_name            |  rolname  
--------------------------------+-----------
 view_created_with_definer_test | Test_User
(1 row)

-- test for functionality of select distinctrow on
select distinctrow on (c1 % 2) * from normal_test_table;
 c1 | c2 
----+----
  2 |  1
  1 |  3
(2 rows)

select distinctrow on (c1, c2) * from normal_test_table;
 c1 | c2 
----+----
  1 |  3
  2 |  1
  3 |  1
  3 |  2
(4 rows)

-- test for functionality of functions
select log(10);
        log        
-------------------
 2.302585092994046
(1 row)

select log(10, 100);
        log         
--------------------
 2.0000000000000000
(1 row)

select log10(100);
 log10 
-------
     2
(1 row)

select log2(16);
 log2 
------
    4
(1 row)

select mod(16, 7);
 mod 
-----
   2
(1 row)

select mod(0.0::float8, 0.0::numeric);
 mod 
-----
    
(1 row)

select sqrt(64::numeric);
       sqrt        
-------------------
 8.000000000000000
(1 row)

select sqrt(b'10000');
       sqrt        
-------------------
 4.000000000000000
(1 row)

select ascii('你');
 ascii 
-------
   228
(1 row)

select instr(null,'bc');
 instr 
-------
      
(1 row)

select instr('abcd12abc',null);
 instr 
-------
      
(1 row)

select instr('abcd12abc','bc');
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2);
 instr 
-------
     2
(1 row)

select instr('abcd12abc','bc', 2, 2);
 instr 
-------
     8
(1 row)

select left('abcdefg', 3);
 left 
------
 abc
(1 row)

select left('abcdefg', -3);
 left 
------
 
(1 row)

select right('abcdefg', 3);
 right 
-------
 efg
(1 row)

select right('abcdefg', -3);
 right 
-------
 
(1 row)

select locate('test','testgood');
 locate 
--------
      1
(1 row)

select locate('','testgood');
 locate 
--------
      1
(1 row)

select locate(NULL,'testgood');
 locate 
--------
       
(1 row)

select locate(true,'testgood');
 locate 
--------
      0
(1 row)

select locate(false,'testgood');
 locate 
--------
      0
(1 row)

select ltrim('') is null;
 ?column? 
----------
 f
(1 row)

select ltrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,10);
   mid    
----------
 \xadbeef
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,0);
 mid 
-----
 \x
(1 row)

select mid(E'\\xDEADBEEF'::bytea,2,-1);
 mid 
-----
 \x
(1 row)

select quote('O\hello');
    quote    
-------------
 E'O\\hello'
(1 row)

SELECT right('abcdefg', 3);
 right 
-------
 efg
(1 row)

SELECT right('abcdefg', -3);
 right 
-------
 
(1 row)

select rtrim('ab  ');
 rtrim 
-------
 ab
(1 row)

select rtrim('ab', 'ab') is null;
 ?column? 
----------
 f
(1 row)

select rtrim('') is null;
 ?column? 
----------
 f
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,-1);
 substr 
--------
 \x
(1 row)

select substr(E'\\xDEADBEEF'::bytea,2,2);
 substr 
--------
 \xadbe
(1 row)

select hex(-1);
       hex        
------------------
 FFFFFFFFFFFFFFFF
(1 row)

select hex(9223372036854775807);
       hex        
------------------
 7FFFFFFFFFFFFFFF
(1 row)

set dolphin.b_compatibility_mode = 1;
select format(1234.456, 2);
  format  
----------
 1,234.46
(1 row)

set dolphin.b_compatibility_mode = 0;
select format('%1s %1s!', 'Hello', 'world');
    format    
--------------
 Hello world!
(1 row)

select uuid();
                 uuid                 
--------------------------------------
--?.*
(1 row)

select if(true,'A','B');
 case 
------
 A
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_inet;
 max_ip_addr 
-------------
 192.168.1.2
(1 row)

select min(c) as min_ip_addr from table_inet;
 min_ip_addr 
-------------
 192.168.1.0
(1 row)

select max(c) as max_ip_addr from table_cidr;
 max_ip_addr 
-------------
 192.168.1.0
(1 row)

select min(c) as min_ip_addr from table_cidr;
  min_ip_addr   
----------------
 192.168.1.0/30
(1 row)

-- test for comments
select description
from pg_description
where objoid in (select relfilenode
                 from pg_class
                 where relnamespace in (select oid from pg_catalog.pg_namespace where nspname = 'test_b_comments'))
order by description;
      description       
------------------------
 comment_test_column
 comment_test_column.a
 comment_test_column.b
 comment_test_row
 comment_test_row.a
 comment_test_row.b
 comment_test_row_index
(7 rows)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_procedure';
        comment         
------------------------
 comment_test_procedure
(1 row)

select obj_description(oid, 'pg_proc') AS comment from pg_proc where proname = 'comment_test_function';
        comment        
-----------------------
 comment_test_function
(1 row)

-- test for drop index .. on table
\d test_drop_index_on_table
Table "public.test_drop_index_on_table"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

-- test for insert statement with no INTO
select * from test_insert_no_into;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert statement with VALUE
select * from test_insert_value;
 c1 | c2  
----+-----
  1 | one
  2 | two
(2 rows)

-- test for insert with empty value list
select * from test_insert_empty_value_with_not_null;
 c1 |     c2     
----+------------
  0 | 1970-01-01
(1 row)

select * from test_insert_empty_value_with_unique;
 c1 | c2 
----+----
    | 
    | 
(2 rows)

select * from test_insert_value_with_no_constraint;
 c1 | c2 
----+----
    | 
    | 
    | 
(3 rows)

select * from test_insert_empty_value_types_1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 | c25 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_2;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 | c14 | c15 | c16 | c17 | c18 | c19 | c20 | c21 | c22 | c23 | c24 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
  1 |  1 |  1 |    |    |    |    |    |    |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
(1 row)

select * from test_insert_empty_value_types_3;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9 | c10 | c11 | c12 | c13 
----+----+----+----+----+----+----+----+----+-----+-----+-----+-----
    |    |    |    |    |    |    |    |    |     |     |     | 
(1 row)

-- test for IGNORE
select * from test_ignore_not_null;
 c1 
----
  0
(1 row)

select * from test_ignore_unique;
 c1 
----
  1
  2
(2 rows)

select * from test_ignore_normal;
 c1 | c2 
----+----
  1 | a
(1 row)

-- test for keywords
select * from allshortestpath_splitprovince;
 enprov | exprov | version | index | now | count | group | m | mver | pver 
--------+--------+---------+-------+-----+-------+-------+---+------+------
(0 rows)

DROP DATABASE IF EXISTS b_test_partition_index;
NOTICE:  database "b_test_partition_index" does not exist, skipping
CREATE DATABASE b_test_partition_index DBCOMPATIBILITY 'B';
\c b_test_partition_index
-- test for partition index
DROP TABLE IF EXISTS sales_range;
NOTICE:  table "sales_range" does not exist, skipping
CREATE TABLE sales_range (
    sale_date DATE,
    PRIMARY KEY (sale_date)
)
PARTITION BY RANGE (SALE_DATE) (
    PARTITION p202401 VALUES LESS THAN ('2024-02-01'),
    PARTITION p202402 VALUES LESS THAN ('2024-03-01'),
    PARTITION p202403 VALUES LESS THAN ('2024-04-01'),
    PARTITION p_others VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "sales_range_pkey" for table "sales_range"
\d sales_range
  Table "public.sales_range"
  Column   | Type | Modifiers 
-----------+------+-----------
 sale_date | date | not null
Indexes:
    "sales_range_pkey" PRIMARY KEY, btree (sale_date) LOCAL TABLESPACE pg_default
Partition By RANGE(sale_date)
Number of partitions: 4 (View pg_partition to check each partition range.)

\! @abs_bindir@/gs_dump b_test_partition_index --quote-all-identifiers -p @portstring@ -f @abs_bindir@/part_index.sql >/dev/null 2>&1; echo $?
0
DROP TABLE IF EXISTS sales_range;
\! @abs_bindir@/gsql -d b_test_partition_index -p @portstring@ -f @abs_bindir@/part_index.sql >/dev/null 2>&1; echo $?
0
\d sales_range
  Table "public.sales_range"
  Column   | Type | Modifiers 
-----------+------+-----------
 sale_date | date | not null
Indexes:
    "sales_range_pkey" PRIMARY KEY, btree (sale_date) LOCAL TABLESPACE pg_default
Partition By RANGE(sale_date)
Number of partitions: 4 (View pg_partition to check each partition range.)

\c postgres
drop database if exists table_test;
drop database if exists b_test_partition_index;

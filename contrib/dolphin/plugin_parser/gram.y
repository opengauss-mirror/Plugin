%{

/*#define YYDEBUG 1*/
/* -------------------------------------------------------------------------
 *
 * gram.y
 *	  POSTGRESQL BISON rules/actions
 *
 * Portions Copyright (c) 1996-2012, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 * Portions Copyright (c) 2021, openGauss Contributors
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/gram.y
 *
 * HISTORY
 *	  AUTHOR			DATE			MAJOR EVENT
 *	  Andrew Yu			Sept, 1994		POSTQUEL to SQL conversion
 *	  Andrew Yu			Oct, 1994		lispy code conversion
 *
 * NOTES
 *	  CAPITALS are used to represent terminal symbols.
 *	  non-capitals are used to represent non-terminals.
 *	  SQL92-specific syntax is separated from plain SQL/Postgres syntax
 *	  to help isolate the non-extensible portions of the parser.
 *
 *	  In general, nothing in this file should initiate database accesses
 *	  nor depend on changeable state (such as SET variables).  If you do
 *	  database accesses, your code will fail when we have aborted the
 *	  current transaction and are just parsing commands to find the next
 *	  ROLLBACK or COMMIT.  If you make use of SET variables, then you
 *	  will do the wrong thing in multi-query strings like this:
 *			SET SQL_inheritance TO off; SELECT * FROM foo;
 *	  because the entire string is parsed by gram.y before the SET gets
 *	  executed.  Anything that depends on the database or changeable state
 *	  should be handled during parse analysis so that it happens at the
 *	  right time not the wrong time.  The handling of SQL_inheritance is
 *	  a good example.
 *
 * WARNINGS
 *	  If you use a list, make sure the datum is a node so that the printing
 *	  routines work.
 *
 *	  Sometimes we assign constants to makeStrings. Make sure we don't free
 *	  those.
 *
 * -------------------------------------------------------------------------
 */
#include "postgres.h"
#include "plugin_nodes/parsenodes_common.h"
#include "plugin_parser/scanner.h"
#include "plugin_nodes/parsenodes.h"
#include "knl/knl_variable.h"
#include "utils/builtins.h"
#include <ctype.h>
#include <limits.h>
#include <port.h>

#include "catalog/index.h"
#include "catalog/namespace.h"
#include "catalog/pg_proc.h"
#include "catalog/gs_package.h"
#include "catalog/pg_trigger.h"
#include "commands/defrem.h"
#include "commands/trigger.h"
#ifdef ENABLE_MULTIPLE_NODES
#include "distribute_core.h"
#endif
#include "funcapi.h"
#include "miscadmin.h"
#include "nodes/makefuncs.h"
#include "nodes/nodeFuncs.h"
#include "nodes/print.h"
#include "plugin_optimizer/planner.h"
#include "plugin_postgres.h"
#include "plugin_parser/gramparse.h"
#include "plugin_parser/parse_type.h"
#include "plugin_parser/parse_hint.h"
#include "plugin_parser/scansup.h"
#include "plugin_parser/parse_utilcmd.h"
#include "pgxc/pgxc.h"
#include "nodes/nodes.h"
#include "pgxc/poolmgr.h"
#include "plugin_parser/parser.h"
#include "storage/lmgr.h"
#include "storage/tcap.h"
#include "storage/lock/waitpolicy.h"
#include "utils/builtins.h"
#include "utils/date.h"
#include "utils/datetime.h"
#include "utils/numeric.h"
#ifdef DOLPHIN
#include "plugin_utils/timestamp.h"
#include "plugin_utils/date.h"
#endif
#include "utils/rel.h"
#include "utils/syscache.h"
#include "utils/xml.h"
#include "utils/pl_package.h"
#include "catalog/pg_streaming_fn.h"
#include "utils/varbit.h"
#include "mb/pg_wchar.h"
#include "lib/string.h"
#include "tcop/tcopprot.h"

#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-variable"

#define MAX_ERROR_COUNT 65535
#define MAXFNAMELEN		64
#define isquote(C) ((C) == '\"')
#ifndef ENABLE_MULTIPLE_NODES
DB_CompatibilityAttr g_dbCompatArray[] = {
    {DB_CMPT_A, "A"},
    {DB_CMPT_B, "B"},
    {DB_CMPT_C, "C"},
    {DB_CMPT_PG, "PG"}
};

IntervalStylePack g_interStyleVal = {"a"};
#endif

/* Location tracking support --- simpler than bison's default */

#define YYLLOC_DEFAULT(Current, Rhs, N) \
	do { \
		if (N) \
			(Current) = (Rhs)[1]; \
		else \
			(Current) = (Rhs)[0]; \
	} while (0)

/*
 * Bison doesn't allocate anything that needs to live across parser calls,
 * so we can easily have it use palloc instead of malloc.  This prevents
 * memory leaks if we error out during parsing.  Note this only works with
 * bison >= 2.0.  However, in bison 1.875 the default is to use alloca()
 * if possible, so there's not really much problem anyhow, at least if
 * you're building with gcc.
 */
#define YYMALLOC palloc
#define YYFREE   pfree
#ifdef YYLEX_PARAM
# define YYLEX yylex (&yylval, &yylloc, YYLEX_PARAM)
#else
# define YYLEX yylex (&yylval, &yylloc, yyscanner)
#endif

#define b_db_ColnameWithoutPrecision(func_colname) \
	do { \
		char b_db_colname[64] = func_colname"()"; \
		n->colname = pstrdup(b_db_colname); \
	} while (0)


#define b_db_ColnameWithPrecision(func_colname, int_node) \
	do { \
		char b_db_colname[64] = func_colname; \
		char precision_char[64]; \
		int precision_int = ((A_Const *)(int_node))->val.val.ival; \
		int rc = EOK; \
		rc = sprintf_s(precision_char, 64, "(%d)", precision_int); \
		securec_check_ss(rc, "\0", "\0"); \
		rc = strcat_s(b_db_colname, 64, precision_char); \
		securec_check(rc, "\0", "\0"); \
		n->colname = pstrdup(b_db_colname); \
	} while (0)

/* Private struct for the result of privilege_target production */
typedef struct PrivTarget
{
	GrantTargetType targtype;
	GrantObjectType objtype;
	List	   *objs;
} PrivTarget;

typedef struct TrgCharacter {
	bool is_follows;
	char* trigger_name;
} TrgCharacter;

typedef struct CreateTableOptions {
  List *inhRelations;             /* relations to inherit from (list of
                                    * inhRelation) */
  List *options;                  /* options from WITH clause */
  OnCommitAction oncommit;        /* what do we do at COMMIT? */
  char *tablespacename;           /* table space to use, or NULL */
  int8 row_compress;              /* row compression flag */
  PartitionState *partTableState; /* the PartitionState */
  Node *compress_type;
#ifdef PGXC
  DistributeBy *distributeby; /* distribution to use, or NULL */
  PGXCSubCluster *subcluster; /* subcluster of table */
#endif
  char *internalData; /* Used for create table like */
  char relkind;       /* type of object */
  Node *autoIncStart; /* DefElem for AUTO_INCREMENT = value*/
  CommentStmt *comment;
  int charset;
  char *collate;
  bool autoextend_size_option;
  bool avg_row_length_option;
  bool checksum_option;
  bool connection_option;
  bool directory_option;
  bool delay_key_write_option;
  bool encryption_option;
  bool engine_attribute_option; 
  bool insert_method_option;
  bool key_block_size_option;
  bool max_rows_option;
  bool min_rows_option;
  bool pack_keys_option;
  bool password_option;
  bool start_transaction_option;
  bool secondary_engine_attribute_option; 
  bool stats_auto_recalc_option;
  bool stats_persistent_option;
  bool stats_sample_pages_option;
  bool union_option;
  bool tablespace_option;
  bool is_row_compress_modified;
} CreateTableOptions;

typedef enum {
    OPT_INHERIT,
    OPT_WITH, 
    OPT_ONCOMMIT, 
    OPT_COMPRESS,
    OPT_DISTRIBUTEBY,
    OPT_SUBCLUSTER,
    OPT_TABLE_PARTITIONING_CLAUSE,
    OPT_INTERNAL_DATA,
    OPT_KIND,
    OPT_COMPRESSION,
    OPT_TABLESPACE,
    OPT_ENGINE,
    OPT_PARTITIONELEMENT,
    OPT_DOLPHIN_COLLATE,
    OPT_DOLPHIN_CHARSET,
    OPT_ROW_FORMAT,
    OPT_AUTO_INC,
    OPT_COMMENT_TAB,
    OPT_AUTOEXTEND_SIZE,
    OPT_AVG_ROW_LENGTH,
    OPT_CHECKSUM,
    OPT_CONNECTION,
    OPT_DIRECTORY,
    OPT_DELAY_KEY_WRITE,
    OPT_ENCRYPTION,
    OPT_ENGINE_ATTRIBUTE,
    OPT_INSERT_METHOD,
    OPT_KEY_BLOCK_SIZE,
    OPT_MAX_ROWS,
    OPT_MIN_ROWS,
    OPT_PACK_KEYS,
    OPT_PASSWORD,
    OPT_START_TRANSACTION,
    OPT_SECONDARY_ENGINE_ATTRIBUTE,
    OPT_STATS_AUTO_RECALC,
    OPT_STATS_PERSISTENT,
    OPT_STATS_SAMPLE_PAGES,
    OPT_UNION,
    OPT_TABLESPACE_STORAGE
} TableOptionType;

typedef struct SingleTableOption {
    TableOptionType option_type;
    union {
        char relkind;
        List *list_content;
        OnCommitAction oncommit;  /* what do we do at COMMIT? */
        char *char_content;
        int8 row_compress;  /* row compression flag */
        PartitionState *partTableState;
        Node *compress_type;
#ifdef PGXC
        DistributeBy *distributeby; /* distribution to use, or NULL */
        PGXCSubCluster *subcluster; /* subcluster of table */
#endif
        Node *autoIncStart;
        CommentStmt *comment;
        int charset;
        char* collate;
    } option;
}SingleTableOption;

typedef enum {
    OPT_INCLUDE,
    OPT_RELOPTIONS,
    OPT_TABLESPACE_INDEX,
    OPT_PARTITIONELEMENT_INDEX,
    OPT_COMMENT_INDEX,
    OPT_VISIBLE_INDEX
} IndexOptionType;

typedef struct CreateIndexOptions {
    char *tableSpace;           /* tablespace, or NULL for default */ 
    List *indexParams;          /* columns to index: a list of IndexElem */
    List *indexIncludingParams; /* additional columns to index: a list of IndexElem */ 
    List *options;              /* WITH clause options: a list of DefElem */
    CommentStmt *comment;
    bool visible;
} CreateIndexOptions;

typedef struct SingleIndexOption {
IndexOptionType option_type;
    union {
        List *list_content;
        char *char_content;
        CommentStmt *comment;
        bool visible;
    } option;
} SingleIndexOption;

typedef struct IndexMethodRelationClause {
	char* accessMethod;
	RangeVar* relation;
} IndexMethodTargetClause;

typedef struct OptLikeWhere
{
    bool is_like;
    Node *like_or_where;
} OptLikeWhere;

typedef struct DolphinString
{
	Node* node;
	char* str;
	bool is_quoted;
	bool is_sconst;
} DolphinString;

/* ConstraintAttributeSpec yields an integer bitmask of these flags: */
#define CAS_NOT_DEFERRABLE			0x01
#define CAS_DEFERRABLE				0x02
#define CAS_INITIALLY_IMMEDIATE		0x04
#define CAS_INITIALLY_DEFERRED		0x08
#define CAS_NOT_VALID				0x10
#define CAS_NO_INHERIT				0x20

/*
 * In the IntoClause structure there is a char value which will eventually be
 * set to RELKIND_RELATION or RELKIND_MATVIEW based on the relkind field in
 * the statement-level structure, which is an ObjectType. Define the default
 * here, which should always be overridden later.
 */
#define INTO_CLAUSE_RELKIND_DEFAULT    '\0'

#define parser_yyerror(msg)  scanner_yyerror(msg, yyscanner)
#define parser_errposition(pos)  scanner_errposition(pos, yyscanner)

#define SYS_SCHEMA_COUNT 14

/* Boundary values for the parameter of blob(n) */
#define MIN_TINYBLOB 0
#define MIN_BLOB 2 << 7
#define MIN_MEDIUMBLOB 2 << 15
#define MIN_LONGBLOB 2 << 23
#define MAX_LONGBLOB 4294967295

static const char* sys_schemas[SYS_SCHEMA_COUNT] = {
	"pg_toast",
	"cstore",
	"pkg_service",
	"dbe_perf",
	"snapshot",
	"blockchain",
	"pg_catalog",
	"public",
	"sqladvisor",
	"dbe_pldebugger",
	"dbe_pldeveloper",
	"dbe_sql_util",
	"information_schema",
	"db4ai"
};

static void base_yyerror(YYLTYPE *yylloc, core_yyscan_t yyscanner,
						 const char *msg);
static Node *makeColumnRef(char *colname, List *indirection,
						   int location, core_yyscan_t yyscanner);
static Node *makeTypeCast(Node *arg, TypeName *typname, int location);
static Node *makeStringConst(char *str, int location);
static Node *makeStringConstCast(char *str, int location, TypeName *typname);
static Node *makeIntConst(int val, int location);
static Node *makeFloatConst(char *str, int location);
static Node *makeBitStringConst(char *str, int location);
Node *makeAConst(Value *v, int location);
Node *makeBoolAConst(bool state, int location);
static void check_qualified_name(List *names, core_yyscan_t yyscanner);
static void check_dolphin_qualified_name(List *names, core_yyscan_t yyscanner);
static List *check_func_name(List *names, core_yyscan_t yyscanner);
static List *check_setting_name(List *names, core_yyscan_t yyscanner);
static List *check_indirection(List *indirection, core_yyscan_t yyscanner);
static List *extractArgTypes(List *parameters);
static void insertSelectOptions(SelectStmt *stmt,
								List *sortClause, List *lockingClause,
								Node *limitOffset, Node *limitCount,
								WithClause *withClause,
								core_yyscan_t yyscanner);
static Node *makeSetOp(SetOperation op, bool all, Node *larg, Node *rarg);
static Node *doNegate(Node *n, int location);
static void doNegateFloat(Value *v);
static Node *makeAArrayExpr(List *elements, int location);
static Node *makeXmlExpr(XmlExprOp op, char *name, List *named_args,
						 List *args, int location);
static Node *makeCallFuncStmt(List* funcname, List* parameters, bool is_call = false);
static List *mergeTableFuncParameters(List *func_args, List *columns);
static TypeName *TableFuncTypeName(List *columns);
static RangeVar *makeRangeVarFromAnyName(List *names, int position, core_yyscan_t yyscanner);
static void SplitColQualList(List *qualList,
							 List **constraintList, CollateClause **collClause, List **columnOptions,
							 core_yyscan_t yyscanner);
static void SplitColQualList(List *qualList,
							 List **constraintList, CollateClause **collClause, ClientLogicColumnRef **clientLogicColumnRef,
							 List **columnOptions, core_yyscan_t yyscanner);
static void processCASbits(int cas_bits, int location, const char *constrType,
			   bool *deferrable, bool *initdeferred, bool *not_valid,
			   bool *no_inherit, core_yyscan_t yyscanner);
static Node *processIntoClauseInSelectStmt(SelectStmt *stmt, IntoClause *itc);
static char* GetPkgName(char* pkgName);
static Expr *makeNodeDecodeCondtion(Expr* firstCond,Expr* secondCond);
static List *make_action_func(List *arguments);
static List *get_func_args(char *sid);
static char *pg_strsep(char **stringp, const char *delim);
static long long get_pid(const char *strsid);
static Node *MakeAnonyBlockFuncStmt(int flag, const char * str);
static CharsetCollateOptions* MakeCharsetCollateOptions(CharsetCollateOptions *options, CharsetCollateOptions *option);
static Node *checkNullNode(Node *n);

static CreateTableOptions* MakeCreateTableOptions(CreateTableOptions *tableOptions, SingleTableOption *tableOption);
static CreateTableOptions* MergeCreateTableOptions(CreateTableOptions *frontTableOptions, CreateTableOptions *rearTableOptions);
static CreateIndexOptions* MakeCreateIndexOptions(CreateIndexOptions *indexOptions, SingleIndexOption *indexOption);
static SingleTableOption* CreateSingleTableOption(TableOptionType tableOptionType);
#define  TYPE_LEN     4 /* strlen("TYPE") */
#define  DATE_LEN     4 /* strlen("DATE") */
#define  DECLARE_LEN     9 /* strlen(" DECLARE ") */
#define  DECLARE_STR     " DECLARE "
#define  PACKAGE_STR     " PACKAGE "
#define  PACKAGE_LEN     9 /* strlen(" PACKAGE ") */
#define  INSTANTIATION_STR   " INSTANTIATION "
#define  INSTANTIATION_LEN     15
#define  BEGIN_STR       "BEGIN\n"
#define  BEGIN_LEN       6
#define  BEGIN_P_STR      " BEGIN_B_PROC " /* used in dolphin type proc body*/
#define  BEGIN_P_LEN      14
#define  END_STR         "\nEND\n"
#define  END_LEN         6
/* if delimiter is multiple characters like '$$', token will be set as END_OF_PROC. */
#define  TOKEN_IS_DELIMITER	(tok == END_OF_PROC || (strlen(u_sess->attr.attr_common.delimiter_name) == 1 && tok == u_sess->attr.attr_common.delimiter_name[0]))
static int get_outarg_num(List *fun_args);
static int get_table_modes(int nargs, const char *p_argmodes);
static void get_arg_mode_by_name(const char *argname, const char * const *argnames,
				const char *argmodes, const int proargnum,
				bool *have_assigend, char *argmode);
static void get_arg_mode_by_pos(const int pos, const char *argmodes, const int narg,
				bool *have_assigend, char *argmode);
static List *append_inarg_list(const char argmode, const ListCell *cell,List *in_parameter);
static void check_outarg_info(const bool *have_assigend,
				const char *argmodes,const int proargnum);
bool IsValidIdentClientKey(const char *input);
bool IsValidIdent(char *input);
bool IsValidIdentUsername(char *input);
bool IsValidGroupname(const char *input);
static void ParseUpdateMultiSet(List *set_target_list, SelectStmt *stmt, core_yyscan_t yyscanner);
static char *GetTargetFuncArgTypeName(char *typeString, TypeName* t);
static char *FormatFuncArgType(core_yyscan_t yyscanner, char *argsString, List* parameters);
static char *ParseFunctionArgSrc(core_yyscan_t yyscanner);
static void parameter_check_execute_direct(const char* query);
static Node *make_node_from_scanbuf(int start_pos, int end_pos, core_yyscan_t yyscanner);
static int64 SequenceStrGetInt64(const char *str);
static int GetLoadType(int load_type_f, int load_type_s);
static Node *MakeSqlLoadNode(char *colname);
static void checkDeleteRelationError();
static TypeName* parseFloatTypeByPrecision(int ival, int location, core_yyscan_t yyscanner, bool is_byprecision = true);
static TypeName* transferFloat4TypeInBFormat(char *typnam, List* list, int location, core_yyscan_t yyscanner);

/* start with .. connect by related utilities */
static bool IsConnectByRootIdent(Node* node);
static void ValidateTripleTuple(Node* node, core_yyscan_t yyscanner, int location, char* token);
static Node* MakeConnectByRootNode(ColumnRef* cr, int location);
static char* MakeConnectByRootColName(char* tabname, char* colname);
static void FilterStartWithUseCases(SelectStmt* stmt, List* locking_clause, core_yyscan_t yyscanner, int location);
static FuncCall* MakePriorAsFunc();
static Node* MakeSetPasswdStmt(char* user, char* passwd, char* replace_passwd);
static Node* MakeKillStmt(int kill_opt, Node *expr);
static Node* makeAnalyzeTableList(List *rangeVars);
static void with_rollup_check_elems_count(Node* expr);
static void CheckIconstType(Node* node);

/* B Compatibility Check */
static void BCompatibilityOptionSupportCheck(const char* keyword);

static char* TriggerBodyGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra);

#ifndef ENABLE_MULTIPLE_NODES
static bool CheckWhetherInColList(char *colname, List *col_list);
#endif
static int GetFillerColIndex(char *filler_col_name, List *col_list);
static void RemoveFillerCol(List *filler_list, List *col_list);
static int errstate;
static void CheckPartitionExpr(Node* expr, int* colCount);
static char* GetValidUserHostId(char* userName, char* hostId);
static void CheckHostId(char* hostId);
static void CheckUserHostIsValid();

static char* DoStmtPreformGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra);
static void setDelimiterName(core_yyscan_t yyscanner, char*input, VariableSetStmt*n);
static unsigned char GetLowerCaseChar(unsigned char ch, bool enc_is_single_byte);
static char* downcase_str(char* ident, bool is_quoted);
static DolphinString* MakeDolphinStringByChar(char* str, bool is_quoted);
static DolphinString* MakeDolphinStringByNode(Node* node, bool is_quoted);
static List* GetNameListFromDolphinString(List* dolphinStringList);
static char* GetDolphinObjName(char* string, bool is_quoted);
static bool DolphinObjNameCmp(const char* s1, const char* s2, bool is_quoted);
static char* GetDolphinSchemaName(char* string, bool is_quoted);
static char* SingleLineProcedureQueryGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra);
static void setAccessMethod(Constraint *n);
static SelectStmt *MakeFunctionSelect(char *funcCall, List* args, core_yyscan_t yyscanner);
static SelectStmt *MakeShowGrantStmt(char *arg, int location, core_yyscan_t yyscanner);
static List* handleCreateDolphinFuncOptions(List* input_options);
static char* appendString(char* source, char* target, int offset);
static inline void ChangeBpcharCastType(TypeName* typname);
/**
 * ANY KEYWORD
 */
static inline List* NakeLikeOpList();
static inline List* MakeNotLikeOpList();
static inline Node* MakeSubLinkWithOp(SubLinkType subType, Node* testExpr, char* op, Node* subSelect, int location);
/* null is the minimum value in sortby */
static inline SortByNulls GetNullOrderRule(SortByDir sortBy, SortByNulls nullRule);
%}

%define api.pure
%expect 0
%name-prefix "base_yy"
%locations

%parse-param {core_yyscan_t yyscanner}
%lex-param   {core_yyscan_t yyscanner}

%union
{
	core_YYSTYPE		core_yystype;
	/* these fields must match core_YYSTYPE: */
	int					ival;
	char				*str;
	const char			*keyword;

	char				chr;
	bool				boolean;
	int64				ival64;
	JoinType			jtype;
	DropBehavior		dbehavior;
	OnCommitAction		oncommit;
	List				*list;
	Node				*node;
	Value				*value;
	ObjectType			objtype;
	TypeName			*typnam;
	FunctionSources		*fun_src;
	FunctionParameter   *fun_param;
	FunctionParameterMode fun_param_mode;
	FuncWithArgs		*funwithargs;
	DefElem				*defelt;
	SortBy				*sortby;
	WindowDef			*windef;
	JoinExpr			*jexpr;
	IndexElem			*ielem;
	Alias				*alias;
	RangeVar			*range;
	IntoClause			*into;
	WithClause			*with;
	A_Indices			*aind;
	ResTarget			*target;
	struct PrivTarget	*privtarget;
	struct TrgCharacter *trgcharacter;
	struct OptLikeWhere	*optlikewhere;
	AccessPriv			*accesspriv;
	DbPriv				*dbpriv;
	InsertStmt			*istmt;
	VariableSetStmt		*vsetstmt;
/* PGXC_BEGIN */
	DistributeBy		*distby;
	PGXCSubCluster		*subclus;
/* PGXC_END */
    ForeignPartState    *foreignpartby;
	MergeWhenClause		*mergewhen;
	UpsertClause *upsert;
	EncryptionType algtype;
	LockClauseStrength lockstrength;
	CharsetCollateOptions *charsetcollateopt;
	OnDuplicateAction onduplicate;
	struct CreateTableOptions	*createtableoptions;
	struct SingleTableOption	*singletableoption;
	struct CreateIndexOptions	*createindexoptions;
	struct SingleIndexOption	*singleindexoption;
	struct IndexMethodRelationClause *indexmethodrelationclause;
	struct DolphinString		*dolphinString;
	struct DolphinIdent			*dolphinIdent;
}
%type <singletableoption> CreateOption CreateIfNotExistsOption CreateAsOption CreateTableOption
%type <createtableoptions> CreateOptionList CreateIfNotExistsOptionList CreateAsOptionList
		CreateTableOptionList CreateOptionEtcList CreateOptionBeforeList CreateOptionBefore CreateOptionAfterList CreateOptionAfter
		CreateIfNotExistsOptionEtcList CreateIfNotExistsOptionBeforeList CreateIfNotExistsOptionBefore CreateIfNotExistsOptionAfterList CreateIfNotExistsOptionAfter
		CreateAsOptionEtcList CreateAsOptionBeforeList CreateAsOptionBefore CreateAsOptionAfterList CreateAsOptionAfter
%type <singleindexoption> TableIndexOption PartitionTableIndexOption
%type <createindexoptions> TableIndexOptionList PartitionTableIndexOptionList
%type <indexmethodrelationclause> index_method_relation_clause fulltext_index_method_relation_clause
%type <node>	stmt schema_stmt
		AlterEventTrigStmt
		AlterDatabaseStmt AlterDatabaseSetStmt AlterDataSourceStmt AlterDomainStmt AlterEnumStmt AlterEventStmt
		AlterFdwStmt AlterForeignServerStmt AlterGroupStmt AlterSchemaStmt
		AlterObjectSchemaStmt AlterOwnerStmt AlterSeqStmt AlterTableStmt
		AlterExtensionStmt AlterExtensionContentsStmt AlterForeignTableStmt
		AlterCompositeTypeStmt AlterUserStmt AlterUserMappingStmt AlterUserSetStmt
		AlterSystemStmt
		AlterRoleStmt AlterRoleSetStmt AlterRlsPolicyStmt
		AlterDefaultPrivilegesStmt DefACLAction AlterSessionStmt
		AnalyzeStmt AnalyzePartitionStmt CleanConnStmt ClosePortalStmt ClusterStmt CommentStmt
		ConstraintsSetStmt CopyStmt CreateAsStmt CreateCastStmt CreateContQueryStmt CreateDirectoryStmt 
		CreateDomainStmt CreateExtensionStmt CreateGroupStmt CreateKeyStmt CreateOpClassStmt
		CreateOpFamilyStmt AlterOpFamilyStmt CreatePLangStmt
		CreateSchemaStmt CreateSeqStmt CreateStmt CreateStreamStmt CreateTableSpaceStmt
		CreateFdwStmt CreateForeignServerStmt CreateForeignTableStmt
		CreateDataSourceStmt
		CreateAssertStmt CreateTrigStmt CreateEventTrigStmt
		CreateUserStmt CreateUserMappingStmt CreateRoleStmt CreateRlsPolicyStmt CreateSynonymStmt
		CreatedbStmt DeclareCursorStmt DefineStmt DeleteStmt DiscardStmt DoStmt
		DropGroupStmt DropOpClassStmt DropOpFamilyStmt DropPLangStmt DropStmt DropEventStmt ShowEventStmt
		DropAssertStmt DropSynonymStmt DropTrigStmt DropRuleStmt DropCastStmt DropRoleStmt DropRlsPolicyStmt
		DropUserStmt DropdbStmt DropTableSpaceStmt DropDataSourceStmt DropDirectoryStmt DropFdwStmt
		DropForeignServerStmt DropUserMappingStmt ExplainStmt ExecDirectStmt FetchStmt
		GrantStmt GrantRoleStmt GrantDbStmt IndexStmt InsertStmt KillStmt ListenStmt LoadStmt
		LockStmt NotifyStmt ExplainableStmt PreparableStmt
		CreateFunctionStmt CreateEventStmt CreateProcedureStmt CreatePackageStmt CreatePackageBodyStmt AlterFunctionStmt AlterProcedureStmt ReindexStmt RemoveAggrStmt
		RemoveFuncStmt RemoveOperStmt RemovePackageStmt RenameStmt RevokeStmt RevokeRoleStmt RevokeDbStmt
		RuleActionStmt RuleActionStmtOrEmpty RuleStmt
		SecLabelStmt SelectStmt SelectStmtWithoutWithClause TimeCapsuleStmt TransactionStmt TruncateStmt CallFuncStmt
		UnlistenStmt UpdateStmt VacuumStmt
		VariableResetStmt VariableSetStmt VariableShowStmt VerifyStmt ShutdownStmt VariableMultiSetStmt
		UseStmt
		ViewStmt ViewStmtBaseBody CheckPointStmt CreateConversionStmt
		DeallocateStmt PrepareStmt ExecuteStmt
		DropOwnedStmt ReassignOwnedStmt
		AlterTSConfigurationStmt AlterTSDictionaryStmt AnonyBlockStmt
		BarrierStmt AlterNodeStmt CreateNodeStmt DropNodeStmt AlterCoordinatorStmt
		AlterNodeGroupStmt DropNodeGroupStmt
		CreatePolicyLabelStmt AlterPolicyLabelStmt DropPolicyLabelStmt 
		CreateAuditPolicyStmt AlterAuditPolicyStmt DropAuditPolicyStmt 
		CreateMaskingPolicyStmt AlterMaskingPolicyStmt DropMaskingPolicyStmt
		CreateResourcePoolStmt AlterResourcePoolStmt DropResourcePoolStmt
		CreateWorkloadGroupStmt AlterWorkloadGroupStmt DropWorkloadGroupStmt
		CreateAppWorkloadGroupMappingStmt AlterAppWorkloadGroupMappingStmt DropAppWorkloadGroupMappingStmt
		MergeStmt PurgeStmt CreateMatViewStmt RefreshMatViewStmt
		CreateWeakPasswordDictionaryStmt DropWeakPasswordDictionaryStmt
		AlterGlobalConfigStmt DropGlobalConfigStmt
		CreatePublicationStmt AlterPublicationStmt
		CreateSubscriptionStmt AlterSubscriptionStmt DropSubscriptionStmt DelimiterStmt CheckSumTableStmt
		OptimizeStmt ShrinkStmt
		FlushStmt

/* <DB4AI> */
/* SNAPSHOTS */
%type <node>	SnapshotStmt
%type <list>	AlterSnapshotCmdOrEmpty AlterSnapshotCmdList AlterSnapshotCmdListNoParens
%type <list>	AlterSnapshotCmdListWithParens SnapshotSample SnapshotSampleList OptSnapshotStratify
%type <str>		SnapshotVersion OptSnapshotVersion OptSnapshotComment opt_bracket
%type <boolean>	OptSnapshotAlias AlterSnapshotDdl AlterSnapshotDdlList
%type <boolean>	OptAlterUpdateSnapshot OptInsertIntoSnapshot OptDeleteFromSnapshot

/* TRAIN MODEL */
%type <node>    CreateModelStmt	hyperparameter_name_value DropModelStmt
%type <list>	features_clause hyperparameter_name_value_list target_clause with_hyperparameters_clause
/* </DB4AI> */

%type <node>	select_no_parens select_no_parens_without_withclause select_with_parens select_clause
				simple_select values_clause insert_empty_values

%type <node>	alter_column_default opclass_item opclass_drop alter_using AutoIncrementValue
%type <ival>	add_drop opt_asc_desc opt_nulls_order con_asc_desc
%type <ival>	OptNoLog
%type <str>	unique_name

%type <node>	alter_table_cmd alter_table_option alter_partition_cmd alter_type_cmd opt_collate_clause exchange_partition_cmd move_partition_cmd
				modify_column_cmd reset_partition_cmd
				replica_identity add_column_first_after event_from_clause 
%type <list>	alter_table_cmds alter_table_option_list alter_partition_cmds alter_table_or_partition alter_index_or_partition alter_type_cmds add_column_cmds modify_column_cmds alter_index_rebuild_partition

%type <node>	AlterPartitionRebuildStmt AlterPartitionRemoveStmt AlterPartitionCheckStmt AlterPartitionRepairStmt AlterPartitionOptimizeStmt

%type <node>	drop_partition_cmd_for_bdatabase drop_subpartition_cmd_for_bdatabase drop_partition_cmd drop_subpartition_cmd add_partition_cmd

%type <list>	alter_partition_cmds_for_bdatabase alter_subpartition_cmds_for_bdatabase drop_partition_cmds_for_bdatabase drop_subpartition_cmds_for_bdatabase drop_partition_cmds drop_subpartition_cmds add_partition_cmds_for_bdatabase

%type <list>	partition_name_list partition_name_list_all

%type <node>	exchange_partition_cmd_for_bdatabase truncate_partition_cmd truncate_partition_cmd_for_bdatabase

%type <list>	truncate_partition_cmds truncate_partition_cmds_for_bdatabase

%type <dbehavior>	opt_drop_behavior

%type <list>	createdb_opt_list alterdb_opt_list copy_opt_list
				transaction_mode_list weak_password_string_list
				create_extension_opt_list alter_extension_opt_list
				pgxcnode_list pgxcnodes bucket_list lines_options_fin
				opt_pgxcnodes fields_options_list fields_options_fin lines_options_list
%type <defelt>	createdb_opt_item alterdb_opt_item copy_opt_item characterset_option
				transaction_mode_item lines_option_item fields_options_item
				create_extension_opt_item alter_extension_opt_item
				start_opt preserve_opt rename_opt status_opt comments_opt action_opt
				end_opt definer_name_opt

%type <list>	opt_fields_options fields_list opt_lines_options lines_list expr_do_list
%type <defelt>	opt_ignore_number opt_character fields_option lines_option conflict_option opt_do_language
%type <ival>	opt_lock lock_type cast_context opt_wait opt_lock_for_b kill_opt
%type <ival>	vacuum_option_list vacuum_option_elem opt_verify_options
%type <boolean>	opt_check opt_force opt_or_replace
				opt_grant_grant_option opt_grant_admin_option
				opt_nowait opt_if_exists opt_with_data opt_large_seq opt_cancelable
%type <ival>	opt_nowait_or_skip

%type <list>	OptRoleList AlterOptRoleList
%type <defelt>	CreateOptRoleElem AlterOptRoleElem

%type <str>		opt_type
%type <str>		foreign_server_version opt_foreign_server_version
%type <str>		data_source_version opt_data_source_version data_source_type opt_data_source_type
%type <str>		auth_ident
%type <str>		opt_in_database opt_rename

%type <str>		OptSchemaName
%type <list>	OptSchemaEltList
%type <boolean>	OptBlockchainWith OptAlterToBlockchain

%type <boolean> TriggerForSpec TriggerForType ForeignTblWritable
%type <ival>	TriggerActionTime DolphinTriggerActionTime
%type <list>	TriggerEvents TriggerOneEvent
%type <value>	TriggerFuncArg
%type <node>	TriggerWhen
%type <list>   event_trigger_when_list event_trigger_value_list
%type <defelt> event_trigger_when_item
%type <chr>        enable_trigger

%type <str>		copy_file_name definer_opt user ev_body ev_where_body event_where_clause
				database_name access_method_clause access_method access_method_clause_without_keyword attr_name
				name namedata_string fdwName cursor_name file_name
				index_name cluster_index_specification dolphin_index_name
				pgxcnode_name pgxcgroup_name resource_pool_name workload_group_name
				application_name password_string hint_string dolphin_force_index_name
%type <list>	func_name func_name_opt_arg dolphin_func_name_opt_arg pkg_name  handler_name qual_Op qual_all_Op dolphin_func_name
				opt_class opt_inline_handler opt_validator validator_clause
				opt_collation collate_option

%type <range>	qualified_name insert_target OptConstrFromTable opt_index_name insert_partition_clause update_delete_partition_clause dolphin_qualified_name
				qualified_trigger_name

%type <str>		all_Op MathOp OptDbName
%type <str>		SingleLineProcPart
%type <list>		proc_arg_no_empty


%type <str>		RowLevelSecurityPolicyName row_level_security_cmd RLSDefaultForCmd row_level_security_role
%type <boolean>	RLSDefaultPermissive
%type <node>	RLSOptionalUsingExpr
%type <list>	row_level_security_role_list RLSDefaultToRole RLSOptionalToRole

%type <str>		iso_level opt_encoding opt_encoding2
%type <node>	grantee
%type <list>	grantee_list
%type <accesspriv> privilege routine_privilege temporary_privilege index_privilege
%type <list>	privileges privilege_list db_privileges db_privilege_list
%type <list>    routine_privilege_list routine_privileges temporary_privilege_list temporary_privileges index_privilege_list index_privileges
%type <dbpriv>  db_privilege
%type <str>		privilege_str
%type <privtarget> privilege_target routine_target temporary_target index_target
%type <optlikewhere> OptLikeOrWhere LikeOrWhere
%type <funwithargs> function_with_argtypes
%type <list>	function_with_argtypes_list
%type <ival>	defacl_privilege_target
%type <defelt>	DefACLOption
%type <list>	DefACLOptionList

%type <list>	stmtblock stmtmulti
				OptTableElementList TableElementList OptInherit_without_empty definition tsconf_definition
				OptTypedTableElementList TypedTableElementList
				OptForeignTableElementList ForeignTableElementList
				reloptions opt_reloptions opt_reloptions_without_empty opt_tblspc_options tblspc_options opt_cfoptions cfoptions
				OptWith OptWith_without_empty opt_distinct opt_definition func_args func_args_list
				func_args_with_defaults func_args_with_defaults_list proc_args
				func_as createfunc_opt_list opt_createproc_opt_list alterfunc_opt_list opt_createfunc_opt_list
				aggr_args old_aggr_definition old_aggr_list
				oper_argtypes RuleActionList RuleActionMulti
				opt_column_list columnList opt_name_list opt_analyze_column_define opt_multi_name_list
				opt_include_without_empty opt_c_include index_including_params
				sort_clause opt_sort_clause sortby_list index_params fulltext_index_params table_index_elems constraint_params
				name_list UserIdList from_clause from_list from_list_parens opt_array_bounds dolphin_schema_name_list
				qualified_name_list any_name type_name_list collate_name any_name_or_sconst any_name_list dolphin_qualified_name_list dolphin_any_name dolphin_any_name_list
				any_operator expr_list attrs callfunc_args callfunc_args_or_empty dolphin_attrs rename_user_clause rename_list
				target_list insert_column_list set_target_list rename_clause_list rename_clause
				set_clause_list set_clause multiple_set_clause
				ctext_expr_list ctext_row def_list tsconf_def_list indirection opt_indirection dolphin_indirection opt_dolphin_indirection
				reloption_list tblspc_option_list cfoption_list group_clause TriggerFuncArgs select_limit
				opt_select_limit opt_delete_limit opclass_item_list opclass_drop_list
				opclass_purpose opt_opfamily transaction_mode_list_or_empty
				OptTableFuncElementList TableFuncElementList opt_type_modifiers
				prep_type_clause
				execute_param_clause using_clause returning_clause
				opt_enum_val_list enum_val_list table_func_column_list
				create_generic_options alter_generic_options
				relation_expr_list dostmt_opt_list
				merge_values_clause publication_name_list empty_value insert_set_list insert_set_clause
				relation_expr_opt_alias_list into_user_var_list user_list

/* b compatibility: comment start */
%type <list>	opt_index_options index_options opt_table_options table_options opt_column_options column_options
%type <node>	index_option table_option column_option table_index_option
%type <list>	opt_table_index_options table_index_options

%type <str>     opt_part_options
%type <list>    part_options
%type <node>    part_option
/* b compatibility: comment end */

%type <list>	key_usage_list index_hint_list opt_index_hint_list
%type <node>	index_hint_definition
%type <list>	group_by_list
%type <node>	group_by_item empty_grouping_set rollup_clause cube_clause
%type <node>	grouping_sets_clause OptAutoIncrement_without_empty
%type <node>	opt_publication_for_tables publication_for_tables
%type <value>	publication_name_item

%type <list>	opt_fdw_options fdw_options
%type <defelt>	fdw_option

%type <range>	OptTempTableName
%type <into>	into_clause create_as_target create_as_target_dolphin create_mv_target opt_into_clause

%type <defelt>	createfunc_opt_item createproc_opt_item common_func_opt_item dostmt_opt_item
%type <fun_param> func_arg func_arg_with_default table_func_column
%type <fun_param_mode> arg_class
%type <typnam>	func_return func_type

%type <boolean>  opt_trusted opt_restart_seqs opt_purge invoker_rights
%type <ival>	 OptTemp TempExpr OptKind_without_empty
%type <oncommit> OnCommitOption OnCommitOption_without_empty
%type <onduplicate>	OptDuplicate
%type <lockstrength> for_locking_strength
%type <node>	for_locking_item
%type <list>	for_locking_clause opt_for_locking_clause for_locking_items
%type <list>	locked_rels_list
%type <boolean>	opt_all

%type <node>	join_outer join_qual
%type <jtype>	join_type

%type <list>	extract_list timestamp_arg_list overlay_list position_list

%type <list>	substr_list trim_list
%type <list>	opt_interval interval_second opt_single_interval opt_multipart_interval event_interval_unit opt_evtime_unit
%type <node>	overlay_placing substr_from substr_for optional_precision get_format_time_type

%type <boolean> opt_instead opt_incremental
%type <boolean> opt_unique opt_concurrently opt_verbose opt_verbose_empty opt_verbose_with_brance opt_full opt_deltamerge opt_compact opt_hdfsdirectory opt_verify opt_global OptQuickExt
%type <boolean> opt_freeze opt_freeze_empty opt_default opt_recheck opt_cascade
%type <defelt>	opt_oids copy_delimiter opt_noescaping
%type <defelt>	OptCopyLogError OptCopyRejectLimit opt_load

%type <boolean> opt_processed
%type <boolean> opt_full_fields
%type <defelt> opt_useeof

%type <str>		DirectStmt CleanConnDbName CleanConnUserName
/* PGXC_END */
%type <boolean> copy_from

%type <ival>	opt_column event cursor_options opt_hold opt_set_data
%type <objtype>	reindex_type drop_type dolphin_drop_type comment_type security_label_type dolphin_comment_type dolphin_security_label_type

%type <node>	fetch_args limit_clause select_limit_value
				offset_clause select_offset_value
				select_offset_value2 opt_select_fetch_first_value
%type <list>	limit_offcnt_clause
%type <ival>	row_or_rows first_or_next

%type <list>	OptSeqOptList SeqOptList
%type <defelt>	SeqOptElem

/* INSERT */
%type <istmt>	insert_rest insert_mysql_rest
%type <node>	upsert_clause

%type <mergewhen>	merge_insert merge_update

%type <vsetstmt> generic_set set_rest set_rest_more SetResetClause FunctionSetResetClause set_session_extension set_global_extension guc_variable_set generic_set_extension
%type <list>	VariableSetElemsList
%type <node>	set_global VariableSetElem

%type <node>	TableElement TypedTableElement ConstraintElem TableFuncElement
				ForeignTableElement
%type <node>	columnDef columnOptions columnDefForTableElement
%type <defelt>	def_elem tsconf_def_elem reloption_elem tblspc_option_elem old_aggr_elem cfoption_elem
%type <node>	def_arg columnElem where_clause where_or_current_clause start_with_expr connect_by_expr
                                a_expr a_expr_without_sconst b_expr c_expr c_expr_noparen c_expr_without_sconst AexprConst AexprConst_without_Sconst indirection_el siblings_clause
                                columnref in_expr start_with_clause having_clause func_table array_expr set_ident_expr set_expr set_expr_extension
				ExclusionWhereClause fulltext_match_params
%type <list>	ExclusionConstraintList ExclusionConstraintElem
%type <list>	func_arg_list
%type <node>	func_arg_expr
%type <list>	row explicit_row implicit_row type_list array_expr_list
%type <node>	case_expr case_arg when_clause case_default
%type <list>	when_clause_list
%type <ival>	sub_type opt_materialized
%type <node>	ctext_expr
%type <value>	NumericOnly
%type <list>	NumericOnly_list
%type <alias>	alias_clause opt_alias_clause dolphin_alias_clause opt_dolphin_alias_clause
%type <sortby>	sortby
%type <ielem>	index_elem table_index_elem constraint_elem fulltext_index_elem
%type <node>	table_ref single_table
%type <jexpr>	joined_table
%type <range>	relation_expr
%type <range>	relation_expr_opt_alias delete_relation_expr_opt_alias
%type <target>	target_el single_set_clause set_target insert_column_item connect_by_root_expr
%type <node>	tablesample_clause timecapsule_clause opt_timecapsule_clause opt_repeatable_clause end_expr start_expr

%type <str>		generic_option_name
%type <node>	generic_option_arg
%type <defelt>	generic_option_elem alter_generic_option_elem
%type <list>	generic_option_list alter_generic_option_list
%type <str>		explain_option_name
%type <keyword>	describe_command
%type <node>	explain_option_arg
%type <defelt>	explain_option_elem
%type <list>	explain_option_list
%type <node>	copy_generic_opt_arg copy_generic_opt_arg_list_item
%type <defelt>	copy_generic_opt_elem
%type <list>	copy_generic_opt_list copy_generic_opt_arg_list
%type <list>	copy_options

%type <typnam>	Typename SimpleTypename ConstTypename
				GenericType Numeric NumericNoConflict opt_float opt_float_noempty dolphin_float
				Character ConstCharacter
				CharacterWithLength CharacterWithoutLength
				PreciseConstDatetime ConstDatetime ConstSet
				Bit ConstBit BitWithLength BitWithoutLength client_logic_type
				datatypecl OptCopyColTypename EnumType
%type <str>		character
%type <str>		extract_arg msq_extract_arg
%type <str>		timestamp_units
%type <str>		selected_timezone

%type <keyword> character_set
%type <ival>	charset opt_charset convert_charset default_charset
%type <str>		collate opt_collate default_collate set_names_collate
%type <charsetcollateopt> CharsetCollate charset_collate optCharsetCollate

%type <boolean> opt_varying opt_timezone opt_no_inherit

%type <ival>	Iconst SignedIconst opt_partitions_num opt_subpartitions_num
%type <str>		Sconst comment_text notify_payload DolphinColColId 
%type <str>		RoleId RoleIdWithOutCurrentUser TypeOwner opt_granted_by opt_boolean_or_string ColId_or_Sconst Dolphin_ColId_or_Sconst definer_user definer_expression UserId
%type <list>	var_list guc_value_extension_list schema_var_list
%type <str>		ColId ColLabel var_name dolphin_var_name schema_var type_function_name param_name charset_collate_name opt_password opt_replace show_index_schema_opt ColIdForTableElement PrivilegeColId
%type <node>	var_value zone_value
%type <dolphinString>	DolphinColId DolphinColLabel dolphin_indirection_el

%type <keyword> unreserved_keyword type_func_name_keyword type_func_name_keyword_without_current_schema unreserved_keyword_without_key unreserved_keyword_without_proxy
%type <keyword> col_name_keyword reserved_keyword col_name_keyword_nonambiguous

%type <node>	TableConstraint TableIndexClause TableLikeClause ForeignTableLikeClause
%type <ival>	excluding_option_list TableLikeOptionList TableLikeIncludingOption TableLikeExcludingOption
%type <list>	ColQualList
%type <node>	ColConstraint ColConstraintElem ConstraintAttr InformationalConstraintElem
%type <ival>	key_actions key_delete key_match key_update key_action
%type <ival>	ConstraintAttributeSpec ConstraintAttributeElem
%type <str>		ExistingIndex

%type <list>	constraints_set_list
%type <boolean> constraints_set_mode
%type <boolean> OptRelative
%type <boolean> OptGPI
%type <str>		OptTableSpace OptTableSpace_without_empty OptConsTableSpace OptConsTableSpaceWithEmpty OptTableSpaceOwner LoggingStr size_clause OptMaxSize OptDatafileSize OptReuse OptAuto OptNextStr OptDatanodeName
%type <ival>	opt_check_option view_algo_expr view_algo_shift_expr opt_view_algo idx_algo_expr opt_idx_algo view_security_expression view_security_option

%type <str>		opt_provider security_label

%type <target>	xml_attribute_el
%type <list>	xml_attribute_list xml_attributes
%type <node>	xml_root_version opt_xml_root_standalone
%type <node>	xmlexists_argument
%type <ival>	document_or_content
%type <boolean> xml_whitespace_option

%type <node>	func_application func_with_separator func_expr_common_subexpr index_functional_expr_key func_application_special functime_app
%type <node>	func_expr func_expr_windowless
%type <node>	common_table_expr
%type <with>	with_clause opt_with_clause
%type <list>	cte_list

%type <node>	uservar_name user_defined_single

%type <list>	within_group_clause pkg_body_subprogram
%type <list>	window_clause window_definition_list opt_partition_clause
%type <windef>	window_definition over_clause window_specification
				opt_frame_clause frame_extent frame_bound
%type <str>		opt_existing_window_name opt_unique_key
%type <boolean>	opt_if_not_exists
%type <chr>		OptCompress OptCompress_without_empty generated_column_option
%type <ival>	KVType
%type <ival>		ColCmprsMode
%type <fun_src>		subprogram_body b_proc_body triggerbody_subprogram_or_single dolphin_flow_control flow_control_func_body
%type <node>    trigger_body_stmt
%type <keyword> as_is as_empty
%type <node>	column_item opt_table_partitioning_clause_without_empty
				opt_partition_index_def  range_partition_index_item  range_partition_index_list
				range_partitioning_clause value_partitioning_clause opt_interval_partition_clause
				interval_expr maxValueItem list_partitioning_clause hash_partitioning_clause
				range_start_end_item range_less_than_item list_partition_item hash_partition_item
				subpartitioning_clause range_subpartitioning_clause hash_subpartitioning_clause
				list_subpartitioning_clause subpartition_item opt_subpartition_index_def
                range_subpartition_index_list range_subpartition_index_item
%type <list>	range_partition_definition_list list_partition_definition_list hash_partition_definition_list maxValueList maxValueList_with_opt_parens listValueList
			column_item_list tablespaceList opt_interval_tablespaceList opt_hash_partition_definition_list
			split_dest_partition_define_list split_dest_listsubpartition_define_list split_dest_rangesubpartition_define_list
			range_start_end_list range_less_than_list opt_range_every_list subpartition_definition_list
%type <range> partition_name
%type <str>	opt_columns

%type <ival> opt_row_movement_clause
/* PGXC_BEGIN */
%type <str>		opt_barrier_id OptDistributeType SliceReferenceClause
%type <distby>	OptDistributeBy OptDistributeBy_without_empty OptDistributeByInternal distribute_by_range_clause
				distribute_by_list_clause
%type <list>	range_slice_definition_list range_slice_less_than_list range_slice_start_end_list
				list_distribution_rules_list list_distribution_rule_row list_distribution_rule_single
%type <node>	range_slice_less_than_item range_slice_start_end_item
				list_dist_state OptListDistribution list_dist_value interval_intexpr initime
				interval_list every_interval interval_cell ev_timeexpr 

%type <subclus> OptSubCluster OptSubCluster_without_empty OptSubClusterInternal
/* PGXC_END */

%type <str>		OptPartitionElement
%type <node>	OptForeignTableLogError OptForeignTableLogRemote OptCopyColExpr
%type <node> 	ForeignPosition ForeignColDef copy_col_format_def copy_column_expr_item
%type <node> 	OptPerNodeRejectLimit
%type <list> 	copy_foramtter_opt copy_column_expr_list

/* FOREIGN_PARTITION */
%type <foreignpartby> OptForeignPartBy OptForeignPartAuto
%type <node>	partition_item
%type <list>	partition_item_list

/* NODE GROUP */
%type <boolean> opt_vcgroup opt_to_elastic_group
%type <ival>	opt_set_vcgroup
%type <str>	opt_redistributed opt_internal_data_without_empty internal_data_body
%type <ival>	bucket_cnt
%type <str>	pgxcgroup_parent

/* MERGE INTO */
%type <node> merge_when_clause opt_merge_where_condition
%type <list> merge_when_list

/* ENCRYPTION */
%type <node> algorithm_desc CreateMasterKeyStmt CreateColumnKeyStmt master_key_elem column_key_elem with_algorithm
%type <list> master_key_params column_key_params
%type <list> columnEncryptionKey 
%type <algtype> encryptionType

/* CLIENT_LOGIC */
%type <list> setting_name

/* POLICY LABEL */
%type <str> 	policy_label_name policy_label_resource_type
				policy_label_filter_type policy_label_any_resource
%type <list> 	resources_to_label_list filters_to_label_list
				policy_label_items opt_add_resources_to_label
				resources_or_filters_to_label_list policy_labels_list
%type <defelt> resources_to_label_list_item filters_to_label_list_item
%type <range> policy_label_item policy_label_any_resource_item
/* AUDIT POLICY */
%type <list> alter_policy_filter_list alter_policy_privileges_list alter_policy_access_list
%type <str> policy_name policy_privilege_type policy_access_type policy_filter_type policy_filter_name policy_target_type
%type <range> policy_target_name
%type <boolean> policy_status_opt opt_ev_on_completion 
%type <defelt> policy_privilege_elem policy_access_elem policy_target_elem_opt
%type <node> policy_filter_elem pp_policy_filter_elem filter_term pp_filter_term filter_expr pp_filter_expr filter_paren filter_expr_list filter_set policy_filter_value 
%type <list> policy_filters_list policy_filter_opt policy_privileges_list policy_access_list policy_targets_list
%type <list> policy_names_list
%type <defelt>  policy_status_alter_clause 
%type <str> alter_policy_action_clause policy_comments_alter_clause

/* MASKING POLICY */
%type <str> 	masking_func masking_func_nsp masking_policy_target_type alter_masking_policy_action_clause
				masking_policy_condition_operator
%type <list> 	masking_clause masking_func_params_opt masking_func_params_list
				alter_masking_policy_func_items_list
%type <defelt> 	masking_clause_elem masking_target
%type <defelt> 	masking_func_param alter_masking_policy_func_item
%type <node> 	policy_condition_opt
%type <node> 	alter_policy_condition
%type <node> 	masking_policy_condition_value

/* LOAD DATA */
%type <list>	load_options_list load_table_options_list opt_load_data_options_list load_when_option_list
%type <ival>	load_type_set load_oper_table_type opt_ev_status
%type <defelt>	load_table_options_item opt_load_data_options_item load_when_option load_options_item
%type <str>     load_quote_str load_col_nullif_spec

%type <node>    load_column_expr_item load_col_sequence load_col_scalar_spec load_col_position_spec load_col_sql_str
%type <node>    copy_column_sequence_item copy_column_filler_item copy_column_constant_item load_when_option_item
%type <list>    load_column_expr_list copy_column_sequence_list copy_column_filler_list copy_column_constant_list 
%type <typnam>  load_col_data_type
%type <ival64>  load_col_sequence_item_sart column_sequence_item_step column_sequence_item_sart
%type <str>  comment_opt opt_label
%type <trgcharacter> trigger_order
%type <str> delimiter_str_name delimiter_str_names
%type <node>	on_table opt_engine engine_option opt_engine_without_empty opt_compression opt_compression_without_empty set_compress_type opt_row_format row_format_option
%type <keyword>	into_empty opt_temporary opt_values_in replace_empty
%type <str>	compression_args
%type <str> normal_ident
%type <boolean> opt_ignore field_unsigned

/* ALTER TABLESPACE */
%type <list>	alter_tblspc_option_list
%type <node>	alter_tblspc_option

%type <dolphinIdent>	DolphinRoleId DolphinRoleIdWithOutCurrentUser DolphinUserId DOLPHINIDENT

/*
 * Non-keyword token types.  These are hard-wired into the "flex" lexer.
 * They must be listed first so that their numeric codes do not depend on
 * the set of keywords.  PL/pgsql depends on this so that it can share the
 * same lexer.  If you add/change tokens here, fix PL/pgsql to match!
 *
 * DOT_DOT is unused in the core SQL grammar, and so will always provoke
 * parse errors.  It is needed by PL/pgsql.
 */
%token <str>	FCONST SCONST BCONST VCONST XCONST Op CmpOp CmpNullOp JsonOp JsonOpText COMMENTSTRING SET_USER_IDENT SET_IDENT UNDERSCORE_CHARSET
%token <ival>	ICONST PARAM
%token			TYPECAST ORA_JOINOP DOT_DOT COLON_EQUALS PARA_EQUALS SET_IDENT_SESSION SET_IDENT_GLOBAL

%token <dolphinIdent>	IDENT

/*
 * If you want to make any keyword changes, update the keyword table in
 * src/include/parser/kwlist.h and add new keywords to the appropriate one
 * of the reserved-or-not-so-reserved keyword lists, below; search
 * this file for "Keyword category lists".
 */

/* ordinary key words in alphabetical order */
/* PGXC - added DISTRIBUTE, DIRECT, COORDINATOR, CLEAN,  NODE, BARRIER, SLICE, DATANODE */
%token <keyword> ABORT_P ABSOLUTE_P ACCESS ACCOUNT ACTION ADD_P ADMIN AFTER
	AGGREGATE ALGORITHM ALL ALSO ALTER ALWAYS ANALYZE AND ANY APP APPEND ARCHIVE ARRAY AS ASC
        ASSERTION ASSIGNMENT ASYMMETRIC AT ATTRIBUTE AUDIT AUTHID AUTHORIZATION AUTOEXTEND AUTOEXTEND_SIZE AUTOMAPPED AUTO_INCREMENT AVG_ROW_LENGTH AGAINST

	BACKWARD BARRIER BEFORE BEGIN_NON_ANOYBLOCK BEGIN_P BETWEEN BIGINT BINARY BINARY_P BINARY_DOUBLE BINARY_INTEGER BIT BLANKS
	BLOB_P BLOCKCHAIN BODY_P BOGUS BOOLEAN_P BOTH BUCKETCNT BY BYTEAWITHOUTORDER BYTEAWITHOUTORDERWITHEQUAL

	CACHE CALL CALLED CANCELABLE CASCADE CASCADED CASE CAST CATALOG_P CHAIN CHANGE CHAR_P
	CHARACTER CHARACTERISTICS CHARACTERSET CHARSET CHECK CHECKPOINT CHECKSUM CLASS CLEAN CLIENT CLIENT_MASTER_KEY CLIENT_MASTER_KEYS CLOB CLOSE
	CLUSTER COALESCE COLLATE COLLATION COLUMN COLUMN_ENCRYPTION_KEY COLUMN_ENCRYPTION_KEYS COLUMNS COMMENT COMMENTS COMMIT
	COMMITTED COMPATIBLE_ILLEGAL_CHARS COMPLETE COMPLETION COMPRESS COMPRESSION CONCURRENTLY CONDITION CONFIGURATION CONNECTION CONSTANT CONSTRAINT CONSTRAINTS
	CONTAINS CONTENT_P CONTINUE_P CONTVIEW CONVERSION_P CONVERT CONNECT COORDINATOR COORDINATORS COPY COST CREATE
	CROSS CSN CSV CUBE CURRENT_P
	CURRENT_CATALOG CURRENT_DATE CURRENT_ROLE CURRENT_SCHEMA
	CURRENT_TIME CURTIME CURRENT_TIMESTAMP CURRENT_USER CURSOR CYCLE NOW_FUNC
	SHRINK

	DATA_P DATABASE DATABASES DATAFILE DATANODE DATANODES DATATYPE_CL DATE_P DATETIME DATE_FORMAT_P DAY_P DAY_HOUR_P DAY_MICROSECOND_P DAY_MINUTE_P DAY_SECOND_P DAYOFMONTH DAYOFWEEK DAYOFYEAR DBCOMPATIBILITY_P DB_B_FORMAT DB_B_JSOBJ DEALLOCATE DEC DECIMAL_P DECLARE DECODE DEFAULT DEFAULTS
	DEFERRABLE DEFERRED DEFINER DELAYED DELAY_KEY_WRITE DELETE_P DELIMITER DELIMITERS DELTA DELTAMERGE DESC DESCRIBE DETERMINISTIC DISK DIV
/* PGXC_BEGIN */
	DICTIONARY DIRECT DIRECTORY DISABLE_P DISCARD DISTINCT DISTINCTROW DISTRIBUTE DISTRIBUTION DO DOCUMENT_P DOMAIN_P DOUBLE_P DUAL_P
/* PGXC_END */
	DROP DUPLICATE DISCONNECT DUMPFILE

	EACH ELASTIC ELSE ENABLE_P ENCLOSED ENCODING ENCRYPTED ENCRYPTED_VALUE ENCRYPTION ENCRYPTION_TYPE END_P ENDS ENFORCED ENGINE_ATTRIBUTE ENGINE_P ENUM_P ERRORS ESCAPE ESCAPED EOL ESCAPING EVENT EVENTS EVERY EXCEPT EXCHANGE
	EXCLUDE EXCLUDING EXCLUSIVE EXECUTE EXISTS EXPANSION EXPIRED_P EXPLAIN
	EXTENDED EXTENSION EXTERNAL EXTRACT

	FALSE_P FAMILY FAST FENCED FETCH FIELDS FILEHEADER_P FILL_MISSING_FIELDS FILLER FILTER FIRST_P FIXED_P FLOAT_P FLUSH FOLLOWING FOLLOWS_P FOR FORCE FOREIGN FORMATTER FORWARD
	FEATURES // DB4AI
	FREEZE FROM FULL FULLTEXT FUNCTION FUNCTIONS

	GENERATED GET_FORMAT GLOBAL GRANT GRANTED GREATEST GROUP_P GROUPING_P GROUPPARENT GRANTS TRIGGERS

	HANDLER HAVING HDFSDIRECTORY HEADER_P HOLD HOSTS HOUR_P HOUR_MICROSECOND_P HOUR_MINUTE_P HOUR_SECOND_P

	IDENTIFIED IDENTITY_P IF_P IFNULL IGNORE IGNORE_EXTRA_DATA ILIKE IMMEDIATE IMMUTABLE IMPLICIT_P IN_P INCLUDE
	INCLUDING INCREMENT INCREMENTAL INDEX INDEXES INFILE INHERIT INHERITS INITIAL_P INITIALLY INITRANS INLINE_P

	INNER_P INOUT INPLACE INPUT_P INSENSITIVE INSERT INSERT_METHOD INSTEAD INT_P INTEGER INTERNAL
	INTERSECT INTERVAL INTO INVISIBLE INVOKER IP IS ISNULL ISOLATION

	JOIN

	KEY KEY_BLOCK_SIZE KEYS KILL KEY_PATH KEY_STORE

	LABEL LANGUAGE LARGE_P LAST_DAY_FUNC LAST_P LC_COLLATE_P LC_CTYPE_P LEADING LEAKPROOF
	LEAST LESS LEFT LEVEL LIKE LINES LIMIT LIST LISTEN LOAD LOCAL LOCALTIME LOCALTIMESTAMP
	LOCATE LOCATION LOCK_P LOCKED LOG_P LOGGING LOGIN_ANY LOGIN_FAILURE LOGIN_SUCCESS LOGOUT LOGS LOOP LOW_PRIORITY
	MAPPING MASKING MASTER MATCH MATERIALIZED MATCHED MAXEXTENTS MAX_ROWS MAXSIZE MAXTRANS MAXVALUE MEDIUMINT MEMORY MERGE MICROSECOND_P MID MIN_ROWS MINUTE_P MINUTE_MICROSECOND_P MINUTE_SECOND_P MINVALUE MINEXTENTS MOD MODE MODIFY_P MONTH_P MOVE MOVEMENT
	MODEL // DB4AI
	MODIFIES
	NAME_P NAMES NATIONAL NATURAL NCHAR NEXT NGRAM NO NOCOMPRESS NOCYCLE NODE NOLOGGING NOMAXVALUE NOMINVALUE NONE
	NOT NOTHING NOTIFY NOTNULL NOWAIT NULL_P NULLCOLS NULLIF NULLS_P NUMBER_P NUMERIC NUMSTR NVARCHAR NVARCHAR2 NVL
	NO_WRITE_TO_BINLOG

	OBJECT_P OF OFF OFFSET OIDS ON ONLY OPERATOR OPTIMIZATION OPTIMIZE OPTION OPTIONALLY OPTIONS OR
	ORDER OUT_P OUTER_P OVER OVERLAPS OVERLAY OWNED OWNER OUTFILE

	PACKAGE PACKAGES PACK_KEYS PARSER PARTIAL PARTITION PARTITIONING PARTITIONS PASSING PASSWORD PCTFREE PER_P PERCENT PERFORMANCE PERM PLACING PLAN PLANS POLICY POSITION
/* PGXC_BEGIN */
	POOL PRECEDING PRECISION
/* PGXC_END */
	PREDICT  // DB4AI
/* PGXC_BEGIN */
	PREFERRED PREFIX PRESERVE PREPARE PREPARED PRIMARY
/* PGXC_END */
	PRECEDES_P PRIVATE PRIOR PRIORER PRIVILEGES PRIVILEGE PROCEDURAL PROCEDURE PROCESSLIST PROFILE PROXY PUBLICATION PUBLISH PURGE

	QUARTER QUERY QUICK QUOTE

	RANDOMIZED RANGE RATIO RAW READ READS REAL REASSIGN REBUILD RECHECK RECURSIVE RECYCLEBIN REDISANYVALUE REF REFERENCES REFRESH REINDEX REJECT_P
	RELATIVE_P RELEASE RELOPTIONS REMOTE_P REMOVE RENAME REPEAT REPEATABLE REPLACE REPLICA REGEXP REORGANIZE REPAIR
	RESET RESIZE RESOURCE RESTART RESTRICT RETURN RETURNING RETURNS REUSE REVOKE RIGHT RLIKE ROLE ROLES ROLLBACK ROLLUP
	ROTATION ROUTINE ROW ROWS ROWTYPE_P ROW_FORMAT RULE

	SAMPLE SAVEPOINT SCHEDULE SCHEMA SCHEMAS SCROLL SEARCH SECONDARY_ENGINE_ATTRIBUTE SECOND_P SECOND_MICROSECOND_P SECURITY SELECT SEPARATOR_P SEQUENCE SEQUENCES
	SERIALIZABLE SERVER SESSION SESSION_USER SET SETS SETOF SHARE SHIPPABLE SHOW SHUTDOWN SIBLINGS SIGNED
	SIMILAR SIMPLE SIZE SKIP SLAVE SLICE SMALLDATETIME SMALLDATETIME_FORMAT_P SMALLINT SNAPSHOT SOME SOUNDS SOURCE_P SPACE SPILL SPLIT STABLE STANDALONE_P START STARTS STARTING STARTWITH
	STATEMENT STATEMENT_ID STATISTICS STATS_AUTO_RECALC STATS_PERSISTENT STATS_SAMPLE_PAGES STATUS STDIN STDOUT STORAGE STORE_P STORED STRATIFY STREAM STRICT_P STRIP_P SUBPARTITION SUBPARTITIONS SUBSCRIPTION SUBSTR SUBSTRING
	SYMMETRIC SYNONYM SYSDATE SYSID SYSTEM_P SYS_REFCURSOR SQL_P

	TABLE TABLES TABLESAMPLE TABLESPACE TARGET TEMP TEMPLATE TEMPORARY TEMPTABLE TERMINATED TEXT_P THAN THEN TIME TIME_FORMAT_P TIMECAPSULE TIMESTAMP TIMESTAMP_FORMAT_P TIMESTAMPADD TIMESTAMPDIFF TINYINT
	TO TRAILING TRANSACTION TRANSFORM TREAT TRIGGER TRIM TRUE_P
	TRUNCATE TRUSTED TSFIELD TSTAG TSTIME TYPE_P TYPES_P

	UNBOUNDED UNCOMMITTED UNDEFINED UNENCRYPTED UNION UNIQUE UNKNOWN UNLIMITED UNLISTEN UNLOCK UNLOGGED UNSIGNED
	UNTIL UNUSABLE UPDATE USE USEEOF USER USING UTC_DATE UTC_TIME UTC_TIMESTAMP

	VACUUM VALID VALIDATE VALIDATION VALIDATOR VALUE_P VALUES VARBINARY VARCHAR VARCHAR2 VARIABLES VARIADIC VARRAY VARYING VCGROUP
	VERBOSE VERIFY VERSION_P VIEW VISIBLE VOLATILE

	WAIT WARNINGS WEAK WHEN WHERE WHILE_P WHITESPACE_P WINDOW WITH WITHIN WITHOUT WORK WORKLOAD WRAPPER WRITE

	XML_P XMLATTRIBUTES XMLCONCAT XMLELEMENT XMLEXISTS XMLFOREST XMLPARSE XOR
	XMLPI XMLROOT XMLSERIALIZE

	YEAR_P YEAR_MONTH_P YES_P

	ZEROFILL ZONE

	AST DB_B_JSON DB_B_JSONB DB_B_BOX DB_B_CIRCLE DB_B_POLYGON DB_B_BYTEA DB_B_TIMETZ DB_B_TIMESTAMPTZ DB_B_CIDR

%token ALGORITHM_UNDEFINED ALGORITHM_MERGE ALGORITHM_TEMPTABLE

/*
 * The grammar thinks these are keywords, but they are not in the kwlist.h
 * list and so can never be entered directly.  The filter in parser.c
 * creates these tokens when required.
 */
%token		NULLS_FIRST NULLS_LAST WITH_TIME INCLUDING_ALL
			RENAME_PARTITION
			PARTITION_FOR
			SUBPARTITION_FOR
			ADD_PARTITION
			DROP_PARTITION
			REBUILD_PARTITION
			MODIFY_PARTITION
			ADD_SUBPARTITION
			DROP_SUBPARTITION
			NOT_ENFORCED
			VALID_BEGIN
			DECLARE_CURSOR ON_UPDATE_TIME
			START_WITH CONNECT_BY SHOW_ERRORS WITH_ROLLUP
			END_OF_INPUT
			END_OF_INPUT_COLON
			END_OF_PROC
			EVENT_TRIGGER
			NOT_IN NOT_BETWEEN NOT_LIKE NOT_ILIKE NOT_SIMILAR
			DEFAULT_FUNC MATCH_FUNC
			DO_SCONST DO_LANGUAGE SHOW_STATUS BEGIN_B_BLOCK
			FORCE_INDEX USE_INDEX LOCK_TABLES IGNORE_INDEX
			LABEL_LOOP LABEL_REPEAT LABEL_WHILE WITH_PARSER
			STORAGE_DISK STORAGE_MEMORY
			FULL_OUTER

/* Precedence: lowest to highest */
%nonassoc AUTHID /* AUTHID has lower priority than the BODY_P */
%nonassoc BODY_P /* BODY_P has higher priority than the AUTHID */
%nonassoc COMMENT
%nonassoc   FIRST_P AFTER
%nonassoc lower_than_key
%nonassoc KEY
%nonassoc lower_than_row
%nonassoc lower_than_on
%left ON USING
%nonassoc   KILL_OPT_EMPTY
%nonassoc   CONNECTION QUERY
%nonassoc   PASSWORD
%nonassoc   PARTIAL_EMPTY_PREC
%nonassoc   CLUSTER
%nonassoc	SET				/* see relation_expr_opt_alias */
%nonassoc	AUTO_INCREMENT
%right      PRIOR SEPARATOR_P
%right      FEATURES TARGET // DB4AI
%left		UNION EXCEPT
%left		INTERSECT
%left		OR XOR
%left		AND
%right		NOT
%right		'=' CmpNullOp COLON_EQUALS
%left		'<' '>' CmpOp
%nonassoc	BINARY
%nonassoc	LIKE ILIKE SIMILAR SOUNDS NOT_LIKE NOT_ILIKE NOT_SIMILAR ANY DO END_P
%nonassoc	ESCAPE
%nonassoc	OVERLAPS
%nonassoc	BETWEEN NOT_BETWEEN
%nonassoc	IN_P NOT_IN
%left		DIV MOD
%nonassoc	REGEXP RLIKE
%left		POSTFIXOP		/* dummy for postfix Op rules */
%nonassoc	lower_than_zerofill
%nonassoc	ZEROFILL
%nonassoc   FULL_OUTER
/*
 * To support target_el without AS, we must give IDENT an explicit priority
 * between POSTFIXOP and Op.  We can safely assign the same priority to
 * various unreserved keywords as needed to resolve ambiguities (this can't
 * have any bad effects since obviously the keywords will still behave the
 * same as if they weren't keywords).  We need to do this for PARTITION,
 * RANGE, ROWS to support opt_existing_window_name; and for RANGE, ROWS
 * so that they can follow a_expr without creating postfix-operator problems;
 * and for NULL so that it can follow b_expr in ColQualList without creating
 * postfix-operator problems.
 *
 * To support CUBE and ROLLUP in GROUP BY without reserving them, we give them
 * an explicit priority lower than '(', so that a rule with CUBE '(' will shift
 * rather than reducing a conflicting rule that takes CUBE as a function name.
 * Using the same precedence as IDENT seems right for the reasons given above.
 *
 * The frame_bound productions UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING
 * are even messier: since UNBOUNDED is an unreserved keyword (per spec!),
 * there is no principled way to distinguish these from the productions
 * a_expr PRECEDING/FOLLOWING.  We hack this up by giving UNBOUNDED slightly
 * lower precedence than PRECEDING and FOLLOWING.  At present this doesn't
 * appear to cause UNBOUNDED to be treated differently from other unreserved
 * keywords anywhere else in the grammar, but it's definitely risky.  We can
 * blame any funny behavior of UNBOUNDED on the SQL standard, though.
 */
%nonassoc	UNBOUNDED		/* ideally should have same precedence as IDENT */
%nonassoc	IDENT GENERATED NULL_P PARTITION SUBPARTITION RANGE ROWS PRECEDING FOLLOWING CUBE ROLLUP DB_B_JSON DB_B_JSONB DB_B_BOX DB_B_CIRCLE DB_B_POLYGON DB_B_BYTEA DB_B_TIMETZ DB_B_TIMESTAMPTZ DB_B_POINT
%left		Op OPERATOR '@'		/* multi-character ops and user-defined operators */
%nonassoc	NOTNULL
%nonassoc	ISNULL
%nonassoc	IS				/* sets precedence for IS NULL, etc */
%nonassoc	JsonOp JsonOpText
%left		'+' '-'
%left		'*' '/' '%'
%left		'^'
/* Unary Operators */
%left		AT				/* sets precedence for AT TIME ZONE */
%left		COLLATE
%right		UMINUS BY NAME_P PASSING ROW TYPE_P VALUE_P
%left		'[' ']'
%left		'(' ')'
%nonassoc   TEXT_P
%nonassoc   SCONST
%left		EMPTY_FROM_CLAUSE
%right		INTO
%left		TYPECAST
%left		'.'
/*
 * These might seem to be low-precedence, but actually they are not part
 * of the arithmetic hierarchy at all in their use as JOIN operators.
 * We make them high-precedence to support their use as function names.
 * They wouldn't be given a precedence at all, were it not that we need
 * left-associativity among the JOIN rules themselves.
 */
%left		JOIN CROSS LEFT FULL RIGHT INNER_P NATURAL ENCRYPTED
/* kluge to keep xml_whitespace_option from causing shift/reduce conflicts */
%right		PRESERVE STRIP_P
%%

/*
 *	The target production for the whole parse.
 */
stmtblock:	stmtmulti
			{
				pg_yyget_extra(yyscanner)->parsetree = $1;
			}
		;

/* the thrashing around here is to discard "empty" statements... */
stmtmulti:	stmtmulti ';' stmt
				{
					if ($3 != NULL)
					{
						if (IsA($3, List))
						{
							$$ = list_concat($1, (List*)$3);
						}
						else
						{
						$$ = lappend($1, $3);
						}
					}
					else
						$$ = $1;
				}
			| stmtmulti ';' END_OF_INPUT stmt
				{
					if ($4 != NULL)
					{
						if (IsA($4, List))
						{
							$$ = list_concat($1, (List*)$4);
						}
						else
						{
						$$ = lappend($1, $4);
						}
					}
					else
						$$ = $1;
				}
			| stmtmulti END_OF_INPUT_COLON stmt
				{
					if ($3 != NULL)
					{
						if (IsA($3, List))
						{
							$$ = list_concat($1, (List*)$3);
						}
						else
						{
						$$ = lappend($1, $3);
						}
					}
					else
						$$ = $1;
				}
			|
			{
                #ifndef ENABLE_MULTIPLE_NODES
                	if (u_sess->attr.attr_common.plsql_show_all_error &&
						CompileWhich() != PLPGSQL_COMPILE_NULL) {
                        errstate = NOTICE;
                    } else {
                        errstate = ERROR;
                    }
                #else
                    errstate = ERROR;
                #endif 
			}
			stmt
				{
					if ($2 != NULL)
					{
						if (IsA($2, List))
						{
							$$ = (List*)$2;
						}
						else
						{
						$$ = list_make1($2);
						}
					}
					else
						$$ = NIL;
				}
			| AST stmt
				{
					$$ = NIL;
				}
		;
stmt :
			AlterAppWorkloadGroupMappingStmt
			| AlterCoordinatorStmt
			| AlterDatabaseStmt
			| AlterDatabaseSetStmt
			| AlterDataSourceStmt
			| AlterDefaultPrivilegesStmt
			| AlterDomainStmt
			| AlterEnumStmt
			| AlterEventTrigStmt
			| AlterExtensionStmt
			| AlterExtensionContentsStmt
			| AlterFdwStmt
			| AlterForeignServerStmt
			| AlterForeignTableStmt
			| AlterFunctionStmt
			| AlterProcedureStmt
			| AlterPublicationStmt
			| AlterGroupStmt
			| AlterNodeGroupStmt
			| AlterNodeStmt
			| AlterObjectSchemaStmt
			| AlterOwnerStmt
			| AlterRlsPolicyStmt
			| AlterResourcePoolStmt
			| AlterGlobalConfigStmt
			| AlterSeqStmt
			| AlterSchemaStmt
			| AlterSubscriptionStmt
			| AlterTableStmt
			| AlterSystemStmt
			| AlterCompositeTypeStmt
			| AlterRoleSetStmt
			| AlterRoleStmt
			| AlterSessionStmt
			| AlterTSConfigurationStmt
			| AlterTSDictionaryStmt
			| AlterUserMappingStmt
			| AlterUserSetStmt
			| AlterUserStmt
			| AlterWorkloadGroupStmt
			| AnalyzeStmt
			| AnalyzePartitionStmt
			| AnonyBlockStmt
			| BarrierStmt
			| CreateAppWorkloadGroupMappingStmt
			| CallFuncStmt
			| CheckPointStmt
                        | CheckSumTableStmt
			| CleanConnStmt
			| ClosePortalStmt
			| ClusterStmt
			| CommentStmt
			| ConstraintsSetStmt
			| CopyStmt
			| CreateAsStmt
			| CreateAssertStmt
			| CreateCastStmt
                        | CreateContQueryStmt
                        | CreateStreamStmt
			| CreateConversionStmt
			| CreateDomainStmt
			| CreateDirectoryStmt
			| CreateEventTrigStmt
			| CreateExtensionStmt
			| CreateFdwStmt
			| CreateForeignServerStmt
			| CreateForeignTableStmt
			| CreateDataSourceStmt
			| CreateFunctionStmt
			| CreateEventStmt
			| AlterEventStmt
			| DropEventStmt
			| ShowEventStmt
			| CreatePackageStmt
			| CreatePackageBodyStmt
			| CreateGroupStmt
			| CreateMatViewStmt
			| CreateModelStmt  // DB4AI
			| CreateNodeStmt
			| CreateOpClassStmt
			| CreateOpFamilyStmt
			| AlterOpFamilyStmt
			| CreateRlsPolicyStmt
			| CreatePLangStmt
			| CreateProcedureStmt
			| CreatePublicationStmt
            | CreateKeyStmt
			| CreatePolicyLabelStmt
			| CreateWeakPasswordDictionaryStmt
			| DropWeakPasswordDictionaryStmt
			| AlterPolicyLabelStmt
			| DropPolicyLabelStmt
            | CreateAuditPolicyStmt
            | AlterAuditPolicyStmt
            | DropAuditPolicyStmt
			| CreateMaskingPolicyStmt
			| AlterMaskingPolicyStmt
			| DropMaskingPolicyStmt
			| CreateResourcePoolStmt
			| CreateSchemaStmt
			| CreateSeqStmt
			| CreateStmt
			| CreateSubscriptionStmt
			| CreateSynonymStmt
			| CreateTableSpaceStmt
			| CreateTrigStmt
			| CreateRoleStmt
			| CreateUserStmt
			| CreateUserMappingStmt
			| CreateWorkloadGroupStmt
			| CreatedbStmt
			| DeallocateStmt
			| DeclareCursorStmt
			| DefineStmt
			| DeleteStmt
			| DiscardStmt
			| DoStmt
			| DropAppWorkloadGroupMappingStmt
			| DropAssertStmt
			| DropCastStmt
			| DropDataSourceStmt
			| DropDirectoryStmt
			| DropFdwStmt
			| DropForeignServerStmt
			| DropGroupStmt
			| DropModelStmt // DB4AI
			| DropNodeGroupStmt
			| DropNodeStmt
			| DropOpClassStmt
			| DropOpFamilyStmt
			| DropOwnedStmt
			| DropRlsPolicyStmt
			| DropPLangStmt
			| DropResourcePoolStmt
			| DropGlobalConfigStmt
			| DropRuleStmt
			| DropStmt
			| DropSubscriptionStmt
			| DropSynonymStmt
			| DropTableSpaceStmt
			| DropTrigStmt
			| DropRoleStmt
			| DropUserStmt
			| DropUserMappingStmt
			| DropWorkloadGroupStmt
			| DropdbStmt
			| ExecuteStmt
			| ExecDirectStmt
			| ExplainStmt
			| FetchStmt
			| GrantStmt
			| GrantRoleStmt
			| GrantDbStmt
			| IndexStmt
			| InsertStmt
			| KillStmt
			| ListenStmt
			| RefreshMatViewStmt
			| LoadStmt
			| LockStmt
			| MergeStmt
			| NotifyStmt
			| PrepareStmt
			| PurgeStmt
			| ReassignOwnedStmt
			| ReindexStmt
			| RemoveAggrStmt
			| RemoveFuncStmt
			| RemovePackageStmt
			| RemoveOperStmt
			| RenameStmt
			| RevokeStmt
			| RevokeRoleStmt
			| RevokeDbStmt
			| RuleStmt
			| SecLabelStmt
			| SelectStmt
			| ShutdownStmt
			| TimeCapsuleStmt
			| SnapshotStmt
			| TransactionStmt
			| TruncateStmt
			| UnlistenStmt
			| UpdateStmt
			| UseStmt
			| VacuumStmt
			| VariableResetStmt
			| VariableSetStmt
			| VariableMultiSetStmt
			| VariableShowStmt
			| VerifyStmt
			| ViewStmt
			| AlterPartitionCheckStmt
			| AlterPartitionRebuildStmt
			| AlterPartitionRemoveStmt
			| AlterPartitionOptimizeStmt
			| AlterPartitionRepairStmt
			| OptimizeStmt
			| ShrinkStmt
			| /*EMPTY*/
				{ $$ = NULL; }
			| DelimiterStmt
			| FlushStmt
		;

/*****************************************************************************
 *
 * Create a new Postgres DBMS role
 *
 *****************************************************************************/

CreateRoleStmt:
			CREATE ROLE RoleId opt_with {u_sess->parser_cxt.isForbidTruncate = true;} OptRoleList
				{
					CreateRoleStmt *n = makeNode(CreateRoleStmt);
					n->stmt_type = ROLESTMT_ROLE;
					if (!isRestoreMode)
						IsValidIdentUsername($3);
					n->role = $3;
					n->options = $6;
					$$ = (Node *)n;
					u_sess->parser_cxt.isForbidTruncate = false;
				}
		;

ShrinkStmt:
            SHRINK TABLE relation_expr_list opt_nowait
                {
                    ShrinkStmt *n = makeNode(ShrinkStmt);
                    n->relations = $3;
                    n->nowait = $4;
                    $$ = (Node*)n;
                }
            |   SHRINK INDEX relation_expr_list opt_nowait
                    {
                        ShrinkStmt *n = makeNode(ShrinkStmt);
                        n->relations = $3;
                        n->nowait = $4;
                        $$ = (Node*)n;
                    }
        ;

opt_with:	WITH									{}
			| /*EMPTY*/								{}
		;

/*
 * Options for CREATE ROLE and ALTER ROLE (also used by CREATE/ALTER USER
 * for backwards compatibility).  Note: the only option required by SQL99
 * is "WITH ADMIN name".
 */
OptRoleList:
			OptRoleList CreateOptRoleElem			{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

AlterOptRoleList:
			AlterOptRoleList AlterOptRoleElem		{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

password_string:
			SCONST
				{
					t_thrd.postgres_cxt.clear_key_memory = true;
					$$ = $1;
				}
			| DOLPHINIDENT
				{
					t_thrd.postgres_cxt.clear_key_memory = true;
					core_yy_extra_type yyextra = pg_yyget_extra(yyscanner)->core_yy_extra;
					if (yyextra.ident_quoted)
						$$ = $1->str;
					else {
            			const char* message = "Password must be quoted";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("Password must be quoted")));
					}
				}
namedata_string:
            SCONST
                {
                    $$ = pg_strtolower($1);
                }
            | DOLPHINIDENT
                {
                    core_yy_extra_type yyextra = pg_yyget_extra(yyscanner)->core_yy_extra;
                    if (yyextra.ident_quoted)
                        $$ = $1->str;
                    else {
            			const char* message = "name data must be quoted";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        ereport(errstate,
                            (errcode(ERRCODE_SYNTAX_ERROR),
                             errmsg("name data must be quoted")));
					}
                }
		;
AlterOptRoleElem:
			PASSWORD password_string
				{
					$$ = makeDefElem("password",
									 (Node *)list_make1(makeStringConst($2, @2)));
				}
			| IDENTIFIED BY password_string
				{
					$$ = makeDefElem("password",
						(Node *)list_make1(makeStringConst($3, @3)));
				}
			| ENCRYPTED IDENTIFIED BY password_string
				{
					$$ = makeDefElem("encryptedPassword",
						(Node *)list_make1(makeStringConst($4, @4)));
				}
			| UNENCRYPTED IDENTIFIED BY password_string
				{
					$$ = makeDefElem("unencryptedPassword",
						(Node *)list_make1(makeStringConst($4, @4)));
				}
			| IDENTIFIED BY password_string REPLACE password_string
				{
					$$ = makeDefElem("password",
						(Node *)list_make2(makeStringConst($3, @3), makeStringConst($5, @5)));
				}
			| ENCRYPTED IDENTIFIED BY password_string REPLACE password_string
				{
					$$ = makeDefElem("encryptedPassword",
						(Node *)list_make2(makeStringConst($4, @4), makeStringConst($6, @6)));
				}
			| UNENCRYPTED IDENTIFIED BY password_string REPLACE password_string
				{
					$$ = makeDefElem("unencryptedPassword",
						(Node *)list_make2(makeStringConst($4, @4), makeStringConst($6, @6)));
				}
			| IDENTIFIED BY DISABLE_P
				{
					$$ = makeDefElem("password", NULL);
				}
			| PASSWORD DISABLE_P
				{
					$$ = makeDefElem("password", NULL);
				}
			| PASSWORD EXPIRED_P
				{
					$$ = makeDefElem("expired", (Node *)makeInteger(TRUE));
				}
			| PASSWORD password_string EXPIRED_P
				{
					$$ = makeDefElem("expiredPassword", (Node *)list_make1(makeStringConst($2, @2)));
				}
			| IDENTIFIED BY password_string EXPIRED_P
				{
					$$ = makeDefElem("expiredPassword", (Node *)list_make1(makeStringConst($3, @3)));
				}
			| ENCRYPTED PASSWORD password_string
				{
					$$ = makeDefElem("encryptedPassword",
									 (Node *)list_make1(makeStringConst($3, @3)));
				}
			| UNENCRYPTED PASSWORD password_string
				{
					$$ = makeDefElem("unencryptedPassword",
									 (Node *)list_make1(makeStringConst($3, @3)));
				}
			| DEFAULT TABLESPACE name
				{
					$$ = makeDefElem("tablespace", (Node *)makeString($3));
				}
			| PROFILE DEFAULT
				{
					$$ = makeDefElem("profile", NULL);
				}
			| PROFILE name
				{
					$$ = makeDefElem("profile",
									 (Node *)list_make1(makeStringConst($2, @2)));
				}
			| INHERIT
				{
					$$ = makeDefElem("inherit", (Node *)makeInteger(TRUE));
				}
			| CONNECTION LIMIT SignedIconst
				{
					$$ = makeDefElem("connectionlimit", (Node *)makeInteger($3));
				}
			| RESOURCE POOL namedata_string
				{
					$$ = makeDefElem("respool", (Node *)makeString($3));
				}
			| NODE GROUP_P pgxcgroup_name
			    {
			        $$ = makeDefElem("node_group", (Node *)makeString($3));
			    }
			| USER GROUP_P namedata_string
				{
					$$ = makeDefElem("parent", (Node *)makeString($3));
				}
			| USER GROUP_P DEFAULT	
				{
					$$ = makeDefElem("parent_default", NULL);
				}
			| PERM SPACE SCONST
				{
					$$ = makeDefElem("space_limit", (Node *)makeString($3));
				}
			| TEMP SPACE SCONST
				{
					$$ = makeDefElem("temp_space_limit", (Node *)makeString($3));
				}
			| SPILL SPACE SCONST
				{
					$$ = makeDefElem("spill_space_limit", (Node *)makeString($3));
				}
			/* VALID and BEGIN is treated as a token to avoid confilict with BEGIN TRANSACTIOn and BEGIN ANONYMOUD BLOCK */
			| VALID_BEGIN SCONST
				{
					$$ = makeDefElem("validBegin", (Node *)makeString($2));
				}
			| VALID UNTIL SCONST
				{
					$$ = makeDefElem("validUntil", (Node *)makeString($3));
				}
		/*	Supported but not documented for roles, for use by ALTER GROUP. */
			| USER name_list
				{
					$$ = makeDefElem("rolemembers", (Node *)$2);
				}
			| normal_ident
				{
					/*
					 * We handle identifiers that aren't parser keywords with
					 * the following special-case codes, to avoid bloating the
					 * size of the main parser.
					 */
					if (strcmp($1, "createrole") == 0)
						$$ = makeDefElem("createrole", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nocreaterole") == 0)
						$$ = makeDefElem("createrole", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "replication") == 0)
						$$ = makeDefElem("isreplication", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "noreplication") == 0)
						$$ = makeDefElem("isreplication", (Node *)makeInteger(FALSE));
					/* add audit admin privilege */
					else if (strcmp($1, "auditadmin") == 0)
						$$ = makeDefElem("isauditadmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "noauditadmin") == 0)
						$$ = makeDefElem("isauditadmin", (Node *)makeInteger(FALSE));
					/* END <audit> */
					else if (strcmp($1, "sysadmin") == 0)
						$$ = makeDefElem("issystemadmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nosysadmin") == 0)
						$$ = makeDefElem("issystemadmin", (Node *)makeInteger(FALSE));
					/* Add system monitor privilege, operator privilege. */
					else if (strcmp($1, "monadmin") == 0)
						$$ = makeDefElem("ismonitoradmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nomonadmin") == 0)
						$$ = makeDefElem("ismonitoradmin", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "opradmin") == 0)
						$$ = makeDefElem("isoperatoradmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "noopradmin") == 0)
						$$ = makeDefElem("isoperatoradmin", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "poladmin") == 0)
						$$ = makeDefElem("ispolicyadmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nopoladmin") == 0)
						$$ = makeDefElem("ispolicyadmin", (Node *)makeInteger(FALSE));
					/* End */
					else if (strcmp($1, "vcadmin") == 0)
						$$ = makeDefElem("isvcadmin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "novcadmin") == 0)
						$$ = makeDefElem("isvcadmin", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "createdb") == 0)
						$$ = makeDefElem("createdb", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nocreatedb") == 0)
						$$ = makeDefElem("createdb", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "useft") == 0)
						$$ = makeDefElem("useft", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nouseft") == 0)
						$$ = makeDefElem("useft", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "login") == 0)
						$$ = makeDefElem("canlogin", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nologin") == 0)
						$$ = makeDefElem("canlogin", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "independent") == 0)
						$$ = makeDefElem("independent", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "noindependent") == 0)
						$$ = makeDefElem("independent", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "persistence") == 0)
						$$ = makeDefElem("persistence", (Node *)makeInteger(TRUE));
					else if (strcmp($1, "nopersistence") == 0)
						$$ = makeDefElem("persistence", (Node *)makeInteger(FALSE));
					else if (strcmp($1, "noinherit") == 0)
					{
						/*
						 * Note that INHERIT is a keyword, so it's handled by main parser, but
						 * NOINHERIT is handled here.
						 */
						$$ = makeDefElem("inherit", (Node *)makeInteger(FALSE));
					}
					else if (strcmp($1, "pguser") == 0)
					{
						$$ = makeDefElem("pguser", (Node *)makeInteger(TRUE));
					}
					else {
            			const char* message = "unrecognized role option";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("unrecognized role option \"%s\"", $1),
									 parser_errposition(@1)));
					}
				}
		;

CreateOptRoleElem:
			AlterOptRoleElem			{ $$ = $1; }
			/* The following are not supported by ALTER ROLE/USER/GROUP */
			| SYSID Iconst
				{
					$$ = makeDefElem("sysid", (Node *)makeInteger($2));
				}
			| ADMIN name_list
				{
					$$ = makeDefElem("adminmembers", (Node *)$2);
				}
			| ROLE name_list
				{
					$$ = makeDefElem("rolemembers", (Node *)$2);
				}
			| IN_P ROLE name_list
				{
					$$ = makeDefElem("addroleto", (Node *)$3);
				}
			| IN_P GROUP_P name_list
				{
					$$ = makeDefElem("addroleto", (Node *)$3);
				}
		;


/*****************************************************************************
 *
 * Create a new Postgres DBMS user (role with implied login ability)
 *
 *****************************************************************************/

UserId:
			SCONST SET_USER_IDENT
					{
						$$ = GetValidUserHostId($1, $2);
					}
			| SCONST '@' SCONST
					{
						$$ = GetValidUserHostId($1, $3);
					}
			| SCONST
					{
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT || !u_sess->attr.attr_common.b_compatibility_user_host_auth)
							ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("syntax error at or near \"%s\"", $1), parser_errposition(@1)));
						if (strchr($1,'@'))
							ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("@ can't be allowed in username")));
						if (strlen($1) >= NAMEDATALEN) {
							ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("String %s is too long for user name (should be no longer than 64)", $1)));
						}
						$$ = $1;
					}
			| RoleId SET_USER_IDENT
					{
						$$ = GetValidUserHostId($1, $2);
					}
			| RoleId
					{
						IsValidIdentUsername($1);
						$$ = $1;
					}
		;

UserIdList:	UserId
					{ $$ = list_make1(makeString($1)); }
			| UserIdList ',' UserId
					{ $$ = lappend($1, makeString($3)); }
		;

CreateUserStmt:
			CREATE USER UserId opt_with {u_sess->parser_cxt.isForbidTruncate = true;} OptRoleList
				{
					CreateRoleStmt *n = makeNode(CreateRoleStmt);
					n->stmt_type = ROLESTMT_USER;
					n->role = $3;
					n->options = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
					u_sess->parser_cxt.isForbidTruncate = false;
				}
			| CREATE USER IF_P NOT EXISTS UserId opt_with {u_sess->parser_cxt.isForbidTruncate = true;} OptRoleList
				{
					CreateRoleStmt *n = makeNode(CreateRoleStmt);
					n->stmt_type = ROLESTMT_USER;
					n->role = $6;
					n->options = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
					u_sess->parser_cxt.isForbidTruncate = false;
				}
		;


/*****************************************************************************
 *
 * Alter a postgresql DBMS role
 *
 *****************************************************************************/

AlterRoleStmt:
			ALTER ROLE RoleId opt_with {u_sess->parser_cxt.isForbidTruncate = true;} AlterOptRoleList
				 {
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = $6;
					n->lockstatus = DO_NOTHING;
					$$ = (Node *)n;
					u_sess->parser_cxt.isForbidTruncate = false;
				 }
			| ALTER ROLE RoleId opt_with ACCOUNT LOCK_P
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = NIL;
					n->lockstatus = LOCK_ROLE;
					$$ = (Node *)n;
				}
			| ALTER ROLE RoleId opt_with ACCOUNT UNLOCK
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = NIL;
					n->lockstatus = UNLOCK_ROLE;
					$$ = (Node *)n;
				}
		;

opt_in_database:
			   /* EMPTY */					{ $$ = NULL; }
			| IN_P DATABASE database_name	{ $$ = $3; }
		;

AlterRoleSetStmt:
			ALTER ROLE RoleId opt_in_database SetResetClause
				{
					AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);
					n->role = $3;
					n->database = $4;
					n->setstmt = $5;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 * Alter a postgresql DBMS user
 *
 *****************************************************************************/

AlterUserStmt:
			ALTER USER UserId opt_with {u_sess->parser_cxt.isForbidTruncate = true;} AlterOptRoleList
				 {
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->missing_ok = FALSE;
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = $6;
					n->lockstatus = DO_NOTHING;
					$$ = (Node *)n;
					u_sess->parser_cxt.isForbidTruncate = false;
				 }
			| ALTER USER IF_P EXISTS UserId opt_with AlterOptRoleList
				 {
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->missing_ok = TRUE;
					n->role = $5;
					n->action = +1;	/* add, if there are members */
					n->options = $7;
					n->lockstatus = DO_NOTHING;
					$$ = (Node *)n;
				 }     
			| ALTER USER UserId opt_with ACCOUNT LOCK_P
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = NIL;
					n->lockstatus = LOCK_ROLE;
					$$ = (Node *)n;
				}
			| ALTER USER UserId opt_with ACCOUNT UNLOCK
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = +1;	/* add, if there are members */
					n->options = NIL;
					n->lockstatus = UNLOCK_ROLE;
					$$ = (Node *)n;
				}
		;


AlterUserSetStmt:
			ALTER USER UserId opt_in_database SetResetClause
				{
					AlterRoleSetStmt *n = makeNode(AlterRoleSetStmt);
					n->role = $3;
					n->database = $4;
					n->setstmt = $5;
					$$ = (Node *)n;
				}
			;


/*****************************************************************************
 *
 * Drop a postgresql DBMS role
 *
 * XXX Ideally this would have CASCADE/RESTRICT options, but since a role
 * might own objects in multiple databases, there is presently no way to
 * implement either cascading or restricting.  Caveat DBA.
 *****************************************************************************/

DropRoleStmt:
			DROP ROLE name_list
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->missing_ok = FALSE;
					n->roles = $3;
					$$ = (Node *)n;
				}
			| DROP ROLE IF_P EXISTS name_list
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->missing_ok = TRUE;
					n->roles = $5;
					$$ = (Node *)n;
				}
			;

/*****************************************************************************
 *
 * Drop a postgresql DBMS user
 *
 * XXX Ideally this would have CASCADE/RESTRICT options, but since a user
 * might own objects in multiple databases, there is presently no way to
 * implement either cascading or restricting.  Caveat DBA.
 *****************************************************************************/

DropUserStmt:
			DROP USER UserIdList opt_drop_behavior
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->missing_ok = FALSE;
					n->is_user = TRUE;
					n->roles = $3;
					n->behavior = $4;
					$$ = (Node *)n;
				}
			| DROP USER IF_P EXISTS UserIdList opt_drop_behavior
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->roles = $5;
					n->missing_ok = true;
					n->is_user = TRUE;
					n->behavior = $6;
					n->is_user = TRUE;
					n->behavior = $6;
					$$ = (Node *)n;
				}
			;

/*****************************************************************************
 *
 * Create a postgresql group (role without login ability)
 *
 *****************************************************************************/

CreateGroupStmt:
			CREATE GROUP_P RoleId opt_with OptRoleList
				{
					CreateRoleStmt *n = makeNode(CreateRoleStmt);
					n->stmt_type = ROLESTMT_GROUP;
					n->role = $3;
					n->options = $5;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 * Alter a postgresql group
 *
 *****************************************************************************/

AlterGroupStmt:
			ALTER GROUP_P RoleId add_drop USER name_list
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $3;
					n->action = $4;
					n->options = list_make1(makeDefElem("rolemembers",
														(Node *)$6));
					$$ = (Node *)n;
				}
		;

add_drop:	ADD_P									{ $$ = +1; }
			| DROP									{ $$ = -1; }
		;

/*****************************************************************************
 *
 * Alter SESSION
 *
 *****************************************************************************/

AlterSessionStmt:
			ALTER SESSION SET set_rest
				{
					VariableSetStmt *n = $4;
					n->is_local = false;
					$$ = (Node *) n;
				}
			;

/* "alter system" */
/*****************************************************************************
 *
 * Alter SYSTEM 
 * (1. kill a session by "select pg_terminate_backend(pid)", so it only needs a SelectStmt node.)
 * (2. disconnect a session. unsupported currently.)
 * (3. set system parameter to, this is used to change configuration parameters persistently.)
 *
 *****************************************************************************/

AlterSystemStmt:
			ALTER SYSTEM_P KILL SESSION SCONST altersys_option
				{
					SelectStmt *n = NULL;
					List *pid = NULL;

					pid = get_func_args($5);

					n = makeNode(SelectStmt);
					n->distinctClause = NIL;
					n->targetList = make_action_func(pid);
					n->intoClause = NULL;
					n->fromClause = NIL;
					n->whereClause = NULL;
					n->groupClause = NIL;
					n->havingClause = NULL;
					n->windowClause = NIL;
					$$ = (Node *)n;
				}

			| ALTER SYSTEM_P DISCONNECT SESSION SCONST altersys_option
				{
            		const char* message = "unsupported action \"DISCONNECT\" for statement \" alter system ";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
					    (errcode(ERRCODE_UNDEFINED_OBJECT),
					     errmsg("unsupported action \"DISCONNECT\" for statement \" alter system \"")));
				}

			| ALTER SYSTEM_P SET generic_set
				{
#if defined(ENABLE_MULTIPLE_NODES) || defined (ENABLE_PRIVATEGAUSS)
            		const char* message = "ALTER SYSTEM SET is not supported";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
					    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					     errmsg("ALTER SYSTEM SET is not supported.")));
#else
					AlterSystemStmt *n = makeNode(AlterSystemStmt);
					n->setstmt = $4;
					$$ = (Node *)n;
#endif
				}
			;

altersys_option:
			IMMEDIATE			{/* empty */}
			|				{/* empty */}
			;

/*****************************************************************************
 *
 * Kill a session or cancel all queries from a session
 *
 *****************************************************************************/

KillStmt:	KILL kill_opt a_expr
			{
				$$ = (Node *)MakeKillStmt($2, $3);
			}
		;

kill_opt: 	CONNECTION { $$ = 1; }
		| QUERY { $$ = 0; }
		| /* empty */ %prec KILL_OPT_EMPTY { $$ = 1; }
		;

/*****************************************************************************
 *
 * Drop a postgresql group
 *
 * XXX see above notes about cascading DROP USER; groups have same problem.
 *****************************************************************************/

DropGroupStmt:
			DROP GROUP_P name_list
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->missing_ok = FALSE;
					n->roles = $3;
					$$ = (Node *)n;
				}
			| DROP GROUP_P IF_P EXISTS name_list
				{
					DropRoleStmt *n = makeNode(DropRoleStmt);
					n->missing_ok = TRUE;
					n->roles = $5;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 * Manipulate a schema
 *
 *****************************************************************************/

CreateSchemaStmt:
			CREATE SCHEMA OptSchemaName AUTHORIZATION RoleId OptBlockchainWith OptSchemaEltList
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					/* One can omit the schema name or the authorization id. */
					if ($3 != NULL)
						n->schemaname = $3;
					else
						n->schemaname = $5;
					n->authid = $5;
					n->hasBlockChain = $6;
					n->schemaElts = $7;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
			| CREATE SCHEMA DolphinColId OptBlockchainWith OptSchemaEltList
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					n->missing_ok = FALSE;
					/* ...but not both */
					n->schemaname = GetDolphinSchemaName($3->str, $3->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = $4;
					n->schemaElts = $5;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
			| CREATE SCHEMA IF_P NOT EXISTS DolphinColId OptBlockchainWith OptSchemaEltList
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					n->missing_ok = TRUE;
					/* ...but not both */
					n->schemaname = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = $7;
					n->schemaElts = $8;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
			| CREATE SCHEMA IF_P NOT EXISTS OptSchemaName AUTHORIZATION RoleId OptBlockchainWith OptSchemaEltList
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					n->missing_ok = TRUE;
					/* One can omit the schema name or the authorization id. */
					if ($6 != NULL)
						n->schemaname = $6;
					else
						n->schemaname = $8;
					n->authid = $8;
					n->hasBlockChain = $9;
					n->schemaElts = $10;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
			| CREATE SCHEMA DolphinColId CharsetCollate
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					n->schemaname = GetDolphinSchemaName($3->str, $3->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = false;
					n->schemaElts = NULL;
					n->charset = $4->charset;
					n->collate = $4->collate;
					$$ = (Node *)n;
				}
			| CREATE SCHEMA IF_P NOT EXISTS DolphinColId CharsetCollate
				{
					CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
					n->schemaname = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = false;
					n->schemaElts = NULL;
					n->charset = $7->charset;
					n->collate = $7->collate;
					$$ = (Node *)n;
				}
		;

OptSchemaName:
			DolphinColId							{ $$ = GetDolphinSchemaName($1->str, $1->is_quoted); }
			| /* EMPTY */							{ $$ = NULL; }
		;

OptSchemaEltList:
			OptSchemaEltList schema_stmt			{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

OptBlockchainWith:
			WITH BLOCKCHAIN
			    {
                    if (ENABLE_DMS) {
			            const char* message = "BLOCKCHAIN is not supported while DMS and DSS enabled";
			            InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			            ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), 
				                errmsg("BLOCKCHAIN is not supported while DMS and DSS enabled")));
					}

                    $$ = true;
			    }
			| /* EMPTY */							{ $$ = false; }
		;

/*****************************************************************************
 *
 * ALTER SCHEMA WITH BLOCKCHAIN
 * alter blockchain property of a schema.
 *
 *****************************************************************************/
AlterSchemaStmt:
			ALTER SCHEMA DolphinColId OptAlterToBlockchain
				{
					AlterSchemaStmt *n = makeNode(AlterSchemaStmt);
					n->schemaname = GetDolphinSchemaName($3->str, $3->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = $4;
					n->charset = PG_INVALID_ENCODING;
					n->collate = NULL;
					$$ = (Node *)n;
				}
			| ALTER SCHEMA DolphinColId CharsetCollate
				{
					AlterSchemaStmt *n = makeNode(AlterSchemaStmt);
					n->schemaname = GetDolphinSchemaName($3->str, $3->is_quoted);
					n->authid = NULL;
					n->hasBlockChain = false;
					n->charset = $4->charset;
					n->collate = $4->collate;
					$$ = (Node *)n;
				}
			;

OptAlterToBlockchain:
			WITH BLOCKCHAIN
			    {
                    if (ENABLE_DMS) {
			            const char* message = "BLOCKCHAIN is not supported while DMS and DSS enabled";
			            InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			            ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), 
				                errmsg("BLOCKCHAIN is not supported while DMS and DSS enabled")));
					}

                    $$ = true;
			    }
			| WITHOUT BLOCKCHAIN					{ $$ = false; }
		;

/*
 *	schema_stmt are the ones that can show up inside a CREATE SCHEMA
 *	statement (in addition to by themselves).
 */
schema_stmt:
			CreateStmt
			| IndexStmt
			| CreateSeqStmt
			| CreateTrigStmt
			| GrantStmt
			| ViewStmt
		;


/*****************************************************************************
 *
 * Set PG internal variable
 *	  SET name TO 'var_value'
 * Include SQL92 syntax (thomas 1997-10-22):
 *	  SET TIME ZONE 'var_value'
 *
 *****************************************************************************/
user_list:
               user    { $$ = list_make1(makeString($1)); }
               | user_list ',' user { $$ = lappend($1, makeString($3)); }
               ;

user:
			ColId_or_Sconst { $$ = $1; }
			| ColId_or_Sconst '@' load_quote_str { $$ = $1; }
			| CURRENT_USER { $$ = GetUserNameFromId(GetUserId()); }
			| CURRENT_USER '(' ')' { $$ = GetUserNameFromId(GetUserId()); }
			;

opt_password:
			password_string { $$ = pstrdup($1); }
			| PASSWORD '(' password_string ')' { $$ = pstrdup($3); }
			;

opt_replace:
			REPLACE opt_password { $$ = $2; }
			| /* empty */ { $$ = NULL; }
			;
opt_charset2:
			CHARACTER SET { /* EMTPY */ }
			| CHARSET { /* EMTPY */ }
			;

opt_encoding2:
			ColId_or_Sconst { $$ = $1; }
			| DEFAULT { $$ = NULL; }
			;

VariableSetStmt:
			SET set_rest
				{
					VariableSetStmt *n = $2;
					n->is_local = false;
					$$ = (Node *) n;
				}
			| SET LOCAL set_rest
				{
					VariableSetStmt *n = $3;
					n->is_local = true;
					$$ = (Node *) n;
				}
			| SET SESSION set_rest
				{
					VariableSetStmt *n = $3;
					n->is_local = false;
					$$ = (Node *) n;
				}
			| SET GLOBAL TRANSACTION transaction_mode_list
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "SET GLOBAL TRANSACTION is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SET GLOBAL TRANSACTION is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("SET GLOBAL TRANSACTION is only supported in B_FORMAT.")));
					}
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_MULTI;
					n->name = "GLOBAL TRANSACTION";
					n->args = $4;
					$$ = (Node *)n;
				}
			| SET PASSWORD '=' opt_password opt_replace
                        	{
                        		$$ = MakeSetPasswdStmt(GetUserNameFromId(GetUserId()), $4, $5);
                        	}
                        | SET PASSWORD FOR UserId '=' opt_password opt_replace
                        	{
                        		$$ = MakeSetPasswdStmt($4, $6, $7);
                        	}
			| SET opt_charset2 opt_encoding2
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "client_encoding";
					if ($3 != NULL)
						n->args = list_make1(makeStringConst($3, @3));
					else
						n->kind = VAR_SET_DEFAULT;
					$$ = (Node *)n;
				}
			| SET generic_set_extension
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "SET config_parameter = expr is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SET config_parameter = expr is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						VariableSetStmt *n = $2;
						n->is_local = false;
						$$ = (Node *) n;
					} else {
						const char* message = "SET supported expr value only in B_FORMAT and enable_set_variable_b_format is on";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("SET supported expr value only in B_FORMAT and enable_set_variable_b_format is on.")));
					}
				}
			| SET SESSION generic_set_extension
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "SET config_parameter = expr is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SET config_parameter = expr is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						VariableSetStmt *n = $3;
						n->is_local = false;
						$$ = (Node *) n;
					} else {
						const char* message = "SET supported expr value only in B_FORMAT and enable_set_variable_b_format is on";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("SET supported expr value only in B_FORMAT and enable_set_variable_b_format is on.")));
					}
				}
		;

set_rest:
			TRANSACTION transaction_mode_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_MULTI;
					n->name = "TRANSACTION";
					n->args = $2;
					$$ = n;
				}
			| SESSION CHARACTERISTICS AS TRANSACTION transaction_mode_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_MULTI;
					n->name = "SESSION CHARACTERISTICS";
					n->args = $5;
					$$ = n;
				}
			| set_rest_more
				{
					$$ = $1;
				}
			;

generic_set:
			var_name TO { GetSessionContext()->is_schema_name = (strcmp($1, "search_path") == 0); } var_list
				{
					GetSessionContext()->is_schema_name = false;
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = $1;
					n->args = $4;
					/* if we are setting role, we switch to the new syntax which check the password of role */
					if(!pg_strcasecmp("role", n->name) || !pg_strcasecmp("session_authorization", n->name))
					{
            			const char* message = "SET TO rolename\" not yet supported";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 	errmsg("\"SET %s TO rolename\" not yet supported", n->name),
								 	errhint("Use \"SET %s rolename\" clauses.", n->name)));
					}
					else
					{
						n->kind = VAR_SET_VALUE;
					}
					$$ = n;
				}
			| dolphin_var_name assign_operator  var_list
				{
					GetSessionContext()->is_schema_name = false;
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = $1;
					n->args = $3;
					/* if we are setting role, we switch to the new syntax which check the password of role */
					if(!pg_strcasecmp("role", n->name) || !pg_strcasecmp("session_authorization", n->name))
					{
            			const char* message = "SET TO rolename\" not yet supported";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("\"SET %s = rolename\" not yet supported", n->name),
									 errhint("Use \"SET %s rolename\" clauses.", n->name)));
					}
					else
					{
						n->kind = VAR_SET_VALUE;
					}
					$$ = n;
				}
			| var_name TO DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = $1;
					$$ = n;
				}
			| dolphin_var_name assign_operator  DEFAULT
				{
					GetSessionContext()->is_schema_name = false;
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = $1;
					$$ = n;
				}
			| CURRENT_SCHEMA TO schema_var_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "current_schema";
					n->args = $3;
					$$ = n;
				}
			| CURRENT_SCHEMA assign_operator  schema_var_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "current_schema";
					n->args = $3;
					$$ = n;
				}
			| CURRENT_SCHEMA TO DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = "current_schema";
					$$ = n;
				}
			| CURRENT_SCHEMA assign_operator  DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = "current_schema";
					$$ = n;
				}
                ;

set_rest_more:  /* Generic SET syntaxes: */
            generic_set
	            {
	                $$ = $1;
	            }
			| var_name FROM CURRENT_P
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_CURRENT;
					n->name = $1;
					$$ = n;
				}
			/* Special syntaxes mandated by SQL standard: */
			| TIME ZONE zone_value
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "timezone";
					if ($3 != NULL)
						n->args = list_make1($3);
					else
						n->kind = VAR_SET_DEFAULT;
					$$ = n;
				}
			| CATALOG_P SCONST
				{
            		const char* message = "current database cannot be changed";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("current database cannot be changed"),
							 parser_errposition(@2)));
					$$ = NULL; /*not reached*/
				}
			| SCHEMA SCONST
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "search_path";
					n->args = list_make1(makeStringConst($2, @2));
					$$ = n;
				}
			| NAMES opt_encoding set_names_collate
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					if ($3 != NULL) {
						if ($2 == NULL) {
							ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("cannot specify collation without character set"),
								parser_errposition(@3)));
						}
						n->args = list_make2(makeStringConst($2, @2), makeStringConst($3, @3));
						n->name = "set_names";
					} else {
						if ($2 != NULL) {
							n->args = list_make1(makeStringConst($2, @2));
						} else {
							n->kind = VAR_SET_DEFAULT;
						}
						if (ENABLE_MULTI_CHARSET) {
							n->name = "set_names";
						} else {
							n->name = "client_encoding";
						}
					}
					$$ = n;
				}
			| ROLE ColId_or_Sconst
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_ROLEPWD;
					n->name = "role";
					n->args = list_make1(makeStringConst($2, @2));
					$$ = n;
				}
			| ROLE ColId_or_Sconst PASSWORD {u_sess->parser_cxt.isForbidTruncate = true;} password_string
				{
					u_sess->parser_cxt.isForbidTruncate = false;
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_ROLEPWD;
					n->name = "role";
					n->args = list_make2(makeStringConst($2, @2), makeStringConst($5, @5));
					$$ = n;
				}
			| SESSION AUTHORIZATION DolphinUserId PASSWORD {u_sess->parser_cxt.isForbidTruncate = true;} password_string
				{
					u_sess->parser_cxt.isForbidTruncate = false;
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_ROLEPWD;
					n->name = "session_authorization";
					n->args = list_make2(makeStringConst(downcase_str($3->str, $3->is_quoted), @3), makeStringConst($6,@6));
					$$ = n;
				}
			| SESSION AUTHORIZATION DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = "session_authorization";
					$$ = n;
				}
			| XML_P OPTION document_or_content
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "xmloption";
					n->args = list_make1(makeStringConst(const_cast<char *>($3 == XMLOPTION_DOCUMENT ? "DOCUMENT" : "CONTENT"), @3));
					$$ = n;
				}
			/* Special syntaxes invented by PostgreSQL: */
			| TRANSACTION SNAPSHOT SCONST
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_MULTI;
					n->name = "TRANSACTION SNAPSHOT";
					n->args = list_make1(makeStringConst($3, @3));
					$$ = n;
				}
		;

/*****************************************************************************
 *
 * VariableMultiSetStmt only used for:
 * 1. set [session|global] configure_param = expr 
 * 2. set @usr_var := expr
 *
 *****************************************************************************/

VariableMultiSetStmt:	SET VariableSetElemsList
						{
#ifdef			ENABLE_MULTIPLE_NODES
							const char* message = "set multiple variables is not yet supported in distributed database.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
							ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
									errmsg("set multiple variables is not yet supported in distributed database.")));
#endif
							if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES))
							{
								VariableMultiSetStmt* n = makeNode(VariableMultiSetStmt);
								n->args = $2;
								$$ = (Node*)n;
							} else {
								const char* message = "SET UserVar/GLOBAL/SESSION is supported only in B-format database, and enable_set_variable_b_format = on.";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
									(errmodule(MOD_PARSER),
										errcode(ERRCODE_SYNTAX_ERROR),
										errmsg("SET UserVar/GLOBAL/SESSION is supported only in B-format database, and enable_set_variable_b_format = on."),
										parser_errposition(@1)));
								$$ = NULL;/* not reached */	
							}
						}
					;

VariableSetElemsList:
						 VariableSetElem 	{ $$ = list_make1($1); }
						| VariableSetElemsList ',' VariableSetElem 	{ $$ = lappend($1, $3); }
				;

VariableSetElem:
					set_session_extension
						{
							VariableSetStmt *n = $1;
							n->is_local = false;
							n->is_multiset = true;
							$$ = (Node *)n;
						}
					| set_global
						{
							$$ = $1;
						}
					| user_defined_single
						{
							VariableSetStmt *n = makeNode(VariableSetStmt);
							n->kind = VAR_SET_DEFINED;
							n->name = "USER DEFINED VARIABLE";
							n->defined_args = list_make1($1);
							n->is_local = false;
							n->is_multiset = true;
							$$ = (Node *)n;
						}
				;

user_defined_single:
			uservar_name COLON_EQUALS a_expr
				{
					UserSetElem *n = makeNode(UserSetElem);
					n->name = list_make1($1);
					n->val = (Expr *)$3;
					$$ = (Node *)n;
				}
			| uservar_name '=' a_expr
				{
					UserSetElem *n = makeNode(UserSetElem);
					n->name = list_make1($1);
					n->val = (Expr *)$3;
					$$ = (Node *)n;
				}
			;

set_global:	 set_global_extension
 				{
#if defined(ENABLE_MULTIPLE_NODES) || defined (ENABLE_PRIVATEGAUSS)
					const char* message = "SET GLOBAL is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SET GLOBAL is not supported.")));
#else
						AlterSystemStmt *n = makeNode(AlterSystemStmt);
						n->setstmt = $1;
						$$ = (Node *) n;
#endif
 				}

generic_set_extension:
			 dolphin_var_name assign_operator guc_value_extension_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = $1;
					n->args = $3;
					/* if we are setting role, we switch to the new syntax which check the password of role */
					if(!pg_strcasecmp("role", n->name) || !pg_strcasecmp("session_authorization", n->name))
					{
						const char* message = "SET TO rolename\" not yet supported";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("\"SET %s = rolename\" not yet supported", n->name),
									 errhint("Use \"SET %s rolename\" clauses.", n->name)));
					}
					else
					{
						n->kind = VAR_SET_VALUE;
					}
					$$ = n;
				}
			| CURRENT_SCHEMA assign_operator guc_value_extension_list
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "current_schema";
					n->args = $3;
					$$ = n;
				}
		;

set_session_extension:
			 SET_IDENT_SESSION '.' guc_variable_set
				{
					VariableSetStmt *n = $3;
					n->is_local = false;
					$$ = n;
				}
			| SET_IDENT assign_operator set_expr
				{
					int len = strlen($1);
					errno_t rc = EOK;
 
					char *name = (char *)palloc(len - 1);
					rc = strncpy_s(name, len - 1, $1 + 2, len-2);
					securec_check(rc, "\0", "\0");

					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = pstrdup(name);
					n->args = list_make1($3);
					pfree(name);
					$$ = n;
				}
			| SET_IDENT assign_operator DEFAULT
				{
					int len = strlen($1);
					errno_t rc = EOK;
 
					char *name = (char *)palloc(len - 1);
					rc = strncpy_s(name, len - 1, $1 + 2, len-2);
					securec_check(rc, "\0", "\0");
	
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = pstrdup(name);
					pfree(name);
					$$ = n;
				}
			;
 
set_global_extension:
			GLOBAL guc_variable_set
				{
					VariableSetStmt *n = $2;
					$$ = n;
				}
			| SET_IDENT_GLOBAL '.' guc_variable_set
				{
					VariableSetStmt *n = $3;
					$$ = n;
 				}
 		;
 
guc_variable_set:
			dolphin_var_name assign_operator set_expr
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = $1;
					n->args = list_make1($3);
					n->is_multiset = true;
					/* if we are setting role, we switch to the new syntax which check the password of role */
					if(!pg_strcasecmp("role", n->name) || !pg_strcasecmp("session_authorization", n->name))
					{
						const char* message = "SET TO rolename\" not yet supported";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("\"SET %s = rolename\" not yet supported", n->name),
									 errhint("Use \"SET %s rolename\" clauses.", n->name)));
					}
					else
					{
						n->kind = VAR_SET_VALUE;
					}
					$$ = n;
				}
			| dolphin_var_name assign_operator DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = $1;
					n->is_multiset = true;
					$$ = n;
				}
			| CURRENT_SCHEMA assign_operator set_expr
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "current_schema";
					n->args = list_make1($3);
					$$ = n;
				}
			| CURRENT_SCHEMA assign_operator DEFAULT
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_DEFAULT;
					n->name = "current_schema";
					$$ = n;
				}
			;

guc_value_extension_list: set_expr_extension		{ $$ = list_make1($1); }
				| guc_value_extension_list ',' set_expr_extension 	{ $$ = lappend($1, $3); }
		;

set_ident_expr:
			SET_IDENT
				{
					int len = strlen($1);
					errno_t rc = EOK;
 
					if (len > 2 && strncmp($1, "@@", 2) == 0) {
						char *name	= (char *)palloc(len - 1);
						rc = strncpy_s(name, len - 1, $1 + 2, len-2);
						securec_check(rc, "\0", "\0");
 
						SetVariableExpr *n = makeNode(SetVariableExpr);
						n->name = pstrdup(name);
						n->is_session = true;
						n->is_global = false;
						$$ = (Node *) n;
					} else {
 
					}
				}
			| SET_IDENT_SESSION '.' normal_ident
				{
					SetVariableExpr *n = makeNode(SetVariableExpr);
					n->name = $3;
					n->is_session = true;
					n->is_global = false;
					$$ = (Node *) n;
				}
			| SET_IDENT_GLOBAL '.' normal_ident
				{
					SetVariableExpr *n = makeNode(SetVariableExpr);
					n->name = $3;
					n->is_session = false;
					n->is_global = true;
					$$ = (Node *) n;
				}
		;

set_expr:	
			 var_value
				{ $$ = $1; }
			| set_expr_extension
				{ $$ = $1; }
		;

set_expr_extension:
			 set_ident_expr
				{ $$ = $1; }
			| '(' a_expr ')' opt_indirection
				{
					if ($4)
					{
						A_Indirection *n = makeNode(A_Indirection);
						n->arg = $2;
						n->indirection = check_indirection($4, yyscanner);
						$$ = (Node *)n;
					}
					else
						$$ = $2;
				}
			| case_expr
				{ $$ = $1; }
			| func_expr
				{ $$ = $1; }
			| select_with_parens			%prec UMINUS
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					$$ = (Node *)n;
				}
			| select_with_parens indirection
				{
					/*
					 * Because the select_with_parens nonterminal is designed
					 * to "eat" as many levels of parens as possible, the
					 * '(' a_expr ')' opt_indirection production above will
					 * fail to match a sub-SELECT with indirection decoration;
					 * the sub-SELECT won't be regarded as an a_expr as long
					 * as there are parens around it.  To support applying
					 * subscripting or field selection to a sub-SELECT result,
					 * we need this redundant-looking production.
					 */
					SubLink *n = makeNode(SubLink);
					A_Indirection *a = makeNode(A_Indirection);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					a->arg = (Node *)n;
					a->indirection = check_indirection($2, yyscanner);
					$$ = (Node *)a;
				}
			| uservar_name           %prec UMINUS
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "@var_name is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("@var_name is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						$$ = $1;
					} else {
						const char* message = "@var_name is supported only in B-format database, and enable_set_variable_b_format = on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("@var_name is supported only in B-format database, and enable_set_variable_b_format = on."),
								parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
				}
			| b_expr TYPECAST Typename
				{
					ChangeBpcharCastType($3);
					$$ = makeTypeCast($1, $3, @2);
				}
			| '@' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", NULL, $2, @1); }
			| b_expr '+' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", $1, $3, @2); }
			| b_expr '-' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "-", $1, $3, @2); }
			| b_expr '*' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "*", $1, $3, @2); }
			| b_expr '/' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "/", $1, $3, @2); }
			| b_expr '%' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "%", $1, $3, @2); }
			| b_expr '^' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "^", $1, $3, @2); }
			| b_expr '<' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "<", $1, $3, @2); }
			| b_expr '>' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, ">", $1, $3, @2); }
			| b_expr '=' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "=", $1, $3, @2); }
			| b_expr '@' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", $1, $3, @2); }
			| b_expr CmpOp b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| b_expr JsonOp b_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| b_expr JsonOpText b_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field_text");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| b_expr qual_Op b_expr				%prec Op
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| qual_Op b_expr					%prec Op
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $1, NULL, $2, @1); }
			| b_expr qual_Op					%prec POSTFIXOP
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, NULL, @2); }
			| b_expr IS DISTINCT FROM b_expr		%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $5, @2);
				}
			| b_expr IS NOT DISTINCT FROM b_expr	%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL,
						NULL, (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $6, @2), @2);
				}
			| b_expr IS OF '(' type_list ')'		%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "=", $1, (Node *) $5, @2);
				}
			| b_expr IS NOT OF '(' type_list ')'	%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "<>", $1, (Node *) $6, @2);
				}
			| b_expr IS DOCUMENT_P					%prec IS
				{
					$$ = makeXmlExpr(IS_DOCUMENT, NULL, NIL, list_make1($1), @2);
				}
			| b_expr IS NOT DOCUMENT_P				%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL, makeXmlExpr(IS_DOCUMENT, NULL, NIL, list_make1($1), @2),@2);
				}
			;

UseStmt:
			USE ColId
				{
					if (!OidIsValid(get_namespace_oid($2, true))) {
						ereport(errstate,
							(errcode(ERRCODE_UNDEFINED_SCHEMA),
								errmsg("Unknown database \'%s\'", $2)));
					}
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_SET_VALUE;
					n->name = "search_path";
					n->args = list_make1(makeStringConst($2, -1));
					n->is_local = false;
					$$ = (Node *) n;
				}
			;

uservar_name:
			SET_USER_IDENT						
			{ 
				int len = strlen($1);
				error_t errorno = EOK;

				if (len < 1) {
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("Incorrect user_defined variable."),
							parser_errposition(@1)));
				}

				char *name = (char *)palloc(len + 1);
				errorno = memset_s(name, len + 1, 0, len + 1);
				securec_check(errorno, "\0", "\0");
				if ((len > 2) && (strncmp($1, "'", 1) == 0 || strncmp($1, "\"", 1) == 0 || strncmp($1, "`", 1) == 0)) {
					errorno = strncpy_s(name, len + 1, $1 + 1, len + 1);
					securec_check(errorno, "\0", "\0");
					name[len - 2] = '\0';
				} else {
					errorno = strncpy_s(name, len + 1, $1, len + 1);
					securec_check(errorno, "\0", "\0");
					name[len] = '\0';
				}

				UserVar *n = makeNode(UserVar);
				n->name = downcase_truncate_identifier(name, strlen(name), true);
				$$ = (Node *)n;
			}
			;

var_name:	ColId								{ $$ = $1; }
			| var_name '.' ColId
				{
					int rc = EOK;						  
					int len = strlen($1) + strlen($3) + 2;
					$$ = (char *)palloc(len);
					rc = sprintf_s($$, len, "%s.%s", $1, $3);
					securec_check_ss(rc, "\0", "\0");
				}
		;

dolphin_var_name: var_name
					{ GetSessionContext()->is_schema_name = (strcmp($1, "search_path") == 0); }
					{ $$ = $1; };

var_list:	var_value								{ $$ = list_make1($1); }
			| var_list ',' var_value				{ $$ = lappend($1, $3); }
		;

schema_var_list:	schema_var										{ $$ = list_make1(makeStringConst($1, @1)); }
					| schema_var_list ',' schema_var				{ $$ = lappend($1, makeStringConst($3, @3)); }
schema_var:
			DolphinColId							{ $$ = GetDolphinSchemaName($1->str, $1->is_quoted); }
			| SCONST								{ $$ = $1; }
		;

var_value:	opt_boolean_or_string
				{ $$ = makeStringConst($1, @1); }
			| NumericOnly
				{ $$ = makeAConst($1, @1); }
		;

iso_level:	READ UNCOMMITTED						{ $$ = "read uncommitted"; }
			| READ COMMITTED						{ $$ = "read committed"; }
			| REPEATABLE READ						{ $$ = "repeatable read"; }
			| SERIALIZABLE							{ $$ = "serializable"; }
		;

opt_boolean_or_string:
			TRUE_P									{ $$ = "true"; }
			| FALSE_P								{ $$ = "false"; }
			| ON									{ $$ = "on"; }
			/*
			 * OFF is also accepted as a boolean value, but is handled
			 * by the ColId rule below. The action for booleans and strings
			 * is the same, so we don't need to distinguish them here.
			 */
			| Dolphin_ColId_or_Sconst				{ $$ = $1; }
		;

/* Timezone values can be:
 * - a string such as 'pst8pdt'
 * - an identifier such as "pst8pdt"
 * - an integer or floating point number
 * - a time interval per SQL99
 * ColId gives reduce/reduce errors against ConstInterval and LOCAL,
 * so use IDENT (meaning we reject anything that is a key word).
 */
zone_value:
			SCONST
				{
					$$ = makeStringConst($1, @1);
				}
			| normal_ident
				{
					$$ = makeStringConst($1, @1);
				}
			| INTERVAL SCONST opt_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					if ($3 != NIL)
					{
						A_Const *n = (A_Const *) linitial($3);
						if ((n->val.val.ival & ~(INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE))) != 0) {
            				const char* message = "time zone interval must be HOUR or HOUR TO MINUTE";
            				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("time zone interval must be HOUR or HOUR TO MINUTE"),
									 parser_errposition(@3)));
						}
					}
					t->typmods = $3;
					$$ = makeStringConstCast($2, @2, t);
				}
			| INTERVAL '(' Iconst ')' SCONST opt_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					if ($6 != NIL)
					{
						A_Const *n = (A_Const *) linitial($6);
						if ((n->val.val.ival & ~(INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE))) != 0) {
            				const char* message = "time zone interval must be HOUR or HOUR TO MINUTE";
            				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("time zone interval must be HOUR or HOUR TO MINUTE"),
									 parser_errposition(@6)));
						}
						if (list_length($6) != 1) {
            				const char* message = "interval precision specified twice";
            				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("interval precision specified twice"),
									 parser_errposition(@1)));
						}
						t->typmods = lappend($6, makeIntConst($3, @3));
					}
					else
						t->typmods = list_make2(makeIntConst(INTERVAL_FULL_RANGE, -1),
												makeIntConst($3, @3));
					$$ = makeStringConstCast($5, @5, t);
				}
			| NumericOnly							{ $$ = makeAConst($1, @1); }
			| DEFAULT								{ $$ = NULL; }
			| LOCAL									{ $$ = NULL; }
		;

opt_encoding:
			SCONST									{ $$ = $1; }
			| normal_ident							{ $$ = $1; }
			| DEFAULT								{ $$ = NULL; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

ColId_or_Sconst:
			ColId									{ $$ = $1; }
			| SCONST								{ $$ = $1; }
		;

Dolphin_ColId_or_Sconst:
			DolphinColId
				{
					if (GetSessionContext()->is_schema_name) {
						$$ = GetDolphinSchemaName($1->str, $1->is_quoted);
					} else {
						$$ = downcase_str($1->str, $1->is_quoted);
					}
				}
			| SCONST								{ $$ = $1; }
		;

VariableResetStmt:
			RESET var_name
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET;
					n->name = $2;
					$$ = (Node *) n;
				}
			| RESET TIME ZONE
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET;
					n->name = "timezone";
					$$ = (Node *) n;
				}
			| RESET CURRENT_SCHEMA
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET;
					n->name = "current_schema";
					$$ = (Node *) n;
				}
			| RESET TRANSACTION ISOLATION LEVEL
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET;
					n->name = "transaction_isolation";
					$$ = (Node *) n;
				}
			| RESET SESSION AUTHORIZATION
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET;
					n->name = "session_authorization";
					$$ = (Node *) n;
				}
			| RESET ALL
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					n->kind = VAR_RESET_ALL;
					$$ = (Node *) n;
				}
		;

/* SetResetClause allows SET or RESET without LOCAL */
SetResetClause:
			SET set_rest					{ $$ = $2; }
			| VariableResetStmt				{ $$ = (VariableSetStmt *) $1; }
		;

/* SetResetClause allows SET or RESET without LOCAL */
FunctionSetResetClause:
			SET set_rest_more				{ $$ = $2; }
			| VariableResetStmt				{ $$ = (VariableSetStmt *) $1; }
		;


VariableShowStmt:
			SHOW WARNINGS
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show warnings feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_warnings";
						n->offset = 0;
						n->count = MAX_ERROR_COUNT;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW WARNINGS LIMIT Iconst
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show warnings feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_warnings";
						n->offset = 0;
						n->count = $4;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW WARNINGS LIMIT Iconst ',' Iconst
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show warnings feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_warnings";
						n->offset = $4;
						n->count = $6;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW DOLPHINIDENT '(' '*' ')' WARNINGS
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show count(*) warnings feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						char *ident = downcase_str($2->str, false);
						if (strcmp(ident, "count") != 0) {
							const char* message = "Un-support feature";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("Un-support function \"%s\" for show warnings", ident)));
						}
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_warnings_count";
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW_ERRORS
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show errors feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_errors";
						n->offset = 0;
						n->count = MAX_ERROR_COUNT;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW_ERRORS LIMIT Iconst
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show errors feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_errors";
						n->offset = 0;
						n->count = $3;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW_ERRORS LIMIT Iconst ',' Iconst
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show errors feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_errors";
						n->offset = $3;
						n->count = $5;
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW DOLPHINIDENT '(' '*' ')' ERRORS
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Show count(*) errors feature is unsupported on distributed mode.")));
#else
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						char *ident = downcase_str($2->str, false);
						if (strcmp(ident, "count") != 0) {
							const char* message = "Un-support feature";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("Un-support function \"%s\" for show errors", ident)));
						}
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = "show_errors_count";
						$$ = (Node *) n;
					}
#endif
				}
			| SHOW var_name
			{
					if(strcmp($2, "events") == 0) {
	#ifdef ENABLE_MULTIPLE_NODES
						const char* message = "SHOW EVENTS is not yet supported in distributed database.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SHOW EVENTS is not yet supported in distributed database.")));
	#endif
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
							const char* message = "show events statement is only supported in B format.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errmodule(MOD_PARSER),
										errcode(ERRCODE_SYNTAX_ERROR),
										errmsg("SHOW EVENTS is supported only in B-format database."),
										parser_errposition(@1)));
							$$ = NULL;
						}
						ShowEventStmt *n = makeNode(ShowEventStmt);
						n->from_clause = NULL;
						n->where_clause = NULL;
						$$ = (Node *)n;
					} else if (pg_strcasecmp($2, "processlist") == 0) {
						SelectStmt *n = makeShowProcesslistQuery(FALSE);
						$$ = (Node *) n;
					} else if (pg_strcasecmp($2, "tables") == 0) {
						SelectStmt *n = makeShowTablesQuery(FALSE, NULL, NULL, FALSE);
						$$ = (Node *) n;
					} else if (pg_strcasecmp($2, "plugins") == 0) {
						SelectStmt *n = makeShowPluginsQuery();
						$$ = (Node *) n;
					} else if (pg_strcasecmp($2, "databases") == 0 || pg_strcasecmp($2, "schemas") == 0) {
						SelectStmt *n = makeShowDatabasesQuery(NULL, NULL);
						$$ = (Node *) n;
					} else if (pg_strcasecmp($2, "variables") == 0) {
						SelectStmt *n = makeShowVariablesQuery(FALSE, NULL, FALSE);
						$$ = (Node *) n;
					} else if (pg_strcasecmp($2, "grants") == 0) {
						$$ = (Node *)MakeShowGrantStmt("", @2, yyscanner);
					} else if (pg_strcasecmp($2, "triggers") == 0) {
						$$ = (Node *) MakeShowTriggersQuery(list_make1(makeStringConst(NULL, 0)), NULL, NULL);
					}  else if (pg_strcasecmp($2, "charset") == 0) {
						$$ = (Node *) MakeShowCharacterQuery(NIL, NULL, NULL);
					}  else if (pg_strcasecmp($2, "collation") == 0) {
						$$ = (Node *) MakeShowCollationQuery(NIL, NULL, NULL);
					} else if (pg_strcasecmp($2, "privileges") == 0) {
                        SelectStmt *n = makeShowPrivilegesQuery();
                        $$ = (Node *) n;
                    } else {
						VariableShowStmt *n = makeNode(VariableShowStmt);
						n->name = $2;
						$$ = (Node *) n;
					}
				}
			| SHOW TABLES LikeOrWhere
				{
					SelectStmt *n = makeShowTablesQuery(FALSE, NULL, $3->like_or_where, $3->is_like);
					$$ = (Node *) n;
				}
			| SHOW TABLES from_in ColId OptLikeOrWhere
				{
					SelectStmt *n = makeShowTablesQuery(FALSE, $4, $5->like_or_where, $5->is_like);
					$$ = (Node *) n;
				}
			| SHOW FULL TABLES OptDbName OptLikeOrWhere
				{
					SelectStmt *n = makeShowTablesQuery(TRUE, $4, $5->like_or_where, $5->is_like);
					$$ = (Node *) n;
				}
			| SHOW TABLE STATUS
				{
					SelectStmt *n = makeShowTableStatusQuery(NULL, NULL, FALSE);
					$$ = (Node *) n;
				}
			| SHOW TABLE STATUS LikeOrWhere
				{
					SelectStmt *n = makeShowTableStatusQuery(NULL, $4->like_or_where, $4->is_like);
					$$ = (Node *) n;
				}
			| SHOW TABLE STATUS from_in ColId OptLikeOrWhere
				{
					SelectStmt *n = makeShowTableStatusQuery($5, $6->like_or_where, $6->is_like);
					$$ = (Node *) n;
				}
			| SHOW opt_full_fields from_in dolphin_qualified_name OptDbName OptLikeOrWhere
				{
					SelectStmt *n = makeShowColumnsQuery($4->schemaname, $4->relname, $5, $2, $6->is_like, $6->like_or_where);
					$$ = (Node *)n;
				}
			| SHOW FULL PROCESSLIST
				{
					SelectStmt *n = makeShowProcesslistQuery(TRUE);
					$$ = (Node *) n;
				}
			| SHOW CURRENT_SCHEMA
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "current_schema";
					$$ = (Node *) n;
				}
			| SHOW TIME ZONE
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "timezone";
					$$ = (Node *) n;
				}
			| SHOW TRANSACTION ISOLATION LEVEL
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "transaction_isolation";
					$$ = (Node *) n;
				}
			| SHOW SESSION AUTHORIZATION
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "session_authorization";
					$$ = (Node *) n;
				}
			| SHOW VARIABLES LIKE var_name
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "all";
					n->likename = $4;
					$$ = (Node *) n;
				}
			| SHOW VARIABLES LikeOrWhere
				{
					SelectStmt *n = makeShowVariablesQuery(FALSE, $3->like_or_where, $3->is_like);
					$$ = (Node *) n;
				}
			| SHOW opt_global VARIABLES OptLikeOrWhere
				{
					SelectStmt *n = makeShowVariablesQuery($2, $4->like_or_where, $4->is_like);
					$$ = (Node *) n;
				}
			| SHOW ALL
				{
					VariableShowStmt *n = makeNode(VariableShowStmt);
					n->name = "all";
					$$ = (Node *) n;
				}
			| SHOW show_index_opt from_in dolphin_qualified_name show_index_schema_opt where_clause
				{
					SelectStmt *s = makeShowIndexQuery($5 ? $5 : $4->schemaname, $4->relname, $6);
					$$ = (Node*)s;
				}
			| SHOW opt_databases LikeOrWhere
				{
					if ($3->is_like) {
						$$ = (Node *)makeShowDatabasesQuery($3->like_or_where, NULL);
					} else {
						$$ = (Node *)makeShowDatabasesQuery(NULL, $3->like_or_where);
					}
				}
			| SHOW MASTER STATUS
				{
					$$ = (Node *)makeShowMasterStatusQuery();
				}
			| SHOW SLAVE HOSTS
				{
					$$ = (Node *)makeShowSlaveHostsQuery();
				}
			| SHOW CREATE FUNCTION func_name_opt_arg
				{
					SelectStmt *n = NULL;
					const char* message = "improper func name (too many dotted names)";
					switch (list_length($4)) {
						case 1:
							n = findCreateProc(NULL,strVal(linitial($4)),GS_SHOW_CREATE_FUNCTION);
							break;
						case 2:
							n = findCreateProc(strVal(linitial($4)),strVal(lsecond($4)),GS_SHOW_CREATE_FUNCTION);
							break;
						default:
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper func name (too many dotted names): %s",
											NameListToString($4)),
									 parser_errposition(@1)));
							break;
					}
					$$ = (Node *) n;
				}
			| SHOW CREATE PROCEDURE func_name_opt_arg
				{
					SelectStmt *n = NULL;
					const char* message = "improper proc name (too many dotted names)";
					switch (list_length($4)) {
						case 1:
							n = findCreateProc(NULL,strVal(linitial($4)),GS_SHOW_CREATE_PROCEDURE);
							break;
						case 2:
							n = findCreateProc(strVal(linitial($4)),strVal(lsecond($4)),GS_SHOW_CREATE_PROCEDURE);
							break;
						default:
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper proc name (too many dotted names): %s",
											NameListToString($4)),
									 parser_errposition(@1)));
							break;
					}
					$$ = (Node *) n;
				}
			| SHOW CREATE TABLE dolphin_qualified_name
				{
					SelectStmt *n = findCreateClass($4,GS_SHOW_CREATE_TABLE);
					$$ = (Node *) n;
				}
			| SHOW CREATE VIEW dolphin_qualified_name
				{
					SelectStmt *n = findCreateClass($4,GS_SHOW_CREATE_VIEW);
					$$ = (Node *) n;
				}
			| SHOW CREATE TRIGGER qualified_name
				{
					SelectStmt *n = findCreateTrigger($4);
					$$ = (Node *) n;
				}
			| SHOW CREATE opt_database ColId
				{
					SelectStmt *n = makeShowCreateDatabaseQuery(FALSE,$4);
					$$ = (Node *) n;
				}
			| SHOW CREATE opt_database IF_P NOT EXISTS ColId
				{
					SelectStmt *n = makeShowCreateDatabaseQuery(TRUE,$7);
					$$ = (Node *) n;
				}
            | SHOW GRANTS FOR UserId
                  {
                      $$ = (Node *)MakeShowGrantStmt($4, @4, yyscanner);
                  }
            | SHOW TRIGGERS LikeOrWhere
                {
                    List *args = list_make1(makeStringConst(NULL, 0));
                    SelectStmt *n = MakeShowTriggersQuery(args, $3->like_or_where, $3->is_like);
                    $$ = (Node *) n;
                }
            | SHOW TRIGGERS from_in ColId OptLikeOrWhere
                {
                    List *args = list_make1(makeStringConst($4, @4));
                    SelectStmt *n = MakeShowTriggersQuery(args, $5->like_or_where, $5->is_like);
                    $$ = (Node *) n;
                }
            | SHOW FUNCTION STATUS OptLikeOrWhere
                {
                    List *args = list_make1(makeStringConst("f", 0));
                    SelectStmt *n = MakeShowFuncProQuery(args, $4->like_or_where, $4->is_like);
                    $$ = (Node *) n;
                } 
            | SHOW PROCEDURE STATUS OptLikeOrWhere
                {
                    List *args = list_make1(makeStringConst("p", 0));
                    SelectStmt *n = MakeShowFuncProQuery(args, $4->like_or_where, $4->is_like);
                    $$ = (Node *) n;
                }
            | SHOW CHARACTER SET OptLikeOrWhere
                {
                    SelectStmt *n = MakeShowCharacterQuery(NIL, $4->like_or_where, $4->is_like);
                    $$ = (Node *) n;
                }
	    | SHOW CHARSET LikeOrWhere
		{
		    SelectStmt *n = MakeShowCharacterQuery(NIL, $3->like_or_where, $3->is_like);
		    $$ = (Node *) n;
		}
	    | SHOW COLLATION LikeOrWhere
		{
		    SelectStmt *n = MakeShowCollationQuery(NIL, $3->like_or_where, $3->is_like);
		    $$ = (Node *) n;
		}
		| SHOW opt_global STATUS OptLikeOrWhere
		{
			SelectStmt *n = makeShowStatusQuery($2, $4->like_or_where, $4->is_like);
			$$ = (Node *) n;
		}
		| SHOW_STATUS OptLikeOrWhere
		{
			SelectStmt *n = makeShowStatusQuery(FALSE, $2->like_or_where, $2->is_like);
			$$ = (Node *) n;
		}
		;

show_index_schema_opt:
			from_in ColId							{ $$ = $2; }
			| /* empty */							{ $$ = NULL; }
		;

show_index_opt:
			INDEX
			| INDEXES
			| KEYS
		;

opt_databases:
			DATABASES { /* EMTPY */ }
			| SCHEMAS { /* EMTPY */ }
		;

opt_database:
			DATABASE { /* EMTPY */ }
			| SCHEMA { /* EMTPY */ }
		;

OptLikeOrWhere:
				{
					OptLikeWhere *n = (OptLikeWhere *)palloc(sizeof(OptLikeWhere));
					n->is_like = FALSE;
					n->like_or_where = NULL;
					$$ = n;
				}
			| LikeOrWhere
				{
					$$ = $1;
				}
                ;

LikeOrWhere:
			WHERE a_expr 
                                {
                                        OptLikeWhere *n = (OptLikeWhere *)palloc(sizeof(OptLikeWhere));
                                        n->is_like = FALSE;
                                        n->like_or_where = $2;
                                        $$ = n;
                                }
                        | LIKE SCONST
                                {
                                        OptLikeWhere *n = (OptLikeWhere *)palloc(sizeof(OptLikeWhere));
                                        n->is_like = TRUE;
                                        n->like_or_where = makeStringConst($2, -1);
                                        $$ = n;
                                }
                ;

opt_global:
			GLOBAL								{ $$ = TRUE; }
			| SESSION							{ $$ = FALSE; }
		;

ConstraintsSetStmt:
			SET CONSTRAINTS constraints_set_list constraints_set_mode
				{
					ConstraintsSetStmt *n = makeNode(ConstraintsSetStmt);
					n->constraints = $3;
					n->deferred = $4;
					$$ = (Node *) n;
				}
		;

constraints_set_list:
			ALL										{ $$ = NIL; }
			| qualified_name_list					{ $$ = $1; }
		;

constraints_set_mode:
			DEFERRED								{ $$ = TRUE; }
			| IMMEDIATE								{ $$ = FALSE; }
		;

opt_full_fields:
			FULL columns_or_fields					{ $$ = TRUE; }
			| columns_or_fields					{ $$ = FALSE; }
		;

OptDbName:
			/* EMPTY*/						{ $$ = NULL; }
			| from_in ColId				    { $$ = $2; }
		;

columns_or_fields:
			COLUMNS
			| FIELDS
		;

/*****************************************************************************
 *
 * SHUTDOWN STATEMENT
 *
 *****************************************************************************/
ShutdownStmt:
                        SHUTDOWN
                                {
                                       ShutdownStmt *n = makeNode(ShutdownStmt);
                                       n->mode = NULL;
                                       $$ = (Node *) n;
                                }
                        | SHUTDOWN var_name
                                {
                                       ShutdownStmt *n = makeNode(ShutdownStmt);
                                       n->mode = $2;
                                       $$ = (Node *) n;
                                }
                ;

/*
 * Checkpoint statement
 */
CheckPointStmt:
			CHECKPOINT
				{
					CheckPointStmt *n = makeNode(CheckPointStmt);
					$$ = (Node *)n;
				}
		;

CheckSumTableStmt:
			CHECKSUM TABLE relation_expr_list OptQuickExt
				{
					SelectStmt *n = makeChecksumsTablesQuery($3, $4, FALSE);
					$$ = (Node*)n;
 				}
		;

OptQuickExt:
		        /* empty */	{ $$ = true; }
		        | QUICK         { $$ = false; }
		        | EXTENDED      { $$ = true; }
		;

/*****************************************************************************
 *
 * DISCARD { ALL | TEMP | PLANS }
 *
 *****************************************************************************/

DiscardStmt:
			DISCARD ALL
				{
					DiscardStmt *n = makeNode(DiscardStmt);
					n->target = DISCARD_ALL;
					$$ = (Node *) n;
				}
			| DISCARD TEMP
				{
					DiscardStmt *n = makeNode(DiscardStmt);
					n->target = DISCARD_TEMP;
					$$ = (Node *) n;
				}
			| DISCARD TEMPORARY
				{
					DiscardStmt *n = makeNode(DiscardStmt);
					n->target = DISCARD_TEMP;
					$$ = (Node *) n;
				}
			| DISCARD PLANS
				{
					DiscardStmt *n = makeNode(DiscardStmt);
					n->target = DISCARD_PLANS;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *	ALTER [ TABLE | INDEX | SEQUENCE | VIEW | MATERIALIZED VIEW| STREAM] variations
 *
 * Note: we accept all subcommands for each of the five variants, and sort
 * out what's really legal at execution time.
 *****************************************************************************/

AlterTableStmt:
		ALTER TABLE relation_expr MODIFY_P '(' modify_column_cmds ')'
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $3;
					n->cmds = $6;
					n->relkind = OBJECT_TABLE;
					n->missing_ok = false;
					n->need_rewrite_sql = false;
					$$ = (Node *)n;
				}
		/* REDISANYVALUE key value only used in tsdb redis command, it is used in OM code */
		|	ALTER TABLE relation_expr REDISANYVALUE
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $3;
					n->cmds = NIL;
					n->relkind = OBJECT_TABLE;
					n->missing_ok = false;
					n->need_rewrite_sql = false;
					$$ = (Node *)n;
				}
		/*
		 * ALTER TABLE IF_P EXISTS MODIFY_P '(' modify_column_cmds ')'
		 */
		|	ALTER TABLE IF_P EXISTS relation_expr MODIFY_P '(' modify_column_cmds ')'
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $5;
					n->cmds = $8;
					n->relkind = OBJECT_TABLE;
					n->missing_ok = true;
					n->need_rewrite_sql = false;
					$$ = (Node *)n;
				}
		|	ALTER TABLE relation_expr alter_table_or_partition
				{
					if ($4->length == 1 && ((AlterTableCmd*)lfirst($4->head))->subtype == AT_RebuildAllIndexOnPartition)
					{
						ReindexStmt *n = makeNode(ReindexStmt);
						n->kind = OBJECT_TABLE_PARTITION;
						n->relation = $3;
						n->name = ((AlterTableCmd*)lfirst($4->head))->name;
						$$ = (Node *)n;
					}
					else
					{
						AlterTableStmt *n = makeNode(AlterTableStmt);
						n->relation = $3;
						n->cmds = $4;
						n->relkind = OBJECT_TABLE;
						n->missing_ok = false;
						n->need_rewrite_sql = false;
						$$ = (Node *)n;
					}
				}
		|	ALTER TABLE IF_P EXISTS relation_expr alter_table_or_partition
				{
					if ($6->length == 1 && ((AlterTableCmd*)lfirst($6->head))->subtype == AT_RebuildAllIndexOnPartition)
					{
						ReindexStmt *n = makeNode(ReindexStmt);
						n->kind = OBJECT_TABLE_PARTITION;
						n->relation = $5;
						n->name = ((AlterTableCmd*)lfirst($6->head))->name;
						$$ = (Node *)n;
					}
					else
					{
						AlterTableStmt *n = makeNode(AlterTableStmt);
						n->relation = $5;
						n->cmds = $6;
						n->relkind = OBJECT_TABLE;
						n->missing_ok = true;
						n->need_rewrite_sql = false;
						$$ = (Node *)n;
					}
				}
		|	ALTER INDEX qualified_name alter_index_or_partition
				{
					if ($4->length == 1 && ((AlterTableCmd*)lfirst($4->head))->subtype == AT_RebuildIndex)
					{
						ReindexStmt *n = makeNode(ReindexStmt);
						n->kind = OBJECT_INDEX;
						n->relation = $3;
						n->name = NULL;
						$$ = (Node *)n;
					}
					else if ($4->length == 1 && ((AlterTableCmd*)lfirst($4->head))->subtype == AT_RebuildIndexPartition)
					{
						ReindexStmt *n = makeNode(ReindexStmt);
						n->kind = OBJECT_INDEX_PARTITION;
						n->relation = $3;
						n->name = ((AlterTableCmd*)lfirst($4->head))->name;
						$$ = (Node *)n;
					}
					else
					{
						ListCell   *cell;
						foreach(cell, $4)
						{
							AlterTableCmd* cmd = (AlterTableCmd*) lfirst(cell);
							if (cmd->subtype == AT_RebuildIndex
								|| cmd->subtype == AT_RebuildIndexPartition)
							{
            					const char* message = "REBUILD is not supported for multiple commands";
            					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("REBUILD is not supported for multiple commands")));
							}
						}

						AlterTableStmt *n = makeNode(AlterTableStmt);
						n->relation = $3;
						n->cmds = $4;
						n->relkind = OBJECT_INDEX;
						n->missing_ok = false;
						$$ = (Node *)n;
					}
				}
		|	ALTER INDEX IF_P EXISTS qualified_name alter_index_or_partition
				{
					ListCell   *cell;
					foreach(cell, $6)
					{
						AlterTableCmd* cmd = (AlterTableCmd*) lfirst(cell);
						if (cmd->subtype == AT_RebuildIndex
							|| cmd->subtype == AT_RebuildIndexPartition)
						{
            				const char* message = "IF EXISTS is not supported for REBUILD";
            				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("IF EXISTS is not supported for REBUILD")));
						}
					}

					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $5;
					n->cmds = $6;
					n->relkind = OBJECT_INDEX;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
		|	ALTER SEQUENCE qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $3;
					n->cmds = $4;
					n->relkind = OBJECT_SEQUENCE;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
		|	ALTER LARGE_P SEQUENCE qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $4;
					n->cmds = $5;
					n->relkind = OBJECT_LARGE_SEQUENCE;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
		|	ALTER SEQUENCE IF_P EXISTS qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $5;
					n->cmds = $6;
					n->relkind = OBJECT_SEQUENCE;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
		|	ALTER LARGE_P SEQUENCE IF_P EXISTS qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $6;
					n->cmds = $7;
					n->relkind = OBJECT_LARGE_SEQUENCE;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
		|	ALTER opt_view_algo VIEW dolphin_qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $4;
					n->cmds = $5;
					n->relkind = OBJECT_VIEW;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
		|	ALTER opt_view_algo VIEW IF_P EXISTS dolphin_qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $6;
					n->cmds = $7;
					n->relkind = OBJECT_VIEW;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
		|	ALTER MATERIALIZED VIEW qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $4;
					n->cmds = $5;
					n->relkind = OBJECT_MATVIEW;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
		|	ALTER MATERIALIZED VIEW IF_P EXISTS qualified_name alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $6;
					n->cmds = $7;
					n->relkind = OBJECT_MATVIEW;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
        |   ALTER STREAM  qualified_name alter_table_cmds
            {
                AlterTableStmt *n = makeNode(AlterTableStmt);
                n->relation = $3;
                n->cmds = $4;
                n->relkind = OBJECT_STREAM;
                n->missing_ok = false;
                $$ = (Node *)n;
            }
        ;

modify_column_cmds:
			modify_column_cmd							{ $$ = list_make1($1); }
			| modify_column_cmds ',' modify_column_cmd	{ $$ = lappend($$, $3); }
			;
modify_column_cmd:
			DolphinColColId Typename opt_charset ColQualList add_column_first_after
				{
					AlterTableCmd *n = (AlterTableCmd *)$5;
					if ($4 == NULL && n->is_first == false && n->after_name == NULL && !ENABLE_MODIFY_COLUMN) {
						ColumnDef *def = makeNode(ColumnDef);
						n->subtype = AT_AlterColumnType;
						n->name = $1;
						n->def = (Node *) def;
						/* We only use these three fields of the ColumnDef node */
						def->typname = $2;
						def->typname->charset = $3;
						def->collClause = NULL;
						def->raw_default = NULL;
						def->update_default = NULL;
						def->clientLogicColumnRef=NULL;
						$$ = (Node *)n;
					} else {
#ifdef ENABLE_MULTIPLE_NODES
						const char* message = "Un-support feature";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("Un-support feature"),
								errdetail("The distributed capability is not supported currently.")));
#endif
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
							ereport(errstate, (errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("Un-support feature"),
								parser_errposition(@4),
								errdetail("this modify syntax is supported only in B compatibility")));
						}
						ColumnDef *def = makeNode(ColumnDef);
						def->colname = $1;
						def->typname = $2;
						def->typname->charset = $3;
						def->kvtype = ATT_KV_UNDEFINED;
						def->inhcount = 0;
						def->is_local = true;
						def->is_not_null = false;
						def->is_from_type = false;
						def->storage = 0;
						def->cmprs_mode = ATT_CMPR_UNDEFINED;
						def->raw_default = NULL;
						def->cooked_default = NULL;
						def->collOid = InvalidOid;
						def->fdwoptions = NULL;
						def->update_default = NULL;
						SplitColQualList($4, &def->constraints, &def->collClause, &def->clientLogicColumnRef, &def->columnOptions, yyscanner);
						n->subtype = AT_ModifyColumn;
						n->name = $1;
						n->def = (Node *)def;
						$$ = (Node *)n;						
					}
				}
			| DolphinColColId NOT NULL_P opt_enable
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetNotNull;
					n->name = $1;
					$$ = (Node *)n;
				}
			| DolphinColColId NULL_P
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropNotNull;
					n->name = $1;
					$$ = (Node *)n;
				}
			| DolphinColColId CONSTRAINT name NOT NULL_P opt_enable
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					ColumnDef *def = makeNode(ColumnDef);
					Constraint *cons = makeNode(Constraint);
					n->subtype = AT_SetNotNull;
					n->name = $1;
					n->def = (Node *) def;
					def->constraints = list_make1(cons);
					cons->contype = CONSTR_NOTNULL;
					cons->conname = $3;
					cons->location = @2;
					$$ = (Node *)n;
				}
			| DolphinColColId CONSTRAINT name NULL_P
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					ColumnDef *def = makeNode(ColumnDef);
					Constraint *cons = makeNode(Constraint);
					n->subtype = AT_DropNotNull;
					n->name = $1;
					n->def = (Node *) def;
					def->constraints = list_make1(cons);
					cons->contype = CONSTR_NULL;
					cons->conname = $3;
					cons->location = @2;
					$$ = (Node *)n;
				}
			;
opt_enable:	ENABLE_P		{}
			| /* empty */	{}
			;
add_column_cmds:
			columnDef
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddColumn;
					n->def = $1;
					$$ = list_make1(n);
				}
			| add_column_cmds ',' columnDef
				{
				 	AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddColumn;
					n->def = $3;
					$$ = lappend($1, n);
				}
			;

alter_index_or_partition:
		alter_table_or_partition        { $$ = ($1); }
		| alter_index_rebuild_partition { $$ = ($1); }
		;

/* ALTER INDEX index_name REBUILD PARTITION partition_name */
alter_index_rebuild_partition:
		REBUILD_PARTITION ColId
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_RebuildIndexPartition;
				n->name = $2;
				$$ = list_make1((Node *)n);
			}
		;

/* ALTER TABLE sql clause both for PARTITION and ordinary table */
alter_table_or_partition:
			alter_table_cmds        { $$ = ($1); }
			| alter_partition_cmds  { $$ = ($1); }
			| alter_partition_cmds_for_bdatabase  { $$ = ($1); }
			| alter_subpartition_cmds_for_bdatabase  { $$ = ($1); }
			| ADD_PARTITION '(' add_partition_cmds_for_bdatabase ')' { $$ = ($3); }
		;

/* ALTER TABLE sql clauses for ordinary table */
alter_table_cmds:
			alter_table_cmd
			{
				/*
				 * alter_table_cmd is defined as Node* actually, but it may be a list, check ADD_P '(' add_column_cmds ')'.
				 * we use a simple way to check nodetag by IsA, otherwise we need to change alter_table_cmd's type to List,
				 * and change all return values in alter_table_cmd as a list, which lead to many code change
				 */
				if (!IsA($1, List)) {
					$$ = list_make1($1);
				} else {
					$$ = (List*)$1;
				}
			}
			| alter_table_cmds ',' alter_table_cmd
			{
				if (!IsA($3, List)) {
					$$ = lappend($1, $3);
				} else {
					$$ = list_concat($1, (List*)$3);
				}
			}
			| alter_table_option_list
				{
					$$ = $1;
				}
			| alter_table_cmds ',' alter_table_option_list
				{
					$$ = list_concat($1, $3);
				}
		;

/* ALTER TABLE PARTITION sql clauses */
alter_partition_cmds:
			alter_partition_cmd                            { $$ = list_make1($1); }
			| alter_partition_cmds ',' alter_partition_cmd { $$ = lappend($1, $3); }
			| move_partition_cmd                           { $$ = list_make1($1); }
			| exchange_partition_cmd                       { $$ = list_make1($1); }
			| reset_partition_cmd                          { $$ = list_make1($1); }
			| exchange_partition_cmd_for_bdatabase             { $$ = list_make1($1); }
		;

alter_partition_cmd:
		/* ALTER INDEX index_name MODIFY PARTITION partition_name UNUSABLE */
		MODIFY_PARTITION ColId UNUSABLE
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_UnusableIndexPartition;
				n->name = $2;
				$$ = (Node *)n;
			}
		/* ALTER TABLE table_name MODIFY PARTITION partition_name UNUSABLE ALL INDEX */
		| MODIFY_PARTITION ColId UNUSABLE LOCAL INDEXES
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_UnusableAllIndexOnPartition;
				n->name = $2;
				$$ = (Node *)n;
			}
		/* ALTER TABLE table_name MODIFY PARTITION partition_name REBUILD ALL INDEX */
		| MODIFY_PARTITION ColId REBUILD UNUSABLE LOCAL INDEXES
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_RebuildAllIndexOnPartition;
				n->name = $2;
				$$ = (Node *)n;
			}
		/* ALTER TABLE ADD PARTITION: use less/than */
		| ADD_PARTITION add_partition_cmd
			{
				$$ = $2;
			}
		/* ALTER TABLE MODIFY PARTITION ADD SUBPARTITION */
		| MODIFY_PARTITION name ADD_SUBPARTITION name VALUES LESS THAN maxValueList_with_opt_parens OptTableSpace
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddSubPartitionState *s = makeNode(AddSubPartitionState);
				p->partitionName = $4;
				p->boundary = $8;
				p->tablespacename = $9;
				s->subPartitionList = list_make1(p);
				s->partitionName = $2;
				n->subtype = AT_AddSubPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| MODIFY_PARTITION name ADD_SUBPARTITION name VALUES '(' expr_list ')' OptTableSpace
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddSubPartitionState *s = makeNode(AddSubPartitionState);
				p->partitionName = $4;
				p->boundary = $7;
				p->tablespacename = $9;
				s->subPartitionList = list_make1(p);
				s->partitionName = $2;
				n->subtype = AT_AddSubPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| MODIFY_PARTITION name ADD_SUBPARTITION name VALUES '(' DEFAULT ')' OptTableSpace
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddSubPartitionState *s = makeNode(AddSubPartitionState);
				p->partitionName = $4;
				Const *n_default = makeNode(Const);
				n_default->ismaxvalue = true;
				n_default->location = -1;
				p->boundary = list_make1(n_default);
				p->tablespacename = $9;
				s->subPartitionList = list_make1(p);
				s->partitionName = $2;
				n->subtype = AT_AddSubPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		/* ALTER TABLE DROP PARTITION */
		| DROP_PARTITION FOR maxValueList_with_opt_parens OptGPI
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);

				p->boundary = $3;
				n->subtype = AT_DropPartition;
				n->def = (Node*)p;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				$$ = (Node *)n;
			}
		/* ALTER TABLE DROP SUBPARTITION */
		| DROP_SUBPARTITION FOR '(' expr_list ')' OptGPI
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);

				p->boundary = $4;
				n->subtype = AT_DropSubPartition;
				n->def = (Node*)p;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $6;
				$$ = (Node *)n;
			}
		/* merge 2 or more partitions into 1 partition */
		| MERGE PARTITIONS name_list INTO PARTITION name OptTableSpace OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->def = (Node*)$3;
				n->name = $6;
				n->target_partition_tablespace = $7;
				n->subtype = AT_MergePartition;
				n->alterGPI = $8;
				$$ = (Node*)n;
			}
		/* split one partition into two partition */
		| SPLIT PARTITION name AT maxValueList_with_opt_parens INTO
		  '(' split_dest_partition_define_list ')' OptGPI
			{
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->src_partition_name = $3;
				s->split_point = $5;
				s->dest_partition_define_list = $8;
				s->partition_for_values = NULL;

				n->def = (Node*)s;
				n->subtype = AT_SplitPartition;
				n->alterGPI = $10;
				$$ = (Node*)n;
			}
		/* split one partition into two partition */
		| SPLIT PARTITION_FOR maxValueList_with_opt_parens AT maxValueList_with_opt_parens INTO
		  '(' split_dest_partition_define_list ')' OptGPI
			{
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->partition_for_values = $3;
				s->split_point = $5;
				s->dest_partition_define_list = $8;
				s->src_partition_name = NULL;

				n->def = (Node*)s;
				n->subtype = AT_SplitPartition;
				n->alterGPI = $10;
				$$ = (Node*)n;
			}
		/*split one partition into multiple partition*/
		| SPLIT PARTITION name INTO '(' range_partition_definition_list ')' OptGPI
			{
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->src_partition_name = $3;
				s->dest_partition_define_list = $6;
				s->split_point = NULL;
				s->partition_for_values = NULL;

				n->def = (Node*)s;
				n->subtype = AT_SplitPartition;
				n->alterGPI = $8;
				$$ = (Node*)n;
			}
		| SPLIT PARTITION_FOR maxValueList_with_opt_parens INTO '(' range_partition_definition_list ')' OptGPI
			{
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->partition_for_values = $3;
				s->dest_partition_define_list = $6;
				s->src_partition_name = NULL;
				s->split_point = NULL;

				n->def = (Node*)s;
				n->subtype = AT_SplitPartition;
				n->alterGPI = $8;
				$$ = (Node*)n;
			}
		/* split one list subpartition into two subpartition */
		| SPLIT SUBPARTITION name VALUES maxValueList_with_opt_parens INTO
		  '(' split_dest_listsubpartition_define_list ')' OptGPI
			{
				if (list_length($8) != 2)  {
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("List subpartition can be split into only two subpartitions.")));
				}
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->src_partition_name = $3;
				s->newListSubPartitionBoundry = $5;
				s->dest_partition_define_list = $8;
				s->partition_for_values = NULL;
				s->splitType = LISTSUBPARTITIION;

				n->def = (Node*)s;
				n->subtype = AT_SplitSubPartition;
				n->alterGPI = $10;
				$$ = (Node*)n;
			}
		/* split one range subpartition into two subpartition */
		| SPLIT SUBPARTITION name AT maxValueList_with_opt_parens INTO
		  '(' split_dest_rangesubpartition_define_list ')' OptGPI
			{
				if (list_length($8) != 2)  {
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("List subpartition can be split into only two subpartitions.")));
				}
				AlterTableCmd	*n = makeNode(AlterTableCmd);
				SplitPartitionState	*s = makeNode(SplitPartitionState);

				s->src_partition_name = $3;
				s->split_point = $5;
				s->dest_partition_define_list = $8;
				s->partition_for_values = NULL;
				s->splitType = RANGESUBPARTITIION;

				n->def = (Node*)s;
				n->subtype = AT_SplitSubPartition;
				n->alterGPI = $10;
				$$ = (Node*)n;
			}
		| REORGANIZE PARTITION name_list INTO '(' range_partition_definition_list ')'
			{
				AlterTableCmd* n = makeNode(AlterTableCmd);
				SplitPartitionState* r = makeNode(SplitPartitionState);

				/* use the split_point of SplitPartitionState to save name_list*/
				r->split_point = $3;
				r->dest_partition_define_list = $6;

				n->def = (Node*)r;
				n->subtype = AT_ReorganizePartition;
				$$ = (Node*)n;
			}
		| REORGANIZE PARTITION name_list INTO '(' list_partition_definition_list ')'
			{
				AlterTableCmd* n = makeNode(AlterTableCmd);
				SplitPartitionState* r = makeNode(SplitPartitionState);

				/* use the split_point of SplitPartitionState to save name_list*/
				r->split_point = $3;
				r->dest_partition_define_list = $6;

				n->def = (Node*)r;
				n->subtype = AT_ReorganizePartition;
				$$ = (Node*)n;
			}
		/* truncate partition */
		| TRUNCATE PARTITION_FOR maxValueList_with_opt_parens OptGPI
			{

				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);

				p->boundary = $3;
				n->subtype = AT_TruncatePartition;
				n->def = (Node*)p;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				$$ = (Node *)n;

			}
		/* truncate subpartition */
		| TRUNCATE SUBPARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncateSubPartition;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				$$ = (Node *)n;

				n->name = $3;

			}
		/* ENABLE ROW MOVEMENT */
		| ENABLE_P ROW MOVEMENT
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_EnableRowMoveMent;
				n->missing_ok = FALSE;
				$$ = (Node *) n;
			}
		/* DISABLE ROW MOVEMENT */
		| DISABLE_P ROW MOVEMENT
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_DisableRowMoveMent;
				n->missing_ok = FALSE;
				$$ = (Node *) n;

			}
		;

move_partition_cmd:
		/* ALTER TABLE <name> MOVE PARTITION <part_name> TABLESPACE <tablespacename> */
		MOVE PARTITION partition_name TABLESPACE name
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_SetPartitionTableSpace;
				n->def = (Node*)$3;
				n->name = $5;
				$$ = (Node *)n;
			}
		/* ALTER TABLE <name> MOVE PARTITION FOR (...) TABLESPACE <tablespacename> */
		| MOVE PARTITION_FOR maxValueList_with_opt_parens TABLESPACE name
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);

				p->boundary = $3;

				n->subtype = AT_SetPartitionTableSpace;
				n->def = (Node*)p;
				n->name = $5;
				$$ = (Node *)n;
			}
		;

exchange_partition_cmd:
		/* exchange partition */
		EXCHANGE PARTITION '(' ColId ')'
		  WITH TABLE relation_expr opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_ExchangePartition;
				n->name = $4;
				n->exchange_with_rel = $8;
				n->check_validation = TRUE;
				n->exchange_verbose = $9;
				n->missing_ok = FALSE;
				n->alterGPI = $10;
				$$ = (Node *)n;
			}
		/* exchange partition */
		| EXCHANGE PARTITION '(' ColId ')'
		  WITH TABLE relation_expr WITH VALIDATION opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_ExchangePartition;
				n->name = $4;
				n->exchange_with_rel = $8;
				n->check_validation = TRUE;
				n->exchange_verbose = $11;
				n->missing_ok = FALSE;
				n->alterGPI = $12;
				$$ = (Node *)n;
			}
		/* exchange partition */
		| EXCHANGE PARTITION '(' ColId ')'
		  WITH TABLE relation_expr WITHOUT VALIDATION OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_ExchangePartition;
				n->name = $4;
				n->exchange_with_rel = $8;
				n->check_validation = FALSE;
				n->missing_ok = FALSE;
				n->alterGPI = $11;
				$$ = (Node *)n;
			}

		/* exchange partition */
		| EXCHANGE PARTITION_FOR maxValueList_with_opt_parens
		  WITH TABLE relation_expr opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				RangePartitionDefState *p = makeNode(RangePartitionDefState);

				p->boundary = $3;

				n->subtype = AT_ExchangePartition;
				n->exchange_with_rel = $6;
				n->check_validation = TRUE;
				n->exchange_verbose = $7;
				n->def = (Node*)p;
				n->missing_ok = FALSE;
				n->alterGPI = $8;
				$$ = (Node *)n;
			}

		| EXCHANGE PARTITION_FOR maxValueList_with_opt_parens
		  WITH TABLE relation_expr WITH VALIDATION opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				RangePartitionDefState *p = makeNode(RangePartitionDefState);

				p->boundary = $3;

				n->subtype = AT_ExchangePartition;
				n->exchange_with_rel = $6;
				n->check_validation = TRUE;
				n->exchange_verbose = $9;
				n->def = (Node*)p;
				n->missing_ok = FALSE;
				n->alterGPI = $10;
				$$ = (Node *)n;
			}

		| EXCHANGE PARTITION_FOR maxValueList_with_opt_parens
		  WITH TABLE relation_expr WITHOUT VALIDATION OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				RangePartitionDefState *p = makeNode(RangePartitionDefState);

				p->boundary = $3;

				n->subtype = AT_ExchangePartition;
				n->exchange_with_rel = $6;
				n->check_validation = FALSE;
				n->def = (Node*)p;
				n->missing_ok = FALSE;
				n->alterGPI = $9;
				$$ = (Node *)n;
			}
		;

reset_partition_cmd:
		RESET PARTITION
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);

				n->subtype = AT_ResetPartitionno;
				n->missing_ok = FALSE;
				$$ = (Node *) n;

			}
		;

/*
 * Note: alter_table_cmd defined as a Node, but it may return a list, check ADD_P '(' add_column_cmds ')'.
 * so please check the return value's nodetag before using it.
 */
alter_table_cmd:
			/*ALTER INDEX index_name UNUSABLE*/
			UNUSABLE
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_UnusableIndex;
					$$ = (Node *)n;
				}
			|
			ALTER INDEX index_name INVISIBLE
				{
					BCompatibilityOptionSupportCheck($4);
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_InvisibleIndex;
					n->name = $3;
					$$ = (Node *)n;
				}
			|
			ALTER INDEX index_name VISIBLE
				{
					BCompatibilityOptionSupportCheck($4);
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_VisibleIndex;
					n->name = $3;
					$$ = (Node *)n;
				}
			|
			/* ALTER TABLE <name> DISABLE KEYS */
			DISABLE_P KEYS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_UnusableIndex;
					$$ = (Node *)n;
				}
			|
			/* ALTER TABLE <name> ENABLE KEYS */
			ENABLE_P KEYS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_RebuildIndex;
					$$ = (Node *)n;
				}
			|
			/*ALTER INDEX index_name REBUILD*/
			REBUILD
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_RebuildIndex;
					$$ = (Node *)n;
				}

			|
			/* ALTER TABLE <name> ADD <coldef> */
			ADD_P columnDefForTableElement add_column_first_after
				{
					AlterTableCmd *n = (AlterTableCmd *)$3;
					n->subtype = AT_AddColumn;
					n->def = $2;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ADD COLUMN <coldef> */
			| ADD_P COLUMN columnDef add_column_first_after
				{
					AlterTableCmd *n = (AlterTableCmd *)$4;
					n->subtype = AT_AddColumn;
					n->def = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ADD <coldef, ...>, add column with bracket does not support first/after */
			| ADD_P '(' add_column_cmds ')'
				{
					$$ = (Node *)$3;
				}
			/* ALTER TABLE <name> ADD COLUMN <coldef, ...>, add column with bracket does not support first/after */
			| ADD_P COLUMN '(' add_column_cmds ')'
				{
					$$ = (Node *)$4;
				}
			| ADD_P TABLE dolphin_qualified_name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					AddTableIntoCBIState *s = makeNode(AddTableIntoCBIState);
					s->relation = $3;
					n->def = (Node *)s;
					n->subtype = AT_AddIntoCBI;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> {SET DEFAULT <expr>|DROP DEFAULT} */
			| ALTER opt_column DolphinColColId alter_column_default
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ColumnDefault;
					n->name = $3;
					n->def = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> DROP NOT NULL */
			| ALTER opt_column DolphinColColId DROP NOT NULL_P
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropNotNull;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET NOT NULL */
			| ALTER opt_column DolphinColColId SET NOT NULL_P
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetNotNull;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET STATISTICS <SignedIconst> */
			| ALTER opt_column DolphinColColId SET STATISTICS SignedIconst
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetStatistics;
					n->name = $3;
					n->def = (Node *) makeInteger($6);
					n->additional_property = AT_CMD_WithoutPercent;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET STATISTICS PERCENT <SignedIconst> */
			| ALTER opt_column DolphinColColId SET STATISTICS PERCENT SignedIconst
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetStatistics;
					n->name = $3;
					n->def = (Node *) makeInteger($7);
					n->additional_property = AT_CMD_WithPercent;
					$$ = (Node *)n;
				}
			| ADD_P STATISTICS '(' opt_multi_name_list ')'
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddStatistics;
					n->def = (Node *) $4;
					$$ = (Node *)n;
				}
			| DELETE_P STATISTICS '(' opt_multi_name_list ')'
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DeleteStatistics;
					n->def = (Node *) $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] ) */
			| ALTER opt_column DolphinColColId SET reloptions
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetOptions;
					n->name = $3;
					n->def = (Node *) $5;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] ) */
			| ALTER opt_column DolphinColColId RESET reloptions
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ResetOptions;
					n->name = $3;
					n->def = (Node *) $5;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ALTER [COLUMN] <colname> SET STORAGE <storagemode> */
			| ALTER opt_column DolphinColColId SET STORAGE ColId
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetStorage;
					n->name = $3;
					n->def = (Node *) makeString($6);
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DROP [COLUMN] IF EXISTS <colname> [RESTRICT|CASCADE] */
			| DROP opt_column IF_P EXISTS DolphinColColId opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropColumn;
					n->name = $5;
					n->behavior = $6;
					n->missing_ok = TRUE;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DROP [COLUMN] <colname> [RESTRICT|CASCADE] */
			| DROP opt_column DolphinColColId opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropColumn;
					n->name = $3;
					n->behavior = $4;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			/*
			 * ALTER TABLE <name> ALTER [COLUMN] <colname> [SET DATA] TYPE <typename>
			 *		[ USING <expression> ]
			 */
			| ALTER opt_column DolphinColColId opt_set_data TYPE_P Typename opt_collate_clause alter_using
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					ColumnDef *def = makeNode(ColumnDef);
					n->subtype = AT_AlterColumnType;
					n->name = $3;
					n->def = (Node *) def;
					/* We only use these three fields of the ColumnDef node */
					def->typname = $6;
					def->collClause = (CollateClause *) $7;
					def->raw_default = $8;
					def->clientLogicColumnRef=NULL;
					$$ = (Node *)n;
				}
			/* ALTER FOREIGN TABLE <name> ALTER [COLUMN] <colname> OPTIONS */
			| ALTER opt_column DolphinColColId alter_generic_options
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AlterColumnGenericOptions;
					n->name = $3;
					n->def = (Node *) $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ADD CONSTRAINT ... */
			| ADD_P TableConstraint
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddConstraint;
					n->def = $2;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ADD INDEX ... */
			| ADD_P TableIndexClause
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_AddIndex;
				n->def = $2;
				$$ = (Node *)n;
			}
			/* ALTER TABLE <name> VALIDATE CONSTRAINT ... */
			| VALIDATE CONSTRAINT name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ValidateConstraint;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DROP CONSTRAINT IF EXISTS <name> [RESTRICT|CASCADE] */
			| DROP CONSTRAINT IF_P EXISTS name opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropConstraint;
					n->name = $5;
					n->behavior = $6;
					n->missing_ok = TRUE;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DROP CONSTRAINT <name> [RESTRICT|CASCADE] */
			| DROP CONSTRAINT name opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropConstraint;
					n->name = $3;
					n->behavior = $4;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			| DROP PRIMARY KEY opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropConstraint;
					n->name = NULL;
					n->behavior = $4;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			| DROP index_key_opt name opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropIndex;
					n->name = $3;
					n->behavior = $4;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			| DROP FOREIGN KEY name opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropForeignKey;
					n->name = $4;
					n->behavior = $5;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			| RENAME index_key_opt name TO name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_RenameIndex;
					n->name = $3;
					n->def = (Node *)makeString($5);
					$$ = (Node *)n;
				}
			| MODIFY_P modify_column_cmd
				{
					$$ = $2;
				}
			| MODIFY_P COLUMN DolphinColColId Typename opt_charset ColQualList add_column_first_after
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The distributed capability is not supported currently.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("Un-support feature"),
							parser_errposition(@1),
							errdetail("ALTER TABLE MODIFY COLUMN syntax is supported only in B compatibility")));
					}
					ColumnDef *def = makeNode(ColumnDef);
					def->colname = $3;
					def->typname = $4;
					def->typname->charset = $5;
					def->kvtype = ATT_KV_UNDEFINED;
					def->inhcount = 0;
					def->is_local = true;
					def->is_not_null = false;
					def->is_from_type = false;
					def->storage = 0;
					def->cmprs_mode = ATT_CMPR_UNDEFINED;
					def->raw_default = NULL;
					def->update_default = NULL;
					def->cooked_default = NULL;
					def->collOid = InvalidOid;
					def->fdwoptions = NULL;
					SplitColQualList($6, &def->constraints, &def->collClause, &def->clientLogicColumnRef, &def->columnOptions, yyscanner);
					AlterTableCmd *n = (AlterTableCmd *)$7;
					n->subtype = AT_ModifyColumn;
					n->name = $3;
					n->def = (Node *)def;
					$$ = (Node *)n;
				}
			| CHANGE opt_column DolphinColColId DolphinColColId Typename opt_charset ColQualList add_column_first_after
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The distributed capability is not supported currently.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("Un-support feature"),
							parser_errposition(@1),
							errdetail("ALTER TABLE CHANGE syntax is supported only in B compatibility")));
					}
					ColumnDef *def = makeNode(ColumnDef);
					def->colname = $4;
					def->typname = $5;
					def->typname->charset = $6;
					def->columnOptions = $8;
					def->kvtype = ATT_KV_UNDEFINED;
					def->inhcount = 0;
					def->is_local = true;
					def->is_not_null = false;
					def->is_from_type = false;
					def->storage = 0;
					def->cmprs_mode = ATT_CMPR_UNDEFINED;
					def->raw_default = NULL;
					def->update_default = NULL;
					def->cooked_default = NULL;
					def->collOid = InvalidOid;
					def->fdwoptions = NULL;
					SplitColQualList($7, &def->constraints, &def->collClause, &def->clientLogicColumnRef, &def->columnOptions, yyscanner);
					AlterTableCmd *n = (AlterTableCmd *)$8;
					n->subtype = AT_ModifyColumn;
					n->name = $3;
					n->def = (Node *)def;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET WITH OIDS  */
			| SET WITH OIDS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddOids;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET WITHOUT OIDS  */
			| SET WITHOUT OIDS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropOids;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> CLUSTER ON <indexname> */
			| CLUSTER ON name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ClusterOn;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET WITHOUT CLUSTER */
			| SET WITHOUT CLUSTER
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropCluster;
					n->name = NULL;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE TRIGGER <trig> */
			| ENABLE_P TRIGGER name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					if (pg_strncasecmp($3, "user", strlen($3)) == 0) {
						n->subtype = AT_EnableTrigUser;
					} else {
						n->subtype = AT_EnableTrig;
						n->name = $3;
					}
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE ALWAYS TRIGGER <trig> */
			| ENABLE_P ALWAYS TRIGGER name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableAlwaysTrig;
					n->name = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE REPLICA TRIGGER <trig> */
			| ENABLE_P REPLICA TRIGGER name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableReplicaTrig;
					n->name = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE TRIGGER ALL */
			| ENABLE_P TRIGGER ALL
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableTrigAll;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DISABLE TRIGGER <trig> */
			| DISABLE_P TRIGGER name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					if (pg_strncasecmp($3, "user", strlen($3)) == 0) {
						n->subtype = AT_DisableTrigUser;
					} else {
						n->subtype = AT_DisableTrig;
						n->name = $3;
					}
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DISABLE TRIGGER ALL */
			| DISABLE_P TRIGGER ALL
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DisableTrigAll;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE RULE <rule> */
			| ENABLE_P RULE name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableRule;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE ALWAYS RULE <rule> */
			| ENABLE_P ALWAYS RULE name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableAlwaysRule;
					n->name = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE REPLICA RULE <rule> */
			| ENABLE_P REPLICA RULE name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableReplicaRule;
					n->name = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DISABLE RULE <rule> */
			| DISABLE_P RULE name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DisableRule;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> INHERIT <parent> */
			| INHERIT dolphin_qualified_name
				{
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
						const char* message = "inherits is not support in B-format database, it conflicts with multi-relation update";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg(message)));
					}
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddInherit;
					n->def = (Node *) $2;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> NO INHERIT <parent> */
			| NO INHERIT dolphin_qualified_name
				{
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
						const char* message = "inherits is not support in B-format database, it conflicts with multi-relation update";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg(message)));
					}
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropInherit;
					n->def = (Node *) $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> OF <type_name> */
			| OF any_name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					TypeName *def = makeTypeNameFromNameList($2);
					def->location = @2;
					n->subtype = AT_AddOf;
					n->def = (Node *) def;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> NOT OF */
			| NOT OF
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropOf;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> OWNER TO RoleId */
			| OWNER TO UserId
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ChangeOwner;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET TABLESPACE <tablespacename> */
			| SET TABLESPACE name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetTableSpace;
					n->name = $3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET COMPRESS/NOCOMPRESS */
			| SET COMPRESS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SET_COMPRESS;
					n->name = "COMPRESS";
					$$ = (Node *)n;
				}
			| SET NOCOMPRESS
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SET_COMPRESS;
					n->name = "NOCOMPRESS";
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> SET (...) */
			| SET reloptions
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetRelOptions;
					n->def = (Node *)$2;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> RESET (...) */
			| RESET reloptions
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ResetRelOptions;
					n->def = (Node *)$2;
					$$ = (Node *)n;
				}
				/* ALTER TABLE <name> REPLICA IDENTITY  */
				| REPLICA IDENTITY_P replica_identity
				    {
				        AlterTableCmd *n = makeNode(AlterTableCmd);
				        n->subtype = AT_ReplicaIdentity;
				        n->def = $3;
				        $$ = (Node *)n;
				    }
				| alter_generic_options
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_GenericOptions;
					n->def = (Node *)$1;
					$$ = (Node *) n;
				}
/* PGXC_BEGIN */
			/* ALTER TABLE <name> DISTRIBUTE BY ... */
			| OptDistributeByInternal
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DistributeBy;
					n->def = (Node *)$1;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> TO [ NODE (nodelist) | GROUP groupname ] */
			| OptSubClusterInternal
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SubCluster;
					n->def = (Node *)$1;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ADD NODE (nodelist) */
			| ADD_P NODE pgxcnodes
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddNodeList;
					n->def = (Node *)$3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DELETE NODE (nodelist) */
			| DELETE_P NODE pgxcnodes
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DeleteNodeList;
					n->def = (Node *)$3;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> UPDATE SLICE LIKE (reftalbename), only used for redis range/list distribution table */
			| UPDATE SLICE LIKE dolphin_qualified_name
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_UpdateSliceLike;
					n->exchange_with_rel = $4;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENABLE ROW LEVEL SECURITY */
			| ENABLE_P ROW LEVEL SECURITY
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EnableRls;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> DISABLE ROW LEVEL SECURITY */
			| DISABLE_P ROW LEVEL SECURITY
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DisableRls;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> FORCE ROW LEVEL SECURITY */
			| FORCE ROW LEVEL SECURITY
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ForceRls;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> NO FORCE ROW LEVEL SECURITY */
			| NO FORCE ROW LEVEL SECURITY
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_NoForceRls;
					$$ = (Node *)n;
				}
			/* ALTER TABLE <name> ENCRYPTION KEY ROTATION */
			| ENCRYPTION KEY ROTATION
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_EncryptionKeyRotation;
					$$ = (Node *)n;
				}
			| CharsetCollate
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetCharsetCollate;
					n->def = (Node *)$1;
					$$ = (Node*)n;					
				}
			| CONVERT TO convert_charset opt_collate
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ConvertCharset;
					CharsetCollateOptions *cc = makeNode(CharsetCollateOptions);
					cc->cctype = OPT_CHARSETCOLLATE;
					cc->charset = $3;
					cc->collate = $4;
					n->def = (Node *)cc;
					$$ = (Node*)n;
				}
/* PGXC_END */
		;

alter_table_option_list:
			alter_table_option
				{
					$$ = list_make1($1);
				}
			| alter_table_option_list alter_table_option
				{
					$$ = lappend($1, $2);
				}
		;

alter_table_option:
			row_format_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SetTableRowFormat;
					$$ = (Node *) n;
				}
			| autoextend_size_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AUTOEXTEND_SIZE;
					$$ = (Node *) n;
				}
			| avg_row_length_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AVG_ROW_LENGTH;
					$$ = (Node *) n;
				}
			| checksum_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_CHECKSUM;
					$$ = (Node *) n;
				}
			| CONNECTION opt_equal SCONST
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_CONNECTION;
					$$ = (Node *) n;
				}
			| directory_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DIRECTORY;
					$$ = (Node *) n;
				}
			| delay_key_write_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DELAY_KEY_WRITE;
					$$ = (Node *) n;
				}
			| ENCRYPTION opt_equal SCONST
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ENCRYPTION;
					$$ = (Node *) n;
				}
			| ENGINE_ATTRIBUTE opt_equal SCONST
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_ENGINE_ATTRIBUTE;
					$$ = (Node *) n;
				}
			| insert_method_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_INSERT_METHOD;
					$$ = (Node *) n;
				}
			| key_block_size_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_KEY_BLOCK_SIZE;
					$$ = (Node *) n;
				}
			| max_rows_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_MAX_ROWS;
					$$ = (Node *) n;
				}
			| min_rows_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_MIN_ROWS;
					$$ = (Node *) n;
				}
			| pack_keys_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_PACK_KEYS;
					$$ = (Node *) n;
				}
			| PASSWORD opt_equal SCONST
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_PASSWORD;
					$$ = (Node *) n;
				}
			| START TRANSACTION
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_START_TRANSACTION;
					$$ = (Node *) n;
				}
			| SECONDARY_ENGINE_ATTRIBUTE opt_equal SCONST
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_SECONDARY_ENGINE_ATTRIBUTE;
					$$ = (Node *) n;
				}
			| stats_auto_recalc_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_STATS_AUTO_RECALC;
					$$ = (Node *) n;
				}
			| stats_persistent_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_STATS_PERSISTENT;
					$$ = (Node *) n;
				}
			| stats_sample_pages_option
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_STATS_SAMPLE_PAGES;
					$$ = (Node *) n;
				}
			| UNION opt_equal '(' dolphin_qualified_name_list ')'
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_UNION;
					$$ = (Node *) n;
				}
			| OptTableSpace_without_empty
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_TABLESPACE;
					n->name = $1;
					$$ = (Node *) n;
				}
			| tablespace_storage_option_without_empty
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_TABLESPACE_STORAGE;
					$$ = (Node *) n;
				}
            | AutoIncrementValue
                {
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "auto_increment is not yet supported";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
                        (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                            errmsg("auto_increment is not yet supported")));
#endif
                    if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
                        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                        errmsg("auto_increment is supported only in B-format database")));
                    }
                    AlterTableCmd *n = makeNode(AlterTableCmd);
                    n->subtype = AT_SetAutoIncrement;
                    n->def = $1;
					$$ = (Node *)n;
                }
/* table comments start */
            | COMMENT opt_equal SCONST
            	{
                    BCompatibilityOptionSupportCheck($1);
                    AlterTableCmd *n = makeNode(AlterTableCmd);
                    n->subtype = AT_COMMENTS;
                    n->name = $3;
                    $$ = (Node *)n;
            	}
/* table comments end */
		;

index_key_opt:
			INDEX
			| KEY
		;

alter_column_default:
			SET DEFAULT a_expr			{ $$ = $3; }
			| DROP DEFAULT				{ $$ = NULL; }
		;

opt_drop_behavior:
			CASCADE						{ $$ = DROP_CASCADE; }
			| RESTRICT					{ $$ = DROP_RESTRICT; }
			| CASCADE CONSTRAINTS				{ $$ = DROP_CASCADE; }
			| /* EMPTY */				{ $$ = DROP_RESTRICT; /* default */ }
		;

opt_collate_clause:
			COLLATE collate_name
				{
					CollateClause *n = makeNode(CollateClause);
					n->arg = NULL;
					n->collname = $2;
					n->location = @1;
					$$ = (Node *) n;
				}
			| /* EMPTY */				{ $$ = NULL; }
		;

alter_using:
			USING a_expr				{ $$ = $2; }
			| /* EMPTY */				{ $$ = NULL; }
		;

reloptions:
			'(' reloption_list ')'					{ $$ = $2; }
		;

replica_identity:
           NOTHING
               {
                   ReplicaIdentityStmt *n = makeNode(ReplicaIdentityStmt);
                   n->identity_type = REPLICA_IDENTITY_NOTHING;
                   n->name = NULL;
                   $$ = (Node *) n;
               }
           | FULL
               {
                   ReplicaIdentityStmt *n = makeNode(ReplicaIdentityStmt);
                   n->identity_type = REPLICA_IDENTITY_FULL;
                   n->name = NULL;
                   $$ = (Node *) n;
               }
           | DEFAULT
               {
                   ReplicaIdentityStmt *n = makeNode(ReplicaIdentityStmt);
                   n->identity_type = REPLICA_IDENTITY_DEFAULT;
                   n->name = NULL;
                   $$ = (Node *) n;
               }
           | USING INDEX name
               {
                   ReplicaIdentityStmt *n = makeNode(ReplicaIdentityStmt);
                   n->identity_type = REPLICA_IDENTITY_INDEX;
                   n->name = $3;
                   $$ = (Node *) n;
               }
       ;

opt_reloptions:		WITH reloptions					{ $$ = $2; }
			 |		/* EMPTY */						{ $$ = NIL; }
		;

opt_reloptions_without_empty:		WITH reloptions					{ $$ = $2; }
		;

opt_index_options:
			 /* EMPTY */						{ $$ = NIL; }
			 | index_options  { $$ = $1; }
			 ;
index_options:
			 index_option
			 {
					$$ = list_make1($1);
			 }
			 | index_options index_option
			 {
					$$ = lcons($2, $1);
			 }
			 ;
index_option:
			 COMMENT opt_equal SCONST
			 {
					BCompatibilityOptionSupportCheck($1);
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_INDEX;
					n->objname = NIL;
					n->objargs = NIL;
					n->comment = $3;
					$$ = (Node*)n;
			 }
			 ;

opt_table_index_options:
			 /* EMPTY */		{ $$ = NIL; }
			 | table_index_options	{ $$ = $1; }
			 ;
table_index_options:
			 table_index_option
			 {
					$$ = list_make1($1);
			 }
			 | table_index_options table_index_option
			 {
					$$ = lcons($2, $1);
			 }
			 ;
table_index_option:
			 COMMENT opt_equal SCONST
			 {
					BCompatibilityOptionSupportCheck($1);
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_INDEX;
					n->objname = NIL;
					n->objargs = NIL;
					n->comment = $3;
					$$ = (Node*)n;
			 }
			 | USING DOLPHINIDENT
			 {
					BCompatibilityOptionSupportCheck($1);
					$$ = makeStringConst(downcase_str($2->str, $2->is_quoted), -1);
			 }
			 | INVISIBLE
			 {
					BCompatibilityOptionSupportCheck($1);
					Value *n = makeString("invisible");
					$$ = (Node*)n;
			 }
			 | VISIBLE
			 {
					BCompatibilityOptionSupportCheck($1);
					Value *n = makeString("visible");
					$$ = (Node*)n;
			 }
			 | WITH_PARSER NGRAM
			 {
					BCompatibilityOptionSupportCheck($2);
					Value *n = makeString("ngram");
					$$ = (Node*)n;
			 }
		;

opt_table_options:
			 /* EMPTY */						{ $$ = NIL; }
			 | table_options  { $$ = $1; }
			 ;
table_options:
			 table_option
			 {
					$$ = list_make1($1);
			 }
			 | table_options opt_comma table_option
			 {
					$$ = lcons($3, $1);
			 }
			 ;

table_option:
			 COMMENT opt_equal SCONST
			 {
				BCompatibilityOptionSupportCheck($1);
				CommentStmt *n = makeNode(CommentStmt);
				n->objtype = OBJECT_TABLE;
				n->objname = NIL;
				n->objargs = NIL;
				n->comment = $3;
				$$ = (Node*)n;
			 }
			| set_compress_type
			 {
				BCompatibilityOptionSupportCheck("compression");
				$$ = $1;
			 }
			| engine_option
			 {
				BCompatibilityOptionSupportCheck("engine");
				$$ = $1;
			 }
			| row_format_option
			 {
				BCompatibilityOptionSupportCheck("row_format");
				$$ = $1;
			 }
			| default_charset
			 {
				BCompatibilityOptionSupportCheck("charset");
				$$ = NULL;
			 }
			| default_collate
			 {
				BCompatibilityOptionSupportCheck("collate");
				$$ = NULL;
			 }
			 ;

opt_comma:
          /* empty */
        | ','
        ;

opt_column_options:
			 /* EMPTY */						{ $$ = NIL; }
			 | column_options  { $$ = $1; }
			 ;
column_options:
			 column_option
			 {
					$$ = list_make1($1);
			 }
			 | column_options column_option
			 {
					$$ = lcons($2, $1);
			 }
			 ;
column_option:
			 COMMENT SCONST
			 {
					BCompatibilityOptionSupportCheck($1);
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_COLUMN;
					n->objname = NIL;
					n->objargs = NIL;
					n->comment = $2;
					$$ = (Node*)n;
			 }
			 ;

opt_part_options:
			 OptTableSpace part_options  { $$ = $1; }
			 | OptTableSpace               { $$ = $1; }
			 ;
/* set null return for grammer comparitibility */
part_options:
			 part_option
			 {
					$$ = NULL;
			 }
			 | part_options part_option
			 {
					$$ = NULL;
			 }
			 ;
part_option:
			 COMMENT opt_equal SCONST
			 {
					BCompatibilityOptionSupportCheck($1);
					u_sess->parser_cxt.hasPartitionComment = true;
					$$ = (Node*)NULL;
			 }
			 ;

reloption_list:
			reloption_elem							{ $$ = list_make1($1); }
			| reloption_list ',' reloption_elem		{ $$ = lappend($1, $3); }
		;

/* This should match def_elem and also allow qualified names */
reloption_elem:
			ColLabel '=' def_arg
				{
					$$ = makeDefElem($1, (Node *) $3);
				}
			| ColLabel '=' ROW
				{
					$$ = makeDefElem($1, (Node *) makeString(downcase_str(pstrdup($3), false)));
				}
			| ColLabel
				{
					$$ = makeDefElem($1, NULL);
				}
			| ColLabel '.' ColLabel '=' def_arg
				{
					$$ = makeDefElemExtended($1, $3, (Node *) $5,
											 DEFELEM_UNSPEC);
				}
			| ColLabel '.' ColLabel
				{
					$$ = makeDefElemExtended($1, $3, NULL, DEFELEM_UNSPEC);
				}
		;

split_dest_partition_define_list:
	PARTITION name OptTableSpace ',' PARTITION name OptTableSpace
		{
			List	*result = NULL;
			RangePartitionDefState *p1 = makeNode(RangePartitionDefState);
			RangePartitionDefState *p2 = makeNode(RangePartitionDefState);

			p1->partitionName = $2;
			p1->tablespacename = $3;
			p1->boundary = NULL;

			p2->partitionName = $6;
			p2->tablespacename = $7;
			p2->boundary = NULL;

			result = lappend(result, p1);
			result = lappend(result, p2);

			$$ = result;
		}
	;

split_dest_listsubpartition_define_list:
	SUBPARTITION name OptTableSpace ',' SUBPARTITION name OptTableSpace
		{
			List	*result = NULL;
			ListPartitionDefState *p1 = makeNode(ListPartitionDefState);
			ListPartitionDefState *p2 = makeNode(ListPartitionDefState);

			p1->partitionName = $2;
			p1->tablespacename = $3;
			p1->boundary = NULL;

			p2->partitionName = $6;
			p2->tablespacename = $7;
			p2->boundary = NULL;

			result = lappend(result, p1);
			result = lappend(result, p2);

			$$ = result;
		}
	;

split_dest_rangesubpartition_define_list:
	SUBPARTITION name OptTableSpace ',' SUBPARTITION name OptTableSpace
		{
			List	*result = NULL;
			RangePartitionDefState *p1 = makeNode(RangePartitionDefState);
			RangePartitionDefState *p2 = makeNode(RangePartitionDefState);

			p1->partitionName = $2;
			p1->tablespacename = $3;
			p1->boundary = NULL;

			p2->partitionName = $6;
			p2->tablespacename = $7;
			p2->boundary = NULL;

			result = lappend(result, p1);
			result = lappend(result, p2);

			$$ = result;
		}
	;

/*support b_database syntax related with partition*/
AlterPartitionRebuildStmt:
			ALTER TABLE dolphin_qualified_name REBUILD_PARTITION partition_name_list
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = list_make1(makeString("rebuild_partition"));
					n->args = list_make1(makeAArrayExpr(lcons(makeStringConst($3->relname, @3), $5), @5));
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->location = @4;
					n->call_func = false;
					ResTarget* rtg = makeNode(ResTarget);
					rtg->name = NULL;
					rtg->indirection = NIL;
					rtg->val = (Node *)n;
					rtg->location = @3;
					SelectStmt *sel = makeNode(SelectStmt);
					sel->targetList = list_make1(rtg);
					$$ = (Node *)sel;
				}
			| ALTER TABLE dolphin_qualified_name REBUILD_PARTITION ALL
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = list_make1(makeString("rebuild_partition"));
					n->args = list_make1(makeAArrayExpr(list_make1(makeStringConst($3->relname, @3)), @3));
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->location = @4;
					n->call_func = false;
					ResTarget* rtg = makeNode(ResTarget);
					rtg->name = NULL;
					rtg->indirection = NIL;
					rtg->val = (Node *)n;
					rtg->location = @3;
					SelectStmt *sel = makeNode(SelectStmt);
					sel->targetList = list_make1(rtg);
					$$ = (Node *)sel;
				}
		;

AlterPartitionRemoveStmt:
			ALTER TABLE dolphin_qualified_name REMOVE PARTITIONING
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = list_make1(makeString("remove_partitioning"));
					n->args = list_make1(makeStringConst($3->relname, @3));
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->location = @4;
					n->call_func = false;
					ResTarget* rtg = makeNode(ResTarget);
					rtg->name = NULL;
					rtg->indirection = NIL;
					rtg->val = (Node *)n;
					rtg->location = @3;
					SelectStmt *sel = makeNode(SelectStmt);
					sel->targetList = list_make1(rtg);
					$$ = (Node *)sel;
				}
		;

partition_name_list_all:
			partition_name_list
			{
				$$ = $1;
			}
			| ALL
			{
				$$ = NULL;
			}

AlterPartitionCheckStmt:
			ALTER TABLE dolphin_qualified_name CHECK PARTITION partition_name_list_all
			{
				AlterTableStmt *n = makeNode(AlterTableStmt);
				AlterTableCmd *cmd = makeNode(AlterTableCmd);
				cmd->subtype = AT_CheckPartition;
				n->relation = $3;
				n->relkind = OBJECT_PARTITION;
				n->cmds = list_make1(cmd);
				$$ = (Node *) n;
			}
		;

AlterPartitionRepairStmt:
			ALTER TABLE dolphin_qualified_name REPAIR PARTITION partition_name_list_all
			{
				AlterTableStmt *n = makeNode(AlterTableStmt);
				AlterTableCmd *cmd = makeNode(AlterTableCmd);
				cmd->subtype = AT_RepairPartition;
				n->relation = $3;
				n->relkind = OBJECT_PARTITION;
				n->cmds = list_make1(cmd);
				$$ = (Node *) n;
			}
		;

AlterPartitionOptimizeStmt:
			ALTER TABLE dolphin_qualified_name OPTIMIZE PARTITION partition_name_list_all
			{
				AlterTableStmt *n = makeNode(AlterTableStmt);
				AlterTableCmd *cmd = makeNode(AlterTableCmd);
				cmd->subtype = AT_OptimizePartition;
				n->relation = $3;
				n->relkind = OBJECT_PARTITION;
				n->cmds = list_make1(cmd);
				$$ = (Node *) n;
			}
		;

AnalyzePartitionStmt:
		ALTER TABLE dolphin_qualified_name analyze_keyword opt_verbose opt_name_list PARTITION partition_name_list
			{
				List* arglist = NIL;
				arglist = lcons(makeStringConst($3->relname, @3), $8);
				FuncCall *n = makeNode(FuncCall);
				n->funcname = list_make1(makeString("analyze_partition"));
				n->args = list_make1(makeAArrayExpr(arglist, @8));
				n->args = lappend(n->args, makeStringConst($3->catalogname, -1));
				n->args = lappend(n->args, makeStringConst($3->schemaname, -1));
				n->agg_star = FALSE;
				n->agg_distinct = FALSE;
				n->func_variadic = FALSE;
				n->location = @4;
				n->call_func = false;
				ResTarget* rtg = makeNode(ResTarget);
				rtg->name = NULL;
				rtg->indirection = NIL;
				rtg->val = (Node *)n;
				rtg->location = @3;
				SelectStmt *sel = makeNode(SelectStmt);
				sel->targetList = list_make1(rtg);
				$$ = (Node *)sel;
			}
		| ALTER TABLE dolphin_qualified_name analyze_keyword opt_verbose opt_name_list PARTITION ALL
			{
				VacuumStmt *n = makeNode(VacuumStmt);
				n->options = VACOPT_ANALYZE;
				if ($5)
					n->options |= VACOPT_VERBOSE;
				n->freeze_min_age = -1;
				n->freeze_table_age = -1;
				n->relation = $3;
				n->va_cols = $6;
				$$ = (Node *)n;
			}

alter_partition_cmds_for_bdatabase:
		TRUNCATE PARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				n->name = $3;
				$$ = list_make1((Node *)n);
			}
		| TRUNCATE PARTITION ColId OptGPI ',' truncate_partition_cmds_for_bdatabase
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				n->name = $3;
				$$ = lappend($6, (Node *)n);
			}
		| TRUNCATE PARTITION ColId OptGPI ',' truncate_partition_cmds
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				n->name = $3;
				$$ = lappend($6, (Node *)n);
			}
		| TRUNCATE PARTITION ALL
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->name = "all";
				$$ = list_make1((Node *)n);
			}
		| DROP_PARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropPartition;
				$$ = list_make1((Node *)n);
			}
		| DROP_PARTITION ColId OptGPI ',' drop_partition_cmds_for_bdatabase
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropPartition;
				$$ = lappend($5, (Node *)n);
			}
		| DROP_PARTITION ColId OptGPI ',' drop_partition_cmds
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropPartition;
				$$ = lappend($5, (Node *)n);
			}
		;

truncate_partition_cmds:
		truncate_partition_cmd
			{
				$$ = list_make1($1);
			}
		| truncate_partition_cmds ',' truncate_partition_cmd
			{
				$$ = lappend($1, $3);
			}
		;

truncate_partition_cmd:
		TRUNCATE PARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->alterGPI = $4;
				$$ = (Node *)n;

				n->name = $3;
			}
		;

truncate_partition_cmds_for_bdatabase:
		truncate_partition_cmd_for_bdatabase
			{
				$$ = list_make1($1);
			}
		| truncate_partition_cmds_for_bdatabase ',' truncate_partition_cmd_for_bdatabase
			{
				$$ = lappend($1, $3);
			}
		;

truncate_partition_cmd_for_bdatabase:
		ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_TruncatePartition;
				n->missing_ok = FALSE;
				n->alterGPI = $2;
				$$ = (Node *)n;

				n->name = $1;
			}
		;

exchange_partition_cmd_for_bdatabase:
		EXCHANGE PARTITION ColId
			WITH TABLE relation_expr opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_ExchangePartition;
				n->name = $3;
				n->exchange_with_rel = $6;
				n->check_validation = TRUE;
				n->exchange_verbose = $7;
				n->missing_ok = FALSE;
				n->alterGPI = $8;
				$$ = (Node *)n;
			}
		| EXCHANGE PARTITION ColId
			WITH TABLE relation_expr WITH VALIDATION opt_verbose OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_ExchangePartition;
				n->name = $3;
				n->exchange_with_rel = $6;
				n->check_validation = TRUE;
				n->exchange_verbose = $9;
				n->missing_ok = FALSE;
				n->alterGPI = $10;
				$$ = (Node *)n;
			}
		| EXCHANGE PARTITION ColId
			WITH TABLE relation_expr WITHOUT VALIDATION OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->subtype = AT_ExchangePartition;
				n->name = $3;
				n->exchange_with_rel = $6;
				n->check_validation = FALSE;
				n->missing_ok = FALSE;
				n->alterGPI = $9;
				$$ = (Node *)n;
			}

partition_name_list:
			name
				{
					$$ = list_make1(makeStringConst($1, @1));
				}
			| partition_name_list ',' name
				{
					$$ = lappend($1, makeStringConst($3, @3));
				}
		;

drop_partition_cmds:
 			drop_partition_cmd
 				{
 					$$ = list_make1($1);
 				}
 			| drop_partition_cmds ',' drop_partition_cmd
 				{
 					$$ = lappend($1, $3);
 				}
 			;

drop_partition_cmd:
		DROP_PARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropPartition;
				$$ = (Node *)n;
			}
		;

drop_partition_cmds_for_bdatabase:
		drop_partition_cmd_for_bdatabase
			{
				$$ = list_make1($1);
			}
		| drop_partition_cmds_for_bdatabase ',' drop_partition_cmd_for_bdatabase
			{
				$$ = lappend($1, $3);
			}
		;

drop_partition_cmd_for_bdatabase:
		ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $1;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $2;
				n->subtype = AT_DropPartition;
				$$ = (Node *)n;
			}
		;

alter_subpartition_cmds_for_bdatabase:
		DROP_SUBPARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropSubPartition;
				$$ = list_make1((Node *)n);
			}
		| DROP_SUBPARTITION ColId OptGPI ',' drop_subpartition_cmds_for_bdatabase
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropSubPartition;
				$$ = lappend($5, (Node *)n);
			}
		| DROP_SUBPARTITION ColId OptGPI ',' drop_subpartition_cmds
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropSubPartition;
				$$ = lappend($5, (Node *)n);
			}
		;

drop_subpartition_cmds:
		drop_subpartition_cmd
			{
				$$ = list_make1($1);
			}
		| drop_subpartition_cmds ',' drop_subpartition_cmd
			{
				$$ = lappend($1, $3);
			}
		;

drop_subpartition_cmd:
		DROP_SUBPARTITION ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $2;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $3;
				n->subtype = AT_DropSubPartition;
				$$ = (Node *)n;
			}
		;

drop_subpartition_cmds_for_bdatabase:
		drop_subpartition_cmd_for_bdatabase
			{
				$$ = list_make1($1);
			}
		| drop_subpartition_cmds_for_bdatabase ',' drop_subpartition_cmd_for_bdatabase
			{
				$$ = lappend($1, $3);
			}
		;

drop_subpartition_cmd_for_bdatabase:
		ColId OptGPI
			{
				AlterTableCmd *n = makeNode(AlterTableCmd);
				n->name = $1;
				n->behavior = DROP_CASCADE;
				n->missing_ok = FALSE;
				n->alterGPI = $2;
				n->subtype = AT_DropSubPartition;
				$$ = (Node *)n;
			}
		;

add_partition_cmds_for_bdatabase:
 			PARTITION add_partition_cmd
 				{
 					$$ = list_make1($2);
 				}
 			| add_partition_cmds_for_bdatabase ',' PARTITION add_partition_cmd
 				{
 					$$ = lappend($1, $4);
 				}
 			;

add_partition_cmd:
		name VALUES LESS THAN maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->boundary = $5;
				p->tablespacename = $6;
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		/* ALTER TABLE ADD PARTITION: use START/END */
		| name START maxValueList_with_opt_parens  END_P maxValueList_with_opt_parens opt_range_every_list opt_part_options
			{
				RangePartitionStartEndDefState *p = makeNode(RangePartitionStartEndDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->startValue = $3;
				p->endValue = $5;
				p->everyValue = $6;
				p->tableSpaceName = $7;
				s->partitionList = list_make1(p);
				s->isStartEnd = true;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name END_P maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionStartEndDefState *p = makeNode(RangePartitionStartEndDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->startValue = NIL;
				p->endValue = $3;
				p->everyValue = NIL;
				p->tableSpaceName = $4;
				s->partitionList = list_make1(p);
				s->isStartEnd = true;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name START maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionStartEndDefState *p = makeNode(RangePartitionStartEndDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->startValue = $3;
				p->endValue = NIL;
				p->everyValue = NIL;
				p->tableSpaceName = $4;
				s->partitionList = list_make1(p);
				s->isStartEnd = true;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name VALUES '(' expr_list ')' opt_part_options
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->boundary = $4;
				p->tablespacename = $6;
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name VALUES '(' DEFAULT ')' opt_part_options
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				Const *n_default = makeNode(Const);
				n_default->ismaxvalue = true;
				n_default->location = -1;
				p->boundary = list_make1(n_default);
				p->tablespacename = $6;
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name VALUES LESS THAN
		maxValueList_with_opt_parens opt_part_options '(' subpartition_definition_list ')'
			{
				RangePartitionDefState *p = makeNode(RangePartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->boundary = $5;
				p->tablespacename = $6;
				p->subPartitionDefState = $8;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = p->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name VALUES '(' expr_list ')' opt_part_options '(' subpartition_definition_list ')'
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				p->boundary = $4;
				p->tablespacename = $6;
				p->subPartitionDefState = $8;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = p->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		| name VALUES '(' DEFAULT ')' opt_part_options '(' subpartition_definition_list ')'
			{
				ListPartitionDefState *p = makeNode(ListPartitionDefState);
				AlterTableCmd *n = makeNode(AlterTableCmd);
				AddPartitionState *s = makeNode(AddPartitionState);
				p->partitionName = $1;
				Const *n_default = makeNode(Const);
				n_default->ismaxvalue = true;
				n_default->location = -1;
				p->boundary = list_make1(n_default);
				p->tablespacename = $6;
				p->subPartitionDefState = $8;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = p->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				s->partitionList = list_make1(p);
				s->isStartEnd = false;
				n->subtype = AT_AddPartition;
				n->def = (Node*)s;
				$$ = (Node *)n;
			}
		;
/*support b_database syntax related with partition*/

/*****************************************************************************
 *
 *	ALTER TYPE
 *
 * really variants of the ALTER TABLE subcommands with different spellings
 *****************************************************************************/

AlterCompositeTypeStmt:
			ALTER TYPE_P any_name alter_type_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);

					/* can't use qualified_name, sigh */
					n->relation = makeRangeVarFromAnyName($3, @3, yyscanner);
					n->cmds = $4;
					n->relkind = OBJECT_TYPE;
					$$ = (Node *)n;
				}
			;

alter_type_cmds:
			alter_type_cmd							{ $$ = list_make1($1); }
			| alter_type_cmds ',' alter_type_cmd	{ $$ = lappend($1, $3); }
		;

alter_type_cmd:
			/* ALTER TYPE <name> ADD ATTRIBUTE <coldef> [RESTRICT|CASCADE] */
			ADD_P ATTRIBUTE TableFuncElement opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_AddColumn;
					n->def = $3;
					n->behavior = $4;
					$$ = (Node *)n;
				}
			/* ALTER TYPE <name> DROP ATTRIBUTE IF EXISTS <attname> [RESTRICT|CASCADE] */
			| DROP ATTRIBUTE IF_P EXISTS ColId opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropColumn;
					n->name = $5;
					n->behavior = $6;
					n->missing_ok = TRUE;
					$$ = (Node *)n;
				}
			/* ALTER TYPE <name> DROP ATTRIBUTE <attname> [RESTRICT|CASCADE] */
			| DROP ATTRIBUTE ColId opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->subtype = AT_DropColumn;
					n->name = $3;
					n->behavior = $4;
					n->missing_ok = FALSE;
					$$ = (Node *)n;
				}
			/* ALTER TYPE <name> ALTER ATTRIBUTE <attname> [SET DATA] TYPE <typename> [RESTRICT|CASCADE] */
			| ALTER ATTRIBUTE ColId opt_set_data TYPE_P Typename opt_collate_clause opt_drop_behavior
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					ColumnDef *def = makeNode(ColumnDef);
					n->subtype = AT_AlterColumnType;
					n->name = $3;
					n->def = (Node *) def;
					n->behavior = $8;
					/* We only use these three fields of the ColumnDef node */
					def->typname = $6;
					def->clientLogicColumnRef=NULL;
					def->collClause = (CollateClause *) $7;
					def->raw_default = NULL;
					def->update_default = NULL;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 *		QUERY :
 *				close <portalname>
 *
 *****************************************************************************/

ClosePortalStmt:
			CLOSE cursor_name
				{
					ClosePortalStmt *n = makeNode(ClosePortalStmt);
					n->portalname = $2;
					$$ = (Node *)n;
				}
			| CLOSE ALL
				{
					ClosePortalStmt *n = makeNode(ClosePortalStmt);
					n->portalname = NULL;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 *		QUERY :
 *				COPY relname [(columnList)] FROM/TO file [WITH] [(options)]
 *				COPY ( SELECT ... ) TO file [WITH] [(options)]
 *
 *				In the preferred syntax the options are comma-separated
 *				and use generic identifiers instead of keywords.  The pre-9.0
 *				syntax had a hard-wired, space-separated set of options.
 *
 *				Really old syntax, from versions 7.2 and prior:
 *				COPY [ BINARY ] table [ WITH OIDS ] FROM/TO file
 *					[ [ USING ] DELIMITERS 'delimiter' ] ]
 *					[ WITH NULL AS 'null string' ]
 *				This option placement is not supported with COPY (SELECT...).
 *
 *****************************************************************************/

CopyStmt:	COPY BINARY dolphin_qualified_name opt_column_list opt_oids
			copy_from copy_file_name opt_load opt_useeof copy_delimiter opt_noescaping OptCopyLogError OptCopyRejectLimit opt_with copy_options 
			opt_processed
				{
					CopyStmt *n = makeNode(CopyStmt);
					n->relation = $3;
					n->query = NULL;
					n->attlist = u_sess->parser_cxt.col_list;
					n->is_from = $6;
					n->filename = $7;
					if ($4)
						n->relation->length = @4;
					else if ($5)
						n->relation->length = @5;
					else
						n->relation->length = @6;
					n->options = NIL;
					/* Concatenate user-supplied flags */
					n->options = lappend(n->options, (Node*)makeDefElem("format", (Node *)makeString("binary")));
					if ($5)
						n->options = lappend(n->options, $5);

					if ($8)
						n->options = lappend(n->options, $8);

					if ($9)
						n->options = lappend(n->options, $9);
					if ($10)
						n->options = lappend(n->options, $10);
					if ($11)
						n->options = lappend(n->options, $11);
					if ($12)
						n->options = lappend(n->options, $12);
					if ($13)
						n->options = lappend(n->options, $13);
					if ($15)
						n->options = list_concat(n->options, $15);
					$$ = (Node *)n;

					u_sess->parser_cxt.is_load_copy = false;
					u_sess->parser_cxt.col_list = NULL;
				}
			| COPY dolphin_qualified_name opt_column_list opt_oids
			copy_from copy_file_name opt_load opt_useeof copy_delimiter opt_noescaping OptCopyLogError OptCopyRejectLimit opt_with copy_options 
			opt_processed
				{
					CopyStmt *n = makeNode(CopyStmt);
					n->relation = $2;
					n->query = NULL;
					n->attlist = u_sess->parser_cxt.col_list;
					n->is_from = $5;
					n->filename = $6;
					if ($3)
						n->relation->length = @3;
					else if ($4)
						n->relation->length = @4;
					else
						n->relation->length = @5;
					n->options = NIL;
					/* Concatenate user-supplied flags */
					if ($4)
						n->options = lappend(n->options, $4);

					if ($7)
						n->options = lappend(n->options, $7);

					if ($8)
						n->options = lappend(n->options, $8);
					if ($9)
						n->options = lappend(n->options, $9);
					if ($10)
						n->options = lappend(n->options, $10);
					if ($11)
						n->options = lappend(n->options, $11);
					if ($12)
						n->options = lappend(n->options, $12);
					if ($14)
						n->options = list_concat(n->options, $14);		
					$$ = (Node *)n;

					u_sess->parser_cxt.is_load_copy = false;
					u_sess->parser_cxt.col_list = NULL;
				}
			| COPY select_with_parens TO copy_file_name opt_noescaping opt_with copy_options opt_processed
				{
					CopyStmt *n = makeNode(CopyStmt);
					n->relation = NULL;
					n->query = $2;
					n->attlist = NIL;
					n->is_from = false;
					n->filename = $4;
					n->options = $7;
					if ($5)
						n->options = lappend(n->options, $5);
					$$ = (Node *)n;
				}
		;

opt_processed:
                ENCRYPTED {$$=TRUE;}
				|  /*EMPTY*/						{ $$ = FALSE; }
		;

opt_load:
                LOAD								
				{
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "COPY ... LOAD FROM is not supported";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("COPY ... LOAD FROM is not supported")));
#endif
					u_sess->parser_cxt.is_load_copy = true; 
					$$ = makeDefElem("loader", (Node *)makeInteger(TRUE)); 
				}
				|  /*EMPTY*/						{ $$ = NULL; }
		;

opt_useeof:
                USEEOF
                                {
                                        $$ = makeDefElem("useeof", (Node *)makeInteger(TRUE));
                                }
                                |  /*EMPTY*/                                            { $$ = NULL; }
		;

copy_from:
			FROM 									{ $$ = TRUE; }
			| TO									{ $$ = FALSE; }
		;

/*
 * copy_file_name NULL indicates stdio is used. Whether stdin or stdout is
 * used depends on the direction. (It really doesn't make sense to copy from
 * stdout. We silently correct the "typo".)		 - AY 9/94
 */
copy_file_name:
			SCONST									{ $$ = $1; }
			| STDIN									{ $$ = NULL; }
			| STDOUT								{ $$ = NULL; }
			| REDISANYVALUE                              { $$ = NULL; }
		;

copy_options: copy_opt_list							{ $$ = $1; }
			| '(' copy_generic_opt_list ')'			{ $$ = $2; }
		;

/* old COPY option syntax */
copy_opt_list:
			copy_opt_list copy_opt_item				{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

copy_opt_item:
			BINARY
				{
					$$ = makeDefElem("format", (Node *)makeString("binary"));
				}
			| OIDS
				{
					$$ = makeDefElem("oids", (Node *)makeInteger(TRUE));
				}
			| FREEZE
				{
					$$ = makeDefElem("freeze", (Node *)makeInteger(TRUE));
				}
			| DELIMITER opt_as SCONST
				{
					$$ = makeDefElem("delimiter", (Node *)makeString($3));
				}
			| NULL_P opt_as SCONST
				{
					$$ = makeDefElem("null", (Node *)makeString($3));
				}
			| CSV
				{
					$$ = makeDefElem("format", (Node *)makeString("csv"));
				}
			| FIXED_P
				{
					$$ = makeDefElem("format", (Node *)makeString("fixed"));
				}
			| HEADER_P
				{
					$$ = makeDefElem("header", (Node *)makeInteger(TRUE));
				}
			| QUOTE opt_as SCONST
				{
					$$ = makeDefElem("quote", (Node *)makeString($3));
				}
			| ESCAPE opt_as SCONST
				{
					$$ = makeDefElem("escape", (Node *)makeString($3));
				}
			| FORCE QUOTE columnList
				{
					$$ = makeDefElem("force_quote", (Node *)$3);
				}
			| FORCE QUOTE '*'
				{
					$$ = makeDefElem("force_quote", (Node *)makeNode(A_Star));
				}
			| FORCE NOT NULL_P columnList
				{
					$$ = makeDefElem("force_not_null", (Node *)$4);
				}
			| ENCODING SCONST
				{
					$$ = makeDefElem("encoding", (Node *)makeString($2));
				}
			| EOL SCONST
				{
					$$ = makeDefElem("eol", (Node*)makeString($2));
				}
			| FILEHEADER_P SCONST
				{
					$$ = makeDefElem("fileheader", (Node*)makeString($2));
				}
			| FORMATTER '(' copy_foramtter_opt ')'
				{
					$$ = makeDefElem("formatter", (Node*)$3);
				}
			| IGNORE_EXTRA_DATA
				{
					$$ = makeDefElem("ignore_extra_data", (Node *)makeInteger(TRUE));
				}
			| DATE_FORMAT_P SCONST
				{
					$$ = makeDefElem("date_format", (Node *)makeString($2));
				}
			| TIME_FORMAT_P SCONST
				{
					$$ = makeDefElem("time_format", (Node *)makeString($2));
				}
			| TIMESTAMP_FORMAT_P SCONST
				{
					$$ = makeDefElem("timestamp_format", (Node *)makeString($2));
				}
			| SMALLDATETIME_FORMAT_P SCONST
				{
					$$ = makeDefElem("smalldatetime_format", (Node *)makeString($2));
				}
			| COMPATIBLE_ILLEGAL_CHARS
				{
					$$ = makeDefElem("compatible_illegal_chars", (Node *)makeInteger(TRUE));
				}
			| FILL_MISSING_FIELDS
				{
					$$ = makeDefElem("fill_missing_fields", (Node *)makeString("one"));
				}
			| FILL_MISSING_FIELDS SCONST
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "FILL_MISSING_FIELDS is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("FILL_MISSING_FIELDS is not supported")));
#endif
					$$ = makeDefElem("fill_missing_fields", (Node *)makeString($2));
				}
            | TRANSFORM '(' copy_column_expr_list ')'
			    {
                    $$ = MakeDefElemWithLoc("transform", (Node *)$3, @1, @4);
                }
			| load_when_option
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "WHEN is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("WHEN is not supported")));
#endif
					$$ = $1;
				}
			| SKIP Iconst
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "SKIP is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("SKIP is not supported")));
#endif
					$$ = makeDefElem("skip", (Node *)makeInteger($2));
				}
			| SEQUENCE '(' copy_column_sequence_list ')'
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "SEQUENCE is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("SEQUENCE is not supported")));
#endif
					$$ = makeDefElem("sequence", (Node *)$3);
				}
			| FILLER '(' copy_column_filler_list ')'
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "FILLER is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("FILLER is not supported")));
#endif
					RemoveFillerCol($3, u_sess->parser_cxt.col_list);
					$$ = makeDefElem("filler", (Node *)$3);
				}
			| CONSTANT '(' copy_column_constant_list ')'
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "CONSTANT is not supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("CONSTANT is not supported")));
#endif
					$$ = makeDefElem("constant", (Node *)$3);
				}
		;

opt_oids:
			WITH OIDS
				{
					$$ = makeDefElem("oids", (Node *)makeInteger(TRUE));
				}
			| /*EMPTY*/								{ $$ = NULL; }
		;

copy_delimiter:
			opt_using DELIMITERS SCONST
				{
					$$ = makeDefElem("delimiter", (Node *)makeString($3));
				}
			| /*EMPTY*/								{ $$ = NULL; }
		;

opt_using:
			USING									{}
			| /*EMPTY*/								{}
		;

opt_noescaping:
			WITHOUT ESCAPING
				{
					$$ = makeDefElem("noescaping", (Node *)makeInteger(TRUE));
				}
			| /*EMPTY*/ 							{$$ = NULL;}
		;

OptCopyLogError:
			LOG_P ERRORS DATA_P
				{
					$$ = makeDefElem("log_errors_data", (Node *)makeInteger(TRUE));
				}
			| LOG_P ERRORS
             	{
             		$$ = makeDefElem("log_errors", (Node *)makeInteger(TRUE));
             	}
             	| /*EMPTY*/	                        { $$ = NULL; }
		;

OptCopyRejectLimit:
			REJECT_P LIMIT SCONST
				{
					$$ = makeDefElem("reject_limit", (Node*)makeString($3));
				}
			| /*EMPTY*/								{ $$ = NULL; }
		;

/* new COPY option syntax */
copy_generic_opt_list:
			copy_generic_opt_elem
				{
					$$ = list_make1($1);
				}
			| copy_generic_opt_list ',' copy_generic_opt_elem
				{
					$$ = lappend($1, $3);
				}
		;

copy_generic_opt_elem:
			ColLabel copy_generic_opt_arg
				{
					$$ = makeDefElem($1, $2);
				}
		;

copy_generic_opt_arg:
			opt_boolean_or_string			{ $$ = (Node *) makeString($1); }
			| NumericOnly					{ $$ = (Node *) $1; }
			| '*'							{ $$ = (Node *) makeNode(A_Star); }
			| '(' copy_generic_opt_arg_list ')'		{ $$ = (Node *) $2; }
			| /* EMPTY */					{ $$ = NULL; }
		;

copy_generic_opt_arg_list:
			  copy_generic_opt_arg_list_item
				{
					$$ = list_make1($1);
				}
			| copy_generic_opt_arg_list ',' copy_generic_opt_arg_list_item
				{
					$$ = lappend($1, $3);
				}
		;

/* beware of emitting non-string list elements here; see commands/define.c */
copy_generic_opt_arg_list_item:
			opt_boolean_or_string	{ $$ = (Node *) makeString($1); }
		;

copy_foramtter_opt:
			copy_col_format_def
				{
					$$ = list_make1($1);
				}
			| copy_foramtter_opt ',' copy_col_format_def
				{
					$$ = lappend($1, $3);
				}
		;

copy_col_format_def:
			ColId '(' Iconst ',' Iconst ')'
				{
					Position *arg = makeNode(Position);
					arg->colname = $1;
					arg->position = $3;
					arg->fixedlen = $5;
					$$ = (Node*)arg;
				}
		;

copy_column_expr_list:
			copy_column_expr_item
				{
					$$ = list_make1($1);
				}
			| copy_column_expr_list ',' copy_column_expr_item
				{
					$$ = lappend($1, $3);
				}
		;
copy_column_expr_item:
			ColId OptCopyColTypename OptCopyColExpr
				{
					CopyColExpr* n = makeNode(CopyColExpr);
					n->colname = $1;
					if ($2 != NULL)
						n->typname = $2;
					else
						n->typname = NULL;
					if ($3 != NULL)
						n->colexpr = $3;
					else
						n->colexpr = NULL;
					$$ = (Node*)n;
				}
		;

OptCopyColTypename:
				Typename			{ $$ = $1; }
				| /*EMPTY*/			{ $$ = NULL; }
		;
OptCopyColExpr:
				AS b_expr			{ $$ = $2; }
				| /*EMPTY*/			{ $$ = NULL; }
		;

copy_column_sequence_list:
			copy_column_sequence_item
				{
					$$ = list_make1($1);
				}
			| copy_column_sequence_list ',' copy_column_sequence_item
				{
					$$ = lappend($1, $3);
				}
		;
copy_column_sequence_item:
			ColId '(' column_sequence_item_sart column_sequence_item_step ')'
				{
					SqlLoadSequInfo* n = makeNode(SqlLoadSequInfo);
					n->colname = $1;
					n->start = $3;
					n->step = $4;
					$$ = (Node *)n;
				}
		;

column_sequence_item_step:
			',' Iconst			{ $$ = $2; }
			| ',' FCONST		{ $$ = SequenceStrGetInt64($2); }
			| /*EMPTY*/			{ $$ = 1; }
		;
column_sequence_item_sart:
			Iconst			{ $$ = $1; }
			| FCONST		{ $$ = SequenceStrGetInt64($1); }
		;
		
copy_column_filler_list:
			copy_column_filler_item
				{
					$$ = list_make1($1);
				}
			| copy_column_filler_list ',' copy_column_filler_item
				{
					$$ = lappend($1, $3);
				}
		;
copy_column_filler_item:
			ColId
				{
					SqlLoadFillerInfo* n = makeNode(SqlLoadFillerInfo);
					n->colname = $1;
					n->index = GetFillerColIndex($1, u_sess->parser_cxt.col_list);
					$$ = (Node *)n;
				}
		;

copy_column_constant_list:
			copy_column_constant_item
				{
					$$ = list_make1($1);
				}
			| copy_column_constant_list ',' copy_column_constant_item
				{
					$$ = lappend($1, $3);
				}
		;
copy_column_constant_item:
			ColId SCONST
				{
					SqlLoadConsInfo* n = makeNode(SqlLoadConsInfo);
					n->colname = $1;
					n->consVal = $2;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *       QUERY :
 *             CREATE STREAM relname
 *
 *     feature:
 *     1) create foreign table for streaming server
 *
 *
 *****************************************************************************/
 
CreateStreamStmt: 
        CREATE STREAM qualified_name '(' OptTableElementList ')'
            {
                CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
                n->servername = STREAMING_SERVER;
                n->base.if_not_exists = false;
                n->base.relation = $3;
                n->base.tableElts = $5;
                $$ = (Node *)n;
            }
        | CREATE STREAM IF_P NOT EXISTS qualified_name '(' OptTableElementList ')'
            {
                CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
                n->servername = STREAMING_SERVER;
                n->base.if_not_exists = true;
                n->base.relation = $6;
                n->base.tableElts = $8;
                $$ = (Node *)n;
            }
        ;

/*****************************************************************************
 *
 *		PURGE :
 *			PURGE TABLE [schema_name.]table_name
 *			PURGE INDEX [schema_name.]index_name
 *			PURGE TABLESPACE tablespace_name
 *			PURGE RECYCLEBIN
 *
 *****************************************************************************/
PurgeStmt:
	PURGE TABLE dolphin_qualified_name 
		{
			TcapFeatureEnsure();
			PurgeStmt *n = makeNode(PurgeStmt);
			n->purtype = PURGE_TABLE;
			n->purobj = $3;
			$$ = (Node *)n;
		}

	| PURGE INDEX qualified_name
		{
			TcapFeatureEnsure();
			PurgeStmt *n = makeNode(PurgeStmt);
			n->purtype = PURGE_INDEX;
			n->purobj = $3;
			$$ = (Node *)n;
		}

	| PURGE TABLESPACE name
		{
            const char* message = "PURGE TABLESPACE is not yet supported.";
            InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("PURGE TABLESPACE is not yet supported.")));
			TcapFeatureEnsure();
			PurgeStmt *n = makeNode(PurgeStmt);
			n->purtype = PURGE_TABLESPACE;
			n->purobj = makeRangeVar(NULL, $3, @3);
			$$ = (Node *) n;
		}

	| PURGE RECYCLEBIN
		{
			TcapFeatureEnsure();
			PurgeStmt *n = makeNode(PurgeStmt);
			n->purtype = PURGE_RECYCLEBIN;
			n->purobj = makeRangeVar(NULL, NULL, @2);
			$$ = (Node *) n;
		}
		;

/*****************************************************************************
 *
 *      TIMECAPSULE :
 *          TIMECAPSULE TABLE { table_name } TO { TIMESTAMP | CSN } expression
 *          TIMECAPSULE TABLE { table_name } TO BEFORE DROP [RENAME TO new_tablename]
 *          TIMECAPSULE TABLE { table_name } TO BEFORE TRUNCATE [ FORCE ]
 *
 *****************************************************************************/
 
TimeCapsuleStmt:
	TIMECAPSULE TABLE dolphin_qualified_name TO opt_timecapsule_clause 
		{
			TcapFeatureEnsure();
			TimeCapsuleStmt *n = makeNode(TimeCapsuleStmt);

			n->relation = $3;
			n->tcaptype = TIMECAPSULE_VERSION;

			n->tvtype = ((RangeTimeCapsule *)$5)->tvtype;
			n->tvver = ((RangeTimeCapsule *)$5)->tvver;

			$$ = (Node *) n;
		}

	| TIMECAPSULE TABLE dolphin_qualified_name TO BEFORE DROP opt_rename
		{
			TcapFeatureEnsure();
			TimeCapsuleStmt *n = makeNode(TimeCapsuleStmt);
			n->relation = $3;
			n->tcaptype = TIMECAPSULE_DROP;
			n->new_relname = $7;
			$$ = (Node *) n;
		}

	| TIMECAPSULE TABLE dolphin_qualified_name TO BEFORE TRUNCATE
		{
			TcapFeatureEnsure();
			TimeCapsuleStmt *n = makeNode(TimeCapsuleStmt);
			n->relation = $3;
			n->tcaptype = TIMECAPSULE_TRUNCATE;
			$$ = (Node *) n;
		}
		;

opt_rename:
	RENAME TO name					{ $$ = $3; }
	| /* EMPTY */					{ $$ = NULL; }
	;

/*****************************************************************************
 *
 *		QUERY :
 *				CREATE TABLE relname
 *
 *		PGXC-related extensions:
 *		1) Distribution type of a table:
 *			DISTRIBUTE BY ( HASH(column) | MODULO(column) |
 *							REPLICATION | ROUNDROBIN )
 *		2) Subcluster for table
 *			TO ( GROUP groupname | NODE nodename1,...,nodenameN )
 *
 *		3) Internal additional data from CN to CN and CN to DN; the clause must be the last clause.
 *			INTERNAL DATA xxxxxxxx
 *
 *****************************************************************************/

CreateOptionEtcList:
				CreateOptionList
					{
						$$ = $1;
					}
				| CreateTableOptionList
					{
						$$ = $1;
					}
				| CreateOptionBeforeList
					{
						$$ = $1;
					}
				| CreateOptionAfterList
					{
						$$ = $1;
					}
				| CreateOptionBeforeList CreateOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
				| CreateOptionAfterList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateOptionBeforeList:
				CreateOptionBefore
					{
						$$ = $1;
					}
				| CreateOptionBeforeList CreateOptionBefore
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

/*
 * Before indicates that CreatOptionList comes first, and after indicates that it comes later.
 * The same goes for the following.
 */
CreateOptionBefore:
				CreateOptionList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateOptionAfterList:
				CreateOptionAfter
					{
						$$ = $1;
					}
				| CreateOptionAfterList CreateOptionAfter
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateOptionAfter:
				CreateTableOptionList CreateOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateOptionList:	CreateOption
					{
						$$ = MakeCreateTableOptions(NULL, $1);
					}
				| CreateOptionList CreateOption
					{	
						$$ = MakeCreateTableOptions($1, $2); 
					}
			;

/*
 * CreateAsOption: 	createAsStmt option
 * CreateTableOption:	equivalent to table_option of MySQL
 * CreateOption:	other create option
 */
CreateOption:
			CreateIfNotExistsOption
				{
					$$ = $1;
				}
			| OptKind_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_KIND;
					n->option.relkind = $1;
					$$ = n;
				}
		;

CreateIfNotExistsOptionEtcList:
				CreateIfNotExistsOptionList
					{
						$$ = $1;
					}
				| CreateTableOptionList
					{
						$$ = $1;
					}
				| CreateIfNotExistsOptionBeforeList
					{
						$$ = $1;
					}
				| CreateIfNotExistsOptionAfterList
					{
						$$ = $1;
					}
				| CreateIfNotExistsOptionBeforeList CreateIfNotExistsOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
				| CreateIfNotExistsOptionAfterList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateIfNotExistsOptionBeforeList:
				CreateIfNotExistsOptionBefore
					{
						$$ = $1;
					}
				| CreateIfNotExistsOptionBeforeList CreateIfNotExistsOptionBefore
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateIfNotExistsOptionBefore:
				CreateIfNotExistsOptionList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateIfNotExistsOptionAfterList:
				CreateIfNotExistsOptionAfter
					{
						$$ = $1;
					}
				| CreateIfNotExistsOptionAfterList CreateIfNotExistsOptionAfter
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateIfNotExistsOptionAfter:
				CreateTableOptionList CreateIfNotExistsOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateIfNotExistsOptionList:	CreateIfNotExistsOption
					{
						$$ = MakeCreateTableOptions(NULL, $1);
					}
				| CreateIfNotExistsOptionList CreateIfNotExistsOption
					{	
						$$ = MakeCreateTableOptions($1, $2); 
					}

			;

CreateIfNotExistsOption:
			OptInherit_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_INHERIT;
					n->option.list_content = $1;
					$$ = n;
				}
			| OptInitRans_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_PARTITIONELEMENT;
					$$ = n;
				}
			| OptMaxTrans_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_PARTITIONELEMENT;
					$$ = n;
				}
			| OptStorage_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_PARTITIONELEMENT;
					$$ = n;
				}
			| OptPctFree_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_PARTITIONELEMENT;
					$$ = n;
				}			
			| opt_internal_data_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_INTERNAL_DATA;
					n->option.char_content = $1;
					$$ = n;
				}
			| opt_table_partitioning_clause_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_TABLE_PARTITIONING_CLAUSE;
					n->option.partTableState = (PartitionState *)$1;
					$$ = n;					
				}
			| CreateAsOption
				{
					$$ = $1;
				}
		;

CreateAsOptionEtcList:
				CreateAsOptionList
					{
						$$ = $1;
					}
				| CreateTableOptionList
					{
						$$ = $1;
					}
				| CreateAsOptionBeforeList
					{
						$$ = $1;
					}
				| CreateAsOptionAfterList
					{
						$$ = $1;
					}
				| CreateAsOptionBeforeList CreateAsOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
				| CreateAsOptionAfterList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateAsOptionBeforeList:
				CreateAsOptionBefore
					{
						$$ = $1;
					}
				| CreateAsOptionBeforeList CreateAsOptionBefore
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateAsOptionBefore:
				CreateAsOptionList CreateTableOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateAsOptionAfterList:
				CreateAsOptionAfter
					{
						$$ = $1;
					}
				| CreateAsOptionAfterList CreateAsOptionAfter
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateAsOptionAfter:
				CreateTableOptionList CreateAsOptionList
					{
						$$ = MergeCreateTableOptions($1, $2);
					}
			;

CreateAsOptionList:	CreateAsOption
					{
						$$ = MakeCreateTableOptions(NULL, $1);
					}
				| CreateAsOptionList CreateAsOption
					{	
						$$ = MakeCreateTableOptions($1, $2); 
					}
			;

CreateAsOption:
			OptWith_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_WITH;
					n->option.list_content = $1;
					$$ = n;
				}
			| OnCommitOption_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_ONCOMMIT;
					n->option.oncommit = $1;
					$$ = n;
				} 
			| OptCompress_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_COMPRESS;
					n->option.row_compress = $1;
					$$ = n;
				}
/* PGXC_BEGIN */
			| OptDistributeBy_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_DISTRIBUTEBY;
					n->option.distributeby = $1;
					$$ = n;
				}
			| OptSubCluster_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_SUBCLUSTER;
					n->option.subcluster = $1;
					$$ = n;
				}
/* PGXC_END */
			;

CreateTableOptionList:
			CreateTableOption
				{
					$$ = MakeCreateTableOptions(NULL, $1);
				}
			| CreateTableOptionList opt_comma CreateTableOption
				{
					$$ = MakeCreateTableOptions($1, $3);
				}
		;

CreateTableOption:
			OptTableSpace_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_TABLESPACE;
					n->option.char_content = $1;
					$$ = n;
				}
			| opt_compression_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_COMPRESSION;
					n->option.compress_type = $1;
					$$ = n;
				} 
			| opt_engine_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_ENGINE;
					$$ = n;
				}
			| default_collate
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_DOLPHIN_COLLATE;
					n->option.collate = $1;
					$$ = n;
				}
			| default_charset
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_DOLPHIN_CHARSET;
					n->option.charset = $1;
					$$ = n;
				}
			| row_format_option
				{
					ereport(WARNING, (errmsg("ROW_FORMAT for TABLE is not supported for current version. skipped")));
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_ROW_FORMAT;
					$$ = n;
				}
			| autoextend_size_option
				{
					$$ = CreateSingleTableOption(OPT_AUTOEXTEND_SIZE);
				}
			| avg_row_length_option
				{
					$$ = CreateSingleTableOption(OPT_AVG_ROW_LENGTH);
				}
			| checksum_option
				{
					$$ = CreateSingleTableOption(OPT_CHECKSUM);
				}
			| CONNECTION opt_equal SCONST
				{
					$$ = CreateSingleTableOption(OPT_CONNECTION);
				}
			| directory_option
				{
					$$ = CreateSingleTableOption(OPT_DIRECTORY);
				}
			| delay_key_write_option
				{
					$$ = CreateSingleTableOption(OPT_DELAY_KEY_WRITE);
				}
			| ENCRYPTION opt_equal SCONST
				{
					$$ = CreateSingleTableOption(OPT_ENCRYPTION);
				}
			| ENGINE_ATTRIBUTE opt_equal SCONST
				{
					$$ = CreateSingleTableOption(OPT_ENGINE_ATTRIBUTE);
				}
			| insert_method_option
				{
					$$ = CreateSingleTableOption(OPT_INSERT_METHOD);
				}
			| key_block_size_option
				{
					$$ = CreateSingleTableOption(OPT_KEY_BLOCK_SIZE);
				}
			| max_rows_option
				{
					$$ = CreateSingleTableOption(OPT_MAX_ROWS);
				}
			| min_rows_option
				{
					$$ = CreateSingleTableOption(OPT_MIN_ROWS);
				}
			| pack_keys_option
				{
					$$ = CreateSingleTableOption(OPT_PACK_KEYS);
				}
			| PASSWORD opt_equal SCONST
				{
					$$ = CreateSingleTableOption(OPT_PASSWORD);
				}
			| START TRANSACTION
				{
					$$ = CreateSingleTableOption(OPT_START_TRANSACTION);
				}
			| SECONDARY_ENGINE_ATTRIBUTE opt_equal SCONST
				{
					$$ = CreateSingleTableOption(OPT_SECONDARY_ENGINE_ATTRIBUTE);
				}
			| stats_auto_recalc_option
				{
					$$ = CreateSingleTableOption(OPT_STATS_AUTO_RECALC);
				}
			| stats_persistent_option
				{
					$$ = CreateSingleTableOption(OPT_STATS_PERSISTENT);
				}
			| stats_sample_pages_option
				{
					$$ = CreateSingleTableOption(OPT_STATS_SAMPLE_PAGES);
				}
			| UNION opt_equal '(' dolphin_qualified_name_list ')'
				{
					$$ = CreateSingleTableOption(OPT_UNION);
				}
			| tablespace_storage_option_without_empty
				{
					$$ = CreateSingleTableOption(OPT_TABLESPACE_STORAGE);
				}
			| OptAutoIncrement_without_empty
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_AUTO_INC;
					n->option.autoIncStart = $1;
					$$ = n;
				}
			| COMMENT opt_equal SCONST
				{
					SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
					n->option_type = OPT_COMMENT_TAB;
					CommentStmt *node = makeNode(CommentStmt);
					node->objtype = OBJECT_TABLE;
					node->objname = NIL;
					node->objargs = NIL;
					node->comment = $3;
					n->option.comment = node;
					$$ = n;
				}
		;

autoextend_size_option:
		AUTOEXTEND_SIZE opt_equal Iconst	{}
		| AUTOEXTEND_SIZE opt_equal FCONST	{}
		| AUTOEXTEND_SIZE opt_equal Iconst normal_ident	{}
		| AUTOEXTEND_SIZE opt_equal FCONST normal_ident	{}
		| AUTOEXTEND_SIZE opt_equal normal_ident	{}
		;

avg_row_length_option:
		AVG_ROW_LENGTH opt_equal Iconst	{}
		| AVG_ROW_LENGTH opt_equal FCONST	{}
		;

checksum_option:
		CHECKSUM opt_equal Iconst	{}
		| CHECKSUM opt_equal FCONST	{}
		| CHECKSUM opt_equal XCONST	{}
		;

directory_option:
		DATA_P DIRECTORY opt_equal SCONST	{}
		| INDEX DIRECTORY opt_equal SCONST	{}
		;

delay_key_write_option:
		DELAY_KEY_WRITE opt_equal Iconst	{}
		| DELAY_KEY_WRITE opt_equal FCONST	{}
		| DELAY_KEY_WRITE opt_equal XCONST	{}
		;

insert_method_option:
		INSERT_METHOD opt_equal NO	{}
		| INSERT_METHOD opt_equal FIRST_P	{}
		| INSERT_METHOD opt_equal LAST_P	{}
		;

key_block_size_option:
		KEY_BLOCK_SIZE opt_equal Iconst	{}
		| KEY_BLOCK_SIZE opt_equal FCONST	{}
		;

max_rows_option:
		MAX_ROWS opt_equal Iconst	{}
		| MAX_ROWS opt_equal FCONST	{}
		;

min_rows_option:
		MIN_ROWS opt_equal Iconst	{}
		| MIN_ROWS opt_equal FCONST	{}
		;

pack_keys_option:
		PACK_KEYS opt_equal Iconst	{}
		| PACK_KEYS opt_equal FCONST	{}
		| PACK_KEYS opt_equal XCONST	{}
		| PACK_KEYS opt_equal DEFAULT	{}
		;

stats_auto_recalc_option:
		STATS_AUTO_RECALC opt_equal Iconst	{}
		| STATS_AUTO_RECALC opt_equal FCONST	{}
		| STATS_AUTO_RECALC opt_equal XCONST	{}
		| STATS_AUTO_RECALC opt_equal DEFAULT	{}
		;

stats_persistent_option:
		STATS_PERSISTENT opt_equal Iconst	{}
		| STATS_PERSISTENT opt_equal FCONST	{}
		| STATS_PERSISTENT opt_equal XCONST	{}
		| STATS_PERSISTENT opt_equal DEFAULT	{}
		;

stats_sample_pages_option:
		STATS_SAMPLE_PAGES opt_equal Iconst	{}
		| STATS_SAMPLE_PAGES opt_equal FCONST	{}
		| STATS_SAMPLE_PAGES opt_equal XCONST	{}
		;

tablespace_storage_option_without_empty:
		STORAGE_DISK	{}
		| STORAGE_MEMORY	{}
		;

tablespace_storage_option:
		STORAGE_DISK	{}
		| STORAGE_MEMORY    {}
		| /*EMPTY*/	{}
		;

charset_with_opt_equal:
		CHARSET opt_equal any_name_or_sconst	{}
		| CHARACTER SET opt_equal any_name_or_sconst	{}
		;

CreateStmt:	CREATE OptTemp TABLE dolphin_qualified_name '(' OptTableElementList ')'
			CreateOptionEtcList
				{
					CreateStmt *n = makeNode(CreateStmt);
					$4->relpersistence = $2;
					n->relation = $4;
					n->tableElts = $6;
					n->constraints = NIL;
					n->if_not_exists = false;
					n->charset = PG_INVALID_ENCODING;
					if ($8 != NULL) {
						n->relkind = $8->relkind;
						n->inhRelations = $8->inhRelations;
						n->options = $8->options;
						n->oncommit = $8->oncommit;
						n->row_compress = $8->row_compress;
						n->tablespacename = $8->tablespacename;
/* PGXC_BEGIN */
						n->distributeby = $8->distributeby;
						n->subcluster = $8->subcluster;
/* PGXC_END */
						n->partTableState = (PartitionState *)$8->partTableState;
						n->internalData = $8->internalData;
						n->autoIncStart = $8->autoIncStart;
						if ($8->compress_type != NULL) {
							n->options = lappend(n->options, $8->compress_type);
						}
						if ($8->comment != NULL) {
							n->tableOptions = lappend(n->tableOptions, $8->comment);
						}
						if ($8->collate != NULL) {
							n->collate = $8->collate;
						}
						if ($8->charset != 0) {
							n->charset = $8->charset;
						}
					}
					$$ = (Node *)n;
				}
		| CREATE OptTemp TABLE dolphin_qualified_name '(' OptTableElementList ')'
				{
					CreateStmt *n = makeNode(CreateStmt);
					$4->relpersistence = $2;
					n->relation = $4;
					n->tableElts = $6;
					n->constraints = NIL;
					n->if_not_exists = false;
					n->relkind = OBJECT_TABLE;
					n->inhRelations = NIL;
					n->options = NIL;
					n->oncommit = ONCOMMIT_NOOP;
					n->row_compress = REL_CMPRS_PAGE_PLAIN;
					n->tablespacename = NULL;
/* PGXC_BEGIN */
					n->distributeby = NULL;
					n->subcluster = NULL;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
		| CREATE OptTemp TABLE IF_P NOT EXISTS dolphin_qualified_name '('
			OptTableElementList ')' CreateIfNotExistsOptionEtcList
				{
					CreateStmt *n = makeNode(CreateStmt);
					$7->relpersistence = $2;
					n->relation = $7;
					n->tableElts = $9;
					n->constraints = NIL;
					n->if_not_exists = true;
					n->charset = PG_INVALID_ENCODING;
					if ($11 != NULL) {
						n->inhRelations = $11->inhRelations;
						n->options = $11->options;
						n->oncommit = $11->oncommit;
						n->row_compress = $11->row_compress;
						n->tablespacename = $11->tablespacename;
/* PGXC_BEGIN */
						n->distributeby = $11->distributeby;
						n->subcluster = $11->subcluster;
/* PGXC_END */
						n->partTableState = (PartitionState *)$11->partTableState;
						n->internalData = $11->internalData;
						n->autoIncStart = $11->autoIncStart;
						if ($11->compress_type != NULL) {
							n->options = lappend(n->options, $11->compress_type);
						}
						if ($11->comment != NULL) {
							n->tableOptions = lappend(n->tableOptions, $11->comment);
						}
						if ($11->collate != NULL) {
							n->collate = $11->collate;
						}
						if ($11->charset != 0) {
							n->charset = $11->charset;
						}
						$$ = (Node *)n;
					}
				}
		| CREATE OptTemp TABLE IF_P NOT EXISTS dolphin_qualified_name '('
			OptTableElementList ')'
				{
					CreateStmt *n = makeNode(CreateStmt);
					$7->relpersistence = $2;
					n->relation = $7;
					n->tableElts = $9;
					n->constraints = NIL;
					n->if_not_exists = true;
					n->inhRelations = NIL;
					n->options = NIL;
					n->oncommit = ONCOMMIT_NOOP;
					n->row_compress = REL_CMPRS_PAGE_PLAIN;
					n->tablespacename = NULL;
/* PGXC_BEGIN */
					n->distributeby = NULL;
					n->subcluster = NULL;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
		| CREATE OptTemp TABLE dolphin_qualified_name OF any_name
			OptTypedTableElementList OptWith OnCommitOption OptCompress OptPartitionElement
/* PGXC_BEGIN */
			OptDistributeBy OptSubCluster
/* PGXC_END */
			opt_compression opt_engine opt_row_format
				{
					CreateStmt *n = makeNode(CreateStmt);
					$4->relpersistence = $2;
					n->relation = $4;
					n->tableElts = $7;
					n->ofTypename = makeTypeNameFromNameList($6);
					n->ofTypename->location = @6;
					n->constraints = NIL;
					n->options = $8;
					n->oncommit = $9;
					n->row_compress = $10;
					n->tablespacename = $11;
					n->if_not_exists = false;
/* PGXC_BEGIN */
					n->distributeby = $12;
					n->subcluster = $13;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					if ($14 != NULL) {
						n->options = lappend(n->options, $14);
					}
					$$ = (Node *)n;
				}
		| CREATE OptTemp TABLE IF_P NOT EXISTS dolphin_qualified_name OF any_name
			OptTypedTableElementList OptWith OnCommitOption OptCompress OptPartitionElement
/* PGXC_BEGIN */
			OptDistributeBy OptSubCluster
/* PGXC_END */
			opt_compression opt_engine opt_row_format
				{
					CreateStmt *n = makeNode(CreateStmt);
					$7->relpersistence = $2;
					n->relation = $7;
					n->tableElts = $10;
					n->ofTypename = makeTypeNameFromNameList($9);
					n->ofTypename->location = @9;
					n->constraints = NIL;
					n->options = $11;
					n->oncommit = $12;
					n->row_compress = $13;
					n->tablespacename = $14;
					n->if_not_exists = true;
/* PGXC_BEGIN */
					n->distributeby = $15;
					n->subcluster = $16;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					if ($17 != NULL) {
						n->options = lappend(n->options, $17);
					}
					$$ = (Node *)n;
				}
		| CREATE OptTemp TABLE dolphin_qualified_name TableLikeClause
				{
					CreateStmt *n = makeNode(CreateStmt);
					$4->relpersistence = $2;
					n->relation = $4;
					((TableLikeClause *)$5)->options |= CREATE_TABLE_LIKE_M_STYLE;
					n->tableElts = list_make1($5);
					n->constraints = NIL;
					n->if_not_exists = false;
					n->relkind = OBJECT_TABLE;
					n->inhRelations = NIL;
					n->options = NIL;
					n->oncommit = ONCOMMIT_NOOP;
					n->row_compress = REL_CMPRS_PAGE_PLAIN;
					n->tablespacename = NULL;
/* PGXC_BEGIN */
					n->distributeby = NULL;
					n->subcluster = NULL;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
		|  CREATE OptTemp TABLE IF_P NOT EXISTS dolphin_qualified_name TableLikeClause
				{
					CreateStmt *n = makeNode(CreateStmt);
					$7->relpersistence = $2;
					n->relation = $7;
					((TableLikeClause *)$8)->options |= CREATE_TABLE_LIKE_M_STYLE;
					n->tableElts = list_make1($8);
					n->constraints = NIL;
					n->if_not_exists = true;
					n->relkind = OBJECT_TABLE;
					n->inhRelations = NIL;
					n->options = NIL;
					n->oncommit = ONCOMMIT_NOOP;
					n->row_compress = REL_CMPRS_PAGE_PLAIN;
					n->tablespacename = NULL;
/* PGXC_BEGIN */
					n->distributeby = NULL;
					n->subcluster = NULL;
/* PGXC_END */
					n->partTableState = NULL;
					n->internalData = NULL;
					n->charset = PG_INVALID_ENCODING;
					$$ = (Node *)n;
				}
		;

engine_option:
	ENGINE_P opt_equal ColId
		{
			$$ = NULL;
		}
	| ENGINE_P opt_equal SCONST
		{
			$$ = NULL;
		}
	;
opt_engine:
	engine_option
		{
			$$ = $1;
		}
	| /* empty */
		{
			$$ = NULL;
		}
	;

row_format_option:
	ROW_FORMAT opt_equal normal_ident
		{
			$$ = NULL;
		}
	| ROW_FORMAT opt_equal SCONST
		{
			$$ = NULL;
		}
	| ROW_FORMAT opt_equal DEFAULT
		{
			$$ = NULL;
		}
	| ROW_FORMAT opt_equal FIXED_P
		{
			$$ = NULL;
		}
	;

opt_row_format:
	row_format_option
		{
			$$ = $1;
		}
	| /* empty */
		{
			$$ = NULL;
		}
	;

opt_engine_without_empty:
	ENGINE_P opt_equal ColId
		{
			$$ = NULL;
		}
	| ENGINE_P opt_equal SCONST
		{
			$$ = NULL;
		}
	;

compression_args:	normal_ident		{ $$ = $1; }
					| SCONST	{ $$ = $1; }
					| NONE		{ $$ = "none"; }
		;

set_compress_type:
	COMPRESSION opt_equal compression_args
		{
			int type = 0;
			if (strcmp($3, "pglz") == 0) {
				type = 1;
			} else if (strcmp($3, "zstd") == 0) {
 				type = 2;
			} else if (strcmp($3, "none") == 0) {
 				type = 0;
			} else {
				ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("unrecognized compress type")));
            }
			$$ = (Node*)makeDefElem("compresstype", (Node*)makeInteger(type));
		}
	;

opt_compression:
	set_compress_type
		{
			$$ = $1;
		}
	| /* empty */
		{
			$$ = NULL;
		}
	;

opt_compression_without_empty:
	set_compress_type
		{
			$$ = $1;
		}
	;

OptKind_without_empty:
	FOR MATERIALIZED VIEW
		{
			$$ = OBJECT_MATVIEW;
		}
	;

opt_table_partitioning_clause_without_empty:
		range_partitioning_clause
			{
				$$ = $1;
			}
		|hash_partitioning_clause
			{
				$$ = $1;
			}
		|list_partitioning_clause
			{
				$$ = $1;
			}
		|value_partitioning_clause
			{
				$$ = $1;
			}
		;

range_partitioning_clause:
		PARTITION BY RANGE opt_columns '(' column_item_list ')'
		opt_interval_partition_clause opt_partitions_num subpartitioning_clause '(' range_partition_definition_list ')' opt_row_movement_clause
			{
				PartitionState *n = makeNode(PartitionState);
				if ($10 != NULL && list_length($6) != 1) {
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				if ($10 != NULL && $8 != NULL) {
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("Subpartitions do not support interval partition."),
							errcause("System error."), erraction("Contact engineer to support.")));
				}
				if ($9 > 0 && u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support syntax in current compatibility"),
						parser_errposition(@9),
						errdetail("range partition with partitions clause is supported only in B compatibility")));
				}
				n->partitionKey = $6;
				n->intervalPartDef = (IntervalPartitionDefState *)$8;
				n->partitionsNum = $9;
				n->partitionList = $12;

				if (n->intervalPartDef)
					n->partitionStrategy = 'i';
				else
					n->partitionStrategy = 'r';

				n->rowMovement = (RowMovementValue)$14;
				n->subPartitionState = (PartitionState *)$10;

				$$ = (Node *)n;
			}
		;

list_partitioning_clause:
		PARTITION BY LIST opt_columns '(' column_item_list ')' opt_partitions_num subpartitioning_clause
		'(' list_partition_definition_list ')' opt_row_movement_clause
			{
#ifdef ENABLE_MULTIPLE_NODES
            	const char* message = "Un-support feature";
            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($6) != 1 && $9 != NULL) {
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("Un-support feature"),
								errdetail("The partition key's length should be 1.")));
				}
				if ($8 > 0 && u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support syntax in current compatibility"),
						parser_errposition(@8),
						errdetail("list partition with partitions clause is supported only in B compatibility")));
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $6;
				n->intervalPartDef = NULL;
				n->partitionList = $11;
				n->partitionStrategy = 'l';
				n->partitionsNum = $8;
				n->subPartitionState = (PartitionState *)$9;
				n->rowMovement = (RowMovementValue)$13;

				$$ = (Node *)n;

			}
		;

hash_partitioning_clause:
		PARTITION BY normal_ident '(' column_item_list ')' opt_partitions_num subpartitioning_clause
		opt_hash_partition_definition_list opt_row_movement_clause
			{
#ifdef ENABLE_MULTIPLE_NODES
            	const char* message = "Un-support feature";
            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($5) != 1) {
            	const char* message = "Un-support feature";
            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				if (strcmp($3, "hash") != 0) {
            		const char* message = "Un-support feature";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("unrecognized option \"%s\"", $3)));	
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = $9;
				n->partitionStrategy = 'h';
				n->partitionsNum = $7;
				n->subPartitionState = (PartitionState *)$8;
				n->rowMovement = (RowMovementValue)$10;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = n->partitionList;
				foreach(elem, parts) {
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				$$ = (Node *)n;

			}
		| PARTITION BY KEY '(' column_item_list ')' opt_partitions_num subpartitioning_clause
		opt_hash_partition_definition_list opt_row_movement_clause
			{
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support syntax in current compatibility"),
						parser_errposition(@3),
						errdetail("PARTITION BY KEY is supported only in B compatibility")));
				}
#ifdef ENABLE_MULTIPLE_NODES
		            	const char* message = "Un-support feature";
		            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($5) != 1) {
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = $9;
				n->partitionStrategy = 'h';
				n->partitionsNum = $7;
				n->subPartitionState = (PartitionState *)$8;
				n->rowMovement = (RowMovementValue)$10;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = n->partitionList;
				foreach(elem, parts) {
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				$$ = (Node *)n;

			}
		;

opt_columns:
		COLUMNS
			{
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support syntax in current compatibility"),
						parser_errposition(@1),
						errdetail("COLUMNS is supported only in B compatibility")));
				}
				$$ = NULL;
			}
		| /* empty */			{ $$ = NULL; }
		;

opt_partitions_num:
		PARTITIONS Iconst
			{
				if ($2 <= 0) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Invalid number of partitions"),
						parser_errposition(@2),
						errdetail("partitions number must be a positive integer")));
				}
				$$ = $2;
			}
		| /* empty */			{ $$ = 0; }
		;

opt_subpartitions_num:
		SUBPARTITIONS Iconst
			{
				if ($2 <= 0) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Invalid number of partitions"),
						parser_errposition(@2),
						errdetail("subpartitions number must be a positive integer")));
				}
				$$ = $2;
			}
		| /* empty */			{ $$ = 0; }
		;

opt_hash_partition_definition_list:
		'(' hash_partition_definition_list ')' { $$ = $2; }
		| /* empty */			{ $$ = NIL; }
		;

value_partitioning_clause:
		PARTITION BY VALUES '(' column_item_list ')'
			{
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->partitionStrategy = 'v';

				$$ = (Node *)n;
			}
		;

subpartitioning_clause:
		range_subpartitioning_clause
			{
				$$ = $1;
			}
		| hash_subpartitioning_clause
			{
				$$ = $1;
			}
		| list_subpartitioning_clause
			{
				$$ = $1;
			}
		| /* empty */			{ $$ = NULL; }
		;

range_subpartitioning_clause:
		SUBPARTITION BY RANGE '(' column_item_list ')'
			{
#ifdef ENABLE_MULTIPLE_NODES
				ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				PartitionState *n = makeNode(PartitionState);
				if (list_length($5) != 1) {
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = NIL;
				n->partitionStrategy = 'r';

				n->rowMovement = ROWMOVEMENT_DEFAULT;
				n->subPartitionState = NULL;

				$$ = (Node *)n;
			}
		;

list_subpartitioning_clause:
		SUBPARTITION BY LIST '(' column_item_list ')'
			{
#ifdef ENABLE_MULTIPLE_NODES
            	const char* message = "Un-support feature";
            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($5) != 1) {
            		const char* message = "Un-support feature";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = NIL;
				n->partitionStrategy = 'l';
				n->subPartitionState = NULL;
				$$ = (Node *)n;
			}
		;

hash_subpartitioning_clause:
		SUBPARTITION BY normal_ident '(' column_item_list ')' opt_subpartitions_num
			{
#ifdef ENABLE_MULTIPLE_NODES
            	const char* message = "Un-support feature";
            	InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($5) != 1) {
            		const char* message = "Un-support feature";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				if (strcmp($3, "hash") != 0) {
            		const char* message = "Un-support feature";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("unrecognized option \"%s\"", $3)));	
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = NIL;
				n->partitionStrategy = 'h';
				n->subPartitionState = NULL;
				n->partitionsNum = $7;
				$$ = (Node *)n;

			}
		| SUBPARTITION BY KEY '(' column_item_list ')' opt_subpartitions_num
			{
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support syntax in current compatibility"),
						parser_errposition(@3),
						errdetail("SUBPARTITION BY KEY is supported only in B compatibility")));
				}
#ifdef ENABLE_MULTIPLE_NODES
				const char* message = "Un-support feature";
				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(ERROR,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));
#endif
				if (list_length($5) != 1) {
					const char* message = "Un-support feature";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The partition key's length should be 1.")));
				}
				PartitionState *n = makeNode(PartitionState);
				n->partitionKey = $5;
				n->intervalPartDef = NULL;
				n->partitionList = NIL;
				n->partitionStrategy = 'h';
				n->subPartitionState = NULL;
				n->partitionsNum = $7;
				$$ = (Node *)n;
			}
		;

subpartition_definition_list:
		subpartition_item
			{
				$$ = list_make1($1);
			}
		| subpartition_definition_list ',' subpartition_item
			{
				$$ = lappend($1, $3);
			}
		;

subpartition_item:
		SUBPARTITION name VALUES '(' listValueList ')' opt_part_options
			{
				ListPartitionDefState *n = makeNode(ListPartitionDefState);
				n->partitionName = $2;
				n->boundary = $5;
				n->tablespacename = $7;

				$$ = (Node *)n;
			}
		| SUBPARTITION name opt_part_options
			{
				HashPartitionDefState *n = makeNode(HashPartitionDefState);
				n->partitionName = $2;
				n->tablespacename = $3;

				$$ = (Node*)n;
			}
		| SUBPARTITION name VALUES LESS THAN
		maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionDefState *n = makeNode(RangePartitionDefState);
				n->partitionName = $2;
				n->boundary = $6;
				n->tablespacename = $7;

				$$ = (Node *)n;
			}
		;

column_item_list:
		column_item
			{
				$$ = list_make1($1);
			}
		| column_item_list ',' column_item
			{
				$$ = lappend($1, $3);
			}
		;

column_item:
		a_expr
			{
				//$$ = makeColumnRef($1, NIL, @1, yyscanner);
				$$ = $1;
				int colCount = 0;
				CheckPartitionExpr($$, &colCount);
				if (colCount == 0)
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("No Column in the part expr")));
			}
		;

opt_interval_partition_clause:
		INTERVAL '(' interval_expr ')' opt_interval_tablespaceList
			{
				IntervalPartitionDefState* n = makeNode(IntervalPartitionDefState);
				n->partInterval = $3;
				n->intervalTablespaces = $5;

				$$ = (Node *)n;
			}
		| /* empty */
			{
				$$ = NULL;
			}
		;

opt_interval_tablespaceList:
		STORE_P IN_P  '(' tablespaceList ')'
			{
				$$= $4;
			}
		|
			{
				$$ = NIL;
			}
		;

interval_expr:
		a_expr
			{
				$$ = $1;
			}
		;

tablespaceList:
		name_list
			{
				$$ = $1;
			}
		;

range_partition_definition_list: /* general range partition syntax: start/end or less/than */
		range_less_than_list
			{
				$$ = $1;
			}
		| range_start_end_list
			{
				$$ = $1;
			}
		;

list_partition_definition_list:
		list_partition_item
			{
				$$ = list_make1($1);
			}
		| list_partition_definition_list ',' list_partition_item
			{
				$$ = lappend($1, $3);
			}
		;

hash_partition_definition_list:
		hash_partition_item
			{
				$$ = list_make1($1);
			}
		| hash_partition_definition_list ',' hash_partition_item
			{
				$$ = lappend($1, $3);
			}
		;

range_less_than_list:
		range_less_than_item
			{
				$$ = list_make1($1);
			}
		| range_less_than_list ',' range_less_than_item
			{
				$$ = lappend($1, $3);
			}
		;

opt_values_in: 
			VALUES IN_P
			| VALUES
	;

list_partition_item:
		PARTITION name opt_values_in '(' listValueList ')' opt_part_options
			{
				ListPartitionDefState *n = makeNode(ListPartitionDefState);
				n->partitionName = $2;
				n->boundary = $5;
				n->tablespacename = $7;

				$$ = (Node *)n;
			}
		| PARTITION name opt_values_in '(' listValueList ')' opt_part_options '(' subpartition_definition_list ')'
			{
				ListPartitionDefState *n = makeNode(ListPartitionDefState);
				n->partitionName = $2;
				n->boundary = $5;
				n->tablespacename = $7;
				n->subPartitionDefState = $9;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = n->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				$$ = (Node *)n;
			}
		;

hash_partition_item:
		PARTITION name opt_part_options
			{
				HashPartitionDefState *n = makeNode(HashPartitionDefState);
				n->partitionName = $2;
				n->tablespacename = $3;

				$$ = (Node*)n;
			}
		| PARTITION name opt_part_options '(' subpartition_definition_list ')'
			{
				HashPartitionDefState *n = makeNode(HashPartitionDefState);
				n->partitionName = $2;
				n->tablespacename = $3;
				n->subPartitionDefState = $5;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = n->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}
				$$ = (Node *)n;
			}
		;

range_less_than_item:
		PARTITION name VALUES LESS THAN
		maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionDefState *n = makeNode(RangePartitionDefState);
				n->partitionName = $2;
				n->boundary = $6;
				n->tablespacename = $7;

				$$ = (Node *)n;
			}
		| PARTITION name VALUES LESS THAN
		maxValueList_with_opt_parens opt_part_options '(' subpartition_definition_list ')'
			{
				RangePartitionDefState *n = makeNode(RangePartitionDefState);
				n->partitionName = $2;
				n->boundary = $6;
				n->tablespacename = $7;
				n->subPartitionDefState = $9;
				int i = 0;
				ListCell *elem = NULL;
				List *parts = n->subPartitionDefState;
				foreach(elem, parts) {
					if (!IsA((Node*)lfirst(elem), HashPartitionDefState)) {
						break;
					}
					HashPartitionDefState *hashPart = (HashPartitionDefState*)lfirst(elem);
					hashPart->boundary = list_make1(makeIntConst(i, -1));
					i++;
				}

				$$ = (Node *)n;
			}
		;
		
range_start_end_list:
		range_start_end_item
			{
				$$ = list_make1($1);
			}
		| range_start_end_list ',' range_start_end_item
			{
				$$ = lappend($1, $3);
			}
		;
	
range_start_end_item:
		PARTITION name START maxValueList_with_opt_parens  END_P maxValueList_with_opt_parens opt_range_every_list opt_part_options
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = $4;
				n->endValue = $6;
				n->everyValue = $7;
				n->tableSpaceName = $8;

				$$ = (Node *)n;
			}
		| PARTITION name END_P maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = NIL;
				n->endValue = $4;
				n->everyValue = NIL;
				n->tableSpaceName = $5;

				$$ = (Node *)n;
			}
		| PARTITION name START maxValueList_with_opt_parens opt_part_options
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = $4;
				n->endValue = NIL;
				n->everyValue = NIL;
				n->tableSpaceName = $5;

				$$ = (Node *)n;
			}
		;

opt_range_every_list:
		EVERY maxValueList_with_opt_parens 
			{
				$$ = $2;
			}
		| /* empty */ { $$ = NIL; }
		;

partition_name:
		ColId
			{
				$$ = makeRangeVar(NULL, $1, @1);
			}
		;

maxValueList_with_opt_parens:
		'(' maxValueList ')'
			{
				$$ = $2;
			}
		| MAXVALUE
			{
				Const *n = makeNode(Const);

				n->ismaxvalue = true;
				n->location = @1;

				$$ = list_make1((Node *)n);
			}
		;

maxValueList:
		maxValueItem
			{
				$$ = list_make1($1);
			}
		| maxValueList ',' maxValueItem
			{
				$$ = lappend($1, $3);
			}
		;

maxValueItem:
		a_expr
			{
				$$ = $1;
			}
		| MAXVALUE
			{
				Const *n = makeNode(Const);

				n->ismaxvalue = true;
				n->location = @1;

				$$ = (Node *)n;
			}
		;

listValueList:
		expr_list
			{
				$$ = $1;
			}
		| DEFAULT
			{
				Const *n = makeNode(Const);
 
				n->ismaxvalue = true;
				n->location = @1;
 
				$$ = list_make1(n);
			}
		;

opt_row_movement_clause: ENABLE_P ROW MOVEMENT		{ $$ = ROWMOVEMENT_ENABLE; }
			| DISABLE_P ROW MOVEMENT					{ $$ = ROWMOVEMENT_DISABLE; }
			| /*EMPTY*/								{ $$ = ROWMOVEMENT_DEFAULT; }
		;

/*
 * Redundancy here is needed to avoid shift/reduce conflicts,
 * since TEMP is not a reserved word.  See also OptTempTableName.
 *
 * NOTE: we accept both GLOBAL and LOCAL options.  They currently do nothing,
 * but future versions might consider GLOBAL to request SQL-spec-compliant
 * temp table behavior, so warn about that.  Since we have no modules the
 * LOCAL keyword is really meaningless; furthermore, some other products
 * implement LOCAL as meaning the same as our default temp table behavior,
 * so we'll probably continue to treat LOCAL as a noise word.
 */
OptTemp: TempExpr
		{
			$$ = $1;
		}
		| /*EMPTY*/	
		{
			$$ = RELPERSISTENCE_PERMANENT;
		}
	;

TempExpr: TEMPORARY						{ $$ = RELPERSISTENCE_TEMP; }
			| TEMP						{ $$ = RELPERSISTENCE_TEMP; }
			| LOCAL TEMPORARY			{ $$ = RELPERSISTENCE_TEMP; }
			| LOCAL TEMP				{ $$ = RELPERSISTENCE_TEMP; }
			| GLOBAL TEMPORARY
				{
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "GLOBAL is deprecated in temporary table creation";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(WARNING,
							(errmsg("GLOBAL is deprecated in temporary table creation"),
							 parser_errposition(@1)));
					$$ = RELPERSISTENCE_TEMP;
#else
                                        $$ = RELPERSISTENCE_GLOBAL_TEMP;
#endif
				}
			| GLOBAL TEMP
				{
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "GLOBAL is deprecated in temporary table creation";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(WARNING,
							(errmsg("GLOBAL is deprecated in temporary table creation"),
							 parser_errposition(@1)));
					$$ = RELPERSISTENCE_TEMP;
#else
                                        $$ = RELPERSISTENCE_GLOBAL_TEMP;
#endif
				}
			| UNLOGGED					{ $$ = RELPERSISTENCE_UNLOGGED; }
		;

OptTableElementList:
			TableElementList					{ $$ = $1; }
			| /*EMPTY*/							{ $$ = NIL; }
		;

OptTypedTableElementList:
			'(' TypedTableElementList ')'		{ $$ = $2; }
			| /*EMPTY*/							{ $$ = NIL; }
		;

TableElementList:
			TableElement
				{
					$$ = list_make1($1);
				}
			| TableElementList ',' TableElement
				{
					$$ = lappend($1, $3);
				}
		;

TypedTableElementList:
			TypedTableElement
				{
					$$ = list_make1($1);
				}
			| TypedTableElementList ',' TypedTableElement
				{
					$$ = lappend($1, $3);
				}
		;

table_index_elems:
					table_index_elem									{ $$ = list_make1($1); }
					| table_index_elems ',' table_index_elem			{ $$ = lappend($1, $3); }
		;
 
table_index_elem:	ColId opt_asc_desc
						{
							$$ = makeNode(IndexElem);
							$$->name = $1;
							$$->expr = NULL;
							$$->indexcolname = NULL;
							$$->collation = NULL;
							$$->opclass = NULL;
							$$->ordering = (SortByDir)$2;
						}
					| ColId '(' Iconst ')' opt_asc_desc
						{
							PrefixKey* pkey = makeNode(PrefixKey);
							pkey->arg = (Expr*)makeColumnRef(pstrdup($1), NIL, @1, yyscanner);
							pkey->length = $3;
							$$ = makeNode(IndexElem);
							$$->name = NULL;
							$$->expr = (Node*)pkey;
							$$->indexcolname = NULL;
							$$->collation = NULL;
							$$->opclass = NULL;
							$$->ordering = (SortByDir)$5;
						}
					| '(' a_expr ')' opt_asc_desc
						{
							$$ = makeNode(IndexElem);
							$$->name = NULL;
							$$->expr = $2;
							$$->indexcolname = NULL;
							$$->collation = NULL;
							$$->opclass = NULL;
							$$->ordering = (SortByDir)$4;
						}
		;

TableIndexClause:
			index_key_opt index_name access_method_clause_without_keyword '(' table_index_elems ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = $2;
					n->relation = NULL;
					n->accessMethod = $3;
					n->indexParams = $5;
					n->indexIncludingParams = NULL;
					n->options = NULL;
					n->tableSpace = NULL;
					n->indexOptions = $7;
					n->whereClause = NULL;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					$$ = (Node *)n;
			}
			| index_key_opt access_method_clause_without_keyword '(' table_index_elems ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = NULL;
					n->relation = NULL;
					n->accessMethod = $2;
					n->indexParams = $4;
					n->indexIncludingParams = NULL;
					n->options = NULL;
					n->tableSpace = NULL;
					n->indexOptions = $6;
					n->whereClause = NULL;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					$$ = (Node *)n;	
			}
			| FULLTEXT INDEX index_name '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = $3;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $5;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $7;
					$$ = (Node *)n;
			}
			| FULLTEXT INDEX '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = NULL;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $4;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $6;
					$$ = (Node *)n;
			}
			| FULLTEXT KEY index_name '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = $3;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $5;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $7;
					$$ = (Node *)n;
			}
			| FULLTEXT KEY '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = NULL;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $4;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $6;
					$$ = (Node *)n;
			}
			| FULLTEXT index_name '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = $2;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $4;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $6;
					$$ = (Node *)n;
			}
			| FULLTEXT '(' fulltext_index_params ')' opt_table_index_options
			{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->idxname = NULL;
					n->relation = NULL;
					n->accessMethod = "gin";
					n->indexParams = $3;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $5;
					$$ = (Node *)n;
			}
		;


TableElement:
			columnDefForTableElement			{ $$ = $1; }
			| TableLikeClause					{ $$ = $1; }
			| TableConstraint					{ $$ = $1; }
			| TableIndexClause					{ $$ = $1; }
		;

TypedTableElement:
			columnOptions						{ $$ = $1; }
			| TableConstraint	 				{ $$ = $1; }
		;

ColIdForTableElement:	DOLPHINIDENT				{ $$ = $1->str; }
			| unreserved_keyword_without_key		{ $$ = pstrdup($1); }
			| col_name_keyword				{ $$ = pstrdup($1); }
		;

columnDefForTableElement:	ColIdForTableElement Typename opt_charset KVType ColCmprsMode create_generic_options ColQualList
				{
					ColumnDef *n = makeNode(ColumnDef);
					n->colname = $1;
					n->typname = $2;
					n->typname->charset = $3;
					n->kvtype = $4;
					n->inhcount = 0;
					n->is_local = true;
					n->is_not_null = false;
					n->is_from_type = false;
					n->storage = 0;
					n->cmprs_mode = $5;
					n->raw_default = NULL;
					n->update_default = NULL;
					n->cooked_default = NULL;
					n->collOid = InvalidOid;
					n->fdwoptions = $6;
					if ($4 == ATT_KV_UNDEFINED) {
						SplitColQualList($7, &n->constraints, &n->collClause, &n->clientLogicColumnRef, &n->columnOptions,
									 yyscanner);
					} else {
						SplitColQualList($7, &n->constraints, &n->collClause, &n->columnOptions,
										yyscanner);
					}
					$$ = (Node *)n;
				}
		;

columnDef:	DolphinColColId Typename opt_charset KVType ColCmprsMode create_generic_options ColQualList
				{
					ColumnDef *n = makeNode(ColumnDef);
					n->colname = $1;
					n->typname = $2;
					n->typname->charset = $3;
					n->kvtype = $4;
					n->inhcount = 0;
					n->is_local = true;
					n->is_not_null = false;
					n->is_from_type = false;
					n->storage = 0;
					n->cmprs_mode = $5;
					n->raw_default = NULL;
					n->update_default = NULL;
					n->cooked_default = NULL;
					n->collOid = InvalidOid;
					n->fdwoptions = $6;
					if ($4 == ATT_KV_UNDEFINED) {
						SplitColQualList($7, &n->constraints, &n->collClause, &n->clientLogicColumnRef, &n->columnOptions,
									 yyscanner);
					} else {
						SplitColQualList($7, &n->constraints, &n->collClause, &n->columnOptions,
										yyscanner);
					}
					n->columnOptions = $8;
					$$ = (Node *)n;
				}
		;

add_column_first_after:
				FIRST_P
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "ALTER TABLE ... ADD ... FIRST is not yet supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("ALTER TABLE ... ADD ... FIRST is not yet supported")));
#endif
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->is_first = true;
					n->after_name = NULL;
					$$ = (Node *)n;
				}
				| AFTER ColId
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "ALTER TABLE ... ADD ... AFTER column_name is not yet supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("ALTER TABLE ... ADD ... AFTER column_name is not yet supported")));
#endif
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->is_first = false;
					n->after_name = $2;
					$$ = (Node *)n;
				}
				| /* EMPTY */
				{
					AlterTableCmd *n = makeNode(AlterTableCmd);
					n->is_first = false;
					n->after_name = NULL;
					$$ = (Node *)n;
				}
			;

KVType: TSTAG		{$$ = ATT_KV_TAG;}  /* tag for kv storage */
		| TSFIELD	{$$ = ATT_KV_FIELD;}  /* field for kv storage */
		| TSTIME	{$$ = ATT_KV_TIMETAG;}  /* field for kv storage */
		| /* EMPTY */	{$$ = ATT_KV_UNDEFINED;} /* not using kv storage */
;

ColCmprsMode:	DELTA		{$$ = ATT_CMPR_DELTA;}  /* delta compression */
		| PREFIX	{$$ = ATT_CMPR_PREFIX;}  /* prefix compression */
		| DICTIONARY		{$$ = ATT_CMPR_DICTIONARY;}  /* dictionary compression */
		| NUMSTR	{$$ = ATT_CMPR_NUMSTR;}  /* number-string compression */
		| NOCOMPRESS	{$$ = ATT_CMPR_NOCOMPRESS;}  /* don't compress */
		| /* EMPTY */	{$$ = ATT_CMPR_UNDEFINED;} /* not specified by user */
;

columnOptions:	ColId WITH OPTIONS ColQualList
				{
					ColumnDef *n = makeNode(ColumnDef);
					n->colname = $1;
					n->typname = NULL;
					n->inhcount = 0;
					n->is_local = true;
					n->is_not_null = false;
					n->is_from_type = false;
					n->storage = 0;
					n->raw_default = NULL;
					n->cooked_default = NULL;
					n->collOid = InvalidOid;
					SplitColQualList($4, &n->constraints, &n->collClause, &n->clientLogicColumnRef, &n->columnOptions,
									 yyscanner);
					$$ = (Node *)n;
				}
		;

ColQualList:
			ColQualList ColConstraint
			{
				if ($2 != NULL) {
					$$ = lappend($1, $2);
				} else {
					$$ = $1;
				}
			}
			| /*EMPTY*/								{ $$ = NIL; }
		;

ColConstraint:
			CONSTRAINT name ColConstraintElem
				{
					Constraint *n = (Constraint *) $3;
            		const char* message = "check node type inconsistant";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					AssertEreport(IsA(n, Constraint),
									MOD_OPT,
									"check node type inconsistant");
					n->conname = $2;
					n->location = @1;
					$$ = (Node *) n;
				}
			| ColConstraintElem						{ $$ = $1; }
			| ConstraintAttr						{ $$ = $1; }
			| COLLATE collate_name
				{
					/*
					 * Note: the CollateClause is momentarily included in
					 * the list built by ColQualList, but we split it out
					 * again in SplitColQualList.
					 */
					CollateClause *n = makeNode(CollateClause);
					n->arg = NULL;
					n->collname = $2;
					n->location = @1;
					$$ = (Node *) n;
				}
			| ENCRYPTED with_algorithm
				{
					$$=$2;
				}
			| AUTO_INCREMENT
				{
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "auto_increment is not yet supported";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
                        (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                            errmsg("auto_increment is not yet supported")));
#endif
                    if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
                        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                        errmsg("auto_increment is supported only in B-format database")));
                    }
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_AUTO_INCREMENT;
					n->location = @1;
					n->raw_expr = NULL;
					n->cooked_expr = NULL;
					$$ = (Node *)n;
				}
			| column_option
				{
					$$ = $1;
				}
		;	
with_algorithm:
                       WITH '(' algorithm_desc ')'
                       {
                        $$=$3;
                       }
                       | /*EMPTY*/ {
                               ClientLogicColumnRef  *n = makeNode(ClientLogicColumnRef);
                               n->column_key_name=NULL;
                               n->columnEncryptionAlgorithmType = EncryptionType::DETERMINISTIC_TYPE;
                               n->orig_typname=NULL;
							   n->location=0;
                               $$ = (Node *) n;
                       }
               ;
algorithm_desc:
        datatypecl columnEncryptionKey ',' encryptionType
        {
            ClientLogicColumnRef  *n = makeNode(ClientLogicColumnRef);
            n->column_key_name=$2;
            n->columnEncryptionAlgorithmType = $4;
            n->orig_typname=NULL;
			n->dest_typname=$1;
            n->location=@2;
            $$ = (Node *) n;
        }
        | datatypecl encryptionType ',' columnEncryptionKey
        {
            ClientLogicColumnRef  *n = makeNode(ClientLogicColumnRef);
            n->column_key_name=$4;
            n->columnEncryptionAlgorithmType = $2;
            n->orig_typname=NULL;
			n->dest_typname=$1;
            n->location=@2;
            $$ = (Node *) n;
        }
		;
columnEncryptionKey:  COLUMN_ENCRYPTION_KEY '=' setting_name  {$$=$3; };
encryptionType:
                ENCRYPTION_TYPE '=' RANDOMIZED {$$ =EncryptionType::RANDOMIZED_TYPE;}
    |           ENCRYPTION_TYPE '=' DETERMINISTIC {$$ =EncryptionType::DETERMINISTIC_TYPE;     }
;
setting_name:
        ColId { $$ = check_setting_name(list_make1(makeString($1)), yyscanner); }
        | ColId indirection
            {
                $$ = check_setting_name(lcons(makeString($1), $2), yyscanner);
            }
        ;

CreateKeyStmt:
        CreateMasterKeyStmt             { $$ = $1; }
        | CreateColumnKeyStmt          { $$ = $1; }
        ;

CreateMasterKeyStmt: 
        CREATE CLIENT MASTER KEY setting_name WITH '(' master_key_params ')'
        {   
            CreateClientLogicGlobal *n = makeNode(CreateClientLogicGlobal);
            n->global_key_name = $5;
            
            ClientLogicGlobalParam *n1 = makeNode (ClientLogicGlobalParam);
            n1->key = ClientLogicGlobalProperty::CLIENT_GLOBAL_FUNCTION;
            n1->value = "encryption";
            // len is not filled on purpose ??

            n->global_setting_params = lappend($8, (Node*)n1);
            $$=(Node*) n;
        }
        ;

master_key_params:
        master_key_elem                         { $$ = list_make1($1); }
        | master_key_params ',' master_key_elem { $$ = lappend($1, $3); }
        ;

master_key_elem: 
        KEY_STORE '=' ColId
        {
            ClientLogicGlobalParam *n = makeNode (ClientLogicGlobalParam);
            n->key = ClientLogicGlobalProperty::CMK_KEY_STORE;
            n->value = $3;
            // len is not filled on purpose ??
            $$ = (Node*) n;
        }
        | KEY_PATH '=' ColId_or_Sconst
        {
            ClientLogicGlobalParam *n = makeNode (ClientLogicGlobalParam);
            n->key = ClientLogicGlobalProperty::CMK_KEY_PATH;
            n->value =$3;
            // len is not filled on purpose ??
            $$ = (Node*) n;
        }
        | ALGORITHM '=' ColId
        {
            ClientLogicGlobalParam *n = makeNode (ClientLogicGlobalParam);
            n->key = ClientLogicGlobalProperty::CMK_ALGORITHM;
            n->value=$3;
            // len is not filled on purpose ??
            $$ = (Node*) n;
        }
        ;

CreateColumnKeyStmt:
        CREATE COLUMN ENCRYPTION KEY setting_name WITH VALUES '(' column_key_params ')'
        {
            CreateClientLogicColumn *n = makeNode(CreateClientLogicColumn);
            n->column_key_name = $5;

            ClientLogicColumnParam *n1 = makeNode (ClientLogicColumnParam);
            n1->key = ClientLogicColumnProperty::COLUMN_COLUMN_FUNCTION;
            n1->value = "encryption";
            // len is not filled on purpose ??

            n->column_setting_params = lappend($9, (Node*)n1);;
            $$=(Node*)n;
        }
        ;

column_key_params:
        column_key_elem                         { $$ = list_make1($1); }
        | column_key_params ',' column_key_elem { $$ = lappend($1, $3); }
        ;

column_key_elem: 
        CLIENT_MASTER_KEY '=' setting_name  {   
            ClientLogicColumnParam *n = makeNode (ClientLogicColumnParam);
            n->key = ClientLogicColumnProperty::CLIENT_GLOBAL_SETTING;
            n->value = NULL;
            n->qualname = $3;
            $$ = (Node*) n;
        }  
        | ALGORITHM '=' ColId
        {
            ClientLogicColumnParam *n = makeNode (ClientLogicColumnParam);
            n->key = ClientLogicColumnProperty::CEK_ALGORITHM;
            n->value =$3;
            n->qualname = NIL;
            $$ = (Node*) n;
        }
        | ENCRYPTED_VALUE '=' SCONST
        {
            ClientLogicColumnParam *n = makeNode (ClientLogicColumnParam);
            n->key = ClientLogicColumnProperty::CEK_EXPECTED_VALUE;
            n->value=$3;
            n->qualname = NIL;
            $$ = (Node*) n;
        }
        ;

datatypecl:
	DATATYPE_CL  '=' client_logic_type','
	{   
    	    $$ = $3;
	}
	| {$$= NULL;}
	;

/*
 * @HDFS
 * InformationalConstraintElem is used for informational constraint.
 */
InformationalConstraintElem:
            NOT_ENFORCED
                {
                    InformationalConstraint *n = makeNode(InformationalConstraint);
                    n->nonforced = true;
                    n->enableOpt = true;
                    $$ = (Node *) n;
                }
            | NOT_ENFORCED  DISABLE_P QUERY OPTIMIZATION
                {
                    InformationalConstraint *n = makeNode(InformationalConstraint);
                    n->nonforced = true;
                    n->enableOpt = false;
                    $$ = (Node *) n;
                }
            | NOT_ENFORCED  ENABLE_P QUERY OPTIMIZATION
                {
                    InformationalConstraint *n = makeNode(InformationalConstraint);
                    n->nonforced = true;
                    n->enableOpt = true;
                    $$ = (Node *) n;
                }
            | ENFORCED
                {
                    InformationalConstraint *n = makeNode(InformationalConstraint);
                    n->nonforced = false;
                    n->enableOpt = false;
                    $$ = (Node *) n;
                }
            | /*EMPTY*/
                {
                    InformationalConstraint *n = makeNode(InformationalConstraint);
                    n->nonforced = false;
                    n->enableOpt = false;
                    $$ = (Node *) n;
                }
        ;

/* DEFAULT NULL is already the default for Postgres.
 * But define it here and carry it forward into the system
 * to make it explicit.
 * - thomas 1998-09-13
 *
 * WITH NULL and NULL are not SQL92-standard syntax elements,
 * so leave them out. Use DEFAULT NULL to explicitly indicate
 * that a column may have that value. WITH NULL leads to
 * shift/reduce conflicts with WITH TIME ZONE anyway.
 * - thomas 1999-01-08
 *
 * DEFAULT expression must be b_expr not a_expr to prevent shift/reduce
 * conflict on NOT (since NOT might start a subsequent NOT NULL constraint,
 * or be part of a_expr NOT LIKE or similar constructs).
 */
ColConstraintElem:
			NOT NULL_P
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_NOTNULL;
					n->location = @1;
					$$ = (Node *)n;
				}
			| NOT NULL_P ENABLE_P
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_NOTNULL;
					n->location = @1;
					$$ = (Node *)n;
				}
			| NULL_P
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_NULL;
					n->location = @1;
					$$ = (Node *)n;
				}
			| opt_unique_key opt_definition OptConsTableSpaceWithEmpty InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = NULL;
					n->options = $2;
					n->indexname = NULL;
					n->indexspace = $3;
					n->inforConstraint = (InformationalConstraint *) $4;
					$$ = (Node *)n;
				}
			| opt_unique_key opt_definition OptConsTableSpaceWithEmpty ENABLE_P InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = NULL;
					n->options = $2;
					n->indexname = NULL;
					n->indexspace = $3;
					n->inforConstraint = (InformationalConstraint *) $5;
					$$ = (Node *)n;
				}
			| PRIMARY KEY opt_definition OptConsTableSpaceWithEmpty InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->keys = NULL;
					n->options = $3;
					n->indexname = NULL;
					n->indexspace = $4;
					n->inforConstraint = (InformationalConstraint *) $5;
					$$ = (Node *)n;
				}
			| PRIMARY KEY opt_definition OptConsTableSpaceWithEmpty ENABLE_P InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->keys = NULL;
					n->options = $3;
					n->indexname = NULL;
					n->indexspace = $4;
					n->inforConstraint = (InformationalConstraint *) $6;
					$$ = (Node *)n;
				}
			| CHECK '(' a_expr ')' opt_no_inherit
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_CHECK;
					n->location = @1;
					n->is_no_inherit = $5;
					n->raw_expr = $3;
					n->cooked_expr = NULL;
					$$ = (Node *)n;
				}
			| CHECK '(' a_expr ')' opt_no_inherit ENABLE_P
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_CHECK;
					n->location = @1;
					n->is_no_inherit = $5;
					n->raw_expr = $3;
					n->cooked_expr = NULL;
					$$ = (Node *)n;
				}
			| DEFAULT b_expr
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_DEFAULT;
					n->location = @1;
					n->raw_expr = $2;
					n->cooked_expr = NULL;
					$$ = (Node *)n;
				}
			| ON_UPDATE_TIME UPDATE b_expr
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						Constraint *n = makeNode(Constraint);
						n->contype = CONSTR_DEFAULT;
						n->location = @1;
						n->update_expr = $3;
						n->cooked_expr = NULL;
						$$ = (Node *)n;
					} else {
						const char* message = "on update syntax be supported dbcompatibility B.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errmodule(MOD_PARSER),
                                                                 errcode(ERRCODE_SYNTAX_ERROR),
                                                                 errmsg("on update syntax is supported in dbcompatibility B."),
                                                                 parser_errposition(@1)));
						$$ = NULL;
					}
#endif
				}
			| opt_generated_always AS '(' a_expr ')' generated_column_option
				{
#ifdef ENABLE_MULTIPLE_NODES
            		const char* message = "Generated column is not yet supported";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errmodule(MOD_GEN_COL), errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Generated column is not yet supported.")));
#endif
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_GENERATED;
					n->generated_when = ATTRIBUTE_IDENTITY_ALWAYS;
					n->raw_expr = $4;
					n->cooked_expr = NULL;
					n->location = @1;
					$$ = (Node *)n;
				}
			| REFERENCES dolphin_qualified_name opt_column_list key_match key_actions
				{
#ifdef 			ENABLE_MULTIPLE_NODES
            		const char* message = "REFERENCES constraint is not yet supported.";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("REFERENCES constraint is not yet supported.")));
#endif						
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_FOREIGN;
					n->location = @1;
					n->pktable			= $2;
					n->fk_attrs			= NIL;
					n->pk_attrs			= $3;
					n->fk_matchtype		= $4;
					n->fk_upd_action	= (char) ($5 >> 8);
					n->fk_del_action	= (char) ($5 & 0xFF);
					n->skip_validation  = false;
					n->initially_valid  = true;
					$$ = (Node *)n;
				}
			| REFERENCES dolphin_qualified_name opt_column_list key_match key_actions ENABLE_P
				{
            		const char* message = "REFERENCES constraint is not yet supported.";
            		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("REFERENCES constraint is not yet supported.")));
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_FOREIGN;
					n->location = @1;
					n->pktable = $2;
					n->fk_attrs = NIL;
					n->pk_attrs = $3;
					n->fk_matchtype = $4;
					n->fk_upd_action = (char) ($5 >> 8);
					n->fk_del_action = (char) ($5 & 0xFF);
					n->skip_validation  = false;
					n->initially_valid = true;
					$$ = (Node *)n;
				}
		;

opt_generated_always:
			GENERATED ALWAYS
			| /* EMPTY */
			;

opt_unique_key:
			UNIQUE { $$ = NULL; }
			| UNIQUE KEY
			{
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(errstate, (errmodule(MOD_PARSER),
						errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Un-support feature"),
						parser_errposition(@1),
						errdetail("UNIQUE KEY is supported only in B compatibility")));
				}
				$$ = NULL;
			}
			;
 
generated_column_option:
			STORED { $$ = 's'; }
			| /* EMPTY */ { $$ = '\0'; }
			;

/*
 * ConstraintAttr represents constraint attributes, which we parse as if
 * they were independent constraint clauses, in order to avoid shift/reduce
 * conflicts (since NOT might start either an independent NOT NULL clause
 * or an attribute).  parse_utilcmd.c is responsible for attaching the
 * attribute information to the preceding "real" constraint node, and for
 * complaining if attribute clauses appear in the wrong place or wrong
 * combinations.
 *
 * See also ConstraintAttributeSpec, which can be used in places where
 * there is no parsing conflict.  (Note: currently, NOT VALID and NO INHERIT
 * are allowed clauses in ConstraintAttributeSpec, but not here.  Someday we
 * might need to allow them here too, but for the moment it doesn't seem
 * useful in the statements that use ConstraintAttr.)
 */
ConstraintAttr:
			DEFERRABLE
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_ATTR_DEFERRABLE;
					n->location = @1;
					$$ = (Node *)n;
				}
			| NOT DEFERRABLE
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_ATTR_NOT_DEFERRABLE;
					n->location = @1;
					$$ = (Node *)n;
				}
			| INITIALLY DEFERRED
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_ATTR_DEFERRED;
					n->location = @1;
					$$ = (Node *)n;
				}
			| INITIALLY IMMEDIATE
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_ATTR_IMMEDIATE;
					n->location = @1;
					$$ = (Node *)n;
				}
		;


TableLikeClause:
			LIKE dolphin_qualified_name TableLikeOptionList
				{
					TableLikeClause *n = makeNode(TableLikeClause);
					n->relation = $2;
					n->options = $3;
#ifndef ENABLE_MULTIPLE_NODES					
					if (IS_SINGLE_NODE && (n->options & CREATE_TABLE_LIKE_DISTRIBUTION))
					{
            			const char* message = "Un-support feature";
            			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
									errmsg("Un-support feature"),                                          
									errdetail("The distributed capability is not supported currently."))); 
					}
#endif					
					$$ = (Node *)n;
				}
			| LIKE dolphin_qualified_name INCLUDING_ALL excluding_option_list
				{
					TableLikeClause *n = makeNode(TableLikeClause);
					n->relation = $2;
					n->options = CREATE_TABLE_LIKE_ALL & ~$4;
					if ($4 & CREATE_TABLE_LIKE_MAX) {
						n->options |= CREATE_TABLE_LIKE_MAX;
					}
#ifndef ENABLE_MULTIPLE_NODES					
					if (IS_SINGLE_NODE) 
					{
						n->options = n->options & ~CREATE_TABLE_LIKE_DISTRIBUTION;
					}
#endif					
					$$ = (Node *)n;
				}
		;

excluding_option_list:
				excluding_option_list EXCLUDING TableLikeExcludingOption	{ $$ = $1 | $3; }
				| /* EMPTY */						{ $$ = 0; }
		;

TableLikeOptionList:
				TableLikeOptionList INCLUDING TableLikeIncludingOption	{ $$ = $1 | $3; }
				| TableLikeOptionList EXCLUDING TableLikeExcludingOption
					{
						if ($3 == CREATE_TABLE_LIKE_ALL) {
							$$ = ($1 & ~$3) | CREATE_TABLE_LIKE_EXCLUDING_PARTITION | CREATE_TABLE_LIKE_EXCLUDING_INDEXES | CREATE_TABLE_LIKE_EXCLUDING_DEFAULTS;
						} else if ($3 & CREATE_TABLE_LIKE_INDEXES) {
							$$ = ($1 & ~$3) | CREATE_TABLE_LIKE_EXCLUDING_INDEXES;
						} else if ($3 & CREATE_TABLE_LIKE_PARTITION) {
							$$ = ($1 & ~$3) | CREATE_TABLE_LIKE_EXCLUDING_PARTITION;
						} else if ($3 & CREATE_TABLE_LIKE_DEFAULTS) {
							$$ = ($1 & ~$3) | CREATE_TABLE_LIKE_EXCLUDING_DEFAULTS;
						} else {
							$$ = $1 & ~$3; 
						}
					}
				| /* EMPTY */						{ $$ = CREATE_TABLE_LIKE_DEFAULTS_SERIAL; }
		;

TableLikeIncludingOption:
				DEFAULTS			{ $$ = CREATE_TABLE_LIKE_DEFAULTS | CREATE_TABLE_LIKE_DEFAULTS_SERIAL; }
				| CONSTRAINTS		{ $$ = CREATE_TABLE_LIKE_CONSTRAINTS; }
				| INDEXES			{ $$ = CREATE_TABLE_LIKE_INDEXES; }
				| STORAGE			{ $$ = CREATE_TABLE_LIKE_STORAGE; }
				| COMMENTS			{ $$ = CREATE_TABLE_LIKE_COMMENTS; }
				| PARTITION			{ $$ = CREATE_TABLE_LIKE_PARTITION; }
				| RELOPTIONS		{ $$ = CREATE_TABLE_LIKE_RELOPTIONS; }
				| DISTRIBUTION		{ $$ = CREATE_TABLE_LIKE_DISTRIBUTION; }
				| OIDS				{ $$ = CREATE_TABLE_LIKE_OIDS;}
				| GENERATED			{ $$ = CREATE_TABLE_LIKE_GENERATED; }
		;

TableLikeExcludingOption:
				DEFAULTS			{ $$ = CREATE_TABLE_LIKE_DEFAULTS | CREATE_TABLE_LIKE_DEFAULTS_SERIAL; }
				| CONSTRAINTS		{ $$ = CREATE_TABLE_LIKE_CONSTRAINTS; }
				| INDEXES			{ $$ = CREATE_TABLE_LIKE_INDEXES; }
				| STORAGE			{ $$ = CREATE_TABLE_LIKE_STORAGE; }
				| COMMENTS			{ $$ = CREATE_TABLE_LIKE_COMMENTS; }
				| PARTITION			{ $$ = CREATE_TABLE_LIKE_PARTITION; }
				| RELOPTIONS		{ $$ = CREATE_TABLE_LIKE_RELOPTIONS; }
				| DISTRIBUTION		{ $$ = CREATE_TABLE_LIKE_DISTRIBUTION; }
				| OIDS				{ $$ = CREATE_TABLE_LIKE_OIDS; }
				| GENERATED			{ $$ = CREATE_TABLE_LIKE_GENERATED; }
				| ALL				{ $$ = CREATE_TABLE_LIKE_ALL; }
		;

opt_internal_data_without_empty: 
            INTERNAL DATA_P 	internal_data_body		{$$ = $3;}
		;

internal_data_body: 	{
				int		begin 		= 0;
				int		end			= 0;
				char	*body 		= NULL;
				int		body_len 	= 0;

				int	tok = YYEMPTY;
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);

				if (yychar == YYEOF || yychar == YYEMPTY)
					tok = YYLEX;

				begin = yylloc;
				while(tok != YYEOF)
				{
					if (tok == ';')
					{
						end = yylloc;
					}
					tok = YYLEX;
				}

				if (end == 0)
					parser_yyerror("internal data of create statment is not ended correctly");

				body_len = end - begin + 1 ;

				body = (char *)palloc0(body_len + 1);
				strncpy(body,
					yyextra->core_yy_extra.scanbuf + begin - 1, body_len);

				body[body_len] = '\0';
				$$ = body;
			}
		;

/* ConstraintElem specifies constraint syntax which is not embedded into
 *	a column definition. ColConstraintElem specifies the embedded form.
 * - thomas 1997-12-03
 */
TableConstraint:
			CONSTRAINT name ConstraintElem
				{
					Constraint *n = (Constraint *) $3;
					Assert(IsA(n, Constraint));
					if ((n->conname == NULL) || (n->conname != NULL && n->contype == CONSTR_FOREIGN)) {
						n->conname = $2;
					}		
					n->location = @1;
					$$ = (Node *) n;
				}
			| CONSTRAINT ConstraintElem
				{
					Constraint *n = (Constraint *) $2;
					Assert(IsA(n, Constraint));
					n->location = @1;
					$$ = (Node *) n;
				}
			| ConstraintElem
			    {
					Constraint *n = (Constraint *) $1;
					$$ = (Node *) n;
                }
		;

ConstraintElem:
			CHECK '(' a_expr ')' ConstraintAttributeSpec opt_index_options
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_CHECK;
					n->location = @1;
					n->raw_expr = $3;
					n->cooked_expr = NULL;
					processCASbits($5, @5, "CHECK",
								   NULL, NULL, &n->skip_validation,
								   &n->is_no_inherit, yyscanner);
					n->constraintOptions = $6;
					n->initially_valid = !n->skip_validation;
					$$ = (Node *)n;
				}
			| UNIQUE unique_name access_method_clause_without_keyword '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->conname = $2;
					n->access_method = $3;
					n->keys = $5;
					n->including = $7;
					n->options = $8;
					n->indexname = NULL;
					n->indexspace = $9;
					n->constraintOptions = $10;
					processCASbits($11, @11, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $12; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE unique_name access_method_clause_without_keyword '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->conname = $2;
					n->access_method = $3;
					n->keys = $5;
					n->including = $7;
					n->options = $8;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $9;
					processCASbits($10, @10, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $11; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->access_method = downcase_str($3->str, $3->is_quoted);
					n->keys = $5;
					n->including = $7;
					n->options = $8;
					n->indexname = NULL;
					n->indexspace = $9;
					n->constraintOptions = $10;
					processCASbits($11, @11, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $12; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}	
			| UNIQUE USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->access_method = downcase_str($3->str, $3->is_quoted);
					n->keys = $5;
					n->including = $7;
					n->options = $8;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $9;
					processCASbits($10, @10, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $11; /* informational constraint info */
					
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = $3;
					n->including = $5;
					n->options = $6;
					n->indexname = NULL;
					n->indexspace = $7;
					n->constraintOptions = $8;
					processCASbits($9, @9, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $10; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = $3;
					n->including = $5;
					n->options = $6;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $7;
					processCASbits($8, @8, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $9; /* informational constraint info */
					
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE index_key_opt unique_name access_method_clause_without_keyword '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->conname = $3;
					n->access_method = $4;
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = $10;
					n->constraintOptions = $11;
					processCASbits($12, @12, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $13; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;	
				}
			| UNIQUE index_key_opt unique_name access_method_clause_without_keyword '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->conname = $3;
					n->access_method = $4;
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $10;
					processCASbits($11, @11, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $12; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;	
				}
			| UNIQUE index_key_opt USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->access_method = downcase_str($4->str, $4->is_quoted);
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = $10;
					n->constraintOptions = $11;
					processCASbits($12, @12, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $13; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE index_key_opt USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->access_method = downcase_str($4->str, $4->is_quoted);
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $10;
					processCASbits($11, @11, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $12; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE index_key_opt '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = $4;
					n->including = $6;
					n->options = $7;
					n->indexname = NULL;
					n->indexspace = $8;
					n->constraintOptions = $9;
					processCASbits($10, @10, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $11; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE index_key_opt '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = $4;
					n->including = $6;
					n->options = $7;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $8;
					processCASbits($9, @9, "UNIQUE",
					               &n->deferrable, &n->initdeferred, NULL,
					               NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $10; /* informational constraint info */	
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| UNIQUE ExistingIndex ConstraintAttributeSpec InformationalConstraintElem opt_index_options
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_UNIQUE;
					n->location = @1;
					n->keys = NIL;
					n->including = NIL;
					n->options = NIL;
					n->indexname = $2;
					n->indexspace = NULL;
					processCASbits($3, @3, "UNIQUE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $4; /* informational constraint info */
					n->constraintOptions = $5;
					$$ = (Node *)n;
				}
			| PRIMARY KEY USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->access_method = downcase_str($4->str, $4->is_quoted);
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = $10;
					n->constraintOptions = $11;
					processCASbits($12, @12, "PRIMARY KEY",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $13; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| PRIMARY KEY USING DOLPHINIDENT '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->access_method = downcase_str($4->str, $4->is_quoted);
					n->keys = $6;
					n->including = $8;
					n->options = $9;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $10;
					processCASbits($11, @11, "PRIMARY KEY",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $12; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| PRIMARY KEY '(' constraint_params ')' opt_c_include opt_definition OptConsTableSpace opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->keys = $4;
					n->including = $6;
					n->options = $7;
					n->indexname = NULL;
					n->indexspace = $8;
					n->constraintOptions = $9;
					processCASbits($10, @10, "PRIMARY KEY",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $11; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| PRIMARY KEY '(' constraint_params ')' opt_c_include opt_definition opt_table_index_options
				ConstraintAttributeSpec InformationalConstraintElem
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->keys = $4;
					n->including = $6;
					n->options = $7;
					n->indexname = NULL;
					n->indexspace = NULL;
					n->constraintOptions = $8;
					processCASbits($9, @9, "PRIMARY KEY",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint *) $10; /* informational constraint info */
					setAccessMethod(n);
					$$ = (Node *)n;
				}
			| PRIMARY KEY ExistingIndex ConstraintAttributeSpec InformationalConstraintElem opt_index_options
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_PRIMARY;
					n->location = @1;
					n->keys = NIL;
					n->including = NIL;
					n->options = NIL;
					n->indexname = $3;
					n->indexspace = NULL;
					processCASbits($4, @4, "PRIMARY KEY",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->inforConstraint = (InformationalConstraint*) $5; /* informational constraint info */
					n->constraintOptions = $6;
					$$ = (Node *)n;
				}
			| EXCLUDE access_method_clause '(' ExclusionConstraintList ')'
				opt_c_include opt_definition OptConsTableSpaceWithEmpty ExclusionWhereClause
				ConstraintAttributeSpec opt_index_options
				{
            		const char* message = "EXCLUDE constraint is not yet supported.";
        			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EXCLUDE constraint is not yet supported.")));
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_EXCLUSION;
					n->location = @1;
					n->access_method	= $2;
					n->exclusions		= $4;
					n->including		= $6;
					n->options			= $7;
					n->indexname		= NULL;
					n->indexspace		= $8;
					n->where_clause		= $9;
					processCASbits($10, @10, "EXCLUDE",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->constraintOptions = $11;
					$$ = (Node *)n;
				}
			| FOREIGN KEY name '(' columnList ')' REFERENCES dolphin_qualified_name
				opt_column_list key_match key_actions ConstraintAttributeSpec opt_index_options
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_FOREIGN;
					n->location = @1;
					n->conname = $3;
					n->pktable			= $8;
					n->fk_attrs			= $5;
					n->pk_attrs			= $9;
					n->fk_matchtype		= $10;
					n->fk_upd_action	= (char) ($11 >> 8);
					n->fk_del_action	= (char) ($11 & 0xFF);
					processCASbits($12, @12, "FOREIGN KEY",
								   &n->deferrable, &n->initdeferred,
								   &n->skip_validation, NULL,
								   yyscanner);
					n->initially_valid = !n->skip_validation;
					n->constraintOptions = $13;
					$$ = (Node *)n;
				}
			| FOREIGN KEY '(' columnList ')' REFERENCES dolphin_qualified_name
				opt_column_list key_match key_actions ConstraintAttributeSpec opt_index_options
				{				
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_FOREIGN;
					n->location = @1;
					n->pktable			= $7;
					n->fk_attrs			= $4;
					n->pk_attrs			= $8;
					n->fk_matchtype		= $9;
					n->fk_upd_action	= (char) ($10 >> 8);
					n->fk_del_action	= (char) ($10 & 0xFF);
					processCASbits($11, @11, "FOREIGN KEY",
								   &n->deferrable, &n->initdeferred,
								   &n->skip_validation, NULL,
								   yyscanner);
					n->initially_valid = !n->skip_validation;
					n->constraintOptions = $12;
					$$ = (Node *)n;
				}
			| PARTIAL CLUSTER KEY '(' columnList ')' ConstraintAttributeSpec opt_index_options
				{
					Constraint *n = makeNode(Constraint);
					n->contype = CONSTR_CLUSTER;
					n->location = @1;
					n->keys = $5;
					processCASbits($7, @7, "PARTIAL CLUSTER KEY",
								   NULL, NULL, NULL, NULL,
								   yyscanner);
					n->constraintOptions = $8;
					$$ = (Node *)n;
				}
		;

unique_name:		  
			DOLPHINIDENT                           			{ $$ = downcase_str($1->str, $1->is_quoted); }
			| unreserved_keyword_without_key			{ $$ = downcase_str(pstrdup($1), false); }
			| col_name_keyword              			{ $$ = downcase_str(pstrdup($1), false); }
			| PROXY                         			{ $$ = downcase_str(pstrdup($1), false); }			
		;

opt_no_inherit:	NO INHERIT							{  $$ = TRUE; }
			| /* EMPTY */							{  $$ = FALSE; }
		;

opt_column_list:
			'(' columnList ')'						{ u_sess->parser_cxt.col_list = $2; $$ = $2; }
			| /*EMPTY*/								{ u_sess->parser_cxt.col_list = NIL; $$ = NIL; }
		;

columnList:
			columnElem								{ $$ = list_make1($1); }
			| columnList ',' columnElem				{ $$ = lappend($1, $3); }
		;

columnElem: ColId
				{
					$$ = (Node *) makeString($1);
				}
		;

opt_c_include:	INCLUDE '(' columnList ')'			{ $$ = $3; }
			 |		/* EMPTY */						{ $$ = NIL; }
		;

key_match:  MATCH FULL
			{
				$$ = FKCONSTR_MATCH_FULL;
			}
		| MATCH PARTIAL
			{
        		const char* message = "MATCH PARTIAL not yet implemented";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						 errmsg("MATCH PARTIAL not yet implemented"),
						 parser_errposition(@1)));
				$$ = FKCONSTR_MATCH_PARTIAL;
			}
		| MATCH SIMPLE
			{
				$$ = FKCONSTR_MATCH_UNSPECIFIED;
			}
		| /*EMPTY*/
			{
				$$ = FKCONSTR_MATCH_UNSPECIFIED;
			}
		;

ExclusionConstraintList:
			ExclusionConstraintElem					{ $$ = list_make1($1); }
			| ExclusionConstraintList ',' ExclusionConstraintElem
													{ $$ = lappend($1, $3); }
		;

ExclusionConstraintElem: index_elem WITH any_operator
			{
				$$ = list_make2($1, $3);
			}
			/* allow OPERATOR() decoration for the benefit of ruleutils.c */
			| index_elem WITH OPERATOR '(' any_operator ')'
			{
				$$ = list_make2($1, $5);
			}
		;

ExclusionWhereClause:
			WHERE '(' a_expr ')'					{ $$ = $3; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

/*
 * We combine the update and delete actions into one value temporarily
 * for simplicity of parsing, and then break them down again in the
 * calling production.  update is in the left 8 bits, delete in the right.
 * Note that NOACTION is the default.
 */
key_actions:
			key_update
				{ $$ = ($1 << 8) | (FKCONSTR_ACTION_NOACTION & 0xFF); }
			| key_delete
				{ $$ = (FKCONSTR_ACTION_NOACTION << 8) | ($1 & 0xFF); }
			| key_update key_delete
				{ $$ = ($1 << 8) | ($2 & 0xFF); }
			| key_delete key_update
				{ $$ = ($2 << 8) | ($1 & 0xFF); }
			| /*EMPTY*/
				{ $$ = (FKCONSTR_ACTION_NOACTION << 8) | (FKCONSTR_ACTION_NOACTION & 0xFF); }
		;

key_update: ON UPDATE key_action		{ $$ = $3; }
		;

key_delete: ON DELETE_P key_action		{ $$ = $3; }
		;

key_action:
			NO ACTION					{ $$ = FKCONSTR_ACTION_NOACTION; }
			| RESTRICT					{ $$ = FKCONSTR_ACTION_RESTRICT; }
			| CASCADE					{ $$ = FKCONSTR_ACTION_CASCADE; }
			| SET NULL_P				{ $$ = FKCONSTR_ACTION_SETNULL; }
			| SET DEFAULT				{ $$ = FKCONSTR_ACTION_SETDEFAULT; }
		;

OptInherit_without_empty: INHERITS '(' dolphin_qualified_name_list ')'
			{
        		const char* message = "CREATE TABLE ... INHERITS is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("CREATE TABLE ... INHERITS is not yet supported.")));
				$$ = $3;
			}
		;

/* WITH (options) is preferred, WITH OIDS and WITHOUT OIDS are legacy forms */
OptWith:
			WITH reloptions				{ $$ = $2; }
			| WITH OIDS
			{
				if (!u_sess->attr.attr_common.IsInplaceUpgrade) {
        			const char* message = "CREATE TABLE ... WITH OIDS is not yet supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("CREATE TABLE ... WITH OIDS is not yet supported.")));
				}
				$$ = list_make1(defWithOids(true));
			}
			| WITHOUT OIDS				{ $$ = list_make1(defWithOids(false)); }
			| /*EMPTY*/					{ $$ = NIL; }
		;

OnCommitOption:  ON COMMIT DROP				{ $$ = ONCOMMIT_DROP; }
			| ON COMMIT DELETE_P ROWS		{ $$ = ONCOMMIT_DELETE_ROWS; }
			| ON COMMIT PRESERVE ROWS		{ $$ = ONCOMMIT_PRESERVE_ROWS; }
			| /*EMPTY*/						{ $$ = ONCOMMIT_NOOP; }
		;

OnCommitOption_without_empty:  ON COMMIT DROP				{ $$ = ONCOMMIT_DROP; }
			| ON COMMIT DELETE_P ROWS		{ $$ = ONCOMMIT_DELETE_ROWS; }
			| ON COMMIT PRESERVE ROWS		{ $$ = ONCOMMIT_PRESERVE_ROWS; }
		;
AutoIncrementValue: AUTO_INCREMENT Iconst	{ $$ = (Node *)makeInteger($2); }
        | AUTO_INCREMENT '=' Iconst	{ $$ = (Node *)makeInteger($3); }
        | AUTO_INCREMENT FCONST	{ $$ = (Node *)makeFloat($2); }
		| AUTO_INCREMENT '=' FCONST	{ $$ = (Node *)makeFloat($3); }
		;

OptAutoIncrement_without_empty: AutoIncrementValue
            {
#ifdef ENABLE_MULTIPLE_NODES
                const char* message = "auto_increment is not yet supported";
                InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                ereport(errstate,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                        errmsg("auto_increment is not yet supported")));
#endif
                if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
                    ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                    errmsg("auto_increment is supported only in B-format database")));
                }
                $$ = (Node*)makeDefElem("start", $1);
            }
		;

OptWith_without_empty:
			WITH reloptions				{ $$ = $2; }
			| WITH OIDS
			{
				if (!u_sess->attr.attr_common.IsInplaceUpgrade) {
        			const char* message = "CREATE TABLE ... WITH OIDS is not yet supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("CREATE TABLE ... WITH OIDS is not yet supported.")));
				}
				$$ = list_make1(defWithOids(true));
			}
			| WITHOUT OIDS				{ $$ = list_make1(defWithOids(false)); }
		;

OptTableSpace:   TABLESPACE opt_equal name					{ $$ = $3; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

OptTableSpace_without_empty:   TABLESPACE opt_equal name					{ $$ = $3; }
		;

OptGPI: 	UPDATE GLOBAL INDEX 	{ $$ = TRUE; }
			| /*EMPTY*/				{ $$ = FALSE; }
		;
OptCompress: COMPRESS	{ $$ = REL_CMPRS_FIELDS_EXTRACT; }
			| NOCOMPRESS { $$ = REL_CMPRS_PAGE_PLAIN; }
			| /* EMPTY */ { $$ = REL_CMPRS_PAGE_PLAIN; }
		;
		
OptCompress_without_empty: COMPRESS	{ $$ = REL_CMPRS_FIELDS_EXTRACT; }
			| NOCOMPRESS { $$ = REL_CMPRS_PAGE_PLAIN; }
			;

/* PGXC_BEGIN */
OptDistributeBy: OptDistributeByInternal			{ $$ = $1; }
			| /* EMPTY */							{ $$ = NULL; }
		;

OptDistributeBy_without_empty: OptDistributeByInternal			{ $$ = $1; }
		;

OptDatanodeName:    DATANODE name					{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

/*
 * For the distribution type, we use IDENT to limit the impact of keywords
 * related to distribution on other commands and to allow extensibility for
 * new distributions.
 */
OptDistributeType: normal_ident							{ $$ = $1; }
		;

OptDistributeByInternal:  DISTRIBUTE BY OptDistributeType '(' name_list ')'
				{
					DistributeBy *n = makeNode(DistributeBy);
#ifndef ENABLE_MULTIPLE_NODES					
					if (IS_SINGLE_NODE)
					{
        				const char* message = "Un-support feature";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,          
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("Un-support feature"),
								errdetail("The distributed capability is not supported currently.")));			
					}
#endif					
					if (strcmp($3, "modulo") == 0)
						n->disttype = DISTTYPE_MODULO;
					else if (strcmp($3, "hash") == 0)
						n->disttype = DISTTYPE_HASH;
					else if (strcmp($3, "list") == 0 || strcmp($3, "range") == 0) {
        				const char* message = "distribution needs user-defined slice clause";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("%s distribution needs user-defined slice clause", $3)));
					} else {
        				const char* message = "unrecognized distribution option";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        			ereport(errstate,
                                			(errcode(ERRCODE_SYNTAX_ERROR),
                                 				errmsg("unrecognized distribution option \"%s\"", $3)));
					}
					n->colname = $5;
					if (list_length(n->colname) > 1 && strcmp($3, "hash") != 0)
					{
        				const char* message = "distribute key can not exceed 1";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        			ereport(errstate,
                                			(errcode(ERRCODE_SYNTAX_ERROR),
                                 				errmsg("The number of %s distribute key can not exceed 1", $3)));

					}
					$$ = n;
				}
			| DISTRIBUTE BY OptDistributeType
				{
					DistributeBy *n = makeNode(DistributeBy);
#ifndef ENABLE_MULTIPLE_NODES					
					if (IS_SINGLE_NODE)
					{
        				const char* message = "Un-support feature";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,          
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("Un-support feature"),
								errdetail("The distributed capability is not supported currently.")));			
					}
#endif					
					if (strcmp($3, "replication") == 0)
                        n->disttype = DISTTYPE_REPLICATION;
					else if (strcmp($3, "roundrobin") == 0)
						n->disttype = DISTTYPE_ROUNDROBIN;
                    else if (strcmp($3, "hidetag") == 0)
                        n->disttype = DISTTYPE_HIDETAG;
                    else {
        				const char* message = "unrecognized distribution option";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        ereport(errstate,
                                (errcode(ERRCODE_SYNTAX_ERROR),
                                 errmsg("unrecognized distribution option \"%s\"", $3)));
					}
					n->colname = NULL;
					$$ = n;
				}
			| distribute_by_range_clause
				{
					$$ = $1;
				}
			| distribute_by_list_clause
				{
					$$ = $1;
				}
		;


distribute_by_list_clause: /* distribute by list ..., or distribute by list ... slice reference base_table */
			DISTRIBUTE BY LIST '(' name_list ')' OptListDistribution
				{
#ifndef ENABLE_MULTIPLE_NODES					
        			const char* message = "unrecognized distribution option";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,          
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The distributed capability is not supported currently.")));			

#endif					

					DistributeBy *n = makeNode(DistributeBy);
					n->disttype = DISTTYPE_LIST;
					n->colname = $5;
					n->distState = (DistState *)$7; 

					if (list_length(n->colname) > 4)
					{
        				const char* message = "The number of LIST distribution keys can not exceed 4";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        			ereport(errstate,
                                			(errcode(ERRCODE_SYNTAX_ERROR),
                                 				errmsg("The number of LIST distribution keys can not exceed 4")));

					}
					$$ = n;
				}
		;

OptListDistribution: 
		'(' list_dist_state ')'
			{ 
				$$ = $2; 
			}
		| SliceReferenceClause
			{
				DistState *n = makeNode(DistState);
				n->strategy = 'l';
				n->refTableName = $1;
				$$ = (Node *)n;
			}
		;

list_dist_state: /* DistState Struct for LIST distribution syntax */
		list_distribution_rules_list
			{
				DistState *n = makeNode(DistState);
				n->strategy = 'l';
				n->sliceList = $1;
				$$ = (Node *)n;
			}
		;

list_distribution_rules_list: /* list of DistSliceValue Struct for LIST distribution syntax */
		list_dist_value
			{
				$$ = list_make1($1);
			}
		| list_distribution_rules_list ',' list_dist_value
			{
				$$ = lappend($1, $3);
			}
		;

list_dist_value:
		SLICE name VALUES '(' list_distribution_rule_row ')' OptDatanodeName
			{
				ListSliceDefState *n = makeNode(ListSliceDefState);
				n->name = $2;
				n->boundaries = $5;
				n->datanode_name = $7;
				$$ = (Node *)n;
			}
		| SLICE name VALUES '(' DEFAULT ')' OptDatanodeName
			{
				Const *m = makeNode(Const);
				m->ismaxvalue = true;
				m->location = @1;

				ListSliceDefState *n = makeNode(ListSliceDefState);
				List *boundary = list_make1((void *)m); 
				n->boundaries = list_make1((void *)boundary);
				n->name = $2;
				n->datanode_name = $7;
				$$ = (Node *)n;
			}
		;

list_distribution_rule_row:  /* ListSliceDefState Struct for LIST distribution syntax */
		list_distribution_rule_single
			{
				$$ = list_make1($1); 
			}
		| list_distribution_rule_row ',' list_distribution_rule_single
			{
				$$ = lappend($1, $3);
			}
		;

list_distribution_rule_single:
		'(' expr_list ')' 
			{
				$$ = $2;
			}
		| c_expr_noparen
			{
				$$ = list_make1($1);
			}
		;



distribute_by_range_clause:
		DISTRIBUTE BY RANGE '(' name_list ')'  '(' range_slice_definition_list ')'
			{
#ifndef ENABLE_MULTIPLE_NODES	
        			const char* message = "The number of LIST distribution keys can not exceed 4";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);				
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("Un-support feature"),
							errdetail("The distributed capability is not supported currently.")));			
#endif
				DistributeBy *n = makeNode(DistributeBy);
				n->disttype = DISTTYPE_RANGE;
				n->colname = $5;
				DistState *n1 = makeNode(DistState);
				n1->strategy = 'r';
				n1->sliceList = $8;
				n->distState = n1;

				if (list_length(n->colname) > 4) {
        			const char* message = "The number of LIST distribution keys can not exceed 4";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("The number of range distribution key can not exceed 4")));
				}

				$$ = n;
			}
		| DISTRIBUTE BY RANGE '(' name_list ')' SliceReferenceClause
			{
#ifndef ENABLE_MULTIPLE_NODES	
        		const char* message = "Un-support feature";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);				
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("Un-support feature"),
						errdetail("The distributed capability is not supported currently.")));			
#endif
				DistributeBy *n = makeNode(DistributeBy);
				n->disttype = DISTTYPE_RANGE;
				n->colname = $5;
				DistState *n1 = makeNode(DistState);
				n1->strategy = 'r';
				n1->refTableName = $7;
				n->distState = n1;
				$$ = n;
			}
		;

SliceReferenceClause:
		SLICE REFERENCES name
			{
				$$ = $3;
			}
		;

range_slice_definition_list: /* general range slice syntax: values less than or start .. end */
		range_slice_less_than_list
			{
				$$ = $1;
			}
		| range_slice_start_end_list
			{
				$$ = $1;
			}
		;

range_slice_less_than_list:
		range_slice_less_than_item
			{
				$$ = list_make1($1);
			}
		| range_slice_less_than_list ',' range_slice_less_than_item
			{
				$$ = lappend($1, $3);
			}
		;

range_slice_less_than_item:
		SLICE name VALUES LESS THAN maxValueList_with_opt_parens OptDatanodeName
			{
				RangePartitionDefState *n = makeNode(RangePartitionDefState);
				n->partitionName = $2;
				n->boundary = $6;
				n->tablespacename = $7;

				$$ = (Node *)n;
			}
		;

range_slice_start_end_list:
		range_slice_start_end_item
			{
				$$ = list_make1($1);
			}
		| range_slice_start_end_list ',' range_slice_start_end_item
			{
				$$ = lappend($1, $3);
			}
		;

range_slice_start_end_item:
		SLICE name START maxValueList_with_opt_parens END_P maxValueList_with_opt_parens opt_range_every_list
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = $4;
				n->endValue = $6;
				n->everyValue = $7;

				$$ = (Node *)n;
			}
		| SLICE name END_P maxValueList_with_opt_parens
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = NIL;
				n->endValue = $4;
				n->everyValue = NIL;

				$$ = (Node *)n;
			}
		| SLICE name START maxValueList_with_opt_parens
			{
				RangePartitionStartEndDefState *n = makeNode(RangePartitionStartEndDefState);
				n->partitionName = $2;
				n->startValue = $4;
				n->endValue = NIL;
				n->everyValue = NIL;

				$$ = (Node *)n;
			}
		;

OptSubCluster:
			OptSubClusterInternal
				{
					$$ = $1;
				}
			| /* EMPTY */							{ $$ = NULL; }
		;

OptSubCluster_without_empty:
			OptSubClusterInternal
				{
					$$ = $1;
				}
		;

OptSubClusterInternal:
			TO NODE pgxcnodes
				{
					PGXCSubCluster *n = makeNode(PGXCSubCluster);
					n->clustertype = SUBCLUSTER_NODE;
					n->members = $3;
					$$ = n;
				}
			| TO GROUP_P pgxcgroup_name
				{
					PGXCSubCluster *n = makeNode(PGXCSubCluster);
					n->clustertype = SUBCLUSTER_GROUP;
					n->members = list_make1(makeString($3));
					$$ = n;
				}
		;
/* PGXC_END */

OptConsTableSpace:   USING INDEX OptPartitionElement	{ $$ = $3; }
;

OptConsTableSpaceWithEmpty:	USING INDEX OptPartitionElement	{ $$ = $3; }
							| /*EMPTY*/						{ $$ = NULL; }
		;

OptPartitionElement:
		OptTableSpace OptPctFree OptInitRans OptMaxTrans OptStorage
			{
				$$ = $1;
			}
		;

OptPctFree:
			PCTFREE Iconst
			| /* empty */
		;

OptPctFree_without_empty:
			PCTFREE Iconst
		;

OptInitRans:
			INITRANS Iconst
			| /* empty */
		;

OptInitRans_without_empty:
			INITRANS Iconst
		;

OptMaxTrans:
			MAXTRANS Iconst
			| /* empty */
		;

OptMaxTrans_without_empty:
			MAXTRANS Iconst
		;

OptStorage:
		STORAGE '(' OptInitial OptNext OptMinextents OptMaxextents ')'
		| /* empty */
		;

OptStorage_without_empty:
		STORAGE '(' OptInitial OptNext OptMinextents OptMaxextents ')'
		;
		
OptInitial:
		INITIAL_P Iconst normal_ident
		| /* empty */
		;

OptNext:
		NEXT Iconst normal_ident
		| /*empty*/
		;

OptMinextents:
		MINEXTENTS Iconst
		| /*empty*/
		;

OptMaxextents:
		MAXEXTENTS UNLIMITED
		| MAXEXTENTS Iconst
		| /*empty*/
		;

ExistingIndex:   USING INDEX index_name				{ $$ = $3; }
		;


/*****************************************************************************
 *
 *		QUERY :
 *				CREATE TABLE relname AS SelectStmt [ WITH [NO] DATA ]
 *
 *
 * Note: SELECT ... INTO is a now-deprecated alternative for this.
 *
 *****************************************************************************/

CreateAsStmt:
		CREATE OptTemp TABLE create_as_target AS SelectStmt opt_with_data
				{
					CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
					ctas->query = $6;
					ctas->into = $4;
					ctas->relkind = OBJECT_TABLE;
					ctas->is_select_into = false;
					/* cram additional flags into the IntoClause */
					$4->rel->relpersistence = $2;
					$4->skipData = !($7);
					$$ = (Node *) ctas;
				}
		| CREATE OptTemp TABLE create_as_target_dolphin SelectStmtWithoutWithClause opt_with_data
				{
					CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
					ctas->query = $5;
					ctas->into = $4;
					ctas->relkind = OBJECT_TABLE;
					ctas->is_select_into = false;
					/* cram additional flags into the IntoClause */
					$4->rel->relpersistence = $2;
					$4->skipData = !($6);
					$$ = (Node *) ctas;
				}
		| CREATE OptTemp TABLE dolphin_qualified_name SelectStmtWithoutWithClause opt_with_data
				{
					CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
					ctas->query = $5;

					IntoClause *into = makeNode(IntoClause);
					into->rel = $4;
					into->skipData = false;		/* might get changed later */
					into->colNames = NULL;
/* PGXC_BEGIN */
					into->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
/* PGXC_END */
					into->options = NIL;
					into->onCommit = ONCOMMIT_NOOP;
					into->row_compress = REL_CMPRS_PAGE_PLAIN;
					into->tableSpaceName = NULL;
/* PGXC_BEGIN */
					into->distributeby = NULL;
					into->subcluster = NULL;
/* PGXC_END */

					ctas->into = into;
					ctas->relkind = OBJECT_TABLE;
					ctas->is_select_into = false;
					/* cram additional flags into the IntoClause */
					into->rel->relpersistence = $2;
					into->skipData = !($6);
					$$ = (Node *) ctas;
				}
		;

OptDuplicate:
			IGNORE	{ $$ = DUPLICATE_IGNORE; }
			| REPLACE	{ $$ = DUPLICATE_REPLACE; }
		;

create_as_target:
			create_as_target_dolphin			{ $$ = $1; }
			| dolphin_qualified_name
				{
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->skipData = false;		/* might get changed later */
					$$->colNames = NULL;
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
/* PGXC_END */
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
/* PGXC_BEGIN */
					$$->distributeby = NULL;
					$$->subcluster = NULL;
/* PGXC_END */

				}
		;

create_as_target_dolphin:
			dolphin_qualified_name opt_column_list CreateAsOptionEtcList
				{
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->skipData = false;		/* might get changed later */
					$$->colNames = $2;
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
/* PGXC_END */
					if ($3 != NULL) {
						$$->options = $3->options;
						$$->onCommit = $3->oncommit;
						$$->row_compress = $3->row_compress;
						$$->tableSpaceName = $3->tablespacename;
						$$->autoIncStart = $3->autoIncStart;
/* PGXC_BEGIN */
						$$->distributeby = $3->distributeby;
						$$->subcluster = $3->subcluster;
/* PGXC_END */
						if ($3->compress_type != NULL) {
							$$->options = lappend($$->options, $3->compress_type);
						}
					}
				}
			| dolphin_qualified_name '(' columnList ')'
				{
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->skipData = false;		/* might get changed later */
					u_sess->parser_cxt.col_list = $3;
					$$->colNames = $3;
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
/* PGXC_END */
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
/* PGXC_BEGIN */
					$$->distributeby = NULL;
					$$->subcluster = NULL;
/* PGXC_END */
					 
				}
			| dolphin_qualified_name '(' OptTableElementList ')' OptDuplicate CreateAsOptionEtcList
				{
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("define column_definition is supported only in B-format database")));
					}
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->tableElts = $3;
					if ($$->tableElts == NIL) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("syntax error at or near \"%s\"", ")"), parser_errposition(@4)));
					}
					$$->skipData = false;           /* might get changed later */
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
/* PGXC_END */
					$$->onduplicate = $5;
					if ($6 != NULL) {
						$$->options = $6->options;
						$$->onCommit = $6->oncommit;
						$$->row_compress = $6->row_compress;
						$$->tableSpaceName = $6->tablespacename;
						$$->autoIncStart = $6->autoIncStart;
/* PGXC_BEGIN */
						$$->distributeby = $6->distributeby;
						$$->subcluster = $6->subcluster;
/* PGXC_END */
						if ($6->compress_type != NULL) {
							$$->options = lappend($$->options, $6->compress_type);
						}
					}
				}
			| dolphin_qualified_name '(' OptTableElementList ')' OptDuplicate
				{
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->tableElts = $3;
					if ($$->tableElts == NIL) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("syntax error at or near \"%s\"", ")"), parser_errposition(@4)));
					}
					$$->skipData = false;           /* might get changed later */
					$$->onduplicate = $5;
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
					$$->distributeby = NULL;
					$$->subcluster = NULL;
/* PGXC_END */
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
				}
			| dolphin_qualified_name '(' OptTableElementList ')'
				{
					$$ = makeNode(IntoClause);
					$$->rel = $1;
					$$->tableElts = $3;
					if ($$->tableElts == NIL) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("syntax error at or near \"%s\"", ")"), parser_errposition(@4)));
					}
					$$->skipData = false;           /* might get changed later */
					$$->onduplicate = DUPLICATE_ERROR;
/* PGXC_BEGIN */
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
					$$->distributeby = NULL;
					$$->subcluster = NULL;
/* PGXC_END */
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
				}
		;

opt_with_data:
			WITH DATA_P								{ $$ = TRUE; }
			| WITH NO DATA_P						{ $$ = FALSE; }
			| /*EMPTY*/								{ $$ = TRUE; }
		;

/*****************************************************************************
 *
 *              QUERY :
 *                              CREATE SNAPSHOT relname AS SelectStmt
 *                              CREATE SNAPSHOT relname FROM @ version USING (AlterAndDMLStmts)
 *                              SAMPLE SNAPSHOT relname AS postfix AT RATIO FCONST
 *                              PUBLISH SNAPSHOT relname @ version
 *                              ARCHIVE SNAPSHOT relname @ version
 *                              PURGE SNAPSHOT relname @ version
 *
 *****************************************************************************/

SnapshotStmt:
			CREATE OptTemp SNAPSHOT qualified_name OptSnapshotVersion
/* PGXC_BEGIN */
			OptDistributeBy OptSubCluster
/* PGXC_END */
			OptSnapshotComment
			AS SelectStmt
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "CREATE SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("CREATE SNAPSHOT is not yet supported.")));
#endif

				if ($2 != RELPERSISTENCE_PERMANENT)
				{
        			const char* message = "Temporary snapshots are not supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Temporary snapshots are not supported.")));
				}

				if ($7 != NULL)
				{
        			const char* message = "Clustered snapshots are not supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Clustered snapshots are not supported.")));
				}

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("create_snapshot")),
					lcons(checkNullNode(makeStringConst($4->schemaname, @4)),
					list_make4(checkNullNode(makeStringConst($4->relname, @4)),
					makeAArrayExpr(list_make1(make_node_from_scanbuf(@10, yylloc , yyscanner)), @10),
					checkNullNode(makeStringConst($5, @5)), checkNullNode(makeStringConst($8, @8)))));
			}
			| CREATE OptTemp SNAPSHOT qualified_name OptSnapshotVersion
/* PGXC_BEGIN */
			OptDistributeBy OptSubCluster
/* PGXC_END */
			FROM SnapshotVersion
			OptSnapshotComment
			USING '(' AlterSnapshotCmdList ')'
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "CREATE SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("CREATE SNAPSHOT is not yet supported.")));
#endif

				if ($2 != RELPERSISTENCE_PERMANENT)
				{
        			const char* message = "Temporary snapshots are not supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Temporary snapshots are not supported.")));
				}

				if ($6 != NULL)
				{
        			const char* message = "illegal DISTRIBUTE BY clause in CREATE SNAPSHOT ... FROM";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("illegal DISTRIBUTE BY clause in CREATE SNAPSHOT ... FROM"),
						errhint("DISTRIBUTE BY is inherited from parent snapshot."),
						parser_errposition(@6)));
				}

				if ($7 != NULL)
				{
        			const char* message = "Clustered snapshots are not supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("Clustered snapshots are not supported."),
						parser_errposition(@7)));
				}

				if ($13 == NIL)
				{
        			const char* message = "List of snapshot modifications is empty.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("List of snapshot modifications is empty."),
						parser_errposition(@13)));
				}

				char *snapshot_name = (char *)palloc0(strlen($4->relname) + 1 + strlen($9) + 1);
				sprintf(snapshot_name, "%s%c%s", $4->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $9);
				$4->relname = snapshot_name;

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("prepare_snapshot")),
					lcons(checkNullNode(makeStringConst($4->schemaname, @4)),
					list_make4(checkNullNode(makeStringConst($4->relname, @4)),
					makeAArrayExpr($13, @13),
					checkNullNode(makeStringConst($5, @5)),
					checkNullNode(makeStringConst($10, @10)))));
			}
			| SAMPLE SNAPSHOT qualified_name SnapshotVersion OptSnapshotStratify SnapshotSampleList
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "SAMPLE SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("SAMPLE SNAPSHOT is not yet supported.")));
#endif

				char *snapshot_name = (char *)palloc0(strlen($3->relname) + 1 + strlen($4) + 1);
				sprintf(snapshot_name, "%s%c%s", $3->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $4);
				$3->relname = snapshot_name;

				List *stratify = NIL;
				foreach_cell (c, $5) {
					ColumnRef *r = (ColumnRef*)lfirst(c);
					stratify = lappend(stratify,
					checkNullNode(makeStringConst(((Value *)llast(r->fields))->val.str, @5)));
				}

				List *names = NIL, *ratios = NIL, *comments = NIL;
				foreach_cell (c, $6) {
					names = lappend(names, lfirst(c));
					c = lnext(c);
					ratios = lappend(ratios, lfirst(c));
					c = lnext(c);
					comments = lappend(comments, lfirst(c));
				}

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("sample_snapshot")),
					lcons(checkNullNode(makeStringConst($3->schemaname, @3)),
					lcons(checkNullNode(makeStringConst($3->relname, @3)),
					list_make4(makeAArrayExpr(names, -1), makeAArrayExpr(ratios, -1),
						(stratify == NIL) ? makeNullAConst(-1) : makeAArrayExpr(stratify, @5),
						makeAArrayExpr(comments, -1)))));
			}
			| ARCHIVE SNAPSHOT qualified_name SnapshotVersion
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "ARCHIVE SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("ARCHIVE SNAPSHOT is not yet supported.")));
#endif

				char *snapshot_name = (char *)palloc0(strlen($3->relname) + 1 + strlen($4) + 1);
				sprintf(snapshot_name, "%s%c%s", $3->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $4);
				$3->relname = snapshot_name;

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("archive_snapshot")),
					list_make2(checkNullNode(makeStringConst($3->schemaname, @3)),
					checkNullNode(makeStringConst($3->relname, @3))));
			}
			| PUBLISH SNAPSHOT qualified_name SnapshotVersion
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "PUBLISH SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("PUBLISH SNAPSHOT is not yet supported.")));
#endif

				char *snapshot_name = (char *)palloc0(strlen($3->relname) + 1 + strlen($4) + 1);
				sprintf(snapshot_name, "%s%c%s", $3->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $4);
				$3->relname = snapshot_name;

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("publish_snapshot")),
					list_make2(checkNullNode(makeStringConst($3->schemaname, @3)),
					checkNullNode(makeStringConst($3->relname, @3))));
			}
			| PURGE SNAPSHOT qualified_name SnapshotVersion {}
			{
#ifdef ENABLE_MULTIPLE_NODES
        		const char* message = "PURGE SNAPSHOT is not yet supported.";
    			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("PURGE SNAPSHOT is not yet supported.")));
#endif

				char *snapshot_name = (char *)palloc0(strlen($3->relname) + 1 + strlen($4) + 1);
				sprintf(snapshot_name, "%s%c%s", $3->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $4);
				$3->relname = snapshot_name;

				$$ = makeCallFuncStmt(
					list_make2(makeString("db4ai"), makeString("purge_snapshot")),
					list_make2(checkNullNode(makeStringConst($3->schemaname, @3)),
					checkNullNode(makeStringConst($3->relname, @3))));
			}
		;

SnapshotVersion:
			'@' Iconst
				{
					char buf[64];
					snprintf(buf, sizeof(buf), "%d", $2);
					$$ = pstrdup(buf);
				}
			| '@' FCONST
				{	for (int i = strlen($2) - 1; i >= 0; i--)
					{
						if ($2[i] == '.')
						{
							$2[i] = DB4AI_SNAPSHOT_VERSION_SEPARATOR;
						}
					}
					$$ = $2;
				}
			| '@' VCONST			{ $$ = $2; }
			| '@' ColId_or_Sconst	{ $$ = $2; }
		;

OptSnapshotVersion:
			SnapshotVersion
				{
#ifdef ENABLE_MULTIPLE_NODES
        			const char* message = "SNAPSHOT VERSION syntax is not yet supported.";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("SNAPSHOT VERSION syntax is not yet supported.")));
#endif
					$$ = $1;
				}
			| /*EMPTY*/				{ $$ = NULL; }
		;

OptSnapshotComment:
			COMMENT IS comment_text	{ $$ = $3; }
			| /*EMPTY*/				{ $$ = NULL; }
		;

AlterSnapshotCmdList: AlterSnapshotCmdListNoParens
			| AlterSnapshotCmdListWithParens
		;

AlterSnapshotCmdListWithParens:
			'(' AlterSnapshotCmdListNoParens ')'		{ $$ = $2; }
			| '(' AlterSnapshotCmdListWithParens ')'	{ $$ = $2; }
		;

AlterSnapshotCmdListNoParens:
			AlterSnapshotCmdOrEmpty { $$ = $1; }
			| AlterSnapshotCmdListNoParens ';' AlterSnapshotCmdOrEmpty { $$ = list_concat($1, $3); }
		;

AlterSnapshotCmdOrEmpty:
			INSERT OptInsertIntoSnapshot insert_rest
				{
					$$ = list_make2(make_node_from_scanbuf(@1, ($2) ? @2 : @3, yyscanner),
									make_node_from_scanbuf(@3, yylloc, yyscanner));
				}
			| UPDATE OptAlterUpdateSnapshot OptSnapshotAlias SET set_clause_list from_clause where_clause
				{
					$$ = list_make1(make_node_from_scanbuf(@1, ($2) ? @2 : ($3) ? @3 : @4, yyscanner));
					if ($3)
						$$ = lappend($$, make_node_from_scanbuf(@3, @4, yyscanner));
					$$ = lappend($$, make_node_from_scanbuf(@4, (@5 == @6) ? ((@5 == @7) ? yylloc : @7) : @6, yyscanner));
					if ($6 != NIL)
						$$ = lappend($$, make_node_from_scanbuf(@6, (@6 == @7) ? yylloc : @7, yyscanner));
					if ($7 != NULL)
						$$ = lappend($$, make_node_from_scanbuf(@7, yylloc, yyscanner));
				}
			| DELETE_P OptDeleteFromSnapshot OptSnapshotAlias using_clause where_clause
				{
					$$ = list_make1(make_node_from_scanbuf(@1, ($2) ? @2 : ($3) ? @3 : (@1 == @4) ? ((@1 == @5) ? yylloc : @5) : @4, yyscanner));
					if ($3)
						$$ = lappend($$, make_node_from_scanbuf(@3, (@3 == @4) ? ((@3 == @5) ? yylloc : @5) : @4, yyscanner));
					if ($4 != NIL)
						$$ = lappend($$, make_node_from_scanbuf(@4, (@4 == @5) ? yylloc : @5, yyscanner));
					if ($5 != NULL)
						$$ = lappend($$, make_node_from_scanbuf(@5, yylloc, yyscanner));
				}
			| ALTER OptAlterUpdateSnapshot AlterSnapshotDdlList
				{
					$$ = list_make2(make_node_from_scanbuf(@1, ($2) ? @2 : @3, yyscanner),
									make_node_from_scanbuf(@3, yylloc, yyscanner));
				}
			| /*EMPTY*/		{ $$ = NIL; }
		;

OptAlterUpdateSnapshot:
			SNAPSHOT		{ $$ = TRUE; }
			| /*EMPTY*/		{ $$ = FALSE; }
		;

OptInsertIntoSnapshot:
			INTO SNAPSHOT	{ $$ = TRUE; }
			| /*EMPTY*/		{ $$ = FALSE; }
		;

OptDeleteFromSnapshot:
			FROM SNAPSHOT	{ $$ = TRUE; }
			| /*EMPTY*/		{ $$ = FALSE; }
		;

OptSnapshotAlias:
			AS ColId		{ $$ = TRUE; }
			| /*EMPTY*/		{ $$ = FALSE; }
		;

AlterSnapshotDdlList:		// parse and ignore
			AlterSnapshotDdl							{ $$ = FALSE; }
			| AlterSnapshotDdlList ',' AlterSnapshotDdl	{ $$ = FALSE; }
		;

AlterSnapshotDdl:			// parse and ignore
			ADD_P opt_column columnDef			{ $$ = FALSE; }
			| DROP opt_column IF_P EXISTS ColId	{ $$ = FALSE; }
			| DROP opt_column ColId				{ $$ = FALSE; }
		;

SnapshotSample:
			AS ColLabel AT RATIO FCONST OptSnapshotComment
			{
				$$ = list_make3(makeStringConst($2, @2), makeStringConst($5, @5), makeStringConst($6, @6));
			}
		;

SnapshotSampleList:
			SnapshotSample { $$ = $1; }
			| SnapshotSampleList ',' SnapshotSample { $$ = list_concat($1, $3); }
		;

OptSnapshotStratify:
			STRATIFY BY column_item_list	{ $$ = $3; }
			| /*EMPTY*/						{ $$ = NIL; }
		;

 /*****************************************************************************
 *
 *        QUERY :
 *                        CREATE MATERIALIZED VIEW relname AS SelectStmt
 *
 *****************************************************************************/

CreateMatViewStmt:
	   CREATE OptNoLog opt_incremental MATERIALIZED VIEW create_mv_target AS SelectStmt opt_with_data
			   {
				   CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
				   ctas->query = $8;
				   ctas->into = $6;
				   ctas->relkind = OBJECT_MATVIEW;
				   ctas->is_select_into = false;
				   /* cram additional flags into the IntoClause */
				   $6->rel->relpersistence = $2;
				   $6->skipData = !($9);
				   if ($6->skipData) {
        				const char* message = "WITH NO DATA for materialized views not yet supported";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				        ereport(errstate,
				            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
				                errmsg("WITH NO DATA for materialized views not yet supported")));
                   }
                   if ($3 && $6->options) {
        				const char* message = "options for incremental materialized views not yet supported";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        ereport(errstate,
                            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                errmsg("options for incremental materialized views not yet supported")));
                   }
#ifndef ENABLE_MULTIPLE_NODES
                   if ($3 && $6->distributeby) {
        				const char* message = "It's not supported to specify distribute key on incremental materialized views";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        ereport(errstate,
                            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                errmsg("It's not supported to specify distribute key on incremental materialized views")));
                   }
#endif
                   if (ENABLE_DMS) {
                        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                            errmsg("matview is not supported while DMS and DSS enabled.")));
                   }
                    
				   $6->ivm = $3;
				   $$ = (Node *) ctas;
			   }
	   ;

create_mv_target:
		   qualified_name opt_column_list
/* PGXC_BEGIN */
           OptDistributeBy
/* PGXC_END */
		   opt_reloptions OptTableSpace
			   {
				   $$ = makeNode(IntoClause);
				   $$->rel = $1;
				   $$->colNames = $2;
				   $$->options = $4;
				   $$->onCommit = ONCOMMIT_NOOP;
				   $$->tableSpaceName = $5;
				   $$->skipData = false;	   /* might get changed later */
				   $$->ivm = false;
/* PGXC_BEGIN */
                   $$->distributeby = $3;
/* PGXC_END */
				   $$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
			   }
	   ;

OptNoLog:  UNLOGGED 				   { $$ = RELPERSISTENCE_UNLOGGED; }
		   | /*EMPTY*/				   { $$ = RELPERSISTENCE_PERMANENT; }
	   ;

opt_incremental:
			INCREMENTAL							{ $$ = TRUE; }
			| /*EMPTY*/							{ $$ = FALSE; }
		;


/*****************************************************************************
 *
 *     QUERY :
 *             REFRESH MATERIALIZED VIEW qualified_name
 *
 *****************************************************************************/

RefreshMatViewStmt:
           REFRESH opt_incremental MATERIALIZED VIEW qualified_name opt_with_data
               {
                   RefreshMatViewStmt *n = makeNode(RefreshMatViewStmt);
                   n->relation = $5;
                   n->incremental = $2;
                   n->skipData = !($6);
                   if (n->skipData) {
        				const char* message = "WITH NO DATA for materialized views not yet supported";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                       ereport(errstate,
                           (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						    errmsg("WITH NO DATA for materialized views not yet supported")));
                   }
                   $$ = (Node *) n;
               }
       ;


/*****************************************************************************
 *
 *		QUERY :
 *				CREATE SEQUENCE seqname
 *				ALTER SEQUENCE seqname
 *
 *****************************************************************************/

CreateSeqStmt:
			CREATE OptTemp opt_large_seq SEQUENCE qualified_name OptSeqOptList
				{
					CreateSeqStmt *n = makeNode(CreateSeqStmt);
					$5->relpersistence = $2;
					n->is_large = $3;
#ifdef ENABLE_MULTIPLE_NODES
					if (n->is_large) {
        				const char* message = "large sequence is not supported.";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(ERROR,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("large sequence is not supported.")));
					}
#endif

					n->sequence = $5;
					n->options = $6;
					n->ownerId = InvalidOid;
/* PGXC_BEGIN */
					n->is_serial = false;
/* PGXC_END */
					n->uuid = 0;
					n->canCreateTempSeq = false;
					$$ = (Node *)n;
				}
		;

AlterSeqStmt:
			ALTER SEQUENCE qualified_name SeqOptList
				{
					AlterSeqStmt *n = makeNode(AlterSeqStmt);
					n->sequence = $3;
					n->options = $4;
					n->missing_ok = false;
/* PGXC_BEGIN */
					n->is_serial = false;
/* PGXC_END */
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE qualified_name SeqOptList
				{
					AlterSeqStmt *n = makeNode(AlterSeqStmt);
					n->is_large = true;
					n->sequence = $4;
					n->options = $5;
					n->missing_ok = false;
/* PGXC_BEGIN */
					n->is_serial = false;
/* PGXC_END */
					$$ = (Node *)n;
				}
			| ALTER SEQUENCE IF_P EXISTS qualified_name SeqOptList
				{
					AlterSeqStmt *n = makeNode(AlterSeqStmt);
					n->sequence = $5;
					n->options = $6;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE IF_P EXISTS qualified_name SeqOptList
				{
					AlterSeqStmt *n = makeNode(AlterSeqStmt);
					n->is_large = true;
					n->sequence = $6;
					n->options = $7;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
		;

opt_large_seq: LARGE_P								{$$ = true; }
			| /*EMPTY*/								{$$ = false; }
		;

OptSeqOptList: SeqOptList							{ $$ = $1; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

SeqOptList: SeqOptElem								{ $$ = list_make1($1); }
			| SeqOptList SeqOptElem					{ $$ = lappend($1, $2); }
		;

SeqOptElem: CACHE NumericOnly
				{
					$$ = makeDefElem("cache", (Node *)$2);
				}
			| CYCLE
				{
					$$ = makeDefElem("cycle", (Node *)makeInteger(TRUE));
				}
			| NO CYCLE
				{
					$$ = makeDefElem("cycle", (Node *)makeInteger(FALSE));
				}
			| INCREMENT opt_by NumericOnly
				{
					$$ = makeDefElem("increment", (Node *)$3);
				}
			| MAXVALUE NumericOnly
				{
					$$ = makeDefElem("maxvalue", (Node *)$2);
				}
			| MINVALUE NumericOnly
				{
					$$ = makeDefElem("minvalue", (Node *)$2);
				}
			| NO MAXVALUE
				{
					$$ = makeDefElem("maxvalue", NULL);
				}
			| NO MINVALUE
				{
					$$ = makeDefElem("minvalue", NULL);
				}
			| OWNED BY any_name
				{
					$$ = makeDefElem("owned_by", (Node *)$3);
				}
			| START_WITH NumericOnly
				{
					$$ = makeDefElem("start", (Node *)$2);
				}

			| START NumericOnly
				{
					$$ = makeDefElem("start", (Node *)$2);
				}
			| RESTART
				{
					$$ = makeDefElem("restart", NULL);
				}
			| RESTART opt_with NumericOnly
				{
					$$ = makeDefElem("restart", (Node *)$3);
				}
			| NOCYCLE
				{
					$$ = makeDefElem("cycle", (Node *)makeInteger(FALSE));
				}
			| NOMAXVALUE
				{
					$$ = makeDefElem("maxvalue", NULL);
				}
			| NOMINVALUE
				{
					$$ = makeDefElem("minvalue", NULL);
				}
		;

opt_by:		BY				{}
			| /* empty */	{}
	  ;

NumericOnly:
			FCONST								{ $$ = makeFloat($1); }
			| '+' FCONST						{ $$ = makeFloat($2); }
			| '-' FCONST
				{
					$$ = makeFloat($2);
					doNegateFloat($$);
				}
			| SignedIconst						{ $$ = makeInteger($1); }
		;

NumericOnly_list:	NumericOnly						{ $$ = list_make1($1); }
				| NumericOnly_list ',' NumericOnly	{ $$ = lappend($1, $3); }
		;

/*****************************************************************************
 *
 *		QUERIES :
 *				CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE ...
 *				DROP [PROCEDURAL] LANGUAGE ...
 *
 *****************************************************************************/

CreatePLangStmt:
			CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
			{
				CreatePLangStmt *n = makeNode(CreatePLangStmt);
				n->replace = $2;
				n->plname = $6;
				/* parameters are all to be supplied by system */
				n->plhandler = NIL;
				n->plinline = NIL;
				n->plvalidator = NIL;
				n->pltrusted = false;
				$$ = (Node *)n;
			}
			| CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
			  HANDLER handler_name opt_inline_handler opt_validator
			{
				CreatePLangStmt *n = makeNode(CreatePLangStmt);
				n->replace = $2;
				n->plname = $6;
				n->plhandler = $8;
				n->plinline = $9;
				n->plvalidator = $10;
				n->pltrusted = $3;
				$$ = (Node *)n;
			}
		;

opt_trusted:
			TRUSTED									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

/* This ought to be just func_name, but that causes reduce/reduce conflicts
 * (CREATE LANGUAGE is the only place where func_name isn't followed by '(').
 * Work around by using simple names, instead.
 */
handler_name:
			name						{ $$ = list_make1(makeString($1)); }
			| name attrs				{ $$ = lcons(makeString($1), $2); }
		;

opt_inline_handler:
			INLINE_P handler_name					{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

validator_clause:
			VALIDATOR handler_name					{ $$ = $2; }
			| NO VALIDATOR							{ $$ = NIL; }
		;

opt_validator:
			validator_clause						{ $$ = $1; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

DropPLangStmt:
			DROP opt_procedural LANGUAGE ColId_or_Sconst opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_LANGUAGE;
					n->objects = list_make1(list_make1(makeString($4)));
					n->arguments = NIL;
					n->behavior = $5;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *)n;
				}
			| DROP opt_procedural LANGUAGE IF_P EXISTS ColId_or_Sconst opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_LANGUAGE;
					n->objects = list_make1(list_make1(makeString($6)));
					n->behavior = $7;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *)n;
				}
		;

opt_procedural:
			PROCEDURAL								{}
			| /*EMPTY*/								{}
		;

tblspc_options:
			'(' tblspc_option_list ')'					{ $$ = $2; }
		;
opt_tblspc_options:		WITH tblspc_options					{ $$ = $2; }
			 |	/* EMPTY */						{ $$ = NIL; }
		;

tblspc_option_list:
			tblspc_option_elem						{ $$ = list_make1($1); }
			| tblspc_option_list ',' tblspc_option_elem			{ $$ = lappend($1, $3); }
		;

tblspc_option_elem:
			ColLabel '=' SCONST
			{
				$$ = makeDefElem($1, (Node *) makeString($3));
			}
			| ColLabel '=' func_type
			{
				if(0 != pg_strcasecmp($1, "filesystem"))
				{
        			const char* message = "Must use single quoted string for option";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					errmsg("Must use single quoted string for \"%s\" option.", $1)));
				}
				$$ = makeDefElem($1, (Node *) $3);
			}
			| ColLabel '=' NumericOnly
			{
				$$ = makeDefElem($1, (Node *) $3);
			}
		;
/*****************************************************************************
 *
 *		QUERY:
 *             CREATE TABLESPACE tablespace LOCATION '/path/to/tablespace/'
 *
 *****************************************************************************/

CreateTableSpaceStmt: CREATE TABLESPACE name OptTableSpaceOwner OptRelative LOCATION SCONST OptMaxSize opt_tblspc_options opt_engine
				{
					CreateTableSpaceStmt *n = makeNode(CreateTableSpaceStmt);
					n->tablespacename = $3;
					n->owner = $4;
					n->location = $7;
					n->maxsize = $8;
					n->options = $9;
					n->relative = $5;
					$$ = (Node *) n;
				}
				| CREATE TABLESPACE name LoggingStr DATAFILE SCONST OptDatafileSize OptReuse OptAuto opt_engine
				{
					CreateTableSpaceStmt *n = makeNode(CreateTableSpaceStmt);
					n->tablespacename = $3;
					n->owner = NULL;
					n->location = $6;
					n->maxsize = $7;
					$$ = (Node *) n;
				}
				| CREATE TABLESPACE name DATAFILE SCONST OptDatafileSize OptReuse OptAuto LoggingStr opt_engine
				{
					CreateTableSpaceStmt *n = makeNode(CreateTableSpaceStmt);
					n->tablespacename = $3;
					n->owner = NULL;
					n->location = $5;
					n->maxsize = $6;
					$$ = (Node *) n;
				}
				| CREATE TABLESPACE name DATAFILE SCONST OptDatafileSize OptReuse OptAuto opt_engine
				{
					CreateTableSpaceStmt *n = makeNode(CreateTableSpaceStmt);
					n->tablespacename = $3;
					n->owner = NULL;
					n->location = $5;
					n->maxsize = $6;
					$$ = (Node *) n;
				}
				| CREATE TABLESPACE name ADD_P DATAFILE SCONST opt_engine
				{
					CreateTableSpaceStmt *n = makeNode(CreateTableSpaceStmt);
					n->tablespacename = $3;
					n->owner = NULL;
					/* if filepath ends with ".ibd", transfer '.' to '_' */				
					char* path = $6;
					int path_len = strlen(path);
					if (path_len > 4 && strcmp(path + (path_len - 4), ".ibd") == 0) {
						path[path_len - 4] = '_';
						ereport(WARNING, (errmsg(
							"Suffix \".ibd\" of datafile path detected. The actual path will be renamed as \"%s\"", path)));
					}
					n->location = path;
					
					n->relative = !is_absolute_path(n->location);
					n->maxsize = NULL;
					$$ = (Node *) n;
				}
		;

LoggingStr:
			LOGGING									{ $$ = NULL ;}
			| NOLOGGING								{ $$ = NULL ;}
		;

OptDatafileSize:
			SIZE Iconst normal_ident 							{ $$ = NULL; }
			| /*EMPTY */								{ $$ = NULL; }
		;

OptReuse:
			REUSE									{ $$ = NULL; }
			| /*EMPTY */								{ $$ = NULL; }
		;

OptAuto:
			AUTOEXTEND ON OptNextStr OptMaxSize					{ $$ = NULL; }
			| AUTOEXTEND OFF							{ $$ = NULL; }
			| /*EMPTY */								{ $$ = NULL; }
		;

OptNextStr:
			NEXT Iconst normal_ident							{ $$ = NULL; }
			| /*EMPTY */								{ $$ = NULL; }
		;

OptMaxSize:
			MAXSIZE SCONST								{ $$ = $2; }
 			| /*EMPTY */								{  $$ = NULL;}
		;
size_clause:
			SCONST						        		{ $$ = $1; }
			| UNLIMITED                                 { $$ = "unlimited"; }
			;

OptRelative:
			RELATIVE_P									{ $$ = true; }
			| /*EMPTY */	 							{ $$ = false; }
		;

OptTableSpaceOwner: OWNER name			{ $$ = $2; }
			| /*EMPTY */				{ $$ = NULL; }
		;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP TABLESPACE <tablespace>
 *
 *		No need for drop behaviour as we cannot implement dependencies for
 *		objects in other databases; we can only support RESTRICT.
 *
 ****************************************************************************/

DropTableSpaceStmt: DROP TABLESPACE name opt_engine
				{
					DropTableSpaceStmt *n = makeNode(DropTableSpaceStmt);
					n->tablespacename = $3;
					n->missing_ok = false;
					$$ = (Node *) n;
				}
				|  DROP TABLESPACE IF_P EXISTS name opt_engine
				{
					DropTableSpaceStmt *n = makeNode(DropTableSpaceStmt);
					n->tablespacename = $5;
					n->missing_ok = true;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *             CREATE EXTENSION extension
 *             [ WITH ] [ SCHEMA schema ] [ VERSION version ] [ FROM oldversion ]
 *
 *****************************************************************************/

CreateExtensionStmt: CREATE EXTENSION name opt_with create_extension_opt_list
				{
					CreateExtensionStmt *n = makeNode(CreateExtensionStmt);
					n->extname = $3;
					n->if_not_exists = false;
					n->options = $5;
					$$ = (Node *) n;
				}
				| CREATE EXTENSION IF_P NOT EXISTS name opt_with create_extension_opt_list
				{
					CreateExtensionStmt *n = makeNode(CreateExtensionStmt);
					n->extname = $6;
					n->if_not_exists = true;
					n->options = $8;
					$$ = (Node *) n;
				}
		;

create_extension_opt_list:
			create_extension_opt_list create_extension_opt_item
				{ $$ = lappend($1, $2); }
			| /* EMPTY */
				{ $$ = NIL; }
		;

create_extension_opt_item:
			SCHEMA DolphinColId
				{
					$$ = makeDefElem("schema", (Node *)makeString(GetDolphinSchemaName($2->str, $2->is_quoted)));
				}
			| VERSION_P ColId_or_Sconst
				{
					$$ = makeDefElem("new_version", (Node *)makeString($2));
				}
			| FROM ColId_or_Sconst
				{
					$$ = makeDefElem("old_version", (Node *)makeString($2));
				}
		;
/*****************************************************************************
 *
 *		QUERY:
 *             CREATE OR REPLACE DIRECTORY directory AS '/path/to/directory/'
 *
 *****************************************************************************/

CreateDirectoryStmt:  CREATE opt_or_replace DIRECTORY name AS SCONST
				{
					CreateDirectoryStmt *n = makeNode(CreateDirectoryStmt);
					n->replace = $2;
					n->directoryname = $4;
					n->location = $6;
					n->owner = NULL;
					$$ = (Node *)n;
				}
	       	;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP DIRECTORY [IF EXISTS] directory
 *
 ****************************************************************************/

DropDirectoryStmt: DROP DIRECTORY name
				{
					DropDirectoryStmt *n = makeNode(DropDirectoryStmt);
					n->directoryname = $3;
					n->missing_ok = false;
					$$ = (Node *) n;
				}
		 | DROP DIRECTORY IF_P EXISTS name
                                { 
					DropDirectoryStmt *n = makeNode(DropDirectoryStmt);
					n->directoryname = $5;
					n->missing_ok = true;
					$$ = (Node *) n;
                                }
		;

/*****************************************************************************
 *
 * ALTER EXTENSION name UPDATE [ TO version ]
 *
 *****************************************************************************/

AlterExtensionStmt: ALTER EXTENSION name UPDATE alter_extension_opt_list
				{
					AlterExtensionStmt *n = makeNode(AlterExtensionStmt);
					n->extname = $3;
					n->options = $5;
					$$ = (Node *) n;
				}
		;

alter_extension_opt_list:
			alter_extension_opt_list alter_extension_opt_item
				{ $$ = lappend($1, $2); }
			| /* EMPTY */
				{ $$ = NIL; }
		;

alter_extension_opt_item:
			TO ColId_or_Sconst
				{
					$$ = makeDefElem("new_version", (Node *)makeString($2));
				}
		;

/*****************************************************************************
 *
 * ALTER EXTENSION name ADD/DROP object-identifier
 *
 *****************************************************************************/

AlterExtensionContentsStmt:
			ALTER EXTENSION name add_drop AGGREGATE func_name aggr_args
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_AGGREGATE;
					n->objname = $6;
					n->objargs = $7;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop EVENT_TRIGGER name
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_EVENT_TRIGGER;
					n->objname = list_make1(makeString($6));
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop CAST '(' Typename AS Typename ')'
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_CAST;
					n->objname = list_make1($7);
					n->objargs = list_make1($9);
					$$ = (Node *) n;
				}
			| ALTER EXTENSION name add_drop COLLATION any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_COLLATION;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop CONVERSION_P any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_CONVERSION;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop DOMAIN_P any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_DOMAIN;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop FUNCTION function_with_argtypes
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_FUNCTION;
					n->objname = $6->funcname;
					n->objargs = $6->funcargs;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop opt_procedural LANGUAGE name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_LANGUAGE;
					n->objname = list_make1(makeString($7));
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop OPERATOR any_operator oper_argtypes
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_OPERATOR;
					n->objname = $6;
					n->objargs = $7;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop OPERATOR CLASS any_name USING access_method
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_OPCLASS;
					n->objname = lcons(makeString($9), $7);
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop OPERATOR FAMILY any_name USING access_method
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_OPFAMILY;
					n->objname = lcons(makeString($9), $7);
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop SCHEMA DolphinColId
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_SCHEMA;
					n->objname = list_make1(makeString(GetDolphinSchemaName($6->str, $6->is_quoted)));
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TABLE dolphin_any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TABLE;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TEXT_P SEARCH PARSER any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TSPARSER;
					n->objname = $8;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TEXT_P SEARCH DICTIONARY any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TSDICTIONARY;
					n->objname = $8;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TEXT_P SEARCH TEMPLATE any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TSTEMPLATE;
					n->objname = $8;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TEXT_P SEARCH CONFIGURATION any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TSCONFIGURATION;
					n->objname = $8;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop SEQUENCE any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_SEQUENCE;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop VIEW any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_VIEW;
					n->objname = $6;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop MATERIALIZED VIEW any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_MATVIEW;
					n->objname = $7;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop FOREIGN TABLE dolphin_any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_FOREIGN_TABLE;
					n->objname = $7;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop FOREIGN DATA_P WRAPPER name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_FDW;
					n->objname = list_make1(makeString($8));
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop SERVER name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_FOREIGN_SERVER;
					n->objname = list_make1(makeString($6));
					$$ = (Node *)n;
				}
			| ALTER EXTENSION name add_drop TYPE_P any_name
				{
					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
					n->extname = $3;
					n->action = $4;
					n->objtype = OBJECT_TYPE;
					n->objname = $6;
					$$ = (Node *)n;
				}
		;
/*****************************************************************************
 *
 *             QUERY:
 *             CREATE WEAK PASSWORD DICTIONARY
 *
 *****************************************************************************/

CreateWeakPasswordDictionaryStmt:
        CREATE WEAK PASSWORD DICTIONARY opt_vals {u_sess->parser_cxt.isForbidTruncate = true;} weak_password_string_list
               {
                       u_sess->parser_cxt.isForbidTruncate = false;
                       CreateWeakPasswordDictionaryStmt *n = makeNode(CreateWeakPasswordDictionaryStmt);
                       n->weak_password_string_list = $7;
                       $$ = (Node*)n;
               }
			   ;

opt_vals:               WITH VALUES                                            {}
                       | /*EMPTY*/                                             {}
			   ;

weak_password_string_list:  '(' password_string ')'                                 { $$ = list_make1(makeString($2)); }
                       | weak_password_string_list ',' '(' password_string ')'      { $$ = lappend($1, makeString($4)); } 
               ;

/*****************************************************************************
 *
 *		QUERY:
 *				DROP WEAK PASSWORD DICTIONARY
 *
 *****************************************************************************/

DropWeakPasswordDictionaryStmt:
			DROP WEAK PASSWORD DICTIONARY 
				{
					DropWeakPasswordDictionaryStmt *n = makeNode(DropWeakPasswordDictionaryStmt);
					$$ = (Node *)n;
				}
		;
					
/*****************************************************************************
 *
 *		QUERY:
 *             CREATE FOREIGN DATA WRAPPER name options
 *
 *****************************************************************************/

CreateFdwStmt: CREATE FOREIGN DATA_P WRAPPER name opt_fdw_options create_generic_options
				{
					CreateFdwStmt *n = makeNode(CreateFdwStmt);
					n->fdwname = $5;
					n->func_options = $6;
					n->options = $7;
					$$ = (Node *) n;
				}
		;

fdw_option:
			HANDLER handler_name				{ $$ = makeDefElem("handler", (Node *)$2); }
			| NO HANDLER						{ $$ = makeDefElem("handler", NULL); }
			| VALIDATOR handler_name			{ $$ = makeDefElem("validator", (Node *)$2); }
			| NO VALIDATOR						{ $$ = makeDefElem("validator", NULL); }
		;

fdw_options:
			fdw_option							{ $$ = list_make1($1); }
			| fdw_options fdw_option			{ $$ = lappend($1, $2); }
		;

opt_fdw_options:
			fdw_options							{ $$ = $1; }
			| /*EMPTY*/							{ $$ = NIL; }
		;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP FOREIGN DATA WRAPPER name
 *
 ****************************************************************************/

DropFdwStmt: DROP FOREIGN DATA_P WRAPPER name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FDW;
					n->objects = list_make1(list_make1(makeString($5)));
					n->arguments = NIL;
					n->missing_ok = false;
					n->behavior = $6;
					n->concurrent = false;
					$$ = (Node *) n;
				}
				|  DROP FOREIGN DATA_P WRAPPER IF_P EXISTS name opt_drop_behavior
                {
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FDW;
					n->objects = list_make1(list_make1(makeString($7)));
					n->arguments = NIL;
					n->missing_ok = true;
					n->behavior = $8;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY :
 *				ALTER FOREIGN DATA WRAPPER name options
 *
 ****************************************************************************/

AlterFdwStmt: ALTER FOREIGN DATA_P WRAPPER name opt_fdw_options alter_generic_options
				{
					AlterFdwStmt *n = makeNode(AlterFdwStmt);
					n->fdwname = $5;
					n->func_options = $6;
					n->options = $7;
					$$ = (Node *) n;
				}
			| ALTER FOREIGN DATA_P WRAPPER name fdw_options
				{
					AlterFdwStmt *n = makeNode(AlterFdwStmt);
					n->fdwname = $5;
					n->func_options = $6;
					n->options = NIL;
					$$ = (Node *) n;
				}
		;

/* Options definition for CREATE FDW, SERVER and USER MAPPING */
create_generic_options:
			OPTIONS '(' generic_option_list ')'			{ $$ = $3; }
			| /*EMPTY*/									{ $$ = NIL; }
		;

generic_option_list:
			generic_option_elem
				{
					$$ = list_make1($1);
				}
			| generic_option_list ',' generic_option_elem
				{
					$$ = lappend($1, $3);
				}
		;

/* Options definition for ALTER FDW, SERVER and USER MAPPING */
alter_generic_options:
			OPTIONS	'(' alter_generic_option_list ')'		{ $$ = $3; }
		;

alter_generic_option_list:
			alter_generic_option_elem
				{
					$$ = list_make1($1);
				}
			| alter_generic_option_list ',' alter_generic_option_elem
				{
					$$ = lappend($1, $3);
				}
		;

alter_generic_option_elem:
			generic_option_elem
				{
					$$ = $1;
				}
			| SET generic_option_elem
				{
					$$ = $2;
					$$->defaction = DEFELEM_SET;
				}
			| ADD_P generic_option_elem
				{
					$$ = $2;
					$$->defaction = DEFELEM_ADD;
				}
			| DROP generic_option_name
				{
					$$ = makeDefElemExtended(NULL, $2, NULL, DEFELEM_DROP);
				}
		;

generic_option_elem:
			generic_option_name generic_option_arg
				{
                    if (strcmp($1, "error_table") == 0) {
        				const char* message = "Invalid option";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                        ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("Invalid option %s", $1)));
					}

					$$ = makeDefElem($1, $2);
				}
		;

generic_option_name:
				ColLabel			{ $$ = $1; }
		;

/* We could use def_arg here, but the spec only requires string literals */
generic_option_arg:
				SCONST				{ $$ = (Node *) makeString($1); }
				| Iconst
					{
						char buf[64];
						errno_t rc = snprintf_s(buf, sizeof(buf), sizeof(buf) - 1, "%d", $1);
						securec_check_ss(rc, "\0", "\0");
						$$ = (Node *) makeString(pstrdup(buf));
					}
		;

/*****************************************************************************
 *
 *		QUERY:
 *             CREATE SERVER name [TYPE] [VERSION] [OPTIONS]
 *
 *****************************************************************************/
fdwName:    normal_ident           { $$ = $1;};

CreateForeignServerStmt: CREATE SERVER name opt_type opt_foreign_server_version
						 FOREIGN DATA_P WRAPPER fdwName create_generic_options
				{
					CreateForeignServerStmt *n = makeNode(CreateForeignServerStmt);
					n->servername = $3;
					n->servertype = $4;
					n->version = $5;
					n->fdwname = $9;
					n->options = $10;
					$$ = (Node *) n;
				}
		;

opt_type:
			TYPE_P SCONST			{ $$ = $2; }
			| /*EMPTY*/				{ $$ = NULL; }
		;


foreign_server_version:
			VERSION_P SCONST		{ $$ = $2; }
		|	VERSION_P NULL_P		{ $$ = NULL; }
		;

opt_foreign_server_version:
			foreign_server_version	{ $$ = $1; }
			| /*EMPTY*/				{ $$ = NULL; }
		;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP SERVER name
 *
 ****************************************************************************/

DropForeignServerStmt: DROP SERVER name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FOREIGN_SERVER;
					n->objects = list_make1(list_make1(makeString($3)));
					n->arguments = NIL;
					n->missing_ok = false;
					n->behavior = $4;
					n->concurrent = false;
					$$ = (Node *) n;
				}
				|  DROP SERVER IF_P EXISTS name opt_drop_behavior
                {
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FOREIGN_SERVER;
					n->objects = list_make1(list_make1(makeString($5)));
					n->arguments = NIL;
					n->missing_ok = true;
					n->behavior = $6;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY :
 *				ALTER SERVER name [VERSION] [OPTIONS]
 *
 ****************************************************************************/

AlterForeignServerStmt: ALTER SERVER name foreign_server_version alter_generic_options
				{
					AlterForeignServerStmt *n = makeNode(AlterForeignServerStmt);
					n->servername = $3;
					n->version = $4;
					n->options = $5;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER SERVER name foreign_server_version
				{
					AlterForeignServerStmt *n = makeNode(AlterForeignServerStmt);
					n->servername = $3;
					n->version = $4;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER SERVER name alter_generic_options
				{
					AlterForeignServerStmt *n = makeNode(AlterForeignServerStmt);
					n->servername = $3;
					n->options = $4;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *             CREATE FOREIGN TABLE relname (...) SERVER name (...)
 *
 *****************************************************************************/

CreateForeignTableStmt:
		CREATE FOREIGN TABLE dolphin_qualified_name
			OptForeignTableElementList
			SERVER name create_generic_options ForeignTblWritable
			OptForeignTableLogError OptForeignTableLogRemote OptPerNodeRejectLimit OptDistributeBy
/* PGXC_BEGIN */
			OptSubCluster
/* PGXC_END */
			OptForeignPartBy
				{
					CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
					$4->relpersistence = RELPERSISTENCE_PERMANENT;
					n->base.relation = $4;
					n->base.tableElts = $5;
					n->base.inhRelations = NIL;
					n->base.if_not_exists = false;
					/* FDW-specific data */
					n->servername = $7;
					n->options = $8;

					n->write_only = $9;
					n->error_relation = (Node*)$10;
					if ($11 != NULL)
						n->extOptions = lappend(n->extOptions, $11);
					if ($12 != NULL)
						n->extOptions = lappend(n->extOptions, $12);
					n->base.distributeby = $13;
/* PGXC_BEGIN */
					n->base.subcluster = $14;
/* PGXC_END */
					if ($15 != NULL)
						n->part_state = $15;

					$$ = (Node *) n;
				}
		| CREATE FOREIGN TABLE IF_P NOT EXISTS dolphin_qualified_name
			OptForeignTableElementList
			SERVER name create_generic_options ForeignTblWritable
			OptForeignTableLogError OptForeignTableLogRemote OptPerNodeRejectLimit OptDistributeBy
/* PGXC_BEGIN */
			OptSubCluster
/* PGXC_END */
			OptForeignPartBy
				{
					CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
					$7->relpersistence = RELPERSISTENCE_PERMANENT;
					n->base.relation = $7;
					n->base.tableElts = $8;
					n->base.inhRelations = NIL;
					n->base.if_not_exists = true;
					/* FDW-specific data */
					n->servername = $10;
					n->options = $11;

					n->write_only = $12;
					n->error_relation = (Node*)$13;
					if ($14 != NULL)
						n->extOptions = lappend(n->extOptions, $14);
					if ($15 != NULL)
						n->extOptions = lappend(n->extOptions, $15);
					n->base.distributeby = $16;
/* PGXC_BEGIN */
					n->base.subcluster = $17;
/* PGXC_END */
					if ($18 != NULL)
						n->part_state = $18;

					$$ = (Node *) n;
				}
/* ENABLE_MOT BEGIN */
                | CREATE FOREIGN TABLE dolphin_qualified_name
			OptForeignTableElementList
			create_generic_options ForeignTblWritable
			OptForeignTableLogError OptForeignTableLogRemote OptPerNodeRejectLimit OptDistributeBy
/* PGXC_BEGIN */
			OptSubCluster
/* PGXC_END */
			OptForeignPartBy
				{
					CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
					$4->relpersistence = RELPERSISTENCE_PERMANENT;
					n->base.relation = $4;
					n->base.tableElts = $5;
					n->base.inhRelations = NIL;
					n->base.if_not_exists = false;
					/* FDW-specific data */
#ifdef ENABLE_MOT
					n->servername = pstrdup("mot_server");
#else
        			const char* message = "Foreign server is not specified";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                    ereport(errstate,
                        (errcode(ERRCODE_SYNTAX_ERROR),
                            errmsg("Foreign server is not specified")));
#endif
					n->options = $6;

					n->write_only = $7;
					n->error_relation = (Node*)$8;
					if ($9 != NULL)
						n->extOptions = lappend(n->extOptions, $9);
					if ($10 != NULL)
						n->extOptions = lappend(n->extOptions, $10);
					n->base.distributeby = $11;
/* PGXC_BEGIN */
					n->base.subcluster = $12;
/* PGXC_END */
					if ($13 != NULL)
						n->part_state = $13;

					$$ = (Node *) n;
				}
               | CREATE FOREIGN TABLE IF_P NOT EXISTS dolphin_qualified_name
			OptForeignTableElementList
			create_generic_options ForeignTblWritable
			OptForeignTableLogError OptForeignTableLogRemote OptPerNodeRejectLimit OptDistributeBy
/* PGXC_BEGIN */
			OptSubCluster
/* PGXC_END */
			OptForeignPartBy
				{
					CreateForeignTableStmt *n = makeNode(CreateForeignTableStmt);
					$7->relpersistence = RELPERSISTENCE_PERMANENT;
					n->base.relation = $7;
					n->base.tableElts = $8;
					n->base.inhRelations = NIL;
					n->base.if_not_exists = true;
					/* FDW-specific data */
#ifdef ENABLE_MOT
					n->servername = pstrdup("mot_server");
#else
        			const char* message = "Foreign server is not specified";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                    ereport(errstate,
                        (errcode(ERRCODE_SYNTAX_ERROR),
                            errmsg("Foreign server is not specified")));
#endif
					n->options = $9;

					n->write_only = $10;
					n->error_relation = (Node*)$11;
					if ($12 != NULL)
						n->extOptions = lappend(n->extOptions, $12);
					if ($13 != NULL)
						n->extOptions = lappend(n->extOptions, $13);
					n->base.distributeby = $14;
/* PGXC_BEGIN */
					n->base.subcluster = $15;
/* PGXC_END */
					if ($16 != NULL)
						n->part_state = $16;

					$$ = (Node *) n;
				}
/* ENABLE_MOT END */
		;

ForeignTblWritable : WRITE ONLY  { $$ = true; }
					| READ ONLY   { $$ = false; }
					| /* EMPTY */ { $$ = false; }
				;

OptForeignTableElementList:
					'(' ForeignTableElementList ')'			{ $$ = $2; }
					| '(' ')'								{ $$ = NIL; }
				;

ForeignTableElementList:
				ForeignTableElement
					{
						$$ = list_make1($1);
					}
				| ForeignTableElementList ',' ForeignTableElement
					{
						$$ = lappend($1, $3);
					}
			;

ForeignTableElement:
			ForeignColDef						{ $$ = $1; }
			| ForeignTableLikeClause			{ $$ = $1; }
			| TableConstraint					{ $$ = $1; } /* @hdfs Add informational constraint syntax on the HDFS foreign table. */
		;
ForeignColDef: ColId Typename ForeignPosition create_generic_options  ColQualList
				{
					ColumnDef *n = makeNode(ColumnDef);
					n->colname = $1;
					n->typname = $2;
					n->inhcount = 0;
					n->is_local = true;
					n->is_not_null = false;
					n->is_from_type = false;
					n->storage = 0;
					n->raw_default = NULL;
					n->cooked_default = NULL;
					n->collOid = InvalidOid;
					n->fdwoptions = $4;
					n->clientLogicColumnRef=NULL;
					SplitColQualList($5, &n->constraints, &n->collClause, &n->columnOptions,
										yyscanner);
					if ($3)
					{
						((Position*)$3)->colname = pstrdup($1);
						n->position = (Position*)$3;
					}
					$$ = (Node*)n;
				}
		;

ForeignPosition:
			POSITION '(' Iconst ',' Iconst ')'
				{
					Position *n = makeNode(Position);
					n->position = $3;
					n->fixedlen = $5;
					$$ = (Node*)n;
				}
			| /*EMPTY*/ 								{ $$ = NULL; }
		;

ForeignTableLikeClause:
			LIKE dolphin_qualified_name				
				{					
					TableLikeClause *n = makeNode(TableLikeClause);
					n->relation = $2;
					$$ = (Node *)n;
				}
		;	

OptForeignTableLogError:
			LOG_P INTO dolphin_qualified_name 	{ $$ = (Node*)$3; }
			| WITH  dolphin_qualified_name 		{ $$ = (Node*)$2; }
			| /*EMPTY*/ 				{ $$ = NULL;}
		;

OptForeignTableLogRemote:
			REMOTE_P LOG_P SCONST
				{
					$$ = (Node*)makeDefElem("log_remote", (Node *)makeString($3));
				}
			|REMOTE_P LOG_P
				{
					$$ = (Node*)makeDefElem("log_remote", (Node*)makeString(""));
				}
			| /* EMPTY */				{ $$ = NULL; }
		;

OptPerNodeRejectLimit:
			PER_P NODE REJECT_P LIMIT SCONST
				{
					$$ = (Node*)makeDefElem("reject_limit", (Node*)makeString($5));
				}
			| /*EMPTY*/ 					{ $$ = NULL; }
		;

OptForeignPartBy:
			OptForeignPartAuto          { $$ = $1; }
			| /*EMPTY*/                 { $$ = NULL; }
		;

OptForeignPartAuto: PARTITION BY '(' partition_item_list ')' AUTOMAPPED
			{
				ForeignPartState *n = makeNode(ForeignPartState);
				n->partitionKey = $4;
				$$ = n;
			}
		| PARTITION BY '(' partition_item_list ')'
			{
				ForeignPartState *n = makeNode(ForeignPartState);
				n->partitionKey = $4;
				$$ = n;
			}
		;

partition_item_list:
		partition_item
			{
				$$ = list_make1($1);
			}
		| partition_item_list ',' partition_item
			{
				$$ = lappend($1, $3);
			}
		;

partition_item:
		ColId
			{
				$$ = makeColumnRef($1, NIL, @1, yyscanner);
			}
		;

/*****************************************************************************
 *
 *		QUERY:
 *             ALTER FOREIGN TABLE relname [...]
 *
 *****************************************************************************/

AlterForeignTableStmt:
			ALTER FOREIGN TABLE relation_expr alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $4;
					n->cmds = $5;
					n->relkind = OBJECT_FOREIGN_TABLE;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr alter_table_cmds
				{
					AlterTableStmt *n = makeNode(AlterTableStmt);
					n->relation = $6;
					n->cmds = $7;
					n->relkind = OBJECT_FOREIGN_TABLE;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
            | ALTER FOREIGN TABLE relation_expr MODIFY_P '(' modify_column_cmds ')'
                {
                    AlterTableStmt *n = makeNode(AlterTableStmt);
                    n->relation = $4;
                    n->cmds = $7;
                    n->relkind = OBJECT_FOREIGN_TABLE;
                    n->missing_ok = false;
                    $$ = (Node *)n;
                }
            | ALTER FOREIGN TABLE IF_P EXISTS relation_expr MODIFY_P '(' modify_column_cmds ')'
                {
                    AlterTableStmt *n = makeNode(AlterTableStmt);
                    n->relation = $6;
                    n->cmds = $9;
                    n->relkind = OBJECT_FOREIGN_TABLE;
                    n->missing_ok = true;
                    $$ = (Node *)n;
                }
		;

/*****************************************************************************
 *
 *		QUERY:
 *             CREATE USER MAPPING FOR auth_ident SERVER name [OPTIONS]
 *
 *****************************************************************************/

CreateUserMappingStmt: CREATE USER MAPPING FOR auth_ident SERVER name create_generic_options
				{
					CreateUserMappingStmt *n = makeNode(CreateUserMappingStmt);
					n->username = $5;
					n->servername = $7;
					n->options = $8;
					$$ = (Node *) n;
				}
		;

/* User mapping authorization identifier */
auth_ident:
			CURRENT_USER opt_bracket			{ $$ = "current_user"; }
		|	DolphinRoleIdWithOutCurrentUser		{ $$ = DolphinObjNameCmp($1->str, "public", $1->is_quoted) ? NULL : $1->str; }
		;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP USER MAPPING FOR auth_ident SERVER name
 *
 ****************************************************************************/

DropUserMappingStmt: DROP USER MAPPING FOR auth_ident SERVER name
				{
					DropUserMappingStmt *n = makeNode(DropUserMappingStmt);
					n->username = $5;
					n->servername = $7;
					n->missing_ok = false;
					$$ = (Node *) n;
				}
				|  DROP USER MAPPING IF_P EXISTS FOR auth_ident SERVER name
				{
					DropUserMappingStmt *n = makeNode(DropUserMappingStmt);
					n->username = $7;
					n->servername = $9;
					n->missing_ok = true;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY :
 *				ALTER USER MAPPING FOR auth_ident SERVER name OPTIONS
 *
 ****************************************************************************/

AlterUserMappingStmt: ALTER USER MAPPING FOR auth_ident SERVER name alter_generic_options
				{
					AlterUserMappingStmt *n = makeNode(AlterUserMappingStmt);
					n->username = $5;
					n->servername = $7;
					n->options = $8;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERY:
 *				CREATE MODEL <model_name>
 *
 *
 *****************************************************************************/


CreateModelStmt:
		CREATE MODEL ColId
		USING ColId
		features_clause
		target_clause
		from_clause
		with_hyperparameters_clause
	{
		CreateModelStmt *n = makeNode(CreateModelStmt);
		n->model 			= pstrdup($3);
		n->architecture 	= pstrdup($5);
		n->model_features 	= $6;
		n->model_target   	= $7;

		// The clause will be constructed in tranform
		SelectStmt *s = makeNode(SelectStmt);
		s->fromClause = $8;	

		n->select_query = (Node*) s;
		n->hyperparameters  = $9;

		$$ = (Node*) n;
	}
	;

features_clause:
	FEATURES target_list{
		List* result = $2;

		// Verify that target clause is not '*'
		foreach_cell(it, result){
			ResTarget* n = (ResTarget*) lfirst(it);
			ColumnRef* cr = (n->val != NULL && IsA(n->val, ColumnRef)) ? (ColumnRef*)(n->val) : NULL;
			List* l = (cr != NULL) ? cr->fields : NULL;
			Node* node = list_length(l) > 0 ? linitial_node(Node, l) : NULL;
			if (node != NULL && IsA(node, A_Star)){
				elog(errstate, "FEATURES clause cannot be *");
			}		
		}

		$$ = result;
	}
	| {
		List* result = NULL;
		$$ = result;
	}
	;

target_clause:
	TARGET target_list{
		List* result = $2;

		// Verify that target clause is not '*'
		foreach_cell(it, result){
			ResTarget* n = (ResTarget*) lfirst(it);
			ColumnRef* cr = (n->val != NULL && IsA(n->val, ColumnRef)) ? (ColumnRef*)(n->val) : NULL;
			List* l = (cr != NULL) ? cr->fields : NULL;
			Node* node = list_length(l) > 0 ? linitial_node(Node, l) : NULL;
			if (node != NULL && IsA(node, A_Star)){
				elog(errstate, "TARGET clause cannot be *");
			}
		}

		$$ = result;
	}
	| {
		List* result = NULL;
		$$ = result;
	}
	;

with_hyperparameters_clause:
	WITH hyperparameter_name_value_list { $$ = $2; }
	| { $$ = NULL; }
	;

hyperparameter_name_value_list:
	hyperparameter_name_value		{ $$ = list_make1($1); }
	| hyperparameter_name_value_list ',' hyperparameter_name_value
	{
		$$ = lappend($1,$3);
	}
	;

hyperparameter_name_value:
	ColLabel '=' var_value
	{
		VariableSetStmt *n = makeNode(VariableSetStmt);
		n->kind = VAR_SET_VALUE;
		n->name = $1;
		n->args = list_make1($3);
		$$ = (Node*) n;
	}
	| ColLabel '=' DEFAULT
	{
		VariableSetStmt *n = makeNode(VariableSetStmt);
		n->kind = VAR_SET_DEFAULT;
		n->name = $1;
		n->args = NULL;
		$$ = (Node*) n;
	}
	;

DropModelStmt:
	DROP MODEL ColId opt_drop_behavior
	{
		DropStmt *n = makeNode(DropStmt);
		n->removeType = OBJECT_DB4AI_MODEL;
		n->objects = list_make1(list_make1(makeString($3)));
		n->arguments = NULL;
		n->behavior = $4;
		n->missing_ok = false;
		n->concurrent = false;
		n->isProcedure = false;
		$$ = (Node *)n;
	}
	;

/*****************************************************************************
 *
 *      QUERIES For ROW LEVEL SECURITY:
 *              CREATE [ROW LEVEL SECURITY] POLICY name ON table
 *                  [AS { PERMISSIVE | RESTRICTIVE }]
 *                  [FOR { ALL | SELECT | INSERT | UPDATE | DELETE }]
 *                  [TO role, ...]
 *                  [USING (qual)]
 *
 *              ALTER [ROW LEVEL SECURITY] POLICY name ON table
 *                  [TO role, ...]
 *                  [USING (qual)]
 *
 *              DROP [ROW LEVEL SECURITY] POLIICY [IF EXISTS] name ON table [CASCADE | RESTRICT]
 *
 *****************************************************************************/

CreateRlsPolicyStmt:
			CREATE RowLevelSecurityPolicyName ON dolphin_qualified_name RLSDefaultPermissive
				RLSDefaultForCmd RLSDefaultToRole
				RLSOptionalUsingExpr
				{
					/* Did not support INSERT, MERGE yet */
					if (strcmp($6, "insert") == 0 ||
						strcmp($6, "merge") == 0)
					{
        				const char* message = "Row Level Security is not yet supported for INSERT and MERGE";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("Row Level Security is not yet supported for INSERT and MERGE")));
					}
					CreateRlsPolicyStmt *n = makeNode(CreateRlsPolicyStmt);
					n->fromExternal = true;
					n->policyName = $2;
					n->relation = $4;
					n->isPermissive = $5;
					n->cmdName = $6;
					n->roleList = $7;
					n->usingQual = $8;
					$$ = (Node *) n;
				}
		;

AlterRlsPolicyStmt:
			ALTER RowLevelSecurityPolicyName ON dolphin_qualified_name RLSOptionalToRole
				RLSOptionalUsingExpr
				{
					AlterRlsPolicyStmt *n = makeNode(AlterRlsPolicyStmt);
					n->policyName = $2;
					n->relation = $4;
					n->roleList = $5;
					n->usingQual = $6;
					$$ = (Node *) n;
				}
		;

DropRlsPolicyStmt:
			DROP RowLevelSecurityPolicyName ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_RLSPOLICY;
					n->objects = list_make1(lappend($4, makeString($2)));
					n->arguments = NIL;
					n->behavior = $5;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP POLICY IF_P EXISTS name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_RLSPOLICY;
					n->objects = list_make1(lappend($7, makeString($5)));
					n->arguments = NIL;
					n->behavior = $8;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP ROW LEVEL SECURITY POLICY IF_P EXISTS name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_RLSPOLICY;
					n->objects = list_make1(lappend($10, makeString($8)));
					n->arguments = NIL;
					n->behavior = $11;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;

RowLevelSecurityPolicyName:
			ROW LEVEL SECURITY POLICY name	{ $$ = $5; }
			| POLICY name						{ $$ = $2; }
		;

RLSOptionalUsingExpr:
			USING '(' a_expr ')'	{ $$ = $3; }
			| /* EMPTY */			{ $$ = NULL; }
		;

RLSDefaultToRole:
			TO row_level_security_role_list			{ $$ = $2; }
			| /* EMPTY */			{ $$ = list_make1(makeString("public")); }
		;

RLSOptionalToRole:
			TO row_level_security_role_list			{ $$ = $2; }
			| /* EMPTY */			{ $$ = NULL; }
		;

row_level_security_role_list: row_level_security_role
							{ $$ = list_make1(makeString($1)); }
					|	row_level_security_role_list ',' row_level_security_role
							{ $$ = lappend($1, makeString($3)); }
					;

row_level_security_role:
			DolphinRoleIdWithOutCurrentUser		{ char* result = "public"; $$ = DolphinObjNameCmp($1->str, "public", $1->is_quoted) ? result : $1->str; }
		|	CURRENT_USER opt_bracket			{ $$ = pstrdup($1); }
		|	SESSION_USER						{ $$ = pstrdup($1); }

		;

RLSDefaultPermissive:
			AS normal_ident
				{
					if (strcmp($2, "permissive") == 0)
						$$ = true;
					else if (strcmp($2, "restrictive") == 0)
						$$ = false;
					else {
        				const char* message = "unrecognized row security option";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("unrecognized row security option \"%s\"", $2),
								 errhint("Only PERMISSIVE or RESTRICTIVE policies are supported currently."),
									 parser_errposition(@2)));
					}
				}
			| /* EMPTY */			{ $$ = true; }
		;

RLSDefaultForCmd:
			FOR row_level_security_cmd	{ $$ = $2; }
			| /* EMPTY */			{ $$ = "all"; }
		;

row_level_security_cmd:
			ALL				{ $$ = "all"; }
		|	SELECT			{ $$ = "select"; }
		|	UPDATE			{ $$ = "update"; }
		|	DELETE_P		{ $$ = "delete"; }
		|	INSERT			{ $$ = "insert"; }
		|	MERGE			{ $$ = "merge"; }
		;

/*****************************************************************************
 *
 *		QUERIES:
 *				CREATE OR REPLACE SYNONYM STATEMENTS
 *
 *****************************************************************************/

CreateSynonymStmt:
			CREATE opt_or_replace SYNONYM any_name FOR any_name
				{
					CreateSynonymStmt *n = makeNode(CreateSynonymStmt);
					n->replace = $2;
					n->synName = $4;
					n->objName = $6;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERIES:
 *				DROP SYNONYM STATEMENTS
 *
 *****************************************************************************/

DropSynonymStmt:
			DROP SYNONYM any_name  opt_drop_behavior
				{
					DropSynonymStmt *n = makeNode(DropSynonymStmt);
					n->synName = $3;
					n->behavior = $4;
					n->missing = false;
					$$ = (Node *) n;
				}
			| DROP SYNONYM IF_P EXISTS any_name  opt_drop_behavior
				{
					DropSynonymStmt *n = makeNode(DropSynonymStmt);
					n->synName = $5;
					n->behavior = $6;
					n->missing = true;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERY:
 *             CREATE DATA SOURCE name [TYPE] [VERSION] [OPTIONS]
 *
 *****************************************************************************/

CreateDataSourceStmt: CREATE DATA_P SOURCE_P name opt_data_source_type 
				opt_data_source_version create_generic_options
				{
					CreateDataSourceStmt *n = makeNode(CreateDataSourceStmt);
					n->srcname = $4;
					n->srctype = $5;
					n->version = $6;
					n->options = $7;
					$$ = (Node *) n;
				}
		;

data_source_type:
			TYPE_P SCONST			{ $$ = $2; }
		;

opt_data_source_type:
			data_source_type			{ $$ = $1; }
			| /*EMPTY*/				{ $$ = NULL; }
		;

data_source_version:
			VERSION_P SCONST		{ $$ = $2; }
			| VERSION_P NULL_P		{ $$ = NULL; }
		;

opt_data_source_version:
			data_source_version	{ $$ = $1; }
			| /*EMPTY*/				{ $$ = NULL; }
		;

/*****************************************************************************
 *
 *		QUERY :
 *				ALTER DATA SOURCE name [TYPE] [VERSION] [OPTIONS]
 *
 ****************************************************************************/

AlterDataSourceStmt: ALTER DATA_P SOURCE_P name data_source_type data_source_version alter_generic_options
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->srctype = $5;
					n->version = $6;
					n->options = $7;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name data_source_type data_source_version
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->srctype = $5;
					n->version = $6;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name data_source_type alter_generic_options
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->srctype = $5;
					n->options = $6;
					n->has_version = false;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name data_source_version alter_generic_options
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->version = $5;
					n->options = $6;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name data_source_type
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->srctype = $5;
					n->has_version = false;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name data_source_version
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->version = $5;
					n->has_version = true;
					$$ = (Node *) n;
				}
			| ALTER DATA_P SOURCE_P name alter_generic_options
				{
					AlterDataSourceStmt *n = makeNode(AlterDataSourceStmt);
					n->srcname = $4;
					n->options = $5;
					n->has_version = false;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERY :
 *				DROP DATA SOURCE name
 *
 ****************************************************************************/

DropDataSourceStmt: DROP DATA_P SOURCE_P name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_DATA_SOURCE;
					n->objects = list_make1(list_make1(makeString($4)));
					n->arguments = NIL;
					n->missing_ok = false;
					n->behavior = $5;
					n->concurrent = false;
					$$ = (Node *) n;
				}
				|  DROP DATA_P SOURCE_P IF_P EXISTS name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_DATA_SOURCE;
					n->objects = list_make1(list_make1(makeString($6)));
					n->arguments = NIL;
					n->missing_ok = true;
					n->behavior = $7;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;

/*****************************************************************************
 *
 *		QUERIES :
 *				CREATE TRIGGER ...
 *				DROP TRIGGER ...
 *
 *****************************************************************************/

CreateTrigStmt:
			CREATE opt_or_replace definer_user TRIGGER qualified_trigger_name DolphinTriggerActionTime TriggerEvents ON
			dolphin_qualified_name TriggerForSpec TriggerWhen
			EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')'
				{
					if ($2 != false)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
							 	errmsg("syntax error.")));
					}
					if ($3 != NULL)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("only support definer in B compatibility database and B syntax")));
					}
					CreateTrigStmt *n = makeNode(CreateTrigStmt);
					n->definer = $3;
					n->if_not_exists = false;
					n->schemaname = $5->schemaname;
					n->trigname = $5->relname;					
					n->relation = $9;
					n->funcname = $14;
					n->args = $16;
					n->row = $10;
					n->timing = $6;
					n->events = intVal(linitial($7));
					n->columns = (List *) lsecond($7);
					n->whenClause = $11;
					n->isconstraint  = FALSE;
					n->deferrable	 = FALSE;
					n->initdeferred  = FALSE;
					n->constrrel = NULL;
					n->funcSource = NULL;
					n->trgordername = NULL;
					n->is_follows = NULL;
					$$ = (Node *)n;
				}
			| CREATE CONSTRAINT TRIGGER qualified_trigger_name AFTER TriggerEvents ON
			dolphin_qualified_name OptConstrFromTable ConstraintAttributeSpec
			FOR EACH ROW TriggerWhen
			EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')'
				{
					CreateTrigStmt *n = makeNode(CreateTrigStmt);
					n->schemaname = $4->schemaname;
					n->trigname = $4->relname;
					n->definer = NULL;
					n->if_not_exists  = false;
					n->relation = $8;
					n->funcname = $17;
					n->args = $19;
					n->row = TRUE;
					n->timing = TRIGGER_TYPE_AFTER;
					n->events = intVal(linitial($6));
					n->columns = (List *) lsecond($6);
					n->whenClause = $14;
					n->isconstraint  = TRUE;
					processCASbits($10, @10, "TRIGGER",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
					n->constrrel = $9;
					n->funcSource = NULL;
					n->trgordername = NULL;
					n->is_follows = NULL;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user TRIGGER qualified_trigger_name DolphinTriggerActionTime TriggerEvents ON
			dolphin_qualified_name TriggerForSpec TriggerWhen
			trigger_order
			{
				u_sess->parser_cxt.eaten_declare = false;
				u_sess->parser_cxt.eaten_begin = false;
				pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
				u_sess->parser_cxt.isCreateFuncOrProc = true;
			} triggerbody_subprogram_or_single
				{
					if ($2 != false)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("syntax error.")));
					}
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("Current syntax is supported only in B compatibility database")));
					}
					CreateTrigStmt *n = makeNode(CreateTrigStmt);
					
					n->definer = $3;
					n->if_not_exists = false;
					n->schemaname = $5->schemaname;
					n->trigname = $5->relname;
					n->timing = $6;
					n->events = intVal(linitial($7));
					n->columns = (List *) lsecond($7);
					n->relation = $9;
					n->row = $10;
					n->whenClause = $11;
					n->trgordername = $12->trigger_name;
					n->is_follows = $12->is_follows;
					FunctionSources *funSource = (FunctionSources *)$14;
					n->funcSource = funSource;
					n->isconstraint  = FALSE;
					n->deferrable	 = FALSE;
					n->initdeferred  = FALSE;
					n->constrrel = NULL;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user TRIGGER IF_P NOT EXISTS qualified_trigger_name DolphinTriggerActionTime TriggerEvents ON
			dolphin_qualified_name TriggerForSpec TriggerWhen
			trigger_order
			{
				u_sess->parser_cxt.eaten_declare = false;
				u_sess->parser_cxt.eaten_begin = false;
				pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
				u_sess->parser_cxt.isCreateFuncOrProc = true;
			} triggerbody_subprogram_or_single
				{
					if ($2 != false)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("syntax error.")));
					}
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT)
					{
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("Current syntax is supported only in B compatibility database")));
					}
					CreateTrigStmt *n = makeNode(CreateTrigStmt);
					
					n->definer = $3;
					n->if_not_exists = true;
					n->schemaname = $8->schemaname;
					n->trigname = $8->relname;
					n->timing = $9;
					n->events = intVal(linitial($10));
					n->columns = (List *) lsecond($10);
					n->relation = $12;
					n->row = $13;
					n->whenClause = $14;
					n->trgordername = $15->trigger_name;
					n->is_follows = $15->is_follows;
					FunctionSources *funSource = (FunctionSources *)$17;
					n->funcSource = funSource;
					n->isconstraint  = FALSE;
					n->deferrable	 = FALSE;
					n->initdeferred  = FALSE;
					n->constrrel = NULL;
					$$ = (Node *)n;
				}
                       ;

triggerbody_subprogram_or_single:
			{
				if (yychar == YYEOF || yychar == YYEMPTY) 
				{
					base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
					int count = strlen(yyextra->core_yy_extra.scanbuf);
					GetSessionContext()->single_line_trigger_begin = count;
				} 
				else
				{
					GetSessionContext()->single_line_trigger_begin = yylloc;
				}
			} trigger_body_stmt
				{
					Node* node = (Node*)$2;
					if(IsA(node, FunctionSources))
					{
						GetSessionContext()->single_line_trigger_begin = 0;
						$$ = (FunctionSources*)$2;
					}
					else
					{
						FunctionSources *funSrc = NULL;
						char* strbody = NULL;
						base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
						int start_pos = GetSessionContext()->single_line_trigger_begin;
						int end_pos = yylloc;
						strbody = TriggerBodyGet(start_pos, end_pos, yyextra);
						GetSessionContext()->single_line_trigger_begin = 0;
						funSrc = makeNode(FunctionSources);
						funSrc->bodySrc   = strbody;

						$$ = funSrc;
					}
				}
			;

trigger_body_stmt:
			DeleteStmt { $$ = (Node*)$1; }
			| InsertStmt { $$ = (Node*)$1; }
			| UpdateStmt { $$ = (Node*)$1; }
			| VariableMultiSetStmt { $$ = (Node*)$1; }
			| VariableSetStmt { $$ = (Node*)$1; }
			| CallFuncStmt { $$ = (Node*)$1; }
			| subprogram_body { $$ = (Node*)$1; }
			| BEGIN_B_BLOCK b_proc_body { $$ = (Node*)$2; }
			;

TriggerActionTime:
			BEFORE								{ $$ = TRIGGER_TYPE_BEFORE; }
			| AFTER								{ $$ = TRIGGER_TYPE_AFTER; }
			| INSTEAD OF						{ $$ = TRIGGER_TYPE_INSTEAD; }
		;

DolphinTriggerActionTime:
			TriggerActionTime
			{
				/* Notice： Do not use this gram except in create trigger statement */
				if (strcmp(";", u_sess->attr.attr_common.delimiter_name) != 0 )
				{
					GetSessionContext()->dolphin_kw_mask = B_KWMASK_CREATE_TRIGGER;
				}
				$$ = $1;
			}

TriggerEvents:
			TriggerOneEvent
				{ $$ = $1; }
			| TriggerEvents OR TriggerOneEvent
				{
					int		events1 = intVal(linitial($1));
					int		events2 = intVal(linitial($3));
					List   *columns1 = (List *) lsecond($1);
					List   *columns2 = (List *) lsecond($3);

					if (events1 & events2)
						parser_yyerror("duplicate trigger events specified");
					/*
					 * concat'ing the columns lists loses information about
					 * which columns went with which event, but so long as
					 * only UPDATE carries columns and we disallow multiple
					 * UPDATE items, it doesn't matter.  Command execution
					 * should just ignore the columns for non-UPDATE events.
					 */
					$$ = list_make2(makeInteger(events1 | events2),
									list_concat(columns1, columns2));
				}
		;

TriggerOneEvent:
			INSERT
				{ $$ = list_make2(makeInteger(TRIGGER_TYPE_INSERT), NIL); }
			| DELETE_P
				{ $$ = list_make2(makeInteger(TRIGGER_TYPE_DELETE), NIL); }
			| UPDATE
				{ $$ = list_make2(makeInteger(TRIGGER_TYPE_UPDATE), NIL); }
			| UPDATE OF columnList
				{ $$ = list_make2(makeInteger(TRIGGER_TYPE_UPDATE), $3); }
			| TRUNCATE
				{ $$ = list_make2(makeInteger(TRIGGER_TYPE_TRUNCATE), NIL); }
		;

TriggerForSpec:
			FOR TriggerForOptEach TriggerForType
				{
					$$ = $3;
				}
			| /* EMPTY */
				{
					/*
					 * If ROW/STATEMENT not specified, default to
					 * STATEMENT, per SQL
					 */
					$$ = FALSE;
				}
		;

TriggerForOptEach:
			EACH									{}
			| /*EMPTY*/								{}
		;

TriggerForType:
			ROW										{ $$ = TRUE; }
			| STATEMENT								{ $$ = FALSE; }
		;

TriggerWhen:
			WHEN '(' a_expr ')'						{ $$ = $3; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

TriggerFuncArgs:
			TriggerFuncArg							{ $$ = list_make1($1); }
			| TriggerFuncArgs ',' TriggerFuncArg	{ $$ = lappend($1, $3); }
			| /*EMPTY*/								{ $$ = NIL; }
		;

TriggerFuncArg:
			Iconst
				{
					char buf[64];
					snprintf(buf, sizeof(buf), "%d", $1);
					$$ = makeString(pstrdup(buf));
				}
			| FCONST								{ $$ = makeString($1); }
			| SCONST								{ $$ = makeString($1); }
			| ColLabel								{ $$ = makeString($1); }
		;

trigger_order:
			/* NULL */
			{
				TrgCharacter *n = (TrgCharacter *)palloc(sizeof(TrgCharacter));
				n->is_follows = false;
				n->trigger_name = NULL;
				$$ = n;
			}
			| FOLLOWS_P ColId
			{
				TrgCharacter *n = (TrgCharacter *)palloc(sizeof(TrgCharacter));
				n->is_follows = true;
				n->trigger_name = $2;
				$$ = n;
			}
			| PRECEDES_P ColId
			{
				TrgCharacter *n = (TrgCharacter *)palloc(sizeof(TrgCharacter));
				n->is_follows = false;
				n->trigger_name = $2;
				$$ = n;
			}
		;

OptConstrFromTable:
			FROM dolphin_qualified_name						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

ConstraintAttributeSpec:
			/*EMPTY*/
				{ $$ = 0; }
			| ConstraintAttributeSpec ConstraintAttributeElem
				{
					/*
					 * We must complain about conflicting options.
					 * We could, but choose not to, complain about redundant
					 * options (ie, where $2's bit is already set in $1).
					 */
					int		newspec = $1 | $2;

					/* special message for this case */
					if ((newspec & (CAS_NOT_DEFERRABLE | CAS_INITIALLY_DEFERRED)) == (CAS_NOT_DEFERRABLE | CAS_INITIALLY_DEFERRED)) {
        				const char* message = "constraint declared INITIALLY DEFERRED must be DEFERRABLE";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("constraint declared INITIALLY DEFERRED must be DEFERRABLE"),
								 parser_errposition(@2)));
					}
					/* generic message for other conflicts */
					if ((newspec & (CAS_NOT_DEFERRABLE | CAS_DEFERRABLE)) == (CAS_NOT_DEFERRABLE | CAS_DEFERRABLE) ||
						(newspec & (CAS_INITIALLY_IMMEDIATE | CAS_INITIALLY_DEFERRED)) == (CAS_INITIALLY_IMMEDIATE | CAS_INITIALLY_DEFERRED)) {
        				const char* message = "conflicting constraint properties";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("conflicting constraint properties"),
								 parser_errposition(@2)));
					}
					$$ = newspec;
				}
		;

ConstraintAttributeElem:
			NOT DEFERRABLE					{ $$ = CAS_NOT_DEFERRABLE; }
			| DEFERRABLE					{ $$ = CAS_DEFERRABLE; }
			| INITIALLY IMMEDIATE			{ $$ = CAS_INITIALLY_IMMEDIATE; }
			| INITIALLY DEFERRED			{ $$ = CAS_INITIALLY_DEFERRED; }
			| NOT VALID						{ $$ = CAS_NOT_VALID; }
			| NO INHERIT					{ $$ = CAS_NO_INHERIT; }
		;


CreateEventTrigStmt:
			CREATE EVENT_TRIGGER name ON ColLabel
			EXECUTE PROCEDURE func_name '(' ')'
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					CreateEventTrigStmt *n = makeNode(CreateEventTrigStmt);
					n->trigname = $3;
					n->eventname = $5;
					n->whenclause = NULL;
					n->funcname = $8;
					$$ = (Node *)n;
				}
			| CREATE EVENT_TRIGGER name ON ColLabel
			WHEN event_trigger_when_list
			EXECUTE PROCEDURE func_name '(' ')'
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					CreateEventTrigStmt *n = makeNode(CreateEventTrigStmt);
					n->trigname = $3;
					n->eventname = $5;
					n->whenclause = $7;
					n->funcname = $10;
					$$ = (Node *)n;
				}
		;
 
event_trigger_when_list:
			event_trigger_when_item
			{ $$ = list_make1($1); }
			| event_trigger_when_list AND event_trigger_when_item
			{ $$ = lappend($1, $3); }
		;
 
event_trigger_when_item:
		ColId IN_P '(' event_trigger_value_list ')'
			{ $$ = makeDefElem($1, (Node *) $4); }
		;
 
event_trigger_value_list:
		SCONST
			{ $$ = list_make1(makeString($1)); }
		| event_trigger_value_list ',' SCONST
			{ $$ = lappend($1, makeString($3)); }
		;
 
AlterEventTrigStmt:
			ALTER EVENT_TRIGGER name enable_trigger
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					AlterEventTrigStmt *n = makeNode(AlterEventTrigStmt);
					n->trigname = $3;
					n->tgenabled = $4;
					$$ = (Node *) n;
				}
		;
 
enable_trigger:
			ENABLE_P                    { $$ = TRIGGER_FIRES_ON_ORIGIN; }
			| ENABLE_P REPLICA          { $$ = TRIGGER_FIRES_ON_REPLICA; }
			| ENABLE_P ALWAYS           { $$ = TRIGGER_FIRES_ALWAYS; }
			| DISABLE_P                 { $$ = TRIGGER_DISABLED; }
		;

qualified_trigger_name:
			name
				{
					$$ = makeRangeVar(NULL, $1, @1);
				}
			| ColId indirection
				{
					check_qualified_name($2, yyscanner);
					$$ = makeRangeVar(NULL, NULL, @1);
					const char* message = "improper qualified name (too many dotted names): %s";
					switch (list_length($2))
					{
						case 1:
							if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT)
							{
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
										(errcode(ERRCODE_SYNTAX_ERROR),
										 errmsg("only support trigger in schema in B compatibility database"),
									 	 parser_errposition(@1)));
							}
							$$->schemaname = $1;
							$$->relname = strVal(linitial($2));
							break;
						default:
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper qualified name (too many dotted names): %s",
											NameListToString(lcons(makeString($1), $2))),
									 parser_errposition(@1)));
							break;
					}
				}
		;

DropTrigStmt:
			DROP TRIGGER qualified_trigger_name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TRIGGER;
					n->objects = list_make1(lappend($5, list_make2(makeString($3->schemaname), makeString($3->relname))));
					n->arguments = NIL;
					n->behavior = $6;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP TRIGGER IF_P EXISTS qualified_trigger_name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TRIGGER;
					n->objects = list_make1(lappend($7, list_make2(makeString($5->schemaname), makeString($5->relname))));
					n->arguments = NIL;
					n->behavior = $8;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP TRIGGER qualified_trigger_name opt_drop_behavior
				{
#ifdef	ENABLE_MULTIPLE_NODES
					const char* message = "drop trigger name is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("drop trigger name is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate, 
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("drop trigger without table name only support in B-format database")));
					}
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TRIGGER;
					n->objects = list_make1(list_make1(list_make2(makeString($3->schemaname), makeString($3->relname))));
					n->arguments = NIL;
					n->behavior = $4;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP TRIGGER IF_P EXISTS qualified_trigger_name opt_drop_behavior
				{
#ifdef	ENABLE_MULTIPLE_NODES
					const char* message = "drop trigger if exists name is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("drop trigger if exists name is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate, 
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("drop trigger without table name only support in B-format database")));
					}
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TRIGGER;
					n->objects = list_make1(list_make1(list_make2(makeString($5->schemaname), makeString($5->relname))));
					n->arguments = NIL;
					n->behavior = $6;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERIES :
 *				CREATE ASSERTION ...
 *				DROP ASSERTION ...
 *
 *****************************************************************************/

CreateAssertStmt:
			CREATE ASSERTION name CHECK '(' a_expr ')'
			ConstraintAttributeSpec
				{
					CreateTrigStmt *n = makeNode(CreateTrigStmt);
					n->trigname = $3;
					n->args = list_make1($6);
					n->isconstraint  = TRUE;
					processCASbits($8, @8, "ASSERTION",
								   &n->deferrable, &n->initdeferred, NULL,
								   NULL, yyscanner);
        			const char* message = "CREATE ASSERTION is not yet implemented";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("CREATE ASSERTION is not yet implemented")));

					$$ = (Node *)n;
				}
		;

DropAssertStmt:
			DROP ASSERTION name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->objects = NIL;
					n->arguments = NIL;
					n->behavior = $4;
					n->removeType = OBJECT_TRIGGER; /* XXX */
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("DROP ASSERTION is not yet implemented")));
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERY :
 *				define (aggregate,operator,type)
 *
 *****************************************************************************/

DefineStmt:
			CREATE AGGREGATE func_name aggr_args definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_AGGREGATE;
					n->oldstyle = false;
					n->defnames = $3;
					n->args = $4;
					n->definition = $5;
					$$ = (Node *)n;
				}
			| CREATE AGGREGATE func_name old_aggr_definition
				{
					/* old-style (pre-8.2) syntax for CREATE AGGREGATE */
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_AGGREGATE;
					n->oldstyle = true;
					n->defnames = $3;
					n->args = NIL;
					n->definition = $4;
					$$ = (Node *)n;
				}
			| CREATE OPERATOR any_operator definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_OPERATOR;
					n->oldstyle = false;
					n->defnames = $3;
					n->args = NIL;
					n->definition = $4;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TYPE;
					n->oldstyle = false;
					n->defnames = $3;
					n->args = NIL;
					n->definition = $4;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name
				{
					/* Shell type (identified by lack of definition) */
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TYPE;
					n->oldstyle = false;
					n->defnames = $3;
					n->args = NIL;
					n->definition = NIL;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name as_is '(' OptTableFuncElementList ')'
				{
					CompositeTypeStmt *n = makeNode(CompositeTypeStmt);

					/* can't use qualified_name, sigh */
					n->typevar = makeRangeVarFromAnyName($3, @3, yyscanner);
					n->coldeflist = $6;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name as_is TABLE OF func_type
				{
					TableOfTypeStmt *n = makeNode(TableOfTypeStmt);
					n->typname = $3;
					n->reftypname = $7;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name as_is ENUM_P '(' opt_enum_val_list ')'
				{
					CreateEnumStmt *n = makeNode(CreateEnumStmt);
					n->typname = $3;
					n->vals = $7;
					$$ = (Node *)n;
				}
			| CREATE TYPE_P any_name as_is RANGE definition
				{
					CreateRangeStmt *n = makeNode(CreateRangeStmt);
					n->typname = $3;
					n->params	= $6;
					$$ = (Node *)n;
				}
			| CREATE TEXT_P SEARCH PARSER any_name definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TSPARSER;
					n->args = NIL;
					n->defnames = $5;
					n->definition = $6;
					$$ = (Node *)n;
				}
			| CREATE TEXT_P SEARCH DICTIONARY any_name definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TSDICTIONARY;
					n->args = NIL;
					n->defnames = $5;
					n->definition = $6;
					$$ = (Node *)n;
				}
			| CREATE TEXT_P SEARCH TEMPLATE any_name definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TSTEMPLATE;
					n->args = NIL;
					n->defnames = $5;
					n->definition = $6;
					$$ = (Node *)n;
				}
			| CREATE TEXT_P SEARCH CONFIGURATION any_name tsconf_definition opt_cfoptions
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_TSCONFIGURATION;
					n->args = $7; /* record configuration options */
					n->defnames = $5;
					n->definition = $6;
					$$ = (Node *)n;
				}
			| CREATE COLLATION any_name definition
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_COLLATION;
					n->args = NIL;
					n->defnames = $3;
					n->definition = $4;
					$$ = (Node *)n;
				}
			| CREATE COLLATION any_name FROM any_name
				{
					DefineStmt *n = makeNode(DefineStmt);
					n->kind = OBJECT_COLLATION;
					n->args = NIL;
					n->defnames = $3;
					n->definition = list_make1(makeDefElem("from", (Node *) $5));
					$$ = (Node *)n;
				}
		;

opt_cfoptions: WITH cfoptions							{ $$ = $2; }
			| /* EMPTY */								{ $$ = NIL; }
		;

cfoptions:'(' cfoption_list ')'							{ $$ = $2; }
		;

cfoption_list: cfoption_elem							{ $$ = list_make1($1); }
			| cfoption_list ',' cfoption_elem			{ $$ = lappend($1, $3); }
		;

cfoption_elem: ColLabel '=' def_arg						{ $$ = makeDefElem($1, (Node *) $3); }
			| ColLabel									{ $$ = makeDefElem($1, NULL); }
		;

tsconf_definition: '(' tsconf_def_list ')'				{ $$ = $2; }
		;

tsconf_def_list: tsconf_def_elem						{ $$ = list_make1($1); }
			| tsconf_def_list ',' tsconf_def_elem		{ $$ = lappend($1, $3); }
		;

tsconf_def_elem: PARSER '=' any_name					{ $$ = makeDefElem("parser", (Node *) $3); }
			| PARSER '=' DEFAULT						{ $$ = makeDefElem("parser", (Node *) list_make1(makeString("default"))); }
			| COPY '=' any_name							{ $$ = makeDefElem("copy", (Node *) $3); }
		;

definition: '(' def_list ')'						{ $$ = $2; }
		;

def_list:	def_elem								{ $$ = list_make1($1); }
			| def_list ',' def_elem					{ $$ = lappend($1, $3); }
		;

def_elem:	ColLabel '=' def_arg
				{
					$$ = makeDefElem($1, (Node *) $3);
				}
			| ColLabel
				{
					$$ = makeDefElem($1, NULL);
				}
		;

/* Note: any simple identifier will be returned as a type name! */
def_arg:	func_type						{ $$ = (Node *)$1; }
			| reserved_keyword				{ $$ = (Node *)makeString(downcase_str(pstrdup($1), false)); }
			| qual_all_Op					{ $$ = (Node *)$1; }
			| NumericOnly					{ $$ = (Node *)$1; }
			| SCONST						{ $$ = (Node *)makeString($1); }
		;

/*
 * aggregate function args.
 * (*)									- normal agg with no args
 * (aggr_arg,...)						- normal agg with args
 * (ORDER BY type_list,...)				- ordered-set agg with no direct args

 */
aggr_args:	'(' type_list ')'						{ $$ = list_make2($2, makeInteger(-1)); }
			| '(' '*' ')'							{ $$ = list_make2(NIL, makeInteger(-1)); }
			| '(' ORDER BY type_list ')'
				{
					$$ = list_make2($4, makeInteger(0));
				}
		;

old_aggr_definition: '(' old_aggr_list ')'			{ $$ = $2; }
		;

old_aggr_list: old_aggr_elem						{ $$ = list_make1($1); }
			| old_aggr_list ',' old_aggr_elem		{ $$ = lappend($1, $3); }
		;

/*
 * Must use IDENT here to avoid reduce/reduce conflicts; fortunately none of
 * the item names needed in old aggregate definitions are likely to become
 * SQL keywords.
 */
old_aggr_elem:  normal_ident '=' def_arg
				{
					$$ = makeDefElem($1, (Node *)$3);
				}
		;

opt_enum_val_list:
		enum_val_list							{ $$ = $1; }
		| /*EMPTY*/								{ $$ = NIL; }
		;

enum_val_list:	SCONST
				{ $$ = list_make1(makeString($1)); }
			| enum_val_list ',' SCONST
				{ $$ = lappend($1, makeString($3)); }
		;

/*****************************************************************************
 *
 *	ALTER TYPE enumtype ADD ...
 *
 *****************************************************************************/

AlterEnumStmt:
		ALTER TYPE_P any_name ADD_P VALUE_P opt_if_not_exists SCONST
			{
				AlterEnumStmt *n = makeNode(AlterEnumStmt);
				n->typname = $3;
				n->oldVal = NULL;
				n->newVal = $7;
				n->newValNeighbor = NULL;
				n->newValIsAfter = true;
				n->skipIfNewValExists = $6;
				$$ = (Node *) n;
			}
		 | ALTER TYPE_P any_name ADD_P VALUE_P opt_if_not_exists SCONST BEFORE SCONST
			{
				AlterEnumStmt *n = makeNode(AlterEnumStmt);
				n->typname = $3;
				n->oldVal = NULL;
				n->newVal = $7;
				n->newValNeighbor = $9;
				n->newValIsAfter = false;
				n->skipIfNewValExists = $6;
				$$ = (Node *) n;
			}
		 | ALTER TYPE_P any_name ADD_P VALUE_P opt_if_not_exists SCONST AFTER SCONST
			{
				AlterEnumStmt *n = makeNode(AlterEnumStmt);
				n->typname = $3;
				n->oldVal = NULL;
				n->newVal = $7;
				n->newValNeighbor = $9;
				n->newValIsAfter = true;
				n->skipIfNewValExists = $6;
				$$ = (Node *) n;
			}
		 | ALTER TYPE_P any_name RENAME VALUE_P SCONST TO SCONST
			{
				AlterEnumStmt *n = makeNode(AlterEnumStmt);
				n->typname = $3;
				n->oldVal = $6;
				n->newVal = $8;
				n->newValNeighbor = NULL;
				n->newValIsAfter = false;
				n->skipIfNewValExists = false;
				$$ = (Node *) n;
			}
		 ;

opt_if_not_exists: IF_P NOT EXISTS 			{ $$ = true; }
		| /* empty */						{ $$ = false; }
		;

/*****************************************************************************
 *
 *		QUERIES :
 *				CREATE OPERATOR CLASS ...
 *				CREATE OPERATOR FAMILY ...
 *				ALTER OPERATOR FAMILY ...
 *				DROP OPERATOR CLASS ...
 *				DROP OPERATOR FAMILY ...
 *
 *****************************************************************************/

CreateOpClassStmt:
			CREATE OPERATOR CLASS any_name opt_default FOR TYPE_P Typename
			USING access_method opt_opfamily AS opclass_item_list
				{
					CreateOpClassStmt *n = makeNode(CreateOpClassStmt);
					n->opclassname = $4;
					n->isDefault = $5;
					n->datatype = $8;
					n->amname = $10;
					n->opfamilyname = $11;
					n->items = $13;
					$$ = (Node *) n;
				}
		;

opclass_item_list:
			opclass_item							{ $$ = list_make1($1); }
			| opclass_item_list ',' opclass_item	{ $$ = lappend($1, $3); }
		;

opclass_item:
			OPERATOR Iconst any_operator opclass_purpose opt_recheck
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_OPERATOR;
					n->name = $3;
					n->args = NIL;
					n->number = $2;
					n->order_family = $4;
					$$ = (Node *) n;
				}
			| OPERATOR Iconst any_operator oper_argtypes opclass_purpose
			  opt_recheck
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_OPERATOR;
					n->name = $3;
					n->args = $4;
					n->number = $2;
					n->order_family = $5;
					$$ = (Node *) n;
				}
			| FUNCTION Iconst func_name func_args
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_FUNCTION;
					n->name = $3;
					n->args = extractArgTypes($4);
					n->number = $2;
					$$ = (Node *) n;
				}
			| FUNCTION Iconst '(' type_list ')' func_name func_args
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_FUNCTION;
					n->name = $6;
					n->args = extractArgTypes($7);
					n->number = $2;
					n->class_args = $4;
					$$ = (Node *) n;
				}
			| STORAGE Typename
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_STORAGETYPE;
					n->storedtype = $2;
					$$ = (Node *) n;
				}
		;

opt_default:	DEFAULT						{ $$ = TRUE; }
			| /*EMPTY*/						{ $$ = FALSE; }
		;

opt_opfamily:	FAMILY any_name				{ $$ = $2; }
			| /*EMPTY*/						{ $$ = NIL; }
		;

opclass_purpose: FOR SEARCH					{ $$ = NIL; }
			| FOR ORDER BY any_name			{ $$ = $4; }
			| /*EMPTY*/						{ $$ = NIL; }
		;

opt_recheck:	RECHECK
				{
					/*
					 * RECHECK no longer does anything in opclass definitions,
					 * but we still accept it to ease porting of old database
					 * dumps.
					 */
					ereport(NOTICE,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("RECHECK is no longer required"),
							 errhint("Update your data type."),
							 parser_errposition(@1)));
					$$ = TRUE;
				}
			| /*EMPTY*/						{ $$ = FALSE; }
		;


CreateOpFamilyStmt:
			CREATE OPERATOR FAMILY any_name USING access_method
				{
					CreateOpFamilyStmt *n = makeNode(CreateOpFamilyStmt);
					n->opfamilyname = $4;
					n->amname = $6;
					$$ = (Node *) n;
				}
		;

AlterOpFamilyStmt:
			ALTER OPERATOR FAMILY any_name USING access_method ADD_P opclass_item_list
				{
					AlterOpFamilyStmt *n = makeNode(AlterOpFamilyStmt);
					n->opfamilyname = $4;
					n->amname = $6;
					n->isDrop = false;
					n->items = $8;
					$$ = (Node *) n;
				}
			| ALTER OPERATOR FAMILY any_name USING access_method DROP opclass_drop_list
				{
					AlterOpFamilyStmt *n = makeNode(AlterOpFamilyStmt);
					n->opfamilyname = $4;
					n->amname = $6;
					n->isDrop = true;
					n->items = $8;
					$$ = (Node *) n;
				}
		;

opclass_drop_list:
			opclass_drop							{ $$ = list_make1($1); }
			| opclass_drop_list ',' opclass_drop	{ $$ = lappend($1, $3); }
		;

opclass_drop:
			OPERATOR Iconst '(' type_list ')'
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_OPERATOR;
					n->number = $2;
					n->args = $4;
					$$ = (Node *) n;
				}
			| FUNCTION Iconst '(' type_list ')'
				{
					CreateOpClassItem *n = makeNode(CreateOpClassItem);
					n->itemtype = OPCLASS_ITEM_FUNCTION;
					n->number = $2;
					n->args = $4;
					$$ = (Node *) n;
				}
		;


DropOpClassStmt:
			DROP OPERATOR CLASS any_name USING access_method opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->objects = list_make1(lcons(makeString($6), $4));
					n->removeType = OBJECT_OPCLASS;
					n->behavior = $7;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP OPERATOR CLASS IF_P EXISTS any_name USING access_method opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->objects = list_make1(lcons(makeString($8), $6));
					n->removeType = OBJECT_OPCLASS;
					n->behavior = $9;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;

DropOpFamilyStmt:
			DROP OPERATOR FAMILY any_name USING access_method opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->objects = list_make1(lcons(makeString($6), $4));
					n->removeType = OBJECT_OPFAMILY;
					n->behavior = $7;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP OPERATOR FAMILY IF_P EXISTS any_name USING access_method opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->objects = list_make1($6);
					n->objects = list_make1(lcons(makeString($8), $6));
					n->removeType = OBJECT_OPFAMILY;
					n->behavior = $9;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERY:
 *
 *		DROP OWNED BY username [, username ...] [ RESTRICT | CASCADE ]
 *		REASSIGN OWNED BY username [, username ...] TO username
 *
 *****************************************************************************/
DropOwnedStmt:
			DROP OWNED BY name_list opt_drop_behavior
				{
					DropOwnedStmt *n = makeNode(DropOwnedStmt);
					n->roles = $4;
					n->behavior = $5;
					$$ = (Node *)n;
				}
		;

ReassignOwnedStmt:
			REASSIGN OWNED BY name_list TO name
				{
					ReassignOwnedStmt *n = makeNode(ReassignOwnedStmt);
					n->roles = $4;
					n->newrole = $6;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		DROP itemtype [ IF EXISTS ] itemname [, itemname ...]
 *           [ RESTRICT | CASCADE ]
 *
 *****************************************************************************/

DropStmt:	DROP drop_type IF_P EXISTS any_name_list opt_drop_behavior opt_purge
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = $2;
					n->missing_ok = TRUE;
					n->objects = $5;
					n->arguments = NIL;
					n->behavior = $6;
					n->concurrent = false;
					n->purge = $7;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->removeType==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}					
					if (n->removeType != OBJECT_TABLE && n->purge) {
        				const char* message = "PURGE clause only allowed in \"DROP TABLE\" statement";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("PURGE clause only allowed in \"DROP TABLE\" statement"),
							 parser_errposition(@7)));
					}

					$$ = (Node *)n;
				}
			| DROP drop_type any_name_list opt_drop_behavior opt_purge
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = $2;
					n->missing_ok = FALSE;
					n->objects = $3;
					n->arguments = NIL;
					n->behavior = $4;
					n->concurrent = false;
					n->purge = $5;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->removeType==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}	
					if (n->removeType != OBJECT_TABLE && n->purge) {
        				const char* message = "PURGE clause only allowed in \"DROP TABLE\" statement";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("PURGE clause only allowed in \"DROP TABLE\" statement"),
							 parser_errposition(@5)));
					}
					$$ = (Node *)n;
				}
			| DROP TYPE_P type_name_list opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TYPE;
					n->missing_ok = FALSE;
					n->objects = $3;
					n->behavior = $4;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP TYPE_P IF_P EXISTS type_name_list opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_TYPE;
					n->missing_ok = TRUE;
					n->objects = $5;
					n->behavior = $6;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP DOMAIN_P type_name_list opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_DOMAIN;
					n->missing_ok = FALSE;
					n->objects = $3;
					n->behavior = $4;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP DOMAIN_P IF_P EXISTS type_name_list opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_DOMAIN;
					n->missing_ok = TRUE;
					n->objects = $5;
					n->behavior = $6;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP dolphin_drop_type IF_P EXISTS dolphin_any_name_list opt_drop_behavior opt_purge
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = $2;
					n->missing_ok = TRUE;
					n->objects = $5;
					n->arguments = NIL;
					n->behavior = $6;
					n->concurrent = false;
					n->purge = $7;

					$$ = (Node *)n;
				}
			| DROP dolphin_drop_type dolphin_any_name_list opt_drop_behavior opt_purge
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = $2;
					n->missing_ok = FALSE;
					n->objects = $3;
					n->arguments = NIL;
					n->behavior = $4;
					n->concurrent = false;
					n->purge = $5;
					$$ = (Node *)n;
				}
			| DROP INDEX IF_P EXISTS any_name_list opt_drop_behavior opt_purge on_table opt_idx_algo
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_INDEX;
					n->missing_ok = TRUE;
					n->objects = $5;
					n->arguments = NIL;
					n->behavior = $6;
					n->concurrent = false;
					n->purge = $7;
					if (n->removeType != OBJECT_TABLE && n->purge) {
        				const char* message = "PURGE clause only allowed in \"DROP TABLE\" statement";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("PURGE clause only allowed in \"DROP TABLE\" statement"),
							 parser_errposition(@7)));
					}

					$$ = (Node *)n;
				}
			| DROP INDEX any_name_list opt_drop_behavior opt_purge on_table opt_idx_algo
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_INDEX;
					n->missing_ok = FALSE;
					n->objects = $3;
					n->arguments = NIL;
					n->behavior = $4;
					n->concurrent = false;
					n->purge = $5;
					if (n->removeType != OBJECT_TABLE && n->purge) {
        				const char* message = "PURGE clause only allowed in \"DROP TABLE\" statement";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							 errmsg("PURGE clause only allowed in \"DROP TABLE\" statement"),
							 parser_errposition(@5)));
					}
					$$ = (Node *)n;
				}
			| DROP INDEX CONCURRENTLY any_name_list opt_drop_behavior on_table opt_idx_algo
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_INDEX;
					n->missing_ok = FALSE;
					n->objects = $4;
					n->arguments = NIL;
					n->behavior = $5;
					n->concurrent = true;
					$$ = (Node *)n;
				}
			| DROP INDEX CONCURRENTLY IF_P EXISTS any_name_list opt_drop_behavior on_table opt_idx_algo
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_INDEX;
					n->missing_ok = TRUE;
					n->objects = $6;
					n->arguments = NIL;
					n->behavior = $7;
					n->concurrent = true;
					$$ = (Node *)n;
				}
		;

on_table:
			ON dolphin_qualified_name					{ $$ = NULL; }
			| /* EMPTY */						{ $$ = NULL; }
		;

opt_purge:
			PURGE								{ $$ = true; }
			| /* EMPTY */							{ $$ = false; }
		;

opt_temporary:
			TEMPORARY
			| /* EMPTY */							{ $$ = NULL; }
		;
dolphin_drop_type:	opt_temporary TABLE						{ $$ = OBJECT_TABLE; }
					| opt_temporary TABLES					{ $$ = OBJECT_TABLE; }
					| SCHEMA								{ $$ = OBJECT_SCHEMA; }
					| VIEW									{ $$ = OBJECT_VIEW; }


drop_type:	 CONTVIEW                              { $$ = OBJECT_CONTQUERY; }
            | STREAM                                { $$ = OBJECT_STREAM; }
			| SEQUENCE								{ $$ = OBJECT_SEQUENCE; }
			| LARGE_P SEQUENCE						{ $$ = OBJECT_LARGE_SEQUENCE; }
			| MATERIALIZED VIEW 					{ $$ = OBJECT_MATVIEW; }
			| FOREIGN TABLE							{ $$ = OBJECT_FOREIGN_TABLE; }
			| COLLATION								{ $$ = OBJECT_COLLATION; }
			| CONVERSION_P							{ $$ = OBJECT_CONVERSION; }
			| EVENT_TRIGGER                         { $$ = OBJECT_EVENT_TRIGGER; }
			| EXTENSION								{ $$ = OBJECT_EXTENSION; }
			| TEXT_P SEARCH PARSER					{ $$ = OBJECT_TSPARSER; }
			| TEXT_P SEARCH DICTIONARY				{ $$ = OBJECT_TSDICTIONARY; }
			| TEXT_P SEARCH TEMPLATE				{ $$ = OBJECT_TSTEMPLATE; }
			| TEXT_P SEARCH CONFIGURATION			{ $$ = OBJECT_TSCONFIGURATION; }
            | CLIENT MASTER KEY                     { $$ = OBJECT_GLOBAL_SETTING; }
            | COLUMN ENCRYPTION KEY                 { $$ = OBJECT_COLUMN_SETTING; }
            | PUBLICATION                           { $$ = OBJECT_PUBLICATION; }
		;
rename_list:
                       rename_user_clause                                                   {$$ = list_make1($1);}
                       | rename_list ',' rename_user_clause                 {$$ = lappend($1, $3);}

rename_user_clause:
                       UserId TO UserId                                        {$$ = list_make2($1, $3); }

collate_name:	any_name					{ $$ = $1; }
				| SCONST					{ $$ = list_make1(makeString($1)); }
		;

type_name_list:
			Typename                                { $$ = list_make1(list_make1($1)); }
			| type_name_list ',' Typename           { $$ = lappend($1, list_make1($3)); }
			
any_name_list:
			any_name								{ $$ = list_make1($1); }
			| any_name_list ',' any_name			{ $$ = lappend($1, $3); }
		;

dolphin_any_name_list:
			dolphin_any_name										{ $$ = list_make1($1); }
			| dolphin_any_name_list ',' dolphin_any_name			{ $$ = lappend($1, $3); }
		;

any_name:	ColId						{ $$ = list_make1(makeString($1)); }
			| ColId attrs				{ $$ = lcons(makeString($1), $2); }
		;

any_name_or_sconst:
		any_name					{ $$ = $1; }
		| SCONST					{ $$ = list_make1(makeString($1)); }

dolphin_any_name:	DolphinColId						{ $$ = list_make1(makeString(GetDolphinObjName($1->str, $1->is_quoted))); }
			| DolphinColId dolphin_attrs
			{
				List* list = $2;
				List* result = NIL;
				ListCell * cell = NULL;
				int length = list_length($2);
				int count = 0;
				int table_index = -1;
				int schema_index = -1;
				switch (length) {
					case 1:
						/* schema_name.table_name */
						result = lappend(result, makeString(GetDolphinSchemaName($1->str, $1->is_quoted)));
						table_index = 0;
						break;
					case 2:
						/* catalog_name.schema_name.table_name */
						result = lappend(result, makeString(downcase_str($1->str, $1->is_quoted)));
						/* fall through */
					default:
						schema_index = 0;
						table_index = 1;
						break;
				}
				foreach (cell, list) {
					DolphinString* dolphinString = (DolphinString*)lfirst(cell);
					Value* value = (Value*)(dolphinString->node);
					char* str = strVal(value);
					bool is_quoted = dolphinString->is_quoted;
					if (count == table_index) {
						result = lappend(result, makeString(GetDolphinObjName(str, is_quoted)));
					} else if (count == schema_index) {
						result = lappend(result, makeString(GetDolphinSchemaName(str, is_quoted)));
					} else {
						/* other_names */
						result = lappend(result, makeString(downcase_str(str, is_quoted)));
					}
					count++;
				}
				$$ = result;
			}
		;

attrs:		'.' attr_name
					{ $$ = list_make1(makeString($2)); }
			| attrs '.' attr_name
					{ $$ = lappend($1, makeString($3)); }
		;

dolphin_attrs:		'.' DolphinColLabel
						{ $$ = list_make1($2); }
					| dolphin_attrs '.' DolphinColLabel
						{ $$ = lappend($1, $3); }
		;


/*****************************************************************************
 *
 *		QUERY:
 *				truncate table relname1, relname2, ...
 *
 *****************************************************************************/

TruncateStmt:
			TRUNCATE opt_table relation_expr_list opt_restart_seqs opt_drop_behavior opt_purge
				{
					TruncateStmt *n = makeNode(TruncateStmt);
					n->relations = $3;
					n->restart_seqs = $4;
					n->behavior = $5;
					n->purge = $6;
					$$ = (Node *)n;
				}
		;

opt_restart_seqs:
			CONTINUE_P IDENTITY_P		{ $$ = false; }
			| RESTART IDENTITY_P		{ $$ = true; }
			| /* EMPTY */				{ $$ = false; }
		;

/*****************************************************************************
 *
 *	The COMMENT ON statement can take different forms based upon the type of
 *	the object associated with the comment. The form of the statement is:
 *
 *	COMMENT ON [ [ DATABASE | DOMAIN | INDEX | SEQUENCE | TABLE | TYPE | VIEW |
 *				   COLLATION | CONVERSION | LANGUAGE | OPERATOR CLASS |
 *				   LARGE OBJECT | CAST | COLUMN | SCHEMA | TABLESPACE |
 *				   EXTENSION | ROLE | TEXT SEARCH PARSER |
 *				   TEXT SEARCH DICTIONARY | TEXT SEARCH TEMPLATE |
 *				   TEXT SEARCH CONFIGURATION | FOREIGN TABLE |
 *				   FOREIGN DATA WRAPPER | SERVER | EVENT_TRIGGER |
 *				   MATERIALIZED VIEW | SNAPSHOT] <objname> |
 *				 AGGREGATE <aggname> (arg1, ...) |
 *				 FUNCTION <funcname> (arg1, arg2, ...) |
 *				 OPERATOR <op> (leftoperand_typ, rightoperand_typ) |
 *				 TRIGGER <triggername> ON <relname> |
 *				 CONSTRAINT <constraintname> ON <relname> |
 *				 RULE <rulename> ON <relname> ]
 *			   IS 'text'
 *
 *****************************************************************************/

CommentStmt:
			COMMENT ON comment_type any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = $3;
					n->objname = $4;
					n->objargs = NIL;
					n->comment = $6;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->objtype==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}	
					$$ = (Node *) n;
				}
			| COMMENT ON dolphin_comment_type dolphin_any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = $3;
					n->objname = $4;
					n->objargs = NIL;
					n->comment = $6;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->objtype==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					$$ = (Node *) n;
				}
			| COMMENT ON AGGREGATE func_name aggr_args IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_AGGREGATE;
					n->objname = $4;
					n->objargs = $5;
					n->comment = $7;
					$$ = (Node *) n;
				}
			| COMMENT ON FUNCTION func_name func_args IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_FUNCTION;
					n->objname = $4;
					n->objargs = extractArgTypes($5);
					n->comment = $7;
					$$ = (Node *) n;
				}
			| COMMENT ON OPERATOR any_operator oper_argtypes IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_OPERATOR;
					n->objname = $4;
					n->objargs = $5;
					n->comment = $7;
					$$ = (Node *) n;
				}
			| COMMENT ON CONSTRAINT name ON dolphin_any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TABCONSTRAINT;
					n->objname = lappend($6, makeString($4));
					n->objargs = NIL;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON CONSTRAINT name ON DOMAIN_P dolphin_any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_DOMCONSTRAINT;
					/*
					 * should use Typename not any_name in the production, but
					 * there's a shift/reduce conflict if we do that, so fix it
					 * up here.
					*/
					n->objname = list_make1(makeTypeNameFromNameList($7));
					n->objargs = list_make1(makeString($4));
					n->comment = $9;
					$$ = (Node *) n;
				}
			| COMMENT ON RULE name ON dolphin_any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_RULE;
					n->objname = lappend($6, makeString($4));
					n->objargs = NIL;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON RULE name IS comment_text
				{
					/* Obsolete syntax supported for awhile for compatibility */
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_RULE;
					n->objname = list_make1(makeString($4));
					n->objargs = NIL;
					n->comment = $6;
					$$ = (Node *) n;
				}
			| COMMENT ON TRIGGER name ON dolphin_any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TRIGGER;
					n->objname = lappend($6, makeString($4));
					n->objargs = NIL;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON OPERATOR CLASS any_name USING access_method IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_OPCLASS;
					n->objname = $5;
					n->objargs = list_make1(makeString($7));
					n->comment = $9;
					$$ = (Node *) n;
				}
			| COMMENT ON OPERATOR FAMILY any_name USING access_method IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_OPFAMILY;
					n->objname = $5;
					n->objargs = list_make1(makeString($7));
					n->comment = $9;
					$$ = (Node *) n;
				}
			| COMMENT ON LARGE_P OBJECT_P NumericOnly IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_LARGEOBJECT;
					n->objname = list_make1($5);
					n->objargs = NIL;
					n->comment = $7;
					$$ = (Node *) n;
				}
			| COMMENT ON CAST '(' Typename AS Typename ')' IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_CAST;
					n->objname = list_make1($5);
					n->objargs = list_make1($7);
					n->comment = $10;
					$$ = (Node *) n;
				}
			| COMMENT ON opt_procedural LANGUAGE any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_LANGUAGE;
					n->objname = $5;
					n->objargs = NIL;
					n->comment = $7;
					$$ = (Node *) n;
				}
			| COMMENT ON TEXT_P SEARCH PARSER any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TSPARSER;
					n->objname = $6;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON TEXT_P SEARCH DICTIONARY any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TSDICTIONARY;
					n->objname = $6;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON TEXT_P SEARCH TEMPLATE any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TSTEMPLATE;
					n->objname = $6;
					n->comment = $8;
					$$ = (Node *) n;
				}
			| COMMENT ON TEXT_P SEARCH CONFIGURATION any_name IS comment_text
				{
					CommentStmt *n = makeNode(CommentStmt);
					n->objtype = OBJECT_TSCONFIGURATION;
					n->objname = $6;
					n->comment = $8;
					$$ = (Node *) n;
				}
		;

comment_type:
			DATABASE							{ $$ = OBJECT_DATABASE; }
			| SCHEMA							{ $$ = OBJECT_SCHEMA; }
			| INDEX								{ $$ = OBJECT_INDEX; }
			| SEQUENCE							{ $$ = OBJECT_SEQUENCE; }
			| LARGE_P SEQUENCE					{ $$ = OBJECT_LARGE_SEQUENCE; }
			| DOMAIN_P							{ $$ = OBJECT_DOMAIN; }
			| TYPE_P							{ $$ = OBJECT_TYPE; }
			| VIEW								{ $$ = OBJECT_VIEW; }
			| MATERIALIZED VIEW 				{ $$ = OBJECT_MATVIEW; }
			| SNAPSHOT							{ $$ = OBJECT_VIEW; }
			| COLLATION							{ $$ = OBJECT_COLLATION; }
			| CONVERSION_P						{ $$ = OBJECT_CONVERSION; }
			| TABLESPACE						{ $$ = OBJECT_TABLESPACE; }
			| EVENT_TRIGGER                     { $$ = OBJECT_EVENT_TRIGGER; }
			| EXTENSION							{ $$ = OBJECT_EXTENSION; }
			| SERVER							{ $$ = OBJECT_FOREIGN_SERVER; }
			| FOREIGN DATA_P WRAPPER			{ $$ = OBJECT_FDW; }
		;

dolphin_comment_type:
			TABLE								{ $$ = OBJECT_TABLE; }
			| FOREIGN TABLE						{ $$ = OBJECT_FOREIGN_TABLE; }
			| ROLE								{ $$ = OBJECT_ROLE; }
			| USER								{ $$ = OBJECT_USER; }
			| COLUMN							{ $$ = OBJECT_COLUMN; }
		;

comment_text:
			SCONST								{ $$ = $1; }
			| NULL_P							{ $$ = NULL; }
		;


/*****************************************************************************
 *
 *  SECURITY LABEL [FOR <provider>] ON <object> IS <label>
 *
 *  As with COMMENT ON, <object> can refer to various types of database
 *  objects (e.g. TABLE, COLUMN, etc.).
 *
 *****************************************************************************/

SecLabelStmt:
			SECURITY LABEL opt_provider ON security_label_type any_name
			IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = $5;
					n->objname = $6;
					n->objargs = NIL;
					n->label = $8;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->objtype==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}	
					$$ = (Node *) n;
				}
			| SECURITY LABEL opt_provider ON dolphin_security_label_type dolphin_any_name
			IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = $5;
					n->objname = $6;
					n->objargs = NIL;
					n->label = $8;
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT && n->objtype==OBJECT_EVENT_TRIGGER)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}	
					$$ = (Node *) n;
				}
			| SECURITY LABEL opt_provider ON AGGREGATE func_name aggr_args
			  IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = OBJECT_AGGREGATE;
					n->objname = $6;
					n->objargs = $7;
					n->label = $9;
					$$ = (Node *) n;
				}
			| SECURITY LABEL opt_provider ON FUNCTION func_name func_args
			  IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = OBJECT_FUNCTION;
					n->objname = $6;
					n->objargs = extractArgTypes($7);
					n->label = $9;
					$$ = (Node *) n;
				}
			| SECURITY LABEL opt_provider ON LARGE_P OBJECT_P NumericOnly
			  IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = OBJECT_LARGEOBJECT;
					n->objname = list_make1($7);
					n->objargs = NIL;
					n->label = $9;
					$$ = (Node *) n;
				}
			| SECURITY LABEL opt_provider ON opt_procedural LANGUAGE any_name
			  IS security_label
				{
					SecLabelStmt *n = makeNode(SecLabelStmt);
					n->provider = $3;
					n->objtype = OBJECT_LANGUAGE;
					n->objname = $7;
					n->objargs = NIL;
					n->label = $9;
					$$ = (Node *) n;
				}
		;

opt_provider:	FOR ColId_or_Sconst	{ $$ = $2; }
				| /* empty */		{ $$ = NULL; }
		;

security_label_type:
			COLUMN								{ $$ = OBJECT_COLUMN; }
			| DATABASE							{ $$ = OBJECT_DATABASE; }
			| EVENT_TRIGGER                     { $$ = OBJECT_EVENT_TRIGGER; }
			| SCHEMA							{ $$ = OBJECT_SCHEMA; }
			| SEQUENCE							{ $$ = OBJECT_SEQUENCE; }
			| DOMAIN_P							{ $$ = OBJECT_TYPE; }
			| TABLESPACE						{ $$ = OBJECT_TABLESPACE; }
			| TYPE_P							{ $$ = OBJECT_TYPE; }
			| VIEW								{ $$ = OBJECT_VIEW; }
			| MATERIALIZED VIEW 				{ $$ = OBJECT_MATVIEW; }
		;
dolphin_security_label_type:
			FOREIGN TABLE						{ $$ = OBJECT_FOREIGN_TABLE; }
			| TABLE								{ $$ = OBJECT_TABLE; }
			| ROLE								{ $$ = OBJECT_ROLE; }
			| USER								{ $$ = OBJECT_USER; }
		;

security_label:	SCONST				{ $$ = $1; }
				| NULL_P			{ $$ = NULL; }
		;

/*****************************************************************************
 *
 *		QUERY:
 *			fetch/move
 *
 *****************************************************************************/

FetchStmt:	FETCH fetch_args
				{
					FetchStmt *n = (FetchStmt *) $2;
					n->ismove = FALSE;
					$$ = (Node *)n;
				}
			| MOVE fetch_args
				{
					FetchStmt *n = (FetchStmt *) $2;
					n->ismove = TRUE;
					$$ = (Node *)n;
				}
		;

fetch_args:	cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $1;
					n->direction = FETCH_FORWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $2;
					n->direction = FETCH_FORWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| NEXT opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_FORWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| PRIOR opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_BACKWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| FIRST_P opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_ABSOLUTE;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| LAST_P opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_ABSOLUTE;
					n->howMany = -1;
					$$ = (Node *)n;
				}
			| ABSOLUTE_P SignedIconst opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_ABSOLUTE;
					n->howMany = $2;
					$$ = (Node *)n;
				}
			| RELATIVE_P SignedIconst opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_RELATIVE;
					n->howMany = $2;
					$$ = (Node *)n;
				}
			| SignedIconst opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_FORWARD;
					n->howMany = $1;
					$$ = (Node *)n;
				}
			| ALL opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_FORWARD;
					n->howMany = FETCH_ALL;
					$$ = (Node *)n;
				}
			| FORWARD opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_FORWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| FORWARD SignedIconst opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_FORWARD;
					n->howMany = $2;
					$$ = (Node *)n;
				}
			| FORWARD ALL opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_FORWARD;
					n->howMany = FETCH_ALL;
					$$ = (Node *)n;
				}
			| BACKWARD opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $3;
					n->direction = FETCH_BACKWARD;
					n->howMany = 1;
					$$ = (Node *)n;
				}
			| BACKWARD SignedIconst opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_BACKWARD;
					n->howMany = $2;
					$$ = (Node *)n;
				}
			| BACKWARD ALL opt_from_in cursor_name
				{
					FetchStmt *n = makeNode(FetchStmt);
					n->portalname = $4;
					n->direction = FETCH_BACKWARD;
					n->howMany = FETCH_ALL;
					$$ = (Node *)n;
				}
		;

from_in:	FROM									{}
			| IN_P									{}
		;

opt_from_in:	from_in								{}
			| /* EMPTY */							{}
		;


/*****************************************************************************
 *
 * GRANT and REVOKE statements
 *
 *****************************************************************************/

GrantStmt:	GRANT privileges ON privilege_target TO grantee_list
			opt_grant_grant_option
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->grant_option = $7;
					$$ = (Node*)n;
				}
			| GRANT routine_privileges ON routine_target
			TO grantee_list opt_grant_grant_option
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->grant_option = $7;
					$$ = (Node*)n;
				}
			| GRANT temporary_privileges ON temporary_target
			TO grantee_list opt_grant_grant_option
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->grant_option = $7;
					$$ = (Node*)n;
				}
			| GRANT index_privileges ON index_target
			TO grantee_list opt_grant_grant_option
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->grant_option = $7;
					$$ = (Node*)n;
				}
			| GRANT CREATE USER ON '*' '.' '*'
			TO UserId
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $9;
					n->action = +1;	/* add, if there are members */
					n->options = list_make1(makeDefElem("createrole", (Node *)makeInteger((TRUE))));
					n->lockstatus = DO_NOTHING;
					$$ = (Node *)n;
				}
			| GRANT CREATE TABLESPACE ON '*' '.' '*'
			TO UserId
				{
					GrantRoleStmt *n = makeNode(GrantRoleStmt);
					n->is_grant = true;
					n->admin_opt = false;
					AccessPriv *n2 = makeNode(AccessPriv);
					n2->priv_name = "gs_role_tablespace";
					n2->cols = NULL;
					n->granted_roles = list_make1(n2);
					n->grantee_roles = list_make1(makeString($9));
					$$ = (Node*)n;
				}
			| GRANT privileges ON '*' '.' '*' TO UserId IDENTIFIED BY opt_passwords password_string
				{
					if (list_length($2) != 1) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("syntax error"),
							parser_errposition(@2)));
					}
					AccessPriv *ap = (AccessPriv*)lfirst(list_head($2));
					if (strcmp(ap->priv_name, "usage") != 0) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("syntax error"),
							parser_errposition(@2)));
					}
					list_free_ext($2);
					List *options = NIL;
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $8;
					n->action = +1;
					options = lappend(options, makeDefElem("b_mode_create_user_if_not_exist", (Node *)makeInteger(TRUE)));
					options = lappend(options, makeDefElem("password", (Node *)list_make1(makeStringConst($12, -1))));
					n->options = options;
					n->lockstatus = DO_NOTHING;
					$$ = (Node*)n;
				}
			| GRANT ALL privilege_str TO UserId
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $5;
					n->action = +1;	/* add, if there are members */
					n->options =  lappend(NULL,makeDefElem("issystemadmin", (Node *)makeInteger(TRUE)));
					$$ = (Node *)n;
				}
		;

opt_passwords:
			PASSWORD
			| /* EMPTY */
		;

RevokeStmt:
			REVOKE privileges ON privilege_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = false;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->behavior = $7;
					$$ = (Node *)n;
				}
			| REVOKE routine_privileges ON routine_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = false;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->behavior = $7;
					$$ = (Node *)n;
				}
			| REVOKE temporary_privileges ON temporary_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = false;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->behavior = $7;
					$$ = (Node *)n;
				}
			| REVOKE index_privileges ON index_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = false;
					n->privileges = $2;
					n->targtype = ($4)->targtype;
					n->objtype = ($4)->objtype;
					n->objects = ($4)->objs;
					n->grantees = $6;
					n->behavior = $7;
					$$ = (Node *)n;
				}
			| REVOKE CREATE USER ON '*' '.' '*'
			FROM RoleId
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $9;
					n->action = +1;	/* add, if there are members */
					n->options = lappend(NULL, makeDefElem("createrole", (Node *)makeInteger(FALSE)));
					n->lockstatus = DO_NOTHING;
					$$ = (Node *)n;
				}
			| REVOKE CREATE TABLESPACE ON '*' '.' '*'
			FROM RoleId
				{
					GrantRoleStmt *n = makeNode(GrantRoleStmt);
					n->is_grant = false;
					n->admin_opt = false;
					AccessPriv *n2 = makeNode(AccessPriv);
					n2->priv_name = "gs_role_tablespace";
					n2->cols = NULL;
					n->granted_roles = list_make1(n2);
					n->grantee_roles = list_make1(makeString($9));
					$$ = (Node*)n;
				}
			| REVOKE GRANT OPTION FOR privileges ON privilege_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = true;
					n->privileges = $5;
					n->targtype = ($7)->targtype;
					n->objtype = ($7)->objtype;
					n->objects = ($7)->objs;
					n->grantees = $9;
					n->behavior = $10;
					$$ = (Node *)n;
				}
			| REVOKE ALL privilege_str FROM UserId
				{
					AlterRoleStmt *n = makeNode(AlterRoleStmt);
					n->role = $5;
					n->action = +1;	/* add, if there are members */
					n->options =  lappend(NULL,makeDefElem("issystemadmin", (Node *)makeInteger(FALSE)));
					$$ = (Node *)n;
				}
		;
privilege_str: PRIVILEGES { $$ = NULL;}
	| PRIVILEGE { $$ = NULL;}
		;

definer_expression: DEFINER '=' UserId
				{
					if (u_sess->attr.attr_sql.sql_compatibility ==  B_FORMAT) {
						$$ = $3;
					} else {
						parser_yyerror("not support DEFINER function");
					}
				}
			;

definer_user: definer_expression
				{
					$$ = $1;
				}
			| /* EMPTY */
				{
					$$ = NULL;
				}
			;

/*
 * Privilege names are represented as strings; the validity of the privilege
 * names gets checked at execution.  This is a bit annoying but we have little
 * choice because of the syntactic conflict with lists of role names in
 * GRANT/REVOKE.  What's more, we have to call out in the "privilege"
 * production any reserved keywords that need to be usable as privilege names.
 */

/* either ALL [PRIVILEGES] or a list of individual privileges */
privileges: privilege_list
				{ $$ = $1; }
			| ALL
				{ $$ = NIL; }
			| ALL PRIVILEGES
				{ $$ = NIL; }
			| ALL '(' columnList ')'
				{
					AccessPriv *n = makeNode(AccessPriv);
					n->priv_name = NULL;
					n->cols = $3;
					$$ = list_make1(n);
				}
			| ALL PRIVILEGES '(' columnList ')'
				{
					AccessPriv *n = makeNode(AccessPriv);
					n->priv_name = NULL;
					n->cols = $4;
					$$ = list_make1(n);
				}
		;

privilege_list:	privilege							{ $$ = list_make1($1); }
			| privilege_list ',' privilege			{ $$ = lappend($1, $3); }
		;

privilege:	SELECT opt_column_list
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = downcase_str(pstrdup($1), false);
				n->cols = $2;
				$$ = n;
			}
		| REFERENCES opt_column_list
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = downcase_str(pstrdup($1), false);
				n->cols = $2;
				$$ = n;
			}
		| CREATE opt_column_list
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = downcase_str(pstrdup($1), false);
				n->cols = $2;
				$$ = n;
			}
		| PrivilegeColId opt_column_list
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = $1;
				n->cols = $2;
				$$ = n;
			}
		| SCONST opt_column_list
			{
				if (strchr($1,'@'))
					ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("@ can't be allowed in username")));
				if (strlen($1) >= NAMEDATALEN) {
					ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("String %s is too long for user name (should be no longer than 64)", $1)));
				}
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = $1;
				n->cols = $2;
				$$ = n;
			}
		| SCONST SET_USER_IDENT
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = GetValidUserHostId($1, $2);
				n->cols = NIL;
				$$ = n;
			}
		| SCONST '@' SCONST
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = GetValidUserHostId($1, $3);
				n->cols = NIL;
				$$ = n;
			}
		| PrivilegeColId SET_USER_IDENT
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = GetValidUserHostId($1, $2);
				n->cols = NIL;
				$$ = n;
			}
		;

index_privilege: INDEX opt_column_list
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = downcase_str(pstrdup($1), false);
				n->cols = $2;
				$$ = n;
			}
		;

index_privileges: index_privilege_list
				{ $$ = $1; }
		;

index_privilege_list:
		index_privilege	{ $$ = list_make1($1); }
		| index_privilege_list ',' index_privilege	{ $$ = lappend($1, $3); }
		| privilege_list ',' index_privilege	{ $$ = lappend($1, $3); }
		| index_privilege_list ',' privilege	{ $$ = lappend($1, $3); }
	;

index_target:
		TABLE dolphin_qualified_name_list
			{
				PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
				n->targtype = ACL_TARGET_OBJECT;
				n->objtype = ACL_OBJECT_RELATION;
				n->objs = $2;
				$$ = n;
			}
		| ALL TABLES IN_P SCHEMA dolphin_schema_name_list
			{
				PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
				n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
				n->objtype = ACL_OBJECT_RELATION;
				n->objs = $5;
				$$ = n;
			}
		;

routine_privileges: routine_privilege_list
				{ $$ = $1; }
		;

routine_privilege_list: 
		routine_privilege					{ $$ = list_make1($1); }
		| routine_privilege_list ',' routine_privilege		{ $$ = lappend($1, $3); }
		| privilege_list ',' routine_privilege		{ $$ = lappend($1, $3); }
		| routine_privilege_list ',' privilege		{ $$ = lappend($1, $3); }
	;

routine_privilege:
		ALTER ROUTINE
				{
					AccessPriv *n = makeNode(AccessPriv);
					n->priv_name = downcase_str(pstrdup($1), false);
					n->cols = NULL;
					$$ = n;
				}
		;

routine_target:
			FUNCTION function_with_argtypes_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $2;
					$$ = n;
				}
			| PROCEDURE function_with_argtypes_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $2;
					$$ = n;
				}
			| ALL FUNCTIONS IN_P SCHEMA dolphin_schema_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $5;
					$$ = n;
				}
			| name '.' '*'
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = list_make1(makeString($1));
					$$ = n;
				}
			;

temporary_privileges: temporary_privilege_list
				{ $$ = $1; }
		;

temporary_privilege_list: 
		temporary_privilege					{ $$ = list_make1($1); }
		| temporary_privilege_list ',' temporary_privilege		{ $$ = lappend($1, $3); }
		| privilege_list ',' temporary_privilege		{ $$ = lappend($1, $3); }
		| temporary_privilege_list ',' privilege		{ $$ = lappend($1, $3); }
	;

temporary_privilege:
		CREATE TEMPORARY TABLES
			{
				AccessPriv *n = makeNode(AccessPriv);
				n->priv_name = downcase_str(pstrdup($2), false);
				n->cols = NULL;
				$$ = n;
			}
		;

		
temporary_target:
			DATABASE name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DATABASE;
					n->objs = $2;
					$$ = n;
				}
			| name '.' '*'
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DATABASE;
					n->objs = list_make1(makeString($1));
					$$ = n;				
				}
			;

/* Don't bother trying to fold the first two rules into one using
 * opt_table.  You're going to get conflicts.
 */
privilege_target:
			dolphin_qualified_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_RELATION;
					n->objs = $1;
					$$ = n;
				}
			| TABLE dolphin_qualified_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_RELATION;
					n->objs = $2;
					$$ = n;
				}
			| SEQUENCE qualified_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_SEQUENCE;
					n->objs = $2;
					$$ = n;
				}
			| LARGE_P SEQUENCE qualified_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_SEQUENCE;
					n->objs = $3;
					$$ = n;
				}
			| FOREIGN DATA_P WRAPPER name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FDW;
					n->objs = $4;
					$$ = n;
				}
			| FOREIGN SERVER name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FOREIGN_SERVER;
					n->objs = $3;
					$$ = n;
				}
			| FUNCTION function_with_argtypes_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $2;
					$$ = n;
				}
			| PACKAGE any_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_PACKAGE;
					n->objs = $2;
					$$ = n;
				}
			| PROCEDURE function_with_argtypes_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $2;
					$$ = n;
				}
			| DATABASE name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DATABASE;
					n->objs = $2;
					$$ = n;
				}
			| DOMAIN_P any_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DOMAIN;
					n->objs = $2;
					$$ = n;
				}
			| LANGUAGE name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_LANGUAGE;
					n->objs = $2;
					$$ = n;
				}
			| LARGE_P OBJECT_P NumericOnly_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_LARGEOBJECT;
					n->objs = $3;
					$$ = n;
				}
			| NODE GROUP_P name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_NODEGROUP;
					n->objs = $3;
					$$ = n;
				}
			| SCHEMA dolphin_schema_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_NAMESPACE;
					n->objs = $2;
					$$ = n;
				}
			| TABLESPACE name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_TABLESPACE;
					n->objs = $2;
					$$ = n;
				}
			| DIRECTORY name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DIRECTORY;
					n->objs = $2;
					$$ = n;
				}
			| TYPE_P any_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_TYPE;
					n->objs = $2;
					$$ = n;
				}
			| ALL TABLES IN_P SCHEMA dolphin_schema_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_RELATION;
					n->objs = $5;
					$$ = n;
				}
			| ALL SEQUENCES IN_P SCHEMA dolphin_schema_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_SEQUENCE;
					n->objs = $5;
					$$ = n;
				}
			| ALL FUNCTIONS IN_P SCHEMA dolphin_schema_name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_FUNCTION;
					n->objs = $5;
					$$ = n;
				}
			| ALL PACKAGES IN_P SCHEMA dolphin_schema_name_list
                {
                    PrivTarget *n = (PrivTarget *)palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_ALL_IN_SCHEMA;
					n->objtype = ACL_OBJECT_PACKAGE;
					n->objs = $5;
					$$ = n;
                }
			| DATA_P SOURCE_P name_list
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_DATA_SOURCE;
					n->objs = $3;
					$$ = n;
				}
			| CLIENT_MASTER_KEY setting_name
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_GLOBAL_SETTING;
					n->objs = $2;
					$$ = n;
				}
			| COLUMN_ENCRYPTION_KEY setting_name
				{
					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
					n->targtype = ACL_TARGET_OBJECT;
					n->objtype = ACL_OBJECT_COLUMN_SETTING;
					n->objs = $2;
					$$ = n;
				}
		;


grantee_list:
			grantee									{ $$ = list_make1($1); }
			| grantee_list ',' grantee				{ $$ = lappend($1, $3); }
		;

grantee:	DolphinUserId
				{
					PrivGrantee *n = makeNode(PrivGrantee);
					/* This hack lets us avoid reserving PUBLIC as a keyword*/
					if (DolphinObjNameCmp($1->str, "public", $1->is_quoted))
						n->rolname = NULL;
					else
						n->rolname = $1->str;
					$$ = (Node *)n;
				}
			| GROUP_P DolphinUserId
				{
					PrivGrantee *n = makeNode(PrivGrantee);
					/* Treat GROUP PUBLIC as a synonym for PUBLIC */
					if (DolphinObjNameCmp($2->str, "public", $2->is_quoted))
						n->rolname = NULL;
					else
						n->rolname = $2->str;
					$$ = (Node *)n;
				}
		;


opt_grant_grant_option:
			WITH GRANT OPTION 
				{ 
					if (isSecurityMode)
					{
						/* Do not support this grammar in security mode.*/
        				const char* message = "WITH GRANT OPTION is not supported in security mode.";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("WITH GRANT OPTION is not supported in security mode.")));
					}
					$$ = TRUE;
				}
			| /*EMPTY*/ { $$ = FALSE; }
		;

function_with_argtypes_list:
			function_with_argtypes					{ $$ = list_make1($1); }
			| function_with_argtypes_list ',' function_with_argtypes
													{ $$ = lappend($1, $3); }
		;

function_with_argtypes:
			func_name func_args
				{
					FuncWithArgs *n = makeNode(FuncWithArgs);
					n->funcname = $1;
					n->funcargs = extractArgTypes($2);
					$$ = n;
				}
		;

/*****************************************************************************
 *
 * GRANT and REVOKE ROLE statements
 *
 *****************************************************************************/

GrantRoleStmt:
			GRANT privilege_list TO UserIdList opt_grant_admin_option opt_granted_by
				{
					GrantRoleStmt *n = makeNode(GrantRoleStmt);
					n->is_grant = true;
					n->granted_roles = $2;
					n->grantee_roles = $4;
					n->admin_opt = $5;
					n->grantor = $6;
					$$ = (Node*)n;
				}
                        | GRANT PROXY ON user TO user_list opt_grant_grant_option
                                {
                                        AccessPriv *priv_n = makeNode(AccessPriv);
                                        priv_n->priv_name = $4;
                                        priv_n->cols = NIL;

                                        GrantRoleStmt *n = makeNode(GrantRoleStmt);
                                        n->is_grant = true;
                                        n->granted_roles = list_make1(priv_n);
                                        n->grantee_roles = $6;
                                        n->admin_opt = $7;
                                        $$ = (Node*)n;
                                }
		;

RevokeRoleStmt:
			REVOKE privilege_list FROM name_list opt_granted_by opt_drop_behavior
				{
					GrantRoleStmt *n = makeNode(GrantRoleStmt);
					n->is_grant = false;
					n->admin_opt = false;
					n->granted_roles = $2;
					n->grantee_roles = $4;
					n->behavior = $6;
					$$ = (Node*)n;
				}
			| REVOKE ADMIN OPTION FOR privilege_list FROM name_list opt_granted_by opt_drop_behavior
				{
					GrantRoleStmt *n = makeNode(GrantRoleStmt);
					n->is_grant = false;
					n->admin_opt = true;
					n->granted_roles = $5;
					n->grantee_roles = $7;
					n->behavior = $9;
					$$ = (Node*)n;
				}
                       | REVOKE PROXY ON user FROM user_list
                                {
                                        AccessPriv *priv_n = makeNode(AccessPriv);
                                        priv_n->priv_name = $4;
                                        priv_n->cols = NIL;

                                        GrantRoleStmt *n = makeNode(GrantRoleStmt);
                                        n->is_grant = false;
                                        n->admin_opt = false;
                                        n->granted_roles = list_make1(priv_n);
                                        n->grantee_roles = $6;
                                        $$ = (Node*)n;
                                }
		;

opt_grant_admin_option: WITH ADMIN OPTION				{ $$ = TRUE; }
			| /*EMPTY*/									{ $$ = FALSE; }
		;

opt_granted_by: GRANTED BY UserId						{ $$ = $3; }
			| /*EMPTY*/									{ $$ = NULL; }
		;

/*****************************************************************************
 *
 * GRANT and REVOKE DATABASE PRIVILEGE statements
 *
 *****************************************************************************/

GrantDbStmt:
			GRANT db_privileges TO grantee_list opt_grant_admin_option
				{
					GrantDbStmt *n = makeNode(GrantDbStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->grantees = $4;
					n->admin_opt = $5;
					$$ = (Node*)n;
				}
			| GRANT index_privileges ON '*' '.' '*' TO grantee_list opt_grant_admin_option
				{
					if (list_length($2) != 1 || strcmp(((AccessPriv *)list_nth($2, 0))->priv_name, "index") != 0) {
						parser_yyerror("syntax error");
					}
					GrantDbStmt *n = makeNode(GrantDbStmt);
					n->is_grant = true;
					DbPriv *n2 = makeNode(DbPriv);
					n2->db_priv_name = pstrdup("create any index");
					n->privileges = list_make1(n2);
					n->grantees = $8;
					n->admin_opt = $9;
					$$ = (Node*)n;
				}
			;

RevokeDbStmt:
			REVOKE db_privileges FROM grantee_list
				{
					GrantDbStmt *n = makeNode(GrantDbStmt);
					n->is_grant = false;
					n->privileges = $2;
					n->grantees = $4;
					n->admin_opt = false;
					$$ = (Node*)n;
				}
			| REVOKE index_privileges ON '*' '.' '*' FROM grantee_list
				{
					if (list_length($2) != 1 || strcmp(((AccessPriv *)list_nth($2, 0))->priv_name, "index") != 0) {
						parser_yyerror("syntax error");
					}		
					GrantDbStmt *n = makeNode(GrantDbStmt);
					n->is_grant = false;
					DbPriv *n2 = makeNode(DbPriv);
					n2->db_priv_name = pstrdup("create any index");
					n->privileges = list_make1(n2);
					n->grantees = $8;
					n->admin_opt = false;
					$$ = (Node*)n;
				}
			| REVOKE ADMIN OPTION FOR db_privileges FROM grantee_list
				{
					GrantDbStmt *n = makeNode(GrantDbStmt);
					n->is_grant = false;
					n->privileges = $5;
					n->grantees = $7;
					n->admin_opt = true;
					$$ = (Node*)n;
				}
		;

db_privileges: db_privilege_list                       { $$ = $1; }
        ;

db_privilege_list: db_privilege                        { $$ = list_make1($1); }
            | db_privilege_list ',' db_privilege       { $$ = lappend($1, $3); }
        ;

db_privilege: CREATE ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any table");
                $$ = n;
            }
            | ALTER ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("alter any table");
                $$ = n;
            }
            | DROP ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any table");
                $$ = n;
            }
            | SELECT ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("select any table");
                $$ = n;
            }
            | INSERT ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("insert any table");
                $$ = n;
            }
            | UPDATE ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("update any table");
                $$ = n;
            }
            | DELETE_P ANY TABLE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("delete any table");
                $$ = n;
            }
            | CREATE ANY SEQUENCE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any sequence");
                $$ = n;
            }
            | CREATE ANY INDEX
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any index");
                $$ = n;
            }
            | CREATE ANY FUNCTION
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any function");
                $$ = n;
            }
            | CREATE ROUTINE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any function");
                $$ = n;				
            }
            | EXECUTE ANY FUNCTION
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("execute any function");
                $$ = n;
            }
            | CREATE ANY PACKAGE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any package");
                $$ = n;
            }
            | EXECUTE ANY PACKAGE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("execute any package");
                $$ = n;
            }
            | CREATE ANY TYPE_P
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any type");
                $$ = n;
            }
            | ALTER ANY TYPE_P
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("alter any type");
                $$ = n;
            }
            | DROP ANY TYPE_P
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any type");
                $$ = n;
            }
            | ALTER ANY SEQUENCE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("alter any sequence");
                $$ = n;
            }
            | DROP ANY SEQUENCE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any sequence");
                $$ = n;
            }
            | SELECT ANY SEQUENCE
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("select any sequence");
                $$ = n;
            }
            | ALTER ANY INDEX
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("alter any index");
                $$ = n;
            }
            | DROP ANY INDEX
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any index");
                $$ = n;
            }
            | CREATE ANY SYNONYM
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any synonym");
                $$ = n;
            }
            | DROP ANY SYNONYM
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any synonym");
                $$ = n;
            }
            | CREATE ANY TRIGGER
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("create any trigger");
                $$ = n;
            }
            | ALTER ANY TRIGGER
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("alter any trigger");
                $$ = n;
            }
            | DROP ANY TRIGGER
            {
                DbPriv *n = makeNode(DbPriv);
                n->db_priv_name = pstrdup("drop any trigger");
                $$ = n;
            }
        ;

/*****************************************************************************
 *
 * ALTER DEFAULT PRIVILEGES statement
 *
 *****************************************************************************/

AlterDefaultPrivilegesStmt:
			ALTER DEFAULT PRIVILEGES DefACLOptionList DefACLAction
				{
					AlterDefaultPrivilegesStmt *n = makeNode(AlterDefaultPrivilegesStmt);
					n->options = $4;
					n->action = (GrantStmt *) $5;
					$$ = (Node*)n;
				}
		;

DefACLOptionList:
			DefACLOptionList DefACLOption			{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

DefACLOption:
			IN_P SCHEMA dolphin_schema_name_list
				{
					$$ = makeDefElem("schemas", (Node *)$3);
				}
			| FOR ROLE name_list
				{
					$$ = makeDefElem("roles", (Node *)$3);
				}
			| FOR USER name_list
				{
					$$ = makeDefElem("roles", (Node *)$3);
				}
		;

/*
 * This should match GRANT/REVOKE, except that individual target objects
 * are not mentioned and we only allow a subset of object types.
 */
DefACLAction:
			GRANT privileges ON defacl_privilege_target TO grantee_list
			opt_grant_grant_option
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = true;
					n->privileges = $2;
					n->targtype = ACL_TARGET_DEFAULTS;
					n->objtype = (GrantObjectType)$4;
					n->objects = NIL;
					n->grantees = $6;
					n->grant_option = $7;
					$$ = (Node*)n;
				}
			| REVOKE privileges ON defacl_privilege_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = false;
					n->privileges = $2;
					n->targtype = ACL_TARGET_DEFAULTS;
					n->objtype = (GrantObjectType)$4;
					n->objects = NIL;
					n->grantees = $6;
					n->behavior = $7;
					$$ = (Node *)n;
				}
			| REVOKE GRANT OPTION FOR privileges ON defacl_privilege_target
			FROM grantee_list opt_drop_behavior
				{
					GrantStmt *n = makeNode(GrantStmt);
					n->is_grant = false;
					n->grant_option = true;
					n->privileges = $5;
					n->targtype = ACL_TARGET_DEFAULTS;
					n->objtype = (GrantObjectType)$7;
					n->objects = NIL;
					n->grantees = $9;
					n->behavior = $10;
					$$ = (Node *)n;
				}
		;

defacl_privilege_target:
			TABLES			{ $$ = ACL_OBJECT_RELATION; }
			| FUNCTIONS		{ $$ = ACL_OBJECT_FUNCTION; }
			| SEQUENCES		{ $$ = ACL_OBJECT_SEQUENCE; }
			| TYPES_P		{ $$ = ACL_OBJECT_TYPE; }
			| CLIENT_MASTER_KEYS			{ $$ = ACL_OBJECT_GLOBAL_SETTING; }
			| COLUMN_ENCRYPTION_KEYS		{ $$ = ACL_OBJECT_COLUMN_SETTING; }
			| PACKAGES      { $$ = ACL_OBJECT_PACKAGE; }
		;


/*****************************************************************************
 *
 *		QUERY: CREATE INDEX
 *
 * Note: we cannot put TABLESPACE clause after WHERE clause unless we are
 * willing to make TABLESPACE a fully reserved word.
 *****************************************************************************/

IndexStmt:	CREATE opt_unique INDEX opt_concurrently opt_index_name
			index_method_relation_clause '(' index_params ')'
			TableIndexOptionList where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $11;
					if ($10 != NULL) {
						n->indexIncludingParams = $10->indexIncludingParams;
						n->options = $10->options;
						n->tableSpace = $10->tableSpace;
						if ($10->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $10->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($10->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			index_method_relation_clause '(' index_params ')'
			TableIndexOptionList idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					if ($10 != NULL) {
						n->indexIncludingParams = $10->indexIncludingParams;
						n->options = $10->options;
						n->tableSpace = $10->tableSpace;
						if ($10->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $10->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($10->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			ON dolphin_qualified_name '(' index_params ')'
			TableIndexOptionList where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $12;
					if ($11 != NULL) {
						n->indexIncludingParams = $11->indexIncludingParams;
						n->options = $11->options;
						n->tableSpace = $11->tableSpace;
						if ($11->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $11->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($11->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			ON dolphin_qualified_name '(' index_params ')'
			TableIndexOptionList idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					if ($11 != NULL) {
						n->indexIncludingParams = $11->indexIncludingParams;
						n->options = $11->options;
						n->tableSpace = $11->tableSpace;
						if ($11->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $11->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($11->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			index_method_relation_clause '(' index_params ')'
			where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $10;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE FULLTEXT INDEX opt_index_name
					fulltext_index_method_relation_clause '(' fulltext_index_params ')' opt_table_index_options
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = false;
					n->concurrent = false;
					n->schemaname = $4->schemaname;
					n->idxname = $4->relname;
					n->relation = $5->relation;
					n->accessMethod = "gin";
					n->indexParams = $7;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					n->indexOptions = $9;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			index_method_relation_clause '(' index_params ')'
			idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			ON dolphin_qualified_name '(' index_params ')'
			where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $11;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			ON dolphin_qualified_name '(' index_params ')'
			idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
			ON dolphin_qualified_name '(' index_params ')' USING access_method opt_idx_algo
				{
					if ($4) {
						ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("syntax error"),
								parser_errposition(@4)));
					} else if ($5->schemaname != NULL) {
						ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("syntax error"),
								parser_errposition(@5)));
					} else if (strcasecmp($12, "BTREE") != 0 && strcasecmp($12, "HASH") != 0) {
						ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("syntax error"),
								parser_errposition(@12)));
					}
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = false;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = $12;
					n->indexParams = $9;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					index_method_relation_clause '(' index_params ')'
					LOCAL opt_partition_index_def PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $11;
					if ($12 != NULL) {
						n->indexIncludingParams = $12->indexIncludingParams;
						n->options = $12->options;
						n->tableSpace = $12->tableSpace;
						if ($12->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $12->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($12->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					LOCAL opt_partition_index_def PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $12;
					if ($13 != NULL) {
						n->indexIncludingParams = $13->indexIncludingParams;
						n->options = $13->options;
						n->tableSpace = $13->tableSpace;
						if ($13->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $13->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($13->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					index_method_relation_clause '(' index_params ')'
					LOCAL opt_partition_index_def opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $11;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					LOCAL opt_partition_index_def opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $12;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					index_method_relation_clause '(' index_params ')'
					GLOBAL PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					if ($11 != NULL) {
						n->indexIncludingParams = $11->indexIncludingParams;
						n->options = $11->options;
						n->tableSpace = $11->tableSpace;
						if ($11->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $11->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($11->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					GLOBAL PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					if ($12 != NULL) {
						n->indexIncludingParams = $12->indexIncludingParams;
						n->options = $12->options;
						n->tableSpace = $12->tableSpace;
						if ($12->comment != NULL) {
							n->indexOptions = lappend(n->indexOptions, $12->comment);
						}
						n->indexOptions = lappend(n->indexOptions, makeString((char*)($12->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					index_method_relation_clause '(' index_params ')'
					GLOBAL opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
					n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $6->relation;
					n->accessMethod = $6->accessMethod;
					n->indexParams = $8;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					GLOBAL opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = false;
                    n->schemaname = $5->schemaname;
					n->idxname = $5->relname;
					n->relation = $7;
					n->accessMethod = NULL;
					n->indexParams = $9;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					TableIndexOptionList where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $14;
					if ($13 != NULL) {
					    n->indexIncludingParams = $13->indexIncludingParams;
					    n->options = $13->options;
					    n->tableSpace = $13->tableSpace;
					    if ($13->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $13->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($13->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					TableIndexOptionList idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					if ($13 != NULL) {
					    n->indexIncludingParams = $13->indexIncludingParams;
					    n->options = $13->options;
					    n->tableSpace = $13->tableSpace;
					    if ($13->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $13->comment);
					    }
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					TableIndexOptionList where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $15;
					if ($14 != NULL) {
					    n->indexIncludingParams = $14->indexIncludingParams;
					    n->options = $14->options;
					    n->tableSpace = $14->tableSpace;
					    if ($14->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $14->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($14->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					TableIndexOptionList idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					if ($14 != NULL) {
					    n->indexIncludingParams = $14->indexIncludingParams;
					    n->options = $14->options;
					    n->tableSpace = $14->tableSpace;
					    if ($14->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $14->comment);
					    }
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $13;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					where_clause
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = $14;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					idx_algo_expr
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->partClause = NULL;
					n->isPartitioned = false;
					n->isGlobal = false;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->whereClause = NULL;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					LOCAL opt_partition_index_def PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $14;
					if ($15 != NULL) {
					    n->indexIncludingParams = $15->indexIncludingParams;
					    n->options = $15->options;
					    n->tableSpace = $15->tableSpace;
					    if ($15->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $15->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($15->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					LOCAL opt_partition_index_def PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $15;
					if ($16 != NULL) {
					    n->indexIncludingParams = $16->indexIncludingParams;
					    n->options = $16->options;
					    n->tableSpace = $16->tableSpace;
					    if ($16->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $16->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($16->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					LOCAL opt_partition_index_def opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $14;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					LOCAL opt_partition_index_def opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->isPartitioned = true;
					n->isGlobal = false;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->partClause  = $15;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					GLOBAL PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					if ($14 != NULL) {
					    n->indexIncludingParams = $14->indexIncludingParams;
					    n->options = $14->options;
					    n->tableSpace = $14->tableSpace;
					    if ($14->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $14->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($14->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					GLOBAL PartitionTableIndexOptionList opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					if ($15 != NULL) {
					    n->indexIncludingParams = $15->indexIncludingParams;
					    n->options = $15->options;
					    n->tableSpace = $15->tableSpace;
					    if ($15->comment != NULL) {
					        n->indexOptions = lappend(n->indexOptions, $15->comment);
					    }
					    n->indexOptions = lappend(n->indexOptions, makeString((char*)($15->visible ? "visible" : "invisible")));
					}
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					index_method_relation_clause '(' index_params ')'
					GLOBAL opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $9->relation;
					n->accessMethod = $9->accessMethod;
					n->indexParams = $11;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
				| CREATE opt_unique INDEX opt_concurrently IF_P NOT EXISTS opt_index_name
					ON dolphin_qualified_name '(' index_params ')'
					GLOBAL opt_idx_algo
				{
					IndexStmt *n = makeNode(IndexStmt);
					n->unique = $2;
					n->concurrent = $4;
					n->missing_ok = true;
					n->schemaname = $8->schemaname;
					n->idxname = $8->relname;
					n->relation = $10;
					n->accessMethod = NULL;
					n->indexParams = $12;
					n->partClause  = NULL;
					n->isPartitioned = true;
					n->isGlobal = true;
					n->excludeOpNames = NIL;
					n->idxcomment = NULL;
					n->indexOid = InvalidOid;
					n->oldNode = InvalidOid;
					n->primary = false;
					n->isconstraint = false;
					n->deferrable = false;
					n->initdeferred = false;
					n->indexIncludingParams = NIL;
					n->options = NIL;
					n->tableSpace = NULL;
					$$ = (Node *)n;
				}
		;

TableIndexOptionList:	TableIndexOption
					{
						$$ = MakeCreateIndexOptions(NULL, $1);
					}
				| TableIndexOptionList TableIndexOption
					{
						$$ = MakeCreateIndexOptions($1, $2);
					}
			;

PartitionTableIndexOptionList:	PartitionTableIndexOption
					{
						$$ = MakeCreateIndexOptions(NULL, $1);
					}
				| PartitionTableIndexOptionList PartitionTableIndexOption
					{
						$$ = MakeCreateIndexOptions($1, $2);
					}
			;

TableIndexOption:
			PartitionTableIndexOption
				{
					$$ = $1;
				}
			| OptInitRans_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_PARTITIONELEMENT_INDEX;
					$$ = n;
				}
			| OptMaxTrans_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_PARTITIONELEMENT_INDEX;
					$$ = n;
				}
			| OptStorage_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_PARTITIONELEMENT_INDEX;
					$$ = n;
				}
			| OptPctFree_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_PARTITIONELEMENT_INDEX;
					$$ = n;
				}
			;

PartitionTableIndexOption:	
			opt_include_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_INCLUDE;
					n->option.list_content = $1;
					$$ = n;
				}
			|	opt_reloptions_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_RELOPTIONS;
					n->option.list_content = $1;
					$$ = n;
				}
			|	OptTableSpace_without_empty
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_TABLESPACE_INDEX;
					n->option.char_content = $1;
					$$ = n;
				}
			| COMMENT opt_equal SCONST
				{
					CommentStmt *node = makeNode(CommentStmt);
					node->objtype = OBJECT_INDEX;
					node->objname = NIL;
					node->objargs = NIL;
					node->comment = $3;
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_COMMENT_INDEX;
					n->option.comment = node;
					$$ = n;
				}
			| INVISIBLE
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_VISIBLE_INDEX;
					n->option.visible = false;
					$$ = n;
				}
			| VISIBLE
				{
					SingleIndexOption *n = (SingleIndexOption*)palloc(sizeof(SingleIndexOption));
					n->option_type = OPT_VISIBLE_INDEX;
					n->option.visible = true;
					$$ = n;
				}
			;

opt_unique:
			UNIQUE									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

opt_concurrently:
			CONCURRENTLY							{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

idx_algo_expr:
	ALGORITHM opt_equal DEFAULT
	{
		$$ = 0;
	}
	| ALGORITHM opt_equal INPLACE
	{
		$$ = 1;
	}
	| ALGORITHM opt_equal COPY
	{
		$$ = 2;
	}

opt_idx_algo:
	idx_algo_expr
	{
		$$ = $1;
	}
	| /* EMPTY */
	{
		$$ = 0;
	}

opt_index_name:
			index_name
				{
					$$ = makeRangeVar(NULL, $1, @1);
				}
			| ColId indirection
				{
					check_qualified_name($2, yyscanner);
					$$ = makeRangeVar(NULL, NULL, @1);
					const char* message = "improper qualified name (too many dotted names): %s";
					switch (list_length($2))
					{
						case 1:
							$$->catalogname = NULL;
							$$->schemaname = $1;
							$$->relname = strVal(linitial($2));
							break;
						default:
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper qualified name (too many dotted names): %s",
											NameListToString(lcons(makeString($1), $2))),
									 parser_errposition(@1)));
							break;
					}
				}
			| /*EMPTY*/								{ $$ = makeRangeVar(NULL, NULL, -1); }
		;

/* b compatibility index hint part */
key_usage_list:
			dolphin_force_index_name
			{
				$$ = list_make1(makeString($1));
			}
			| key_usage_list ',' dolphin_force_index_name
			{
				$$ = lappend($1,makeString($3));
			}
		;

index_hint_definition:
			USE_INDEX '(' key_usage_list ')'
			{
				IndexHintDefinition* n = makeNode(IndexHintDefinition);
				n->index_type = INDEX_HINT_USE;
				n->indexnames = $3;
				$$ = (Node*)n;
			}
			| USE_INDEX '(' ')'
			{
				IndexHintDefinition* n = makeNode(IndexHintDefinition);
				n->index_type = INDEX_HINT_USE;
				n->indexnames = NIL;
				$$ = (Node*)n;
			}
			| FORCE_INDEX '(' key_usage_list ')'
			{
				IndexHintDefinition* n = makeNode(IndexHintDefinition);
				n->index_type = INDEX_HINT_FORCE;
				n->indexnames = $3;
				$$ = (Node*)n;
			}
			| IGNORE_INDEX '(' key_usage_list ')'
			{
				IndexHintDefinition* n = makeNode(IndexHintDefinition);
				n->index_type = INDEX_HINT_IGNORE;
				n->indexnames = $3;
				$$ = (Node*)n;
			}
		;

index_hint_list:
			index_hint_definition
			{
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT)
				{
					const char* message = "index_hint is supported only in B-format database";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("index_hint is supported only in B-format database"),
							parser_errposition(@1)));
				}
				$$ = list_make1($1);
			}
			| index_hint_list index_hint_definition
			{
				$$ = lappend($1,$2);
			}
		;

opt_index_hint_list:
			index_hint_list {$$ = $1;}
			| /*Empty*/ {$$ = NIL;}
		;
/* b compatibility index hint part end*/


access_method_clause:
			USING access_method						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

access_method_clause_without_keyword:
			USING DOLPHINIDENT								{ $$ = downcase_str($2->str, $2->is_quoted); }
			| /*EMPTY*/								{ $$ = NULL; }
		;

index_params:	index_elem							{ $$ = list_make1($1); }
			| index_params ',' index_elem			{ $$ = lappend($1, $3); }
		;

fulltext_index_params:
			fulltext_index_elem											{ $$ = list_make1($1); }
			| fulltext_index_params ',' fulltext_index_elem				{ $$ = lappend($1, $3); }
	;

fulltext_index_elem:
			ColId
				{
					ColumnRef *fulltext_col = makeNode(ColumnRef);
					fulltext_col->fields = list_make1(makeString($1));

					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("to_tsvector");
					n->args = lappend(n->args, makeStringConst("ngram", -1));
					n->args = lappend(n->args, (Node*)fulltext_col);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;

					$$ = makeNode(IndexElem);
					$$->name = NULL;
					$$->expr = (Node *)n;
					$$->indexcolname = NULL;
					$$->collation = NIL;
					$$->opclass = NIL;
					$$->ordering = SORTBY_DEFAULT;
					$$->nulls_ordering = SORTBY_NULLS_DEFAULT;
				}
		;

fulltext_index_method_relation_clause:
			ON dolphin_qualified_name
				{
					 IndexMethodRelationClause* result = (IndexMethodRelationClause*)palloc0(sizeof(IndexMethodRelationClause));
					 result->relation = $2;
					 result->accessMethod = "gin";
					 $$ = result;
				}
		;

index_method_relation_clause:
			ON dolphin_qualified_name USING access_method
				{
					 IndexMethodRelationClause* result = (IndexMethodRelationClause*)palloc0(sizeof(IndexMethodRelationClause));
					 result->relation = $2;
					 result->accessMethod = $4;
					 $$ = result;
				}
			| USING access_method ON dolphin_qualified_name
				{
					 IndexMethodRelationClause* result = (IndexMethodRelationClause*)palloc0(sizeof(IndexMethodRelationClause));
					 result->relation = $4;
					 result->accessMethod = $2;
					 $$ = result;
				}
		;

search_modifier:
			IN_P NATURAL LANGUAGE MODE
			| IN_P NATURAL LANGUAGE MODE WITH QUERY EXPANSION
			| IN_P BOOLEAN_P MODE
			| WITH QUERY EXPANSION
			| /* EMPTY */
		;

/*
 * Index attributes can be either simple column references, or arbitrary
 * expressions in parens.  For backwards-compatibility reasons, we allow
 * an expression that's just a function call to be written without parens.
 */
index_elem:	DolphinColId opt_collation opt_class opt_asc_desc opt_nulls_order
				{
					$$ = makeNode(IndexElem);
					$$->name = downcase_str($1->str, $1->is_quoted);
					$$->expr = NULL;
					$$->indexcolname = NULL;
					$$->collation = $2;
					$$->opclass = $3;
					$$->ordering = (SortByDir)$4;
					$$->nulls_ordering = (SortByNulls)$5;
				}
			| index_functional_expr_key opt_collation opt_class opt_asc_desc opt_nulls_order
				{
					$$ = makeNode(IndexElem);
					$$->name = NULL;
					$$->expr = $1;
					$$->indexcolname = NULL;
					$$->collation = $2;
					$$->opclass = $3;
					$$->ordering = (SortByDir)$4;
					$$->nulls_ordering = (SortByNulls)$5;
				}
			| '(' a_expr ')' opt_collation opt_class opt_asc_desc opt_nulls_order
				{
					$$ = makeNode(IndexElem);
					$$->name = NULL;
					$$->expr = $2;
					$$->indexcolname = NULL;
					$$->collation = $4;
					$$->opclass = $5;
					$$->ordering = (SortByDir)$6;
					$$->nulls_ordering = (SortByNulls)$7;
				}
		;

constraint_params:	constraint_elem							{ $$ = list_make1($1); }
			| constraint_params ',' constraint_elem			{ $$ = lappend($1, $3); }
		;

con_asc_desc: ASC							{ $$ = SORTBY_ASC; }
			| DESC							{ $$ = SORTBY_DESC; }
		;

constraint_elem: ColId con_asc_desc
				{
#ifdef 			ENABLE_MULTIPLE_NODES	
					const char* message = "ASC/DESC is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("ASC/DESC is not yet supported in distributed database.")));
#endif	
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
						$$ = makeNode(IndexElem);
						$$->name = $1;
						$$->expr = NULL;
						$$->indexcolname = NULL;
						$$->collation = NIL;
						$$->opclass = NIL;
						$$->ordering = (SortByDir)$2;
						$$->nulls_ordering = SORTBY_NULLS_DEFAULT;
					} else {
						const char* message = "ASC/DESC is supported only in B-format database.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errmodule(MOD_PARSER),
									errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("ASC/DESC is supported only in B-format database."),
									parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
				}
			| ColId
				{
					$$ = makeNode(IndexElem);
					$$->name = $1;
					$$->expr = NULL;
					$$->indexcolname = NULL;
					$$->collation = NIL;
					$$->opclass = NIL;
					$$->ordering = SORTBY_DEFAULT;
					$$->nulls_ordering = SORTBY_NULLS_DEFAULT;
				}
			| ColId '(' Iconst ')' opt_asc_desc
				{
					PrefixKey* pkey = makeNode(PrefixKey);
					pkey->arg = (Expr*)makeColumnRef(pstrdup($1), NIL, @1, yyscanner);
					pkey->length = $3;
					$$ = makeNode(IndexElem);
					$$->name = NULL;
					$$->expr = (Node*)pkey;
					$$->indexcolname = NULL;
					$$->collation = NULL;
					$$->opclass = NULL;
					$$->ordering = (SortByDir)$5;
				}
			| '(' a_expr ')' opt_asc_desc
				{
#ifdef 			ENABLE_MULTIPLE_NODES	
					const char* message = "expression is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("expression is not yet supported in distributed database.")));
#endif	
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
						$$ = makeNode(IndexElem);
						$$->name = NULL;
						$$->expr = $2;
						$$->indexcolname = NULL;
						$$->collation = NIL;
						$$->opclass = NIL;
						$$->ordering = (SortByDir)$4;
						$$->nulls_ordering = SORTBY_NULLS_DEFAULT;
					} else {
						const char* message = "expression is supported only in B-format database.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errmodule(MOD_PARSER),
									errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("expression is supported only in B-format database."),
									parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
					
				}
		;

index_functional_expr_key:	col_name_keyword_nonambiguous '(' Iconst ')'
					{
						PrefixKey* pk = makeNode(PrefixKey);
						pk->arg = (Expr*)makeColumnRef(pstrdup($1), NIL, @1, yyscanner);
						pk->length = $3;
						$$ = (Node*)pk;
					}
				| dolphin_func_name '(' func_arg_list opt_sort_clause ')'
					{
						List* elist = (List*)$3;
						List* nlist = (List*)$1;
						
						/*
						 * This syntax branch can be parsed either as a column prefix or as a function.
						 * In B-compatible mode, it is preferentially treated as a column prefix.
						 */
						if ($4 == NIL && list_length(elist) == 1 && list_length(nlist) == 1) {
							Node* arg = (Node*)linitial(elist);
							if (IsA(arg, A_Const) && ((A_Const*)arg)->val.type == T_Integer) {
								PrefixKey* pk = makeNode(PrefixKey);
								pk->arg = (Expr*)makeColumnRef(strVal(linitial(nlist)), NIL, @1, yyscanner);
								pk->length = intVal(&((A_Const*)arg)->val);
								$$ = (Node*)pk;
								break;
							}
						}
						
						FuncCall *n = makeNode(FuncCall);
						n->funcname = $1;
						n->args = $3;
						n->agg_order = $4;
						n->agg_star = FALSE;
						n->agg_distinct = FALSE;
						n->func_variadic = FALSE;
						n->over = NULL;
						n->location = @1;
						n->call_func = false;
						$$ = (Node *)n;
					}
				| func_application_special  { $$ = $1; }
				| func_expr_common_subexpr  { $$ = $1; }
		;

opt_include_without_empty:		INCLUDE '(' index_including_params ')'			{ $$ = $3; }
		;

index_including_params:	index_elem						{ $$ = list_make1($1); }
			| index_including_params ',' index_elem		{ $$ = lappend($1, $3); }
		;

collate_option: opt_default COLLATE opt_equal any_name_or_sconst			{ $$ = $4; }
		;

collate:
			COLLATE opt_equal charset_collate_name
			{
#ifdef ENABLE_MULTIPLE_NODES
				const char* message = "specifying character sets and collations is not yet supported";
				InsertErrorMessage(message, u_sess->plsql_cxt.gsplsql_yylloc);
				ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("Un-support feature"),
					errdetail(specifying character sets and collations is not yet supported)));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("specifying character sets and collations is supported only in B-format database")));
				}
				$$ = $3;
			}
		;

set_names_collate:    COLLATE charset_collate_name		{ $$ = $2; }
					| COLLATE DEFAULT					{ $$ = NULL; }
					| /*EMPTY*/							{ $$ = NULL; }
			;

opt_collate:
				collate								{ $$ = $1; }
				| /*EMPTY*/							{ $$ = NULL; }
			;

default_collate:
				collate								{ $$ = $1; }
				| DEFAULT collate					{ $$ = $2; }
			;

opt_collation: 
				COLLATE collate_name				{ $$ = $2; }
				| /*EMPTY*/							{ $$ = NIL; }
			;

opt_class:	any_name								{ $$ = $1; }
			| USING any_name						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

opt_asc_desc: ASC							{ $$ = SORTBY_ASC; }
			| DESC							{ $$ = SORTBY_DESC; }
			| /*EMPTY*/						{ $$ = SORTBY_DEFAULT; }
		;

opt_nulls_order: NULLS_FIRST				{ $$ = SORTBY_NULLS_FIRST; }
			| NULLS_LAST					{ $$ = SORTBY_NULLS_LAST; }
			| /*EMPTY*/						{ $$ = SORTBY_NULLS_DEFAULT; }
		;


opt_partition_index_def:	'(' range_partition_index_list  ')'
							{
								$$ = (Node *)$2;
							}
							| 	{$$ = NULL;}
							;

range_partition_index_list:
							range_partition_index_item
							{
								$$ = (Node*)list_make1($1);
							}
							| range_partition_index_list ',' range_partition_index_item
							{
								$$ = (Node*)lappend((List*)$1, $3);
							}
							;


range_partition_index_item:
                        PARTITION index_name opt_part_options
                        {
                            RangePartitionindexDefState* def = makeNode(RangePartitionindexDefState);
                            def->name = $2;
                            def->tablespace = $3;
                            $$ = (Node*)def;

                        }
                        | PARTITION index_name opt_part_options opt_subpartition_index_def
                        {
                            RangePartitionindexDefState* def = makeNode(RangePartitionindexDefState);
                            def->name = $2;
                            def->tablespace = $3;
                            def->sublist = (List *)$4;
                            $$ = (Node*)def;
                        }
						;

opt_subpartition_index_def:
                        '(' range_subpartition_index_list  ')'
                        {
                            $$ = (Node *)$2;
                        }
                        ;

range_subpartition_index_list:
                        range_subpartition_index_item
                        {
                            $$ = (Node*)list_make1($1);
                        }
                        | range_subpartition_index_list ',' range_subpartition_index_item
                        {
                            $$ = (Node*)lappend((List*)$1, $3);
                        }
                        ;

range_subpartition_index_item:
                       SUBPARTITION index_name opt_part_options
                        {
                            RangePartitionindexDefState* def = makeNode(RangePartitionindexDefState);
                            def->name = $2;
                            def->tablespace = $3;
                            $$ = (Node*)def;
                        }
                        ;
/*****************************************************************************
 *
 *		QUERY:
 *				create [or replace] function <fname>
 *						[(<type-1> { , <type-n>})]
 *						returns <type-r>
 *						as <filename or code in language as appropriate>
 *						language <lang> [with parameters]
 *
 *****************************************************************************/

CreateFunctionStmt:
			CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
			RETURNS func_return createfunc_opt_list opt_definition
				{
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					n->isOraStyle = false;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}			
					n->funcname = $5;
					n->parameters = $6;
					n->returnType = $8;
					n->options = $9;
					n->withClause = $10;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
			  RETURNS TABLE '(' table_func_column_list ')' createfunc_opt_list opt_definition
				{
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					n->isOraStyle = false;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = mergeTableFuncParameters($6, $10);
					n->returnType = TableFuncTypeName($10);
					n->returnType->location = @8;
					n->options = $12;
					n->withClause = $13;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
			  createfunc_opt_list opt_definition
				{
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					n->isOraStyle = false;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = $6;
					n->returnType = NULL;
					n->options = $7;
					n->withClause = $8;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
			  RETURN func_return opt_createproc_opt_list as_is {
				  u_sess->parser_cxt.eaten_declare = false;
				  u_sess->parser_cxt.eaten_begin = false;
				  pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
                  u_sess->parser_cxt.isCreateFuncOrProc = true;
			  } subprogram_body
				{
					int rc = 0;
					rc = CompileWhich();
                                        if (rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) {
                                            u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @10);
                                        }
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					FunctionSources *funSource = (FunctionSources *)$12;
					n->isOraStyle = true;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = $6;
					n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
					n->returnType = $8;
					n->options = $9;
					n->options = lappend(n->options, makeDefElem("as",
										(Node *)list_make1(makeString(funSource->bodySrc))));

					n->withClause = NIL;
					n->isProcedure = false;
					u_sess->parser_cxt.isCreateFuncOrProc = false;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
				RETURNS func_return opt_createfunc_opt_list {
					u_sess->parser_cxt.eaten_declare = false;
					u_sess->parser_cxt.eaten_begin = false;
					pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
			  		u_sess->parser_cxt.isCreateFuncOrProc = true;
                        	} BEGIN_P b_proc_body
                        	{
					int rc = 0;
					rc = CompileWhich();
					if (rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) {
					    u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @9);
					}
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					FunctionSources *funSource = (FunctionSources*)$12;
					/* check whether function body has RETURN */
					if (!funSource->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					n->isOraStyle = false;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = $6;
					n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
					n->returnType = $8;
					List* filtered_options = NIL;
					n->options = handleCreateDolphinFuncOptions($9);
					n->options = lappend(n->options, makeDefElem("as", (Node*)list_make1(makeString(funSource->bodySrc))));
					n->options = lappend(n->options, makeDefElem("language", (Node*)makeString("plpgsql")));

					n->withClause = NIL;
					n->isProcedure = false;
		    			u_sess->parser_cxt.isCreateFuncOrProc = false;
					$$ = (Node*)n;
				}
			| CREATE opt_or_replace definer_user FUNCTION func_name_opt_arg proc_args
				RETURNS func_return opt_createfunc_opt_list {
					u_sess->parser_cxt.eaten_declare = false;
					u_sess->parser_cxt.eaten_begin = false;
					pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
			  		u_sess->parser_cxt.isCreateFuncOrProc = true;
					GetSessionContext()->is_first_lable = true;
				} dolphin_flow_control
				{
					int rc = 0;
					rc = CompileWhich();
					if (rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) {
					    u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @9);
					}
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					FunctionSources *funSource = (FunctionSources*)$11;
					n->isOraStyle = false;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = $6;
					n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
					n->returnType = $8;
					List* filtered_options = NIL;
					n->options = handleCreateDolphinFuncOptions($9);
					n->options = lappend(n->options, makeDefElem("as", (Node*)list_make1(makeString(funSource->bodySrc))));
					n->options = lappend(n->options, makeDefElem("language", (Node*)makeString("plpgsql")));

					n->withClause = NIL;
					n->isProcedure = false;
					u_sess->parser_cxt.isCreateFuncOrProc = false;
					$$ = (Node*)n;
                        	}
		;

CallFuncStmt:    CALL func_name_opt_arg callfunc_args_or_empty
					{
#ifndef ENABLE_MULTIPLE_NODES
						$$ = makeCallFuncStmt($2, $3, enable_out_param_override());
#else
						$$ = makeCallFuncStmt($2, $3, false);
#endif
					}
				;

callfunc_args_or_empty:  {$$ = NULL;}
			|'(' callfunc_args ')'
					{
					$$ = $2;
					}
				;

callfunc_args:   func_arg_expr
				{
					$$ = list_make1($1);
				}
			| callfunc_args ',' func_arg_expr
				{
					$$ = lappend($1, $3);
				}
			| /* Empty */
				{
					$$ = NULL;
				}
			;
			
/*****************************************************************************
 *
 *             QUERY:
 *                             create [definer_name] event [IF NOT EXIST] <ename>
 *                                             on schedule schedule_time
 *                                             [ON COMPLETION [NOT] PRESERVE]
 *                                             [ENABLE | DISABLE | DISABLE ON SLAVE]
 *                                             [COMMENT 'string']
 *                                             do event_body
 *
 *****************************************************************************/
 
 CreateEventStmt:
                CREATE opt_or_replace definer_opt EVENT qualified_name ON SCHEDULE start_expr opt_ev_on_completion
                opt_ev_status comment_opt DO ev_body
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "create event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("CREATE EVENT is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						const char* message = "create event statement is only supported in B format.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("CREATE EVENT is supported only in B-format database"),
								parser_errposition(@1)));
						$$ = NULL;
					} 
					if($2) {
						parser_yyerror("EVENT not support REPLACE function");
					}
					CreateEventStmt *n = makeNode(CreateEventStmt);
					n->def_name = $3;
					n->if_not_exists = false;
					n->event_name = $5;
					n->start_time_expr = $8;
					n->end_time_expr = NULL;
					n->interval_time = NULL;
					n->complete_preserve = $9;
					n->event_status = (EventStatus)$10;
					n->event_comment_str = $11;
					n->event_query_str = $13;
					$$ = (Node *)n;
				}
				| CREATE opt_or_replace definer_opt EVENT IF_P NOT EXISTS qualified_name ON SCHEDULE start_expr opt_ev_on_completion
                opt_ev_status comment_opt DO ev_body
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "create event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("CREATE EVENT is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						const char* message = "create event statement is only supported in B format.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("CREATE EVENT is supported only in B-format database."),
								parser_errposition(@1)));
						$$ = NULL;
					} 
					if($2) {
						parser_yyerror("EVENT not support REPLACE function");
					}
					CreateEventStmt *n = makeNode(CreateEventStmt);
					n->def_name = $3;
					n->if_not_exists = true;
					n->event_name = $8;
					n->start_time_expr = $11;
					n->end_time_expr = NULL;
					n->interval_time = NULL;
					n->complete_preserve = $12;
					n->event_status = (EventStatus)$12;
					n->event_comment_str = $14;
					n->event_query_str = $16;
					$$ = (Node *)n;
				}
				| CREATE opt_or_replace definer_opt EVENT qualified_name ON SCHEDULE EVERY every_interval start_expr end_expr opt_ev_on_completion
				opt_ev_status comment_opt DO ev_body
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "create event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("CREATE EVENT is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						const char* message = "create event statement is only supported in B format.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("CREATE EVENT is supported only in B-format database."),
								parser_errposition(@1)));
						$$ = NULL;
					}
					if($2) {
						parser_yyerror("EVENT not support REPLACE function");
					}
					CreateEventStmt *n = makeNode(CreateEventStmt);
					n->def_name = $3;
					n->if_not_exists = false;
					n->event_name = $5;
					n->start_time_expr = $10;
					n->end_time_expr = $11;
					n->interval_time = $9;
					n->complete_preserve = $12;
					n->event_status = (EventStatus)$13;
					n->event_comment_str = $14;
					n->event_query_str = $16;
					$$ = (Node *)n;
				}
				| CREATE opt_or_replace definer_opt EVENT IF_P NOT EXISTS qualified_name ON SCHEDULE EVERY every_interval start_expr end_expr opt_ev_on_completion
				opt_ev_status comment_opt DO ev_body
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "create event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc); 
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("CREATE EVENT is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						const char* message = "create event statement is only supported in B format.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("CREATE EVENT is supported only in B-format database."),
								parser_errposition(@1)));
						$$ = NULL;
					}
					if($2) {
						parser_yyerror("EVENT not support REPLACE function");
					}
					CreateEventStmt *n = makeNode(CreateEventStmt);
					n->def_name = $3;
					n->if_not_exists = true;
					n->event_name = $8;
					n->start_time_expr = $13;
					n->end_time_expr = $14;
					n->interval_time = $12;
					n->complete_preserve = $15;
					n->event_status = (EventStatus)$16;
					n->event_comment_str = $17;
					n->event_query_str = $19;
					$$ = (Node *)n;
				}
			;


definer_opt:
			DEFINER '=' UserId                        { $$ = $3; }
			| /* EMPTY */                           { $$ = NULL; }
		;

event_interval_unit: opt_interval			{$$ = $1;}
					| opt_evtime_unit		{$$ = $1;}
				;

every_interval:
                Iconst event_interval_unit			
				{
					TypeName *t;
					t = SystemTypeName("interval");
					t->typmods = $2;
					Node *num = makeIntConst($1, @1);
		            $$ = makeTypeCast(num, t, -1);	
				}
				| SCONST event_interval_unit
				{
					TypeName *t;
					t = SystemTypeName("interval");
					t->typmods = $2;
					Node *num = makeStringConst($1, @1);
					$$ = makeTypeCast(num, t, -1);
				}
				| FCONST event_interval_unit
				{
					TypeName *t;
					t = SystemTypeName("interval");
					t->typmods = $2;
					Node *num = makeStringConst($1, @1);
					$$ = makeTypeCast(num, t, -1);
				}
			;

start_expr:		STARTS ev_timeexpr
			{ $$ = $2; }
				| AT ev_timeexpr  		
			{ $$ = $2; }
				| /* EMPTY */               { $$ = NULL; }
			;

end_expr:		ENDS ev_timeexpr		
			{ $$ = $2; }
				| /* EMPTY */ 				{ $$ = NULL; }
			;

ev_timeexpr:		initime	{ $$ = $1; }
			| initime '+' interval_list
			{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", $1, $3, @2);}
			| initime '-' interval_list
			{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "-", $1, $3, @2);}
		;

interval_list: interval_cell						{ $$ = $1; }
			| interval_list '+' interval_list
            	{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", $1, $3, @2); }
            | interval_list '-' interval_list
            	{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "-", $1, $3, @2); }
	;

interval_cell:  INTERVAL ICONST opt_interval
				{
					char* a = NULL;
					a = (char*)palloc(8);
					pg_itoa($2, a);
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					t->typmods = $3;
					$$ = makeStringConstCast(a, @2, t);
				}
				| INTERVAL SCONST opt_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					t->typmods = $3;
					$$ = makeStringConstCast($2, @2, t);
				}
				| INTERVAL FCONST opt_interval
				{
					$$  = makeFloatConst($2, @2);
				}
				| /* EMPTY */ 				{ $$ = NULL; }
			;

initime: 		interval_intexpr			{$$ = $1; }
				| func_expr_common_subexpr	{$$ = $1; }
				| functime_app				{$$ = $1; }
			;

functime_app:			normal_ident '(' ')'
				{
					FuncCall *n = makeNode(FuncCall);
					
					n->funcname = list_make1(makeString($1));
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
				| normal_ident '(' func_arg_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = list_make1(makeString($1));
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			;

interval_intexpr:
		 SCONST
		{
			$$ = makeStringConstCast($1, @1, SystemTypeName("timestamp"));
		}
	;

opt_ev_on_completion:
                       ON COMPLETION PRESERVE                  { $$ = FALSE; }
                       | ON COMPLETION NOT PRESERVE            { $$ = TRUE; }
                       | /*EMPTY*/                             	   { $$ = TRUE; }
               	;

opt_ev_status:
                       ENABLE_P                        				{ $$ = EVENT_ENABLE; }
                       | DISABLE_P                            		{ $$ = EVENT_DISABLE; }
                       | DISABLE_P ON SLAVE         				{ $$ = EVENT_DISABLE_ON_SLAVE; }
                       | /*EMPTY*/                                	{ $$ = EVENT_ENABLE; }
               ;



comment_opt:    COMMENT SCONST                                  { $$ = $2; }
                | /*EMPTY*/                                     { $$ = NULL; }
	;

ev_body:    {
				char    *ev_body_str = NULL;
				int     ev_body_len = 0;
				int     tok = YYEMPTY;
				int     proc_b = 0;
				int     proc_e = 0;
				int     rc = 0;
				int     pre_tok = 0;
				int    	ploc = 0;
				int     pre_loc = 0;
				int     next_tok = 0;
				int  	flag = 0;
				rc = CompileWhich();
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
				if (yychar == YYEOF || yychar == YYEMPTY) {
					tok = YYLEX;
				}
				else {
					tok = yychar;
					yychar = YYEMPTY;
				}
				proc_b = yylloc;
				/* start event body scan */
				while (true) {
					if(tok == ';') {
						++flag;
					}

					if(tok == YYEOF ) {
						tok = YYLEX;
						if(flag) {
							proc_e = pre_loc;
						} else {
							proc_e = yylloc;
						}	
						break;
					}
					ploc = yylloc;
					if(tok != 0) {
						pre_loc = ploc;
					}
					pre_tok = tok;
					tok = YYLEX;
				}
				if (proc_e == 0) {
					ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("event body is not ended correctly.")));
				}
				ev_body_len = proc_e - proc_b + 1;
				ev_body_str = (char*)palloc0(ev_body_len + 1);
				rc = strncpy_s(ev_body_str, ev_body_len + 1, yyextra->core_yy_extra.scanbuf + proc_b - 1, ev_body_len);
				securec_check(rc, "\0", "\0");
				ev_body_str[ev_body_len] = '\0';
				/* Reset the flag which mark whether we are in slash proc. */
				yyextra->core_yy_extra.in_slash_proc_body = false;
				yyextra->core_yy_extra.dolqstart = NULL;
				$$ = ev_body_str;
		}
	;


/*****************************************************************************
 *
 *             QUERY:
 *                  ALTER
 *						[DEFINER = user]
 *						EVENT event_name
 *						[ON SCHEDULE schedule]
 *						[ON COMPLETION [NOT] PRESERVE]
 *						[RENAME TO new_event_name]
 *						[ENABLE | DISABLE | DISABLE ON SLAVE]
 *						[COMMENT 'string']
 *						[DO event_body]
 *
 *****************************************************************************/
AlterEventStmt:
					ALTER definer_name_opt EVENT qualified_name  preserve_opt rename_opt status_opt comments_opt action_opt
					{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "alter event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("ALTER EVENT is not yet supported in distributed database.")));
#endif
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
							const char* message = "alter event statement is only supported in B format.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errmodule(MOD_PARSER),
									errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("ALTER EVENT is supported only in B-format database."),
									parser_errposition(@1)));
							$$ = NULL;
						}
						AlterEventStmt *n = makeNode(AlterEventStmt);
						n->def_name = $2;
						n->event_name = $4;
						n->start_time_expr = NULL;
						n->end_time_expr = NULL;
						n->interval_time = NULL;
						n->complete_preserve = $5;
						n->new_name = $6;
						n->event_status = $7;
						n->event_comment_str = $8;
						n->event_query_str = $9;
						$$ = (Node*)n;
					}
					| ALTER definer_name_opt EVENT qualified_name ON SCHEDULE AT ev_timeexpr preserve_opt 
					rename_opt status_opt comments_opt action_opt
					{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "alter event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("ALTER EVENT is not yet supported in distributed database.")));
#endif
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
							const char* message = "alter event statement is only supported in B format.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("ALTER EVENT is supported only in B-format database."),
								parser_errposition(@1)));
							$$ = NULL;
						}
						AlterEventStmt *n = makeNode(AlterEventStmt);
						n->def_name = $2;
						n->event_name = $4;
						n->start_time_expr = makeDefElem("start_date", (Node *)$8);
						n->end_time_expr = NULL;
						n->interval_time = makeDefElem("repeat_interval", NULL);
						n->complete_preserve = $9;
						n->new_name = $10;
						n->event_status = $11;
						n->event_comment_str = $12;
						n->event_query_str = $13;
						$$ = (Node*)n;
					}
					| ALTER definer_name_opt EVENT qualified_name ON SCHEDULE EVERY every_interval start_opt
					end_opt preserve_opt rename_opt status_opt comments_opt action_opt
					{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "alter event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("ALTER EVENT is not yet supported in distributed database.")));
#endif
						if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
							const char* message = "alter event statement is only supported in B format.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errmodule(MOD_PARSER),
									errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("ALTER EVENT is supported only in B-format database."),
									parser_errposition(@1)));
							$$ = NULL;
							
						}
						AlterEventStmt *n = makeNode(AlterEventStmt);
						n->def_name = $2;
						n->event_name = $4;
						n->start_time_expr = $9;
						n->end_time_expr = $10;
						n->interval_time = makeDefElem("repeat_interval", (Node *)$8);
						n->complete_preserve = $11;
						n->new_name = $12;
						n->event_status = $13;
						n->event_comment_str = $14;
						n->event_query_str = $15;
						$$ = (Node*)n;
					}
                        ;

definer_name_opt:	DEFINER '=' UserId
			{ 
				$$ = makeDefElem("owner", (Node *)makeString($3));
			} 
                        | /* EMPTY */                           { $$ = NULL; }
                ;


end_opt:                ENDS ev_timeexpr 
                                {
                                        $$ = makeDefElem("end_date", (Node *)$2);
                                }
                                |/*EMPTY*/                      { $$ = NULL; }
                        ;

start_opt:
                                STARTS  ev_timeexpr
                                {
                                        $$ = makeDefElem("start_date", (Node *)$2);
                                }
                                | /*EMPTY*/                     { $$ = NULL; }
                        ;
preserve_opt:   ON COMPLETION PRESERVE
                                {
                                        $$ = makeDefElem("auto_drop", (Node *)makeInteger(0));
                                }
                                | ON COMPLETION NOT PRESERVE
                                {
                                        $$ = makeDefElem("auto_drop", (Node *)makeInteger(1));
                                }
                                | /*EMPTY*/                     { $$ = NULL; }
                        ;

rename_opt:		RENAME TO name
				{
					$$ = makeDefElem("rename", (Node *)makeString($3));
				}
				| /*EMPTY*/			{ $$ = NULL; }
			;
status_opt:		ENABLE_P			{$$ = makeDefElem("enabled", (Node *)makeInteger(0));}
				| DISABLE_P			{$$ = makeDefElem("enabled", (Node *)makeInteger(1));}
				| DISABLE_P ON SLAVE{$$ = makeDefElem("enabled", (Node *)makeInteger(2));}
				| /*EMPTY*/			{ $$ = NULL; }
			;

comments_opt:	COMMENT SCONST					{$$ = makeDefElem("comments", (Node *)makeString($2));}
				| /*EMPTY*/			{ $$ = NULL; }
			;

action_opt:		DO ev_body				{$$ = makeDefElem("program_action", (Node *)makeString($2));}
				| /*EMPTY*/			{ $$ = NULL; }
			;


/*****************************************************************************
 *
 *             QUERY:
 *                             DROP EVENT [IF EXISTS] event_name
 *
 *****************************************************************************/
DropEventStmt:
			DROP EVENT IF_P EXISTS qualified_name
			{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "drop event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("DROP EVENT is not yet supported in distributed database.")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					const char* message = "drop event statement is only supported in B format.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("DROP EVENT is supported only in B-format database."),
							parser_errposition(@1)));
					$$ = NULL;
				}
				DropEventStmt *n = makeNode(DropEventStmt);
				n->missing_ok = true;
				n->event_name = $5;
				$$ = (Node*)n; 
			}
			| DROP EVENT qualified_name
			{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "drop event statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("DROP EVENT is not yet supported in distributed database.")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					const char* message = "drop event statement is only supported in B format.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("DROP EVENT is supported only in B-format database"),
								parser_errposition(@1)));
					$$ = NULL;
				}
				DropEventStmt *n = makeNode(DropEventStmt);
				n->missing_ok = false;
				n->event_name = $3;
				$$ = (Node*)n; 
			}
		;

/*****************************************************************************
 *
 *             QUERY:
 *                             SHOW EVENTS
 *   							[{FROM | IN} schema_name]
 *  							[LIKE 'pattern' | WHERE expr]
 *
 *****************************************************************************/

ShowEventStmt:
			 SHOW EVENTS event_from_clause event_where_clause
			{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "show events statement is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SHOW EVENTS is not yet supported in distributed database.")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					const char* message = "show events statement is only supported in B format.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("SHOW EVENTS is supported only in B-format database."),
							parser_errposition(@1)));
					$$ = NULL;
				}
				ShowEventStmt *n = makeNode(ShowEventStmt);
				n->from_clause = $3;
				n->where_clause = $4;
				$$ = (Node*)n;
            }
			| SHOW EVENTS event_from_clause
			{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "show events is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SHOW EVENTS is not yet supported in distributed database.")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					const char* message = "show events statement is only supported in B format.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("SHOW EVENTS is supported only in B-format database."),
							parser_errposition(@1)));
					$$ = NULL;
				}
				ShowEventStmt *n = makeNode(ShowEventStmt);
					n->from_clause = $3;
					n->where_clause = NULL;	
					$$ = (Node*)n;
			}
			| SHOW EVENTS event_where_clause
			{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "show events is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SHOW EVENTS is not yet supported in distributed database.")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					const char* message = "show events statement is only supported in B format.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate, (errmodule(MOD_PARSER),
							errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("SHOW EVENTS is supported only in B-format database."),
							parser_errposition(@1)));
					$$ = NULL;
				}
				ShowEventStmt *n = makeNode(ShowEventStmt);
				n->from_clause = NULL;
				n->where_clause = $3;
				$$ = (Node*)n;
			}
		;


event_from_clause:
			FROM ColId
			{
				$$ = makeStringConst($2, @2);
			}
			| IN_P ColId
			{
				$$ = makeStringConst($2, @2);
			}
        ;

event_where_clause:
			WHERE ev_where_body 
			{
				$$ = $2;
			}
			| LIKE SCONST
			{
				errno_t	rc = EOK;
				char* event_where_str;
				event_where_str = (char *)palloc(1024 + strlen($2));
				rc = strcpy_s(event_where_str, 1024 + strlen($2), "job_name like '");
				securec_check(rc, "\0", "\0");
				rc = strcat_s(event_where_str, 1024 + strlen($2), $2);
				securec_check(rc, "\0", "\0");
				rc = strcat_s(event_where_str, 1024 + strlen($2), "\'");
				securec_check(rc, "\0", "\0");
				$$ = event_where_str;
			}
        ;

ev_where_body:	{
				char    *ev_body_str = NULL;
				int     ev_body_len = 0;
				int     tok = YYEMPTY;
				int     proc_b = 0;
				int     proc_e = 0;
				int     rc = 0;
				int     pre_tok = 0;
				int    	ploc = 0;
				int     pre_loc = 0;
				int     next_tok = 0;
				int  	flag = 0;
				rc = CompileWhich();
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
				if (yychar == YYEOF || yychar == YYEMPTY) {
					tok = YYLEX;
				}
				else {
					tok = yychar;
					yychar = YYEMPTY;
				}
				proc_b = yylloc;
				/* start event body scan */
				while (true) {
					if(tok == ';') {
						++flag;
					}

					if(tok == YYEOF ) {
						tok = YYLEX;
						if(flag) {
							proc_e = pre_loc;
						} else {
							proc_e = yylloc;
						}
						break;
					}
					ploc = yylloc;
					if(tok != 0) {
						pre_loc = ploc;
					}
					pre_tok = tok;
					tok = YYLEX;
				}
				if (proc_e == 0) {
					ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("where body is not ended correctly.")));
				}
				ev_body_len = proc_e - proc_b + 1;
				ev_body_str = (char*)palloc0(ev_body_len + 1);
				rc = strncpy_s(ev_body_str, ev_body_len + 1, yyextra->core_yy_extra.scanbuf + proc_b - 1, ev_body_len);
				securec_check(rc, "\0", "\0");
				ev_body_str[ev_body_len] = '\0';
				/* Reset the flag which mark whether we are in slash proc. */
				yyextra->core_yy_extra.in_slash_proc_body = false;
				yyextra->core_yy_extra.dolqstart = NULL;
				$$ = ev_body_str;
			}
		;


b_proc_body:{
				int		proc_b	= 0;
				int		proc_e	= 0;
				char	*proc_body_str	= NULL;
				int		proc_body_len	= 0;
				int		blocklevel		= 0;
				FunctionSources *funSrc = NULL;
				char *proc_header_str = NULL;
				int rc = 0;
				rc = CompileWhich();
				int	tok = YYEMPTY;
				int	pre_tok = 0;
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);

				yyextra->core_yy_extra.in_slash_proc_body = true;
				/* the token BEGIN_P have been parsed */
				blocklevel = 1;

				if (yychar == YYEOF || yychar == YYEMPTY)
					tok = YYLEX;
				else
				{
					tok = yychar;
					yychar = YYEMPTY;
				}

				/* Save procedure header str,start with param exclude brackets */
				proc_header_str = ParseFunctionArgSrc(yyscanner);

				/* Save the beginning of procedure body. */
				proc_b = yylloc;
				if (rc != PLPGSQL_COMPILE_NULL && rc != PLPGSQL_COMPILE_PROC) {
					u_sess->plsql_cxt.procedure_first_line = GetLineNumber(yyextra->core_yy_extra.scanbuf, yylloc);
				}
				/* start procedure body scan */
				bool hasReturn = false;
				while(true)
				{
					if (tok == YYEOF) {
						proc_e = yylloc;
						parser_yyerror("subprogram body is not ended correctly");
						break;
					}

					if (tok == BEGIN_P)
						blocklevel++;

					/*
					 * End of procedure rules:
					 *	;END [;]
					 * 	| BEGIN END[;]
					 */
					if (tok == END_P)
					{
						tok = YYLEX;

						/* adapt A db's label */
						if (!(tok == ';' || (tok == YYEOF || TOKEN_IS_DELIMITER))
							&& tok != IF_P
							&& tok != CASE
							&& tok != LOOP
							&& tok != WHILE_P
							&& tok != REPEAT)
						{
							tok = END_P;
							continue;
						}

						/*pre_tok = 0 for begin (nothing) end;*/
					 	if (blocklevel == 1
							&& (pre_tok == ';' || pre_tok == BEGIN_P || pre_tok == 0)
							&& (tok == ';' || (tok == YYEOF || TOKEN_IS_DELIMITER)))
						{
							/* Save the end of procedure body. */
							proc_e = yylloc;

							if (tok == ';' )
							{
								if (yyextra->lookahead_num != 0) {
									parser_yyerror("subprogram body is not ended correctly");
									break;
								}
								else
								{
									yyextra->lookahead_token[0] = tok;
									yyextra->lookahead_num = 1;
								}
							}
							break;
						}

						/* Cope with nested BEGIN/END pairs.
						 * In fact the tok can not be 0
						 */
					 	if (blocklevel > 1
							 && (pre_tok == ';' || pre_tok == BEGIN_P)
							 && (tok == ';' || tok == 0))
						{
							blocklevel--;
						}
					}
					if (tok == RETURN) {
						hasReturn = true;
					}
					pre_tok = tok;
					tok = YYLEX;
				}

				if (proc_e == 0) {
					ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("subprogram body is not ended correctly")));
				}

				proc_body_len = proc_e - proc_b + 1 ;

				proc_body_str = (char *)palloc0(proc_body_len + BEGIN_P_LEN + 1);

				rc = strncpy_s(proc_body_str, proc_body_len + BEGIN_P_LEN + 1, BEGIN_P_STR, BEGIN_P_LEN + 1);
				securec_check(rc, "", "");
				rc = strncpy_s(proc_body_str + BEGIN_P_LEN, proc_body_len + 1,
					yyextra->core_yy_extra.scanbuf + proc_b - 1, proc_body_len);
				securec_check(rc, "", "");

				proc_body_len = BEGIN_P_LEN + proc_body_len;

				proc_body_str[proc_body_len] = '\0';

				/* Reset the flag which mark whether we are in slash proc. */
				yyextra->core_yy_extra.in_slash_proc_body = false;
				yyextra->core_yy_extra.dolqstart = NULL;

				/*
				 * Add the end location of slash proc to the locationlist for the multi-query 
				 * processed.
				 */
				yyextra->core_yy_extra.query_string_locationlist = 
					lappend_int(yyextra->core_yy_extra.query_string_locationlist, yylloc);

				funSrc = makeNode(FunctionSources);
				funSrc->bodySrc   = proc_body_str;
				funSrc->headerSrc = proc_header_str;
				funSrc->hasReturn = hasReturn;

				$$ = funSrc;
			}
		;

SingleLineProcPart:
			{GetSessionContext()->single_line_proc_begin = yylloc;}
				SelectStmt
                        {
                                char* strbody = NULL;
                                base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
                                int start_pos = GetSessionContext()->single_line_proc_begin;
                                int end_pos = yylloc;
                                strbody = SingleLineProcedureQueryGet(start_pos, end_pos, yyextra);
                                GetSessionContext()->single_line_proc_begin = -1;
                                $$ = strbody;
                        }
		;
proc_arg_no_empty:
                        {pg_yyget_extra(yyscanner)->core_yy_extra.func_param_begin = yylloc;}
                        func_args_with_defaults {
                                        pg_yyget_extra(yyscanner)->core_yy_extra.func_param_end = yylloc;
                                        $$= $2;
                                }
		;

CreateProcedureStmt:
			CREATE opt_or_replace definer_user PROCEDURE func_name_opt_arg proc_arg_no_empty
			opt_createproc_opt_list{
                                u_sess->parser_cxt.eaten_declare = false;
                                u_sess->parser_cxt.eaten_begin = false;
                                pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
                                u_sess->parser_cxt.isCreateFuncOrProc = true;
                        }
			BEGIN_P b_proc_body
				{
					int rc = 0;
                                        rc = CompileWhich();
                                        if ((rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) && u_sess->cmd_cxt.CurrentExtensionObject == InvalidOid) {
                                                u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @6);
                                        }
                                        rc = CompileWhich();
                                        CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
                                        FunctionSources *funSource = (FunctionSources *)$10;
                                        int count = get_outarg_num($6);
					n->isOraStyle = true;
                                        n->isPrivate = false;
                                        n->replace = $2;
                                        n->definer = $3;
                                        if (n->replace && NULL != n->definer) {
                                                parser_yyerror("not support DEFINER function");
                                        }
                                        n->funcname = $5;
                                        n->parameters = $6;
                                        n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
                                        n->returnType = NULL;
                                        n->isProcedure = true;
                                        if (0 == count)
                                        {
                                                n->returnType = makeTypeName("void");
                                                n->returnType->typmods = NULL;
                                                n->returnType->arrayBounds = NULL;
                                        }
                                        n->options = $7;
                                        n->options = lappend(n->options, makeDefElem("as",
                                                                                (Node *)list_make1(makeString(funSource->bodySrc))));
                                        n->withClause = NIL;
					u_sess->parser_cxt.isCreateFuncOrProc = false;
                                        $$ = (Node *)n;
				}

			| CREATE opt_or_replace definer_user PROCEDURE func_name_opt_arg proc_arg_no_empty
			opt_createproc_opt_list as_is {
				u_sess->parser_cxt.eaten_declare = false;
				u_sess->parser_cxt.eaten_begin = false;
				pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
				u_sess->parser_cxt.isCreateFuncOrProc = true;
			} subprogram_body
				{
					int rc = 0;
					rc = CompileWhich();
					if ((rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) && u_sess->cmd_cxt.CurrentExtensionObject == InvalidOid) {
						u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @8);
					}
					rc = CompileWhich();
					CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
					FunctionSources *funSource = (FunctionSources *)$10;
					int count = get_outarg_num($6);

					n->isOraStyle = true;
					n->isPrivate = false;
					n->replace = $2;
					n->definer = $3;
					if (n->replace && NULL != n->definer) {
						parser_yyerror("not support DEFINER function");
					}
					n->funcname = $5;
					n->parameters = $6;
					n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
					n->returnType = NULL;
					n->isProcedure = true;
					if (0 == count)
					{
						n->returnType = makeTypeName("void");
						n->returnType->typmods = NULL;
						n->returnType->arrayBounds = NULL;
					}
					n->options = $7;
					n->options = lappend(n->options, makeDefElem("as",
										(Node *)list_make1(makeString(funSource->bodySrc))));
					n->withClause = NIL;
					u_sess->parser_cxt.isCreateFuncOrProc = false;
					$$ = (Node *)n;
				}
			| CREATE opt_or_replace definer_user PROCEDURE func_name_opt_arg opt_createproc_opt_list as_is {
						u_sess->parser_cxt.eaten_declare = false;
						u_sess->parser_cxt.eaten_begin = false;
						pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
						u_sess->parser_cxt.isCreateFuncOrProc = true;
					}
					subprogram_body
					{
							int rc = 0;
							rc = CompileWhich();
							if ((rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) && u_sess->cmd_cxt.CurrentExtensionObject == InvalidOid) {
									u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @7);
							}
							rc = CompileWhich();
							CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
							FunctionSources *funSource = (FunctionSources *)$9;
							int count = get_outarg_num(NIL);
		
							n->isOraStyle = true;
							n->isPrivate = false;
							n->replace = $2;
							n->definer = $3;
							if (n->replace && NULL != n->definer) {
									parser_yyerror("not support DEFINER function");
							}
							n->funcname = $5;
							n->parameters = NIL;
							n->inputHeaderSrc = FormatFuncArgType(yyscanner, funSource->headerSrc, n->parameters);
							n->returnType = NULL;
							n->isProcedure = true;
							if (0 == count)
							{
									n->returnType = makeTypeName("void");
									n->returnType->typmods = NULL;
									n->returnType->arrayBounds = NULL;
							}
							n->options = $6;
							n->options = lappend(n->options, makeDefElem("as",
									(Node *)list_make1(makeString(funSource->bodySrc))));
							n->withClause = NIL;
							u_sess->parser_cxt.isCreateFuncOrProc = false;
							$$ = (Node *)n;
		
					}

			| CREATE opt_or_replace definer_user PROCEDURE func_name_opt_arg 
				proc_arg_no_empty
				opt_createproc_opt_list{
						u_sess->parser_cxt.eaten_declare = false;
						u_sess->parser_cxt.eaten_begin = false;
						pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;
						u_sess->parser_cxt.isCreateFuncOrProc = true;
				} SingleLineProcPart
					{
						int rc = 0;
						rc = CompileWhich();
						if ((rc == PLPGSQL_COMPILE_PROC || rc == PLPGSQL_COMPILE_NULL) && u_sess->cmd_cxt.CurrentExtensionObject == InvalidOid) {
								u_sess->plsql_cxt.procedure_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @8);
						}
						rc = CompileWhich();
						CreateFunctionStmt *n = makeNode(CreateFunctionStmt);
						int count = get_outarg_num($6);
						n->isOraStyle = false;
						n->isPrivate = false;
						n->replace = $2;
						n->definer = $3;
						if (n->replace && NULL != n->definer) {
								parser_yyerror("not support DEFINER function");
						}
						n->funcname = $5;
						n->parameters = $6;
						n->inputHeaderSrc = FormatFuncArgType(yyscanner, NULL, n->parameters);
						n->returnType = NULL;
						n->isProcedure = false;
						if (0 == count)
						{
							n->returnType = makeTypeName("void");
							n->returnType->typmods = NULL;
							n->returnType->arrayBounds = NULL;
						}
						n->options = $7;
						n->options = lappend(n->options, makeDefElem("as",
								(Node *)list_make1(makeString($9))));
						n->withClause = NIL;
						u_sess->parser_cxt.isCreateFuncOrProc = false;

						TypeName* type =  makeTypeName("record");
						type->setof = TRUE;
						type->arrayBounds = NIL;
						n->returnType = type;

						$$ = (Node *)n;
					}
		;

CreatePackageStmt:
			CREATE opt_or_replace PACKAGE pkg_name invoker_rights as_is {pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;}
				{
                    u_sess->plsql_cxt.package_as_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @6);
                    CreatePackageStmt *n = makeNode(CreatePackageStmt);
					char *pkgNameBegin = NULL;
					char *pkgNameEnd = NULL;
                    char *pkgName = NULL;
					base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
					yyextra->core_yy_extra.in_slash_proc_body = true;
					switch (list_length($4)) {
						case 1:
							pkgName = strVal(linitial($4));
							break;
						case 2:
							pkgName = strVal(lsecond($4));
							break;
						case 3:
							pkgName = strVal(lthird($4));
							break;
						default:
							parser_yyerror("package name is invalid!");
							break;
					}
                    pkgNameBegin = (char *)palloc(strlen(pkgName) + 1);
                    pkgNameEnd = (char *)palloc(strlen(pkgName) + 1);
                    strcpy(pkgNameBegin, pkgName);
					pkgNameBegin = pg_strtolower(pkgNameBegin);

                    int tok = YYEMPTY;
                    if (yychar == YYEOF || yychar == YYEMPTY)
                        tok = YYLEX;
                    else
                    {
                        tok = yychar;
                        yychar = YYEMPTY;
                    }
                    int proc_start_pos = n->pkgspec_location = yylloc;
                    u_sess->plsql_cxt.package_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, yylloc);

                    // Scan whole stmt.        
                    List* toks = NULL;
                    List* positions = NULL;

                    while(true) {
                        if (tok == YYEOF) {
                            break;
                        }

                        toks = lappend_int(toks, tok);
                        positions = lappend_int(positions, yylloc);
                        
                        if (tok == END_P) {
                            tok = YYLEX;
                            // append pkgname into toks
                            toks = lappend_int(toks, tok);
                            positions = lappend_int(positions, yylloc);
                            if (tok != ';') {
                                // append ; into toks
                                tok = YYLEX;
                                toks = lappend_int(toks, tok);
                                positions = lappend_int(positions, yylloc);

                                int start_pos = list_nth_int(positions, positions->length - 2);
                                int end_pos = list_nth_int(positions, positions->length - 1);
                                StringInfoData name_info;
                                initStringInfo(&name_info);
                                appendBinaryStringInfo(&name_info, yyextra->core_yy_extra.scanbuf + start_pos - 1, end_pos - start_pos + 1);
                                char* pkg_name_temp = GetPkgName(name_info.data);
                                pkg_name_temp = pg_strtolower(pkg_name_temp);
                                truncate_identifier(pkg_name_temp, strlen(pkg_name_temp), false);
                                if (strcmp(pkgNameBegin, pkg_name_temp) == 0) {
                                    strcpy(pkgNameEnd, pkg_name_temp);
                                    pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = false;
                                    break;
                                }
                                pfree(name_info.data);
                                pkg_name_temp = NULL;
                            } else {
								parser_yyerror("package spec is not ended correctly");
							}
                        }
                        tok = YYLEX;
                    }
                	yyextra->core_yy_extra.query_string_locationlist =
                    	lappend_int(yyextra->core_yy_extra.query_string_locationlist, yylloc);
                    if (toks == NULL || toks->length < 1) {
                        parser_yyerror("package spec is not ended correctly");
                    }
                    int last_tok = list_nth_int(toks, toks->length - 1);
                    if (last_tok != ';') {
                        parser_yyerror("variable/func/proc declare in package spec is not ended correctly");
                    }

                    if (toks->length < 2) {
                        parser_yyerror("package spec is not ended correctly");
                    }

                    // Package spec content.
                    int name_start_pos = list_nth_int(positions, positions->length - 2);
                    StringInfoData content_info;
                    initStringInfo(&content_info);
                    appendStringInfo(&content_info, "%s", PACKAGE_STR);
                    appendStringInfo(&content_info, "%s", DECLARE_STR);
                    n->pkgspec_prefix_len = content_info.len;
                    n->pkgspec_location -= 1;
                    appendBinaryStringInfo(&content_info, yyextra->core_yy_extra.scanbuf + proc_start_pos - 1, name_start_pos - proc_start_pos + 1);
                    char* pkg_spec_str = content_info.data;

                    if (yyextra->lookahead_num != 0) {
                        parser_yyerror("package spec is not ended correctly");
                    } else {
                        yyextra->lookahead_token[0] = tok;
                        yyextra->lookahead_num = 1;
                    }

                    /* Reset the flag which mark whether we are in slash proc. */
                    yyextra->core_yy_extra.in_slash_proc_body = false;
                    yyextra->core_yy_extra.dolqstart = NULL;
                    /*
                     * Add the end location of slash proc to the locationlist for the multi-query 
                     * processed.
                     */

					u_sess->plsql_cxt.package_as_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @6);
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_common.plsql_show_all_error == true) {
						if (pkgNameBegin != NULL && pkgNameEnd != NULL) {
							if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
							{
								parser_yyerror("package name end is not match the one begin!");
							}
						} else {
							parser_yyerror("package name end is not match the one begin!");
						}
					} else {
						if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
						{
							parser_yyerror("package name end is not match the one begin!");
						}
					}
#else
					if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
					{
						parser_yyerror("package name end is not match the one begin!");
					}
#endif
					n->replace = $2;
					n->pkgname = $4;
					n->pkgspec = pkg_spec_str;
					n->pkgsecdef = $5;
					$$ = (Node *)n;
				}
            
		;
pkg_name:	ColId
				{ $$ = list_make1(makeString($1)); }
			| ColId indirection
				{
					$$ = check_func_name(lcons(makeString($1), $2),
										 yyscanner);
				}
		;
invoker_rights:	 AUTHID DEFINER
				{
					$$ = true;
				}
			| AUTHID CURRENT_USER
				{
					$$ = false;
				}
			|
				{
                    if (PLSQL_SECURITY_DEFINER && u_sess->attr.attr_common.upgrade_mode == 0) {
						$$ = true;
                    } else {
                        $$ = false;
                    }
				}
			;
view_security_option: DEFINER
				{
					$$ = VIEW_SQL_SECURITY_DEFINER;
				}
				| INVOKER
				{
					$$ = VIEW_SQL_SECURITY_INVOKER;
				}
			;
view_security_expression: SQL_P SECURITY view_security_option
				{
					if (u_sess->attr.attr_sql.sql_compatibility ==  B_FORMAT) {
						$$ = $3;
					} else {
						parser_yyerror("not support SQL SECURITY EXPRESSION");
					}
				}
			;

pkg_body_subprogram: {
                int proc_b  = 0;
                int proc_e  = 0;
                char *pkg_body_str = NULL;
                char *pkg_name_str = NULL;
                int pkg_name_len    = 0;
                int pkg_body_len    = 0;
                int instantiation_start = 0;
                int instantiation_end = 0;
                int block_level = 0;
                int tok = YYEMPTY;
                int pre_tok_loc = 0;
				int pre_tok = 0;
                int pre_pre_tok = 0;
                bool pkg_end = true;
                char* instantiation_str = NULL;
                base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
                bool in_procedure = false;
                yyextra->core_yy_extra.in_slash_proc_body = true;
                /* the token BEGIN_P have been parsed */
                List* result_list = NULL;
                if (yychar == YYEOF || yychar == YYEMPTY)
                {
                    tok = YYLEX;
                }
                else
                {
                    tok = yychar;
                    yychar = YYEMPTY;
                }
                proc_b = yylloc;
				u_sess->plsql_cxt.package_first_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, yylloc);

                List* toks = NULL;
                List* positions = NULL;

                while(true)
                {
                    if (tok == YYEOF) {
						break;
					}

                    toks = lappend_int(toks, tok);
                    positions = lappend_int(positions, yylloc);

                    if (tok == PROCEDURE || tok == FUNCTION) {
                        in_procedure = true;
					}

                    if (tok == BEGIN_P) {
                        block_level = block_level + 1;
                        if (in_procedure == false) {
                            instantiation_start = yylloc;
                        }
                    }
					
                    if (tok == END_P)
                    {
						pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = false;
                        tok = YYLEX;
                        proc_e = yylloc;

                        toks = lappend_int(toks, tok);
                        positions = lappend_int(positions, yylloc);
                                                /* If there is a comment before END_P, check pre_pre_tok */
						if ((pre_tok != ';' && pre_tok != BEGIN_P && pre_tok != 0 && pre_tok != COMMENTSTRING) ||
                                                    (pre_tok == COMMENTSTRING && pre_pre_tok != 0 && pre_pre_tok != ';' && pre_pre_tok != BEGIN_P)) {
							continue;
						} else if (block_level == 0 && tok != ';') {
							in_procedure = false;
						}
                        if (tok == ';')
                        {
                            block_level = block_level - 1;
                            if (block_level == 0)
                            {
                                in_procedure = false;
                            }
                            continue;
                        }
						if (tok == LOOP || tok == IF_P || tok == CASE || tok == WHILE_P || tok == REPEAT)
						{
							continue;
						}
                        tok = YYLEX;

                        toks = lappend_int(toks, tok);
                        positions = lappend_int(positions, yylloc);

                        if (tok != ';' && tok != 0) {
                          continue;
                        } else if (tok == 0) {
                            parser_yyerror("package is not ended correctly");
							break;
                        }
                        if (proc_e == 0) {
                            parser_yyerror("variable declare in package is not ended correctly");
							break;
						}
                        break;
                    }
                    /* When multiple lines are commented out, pre_pre_tok should not is COMMENTSTRING,
                     * but should be displayed as the tok before the COMMENTSTRING start.
                     */
                    if (tok != COMMENTSTRING || pre_tok != COMMENTSTRING) {
                        pre_pre_tok = pre_tok;
                    }
					pre_tok = tok;
                    tok = YYLEX;
                    pre_tok_loc = yylloc;
                }

                if (toks == NULL || toks->length < 1) {
                    parser_yyerror("package is not ended correctly");
                }
                int last_tok = list_nth_int(toks, toks->length - 1);
                if (last_tok != ';') {
                    parser_yyerror("package is not ended correctly");
                }

                if (toks->length < 2) {
                    parser_yyerror("package is not ended correctly");
                }

                // package name.
                int name_start_pos = list_nth_int(positions, positions->length - 2);
                int name_end_pos = list_nth_int(positions, positions->length -1);
                StringInfoData name_info;
                initStringInfo(&name_info);
                appendBinaryStringInfo(&name_info, yyextra->core_yy_extra.scanbuf + name_start_pos - 1, name_end_pos - name_start_pos + 1);
                pkg_name_str = GetPkgName(name_info.data);
				pkg_name_str = pg_strtolower(pkg_name_str);
                truncate_identifier(pkg_name_str, strlen(pkg_name_str), false);

                if (instantiation_start == 0) {
                    pkg_body_len = proc_e - proc_b + 1;
                    pkg_body_str = (char *)palloc0(pkg_body_len + DECLARE_LEN + PACKAGE_LEN + 1);
                    strncpy_s(pkg_body_str, PACKAGE_LEN + 1, PACKAGE_STR, PACKAGE_LEN);
                    strncpy_s(pkg_body_str + PACKAGE_LEN, DECLARE_LEN + 1, DECLARE_STR, DECLARE_LEN);
                    strncpy_s(pkg_body_str + DECLARE_LEN + PACKAGE_LEN, pkg_body_len + 1,
                    yyextra->core_yy_extra.scanbuf + proc_b - 1, pkg_body_len);
                    pkg_body_str[pkg_body_len + DECLARE_LEN + PACKAGE_LEN] = '\0';
                    proc_b = proc_e;
                    proc_e = yylloc;
                    if (proc_e == 0)
                        parser_yyerror("variable declare in package spec is not ended correctly");
                } else {
                    int proc_end_all = proc_e;
                    proc_e = instantiation_start;
                    pkg_body_len = proc_e - proc_b + 1;
                    pkg_body_str = (char *)palloc0(pkg_body_len + DECLARE_LEN + PACKAGE_LEN + END_LEN + 2); 
                    strncpy_s(pkg_body_str, PACKAGE_LEN + 1, PACKAGE_STR, PACKAGE_LEN);
                    strncpy_s(pkg_body_str + PACKAGE_LEN, DECLARE_LEN + 1, DECLARE_STR, DECLARE_LEN);
                    strncpy_s(pkg_body_str + DECLARE_LEN + PACKAGE_LEN, pkg_body_len + 1,
                    yyextra->core_yy_extra.scanbuf + proc_b - 1, pkg_body_len);
                    strncpy_s(pkg_body_str + DECLARE_LEN + PACKAGE_LEN + pkg_body_len, END_LEN + 1,
                    END_STR, END_LEN);
                    pkg_body_str[pkg_body_len + DECLARE_LEN + PACKAGE_LEN + END_LEN] = '\0'; 
                    proc_b = proc_end_all;
                    proc_e = yylloc;
                    if (proc_e == 0) 
                        parser_yyerror("variable declare in package spec is not ended correctly");
                    instantiation_end = pre_tok_loc;
                    int pkg_instantiation_len = instantiation_end - instantiation_start;
                    instantiation_str = (char *)palloc0(INSTANTIATION_LEN + pkg_instantiation_len + END_LEN + 2); 
                    strncpy_s(instantiation_str, INSTANTIATION_LEN + 1, INSTANTIATION_STR, INSTANTIATION_LEN);
                    strncpy_s(instantiation_str +  INSTANTIATION_LEN, pkg_instantiation_len + 1,  
                        yyextra->core_yy_extra.scanbuf + instantiation_start - 1, pkg_instantiation_len);
                    strncpy_s(instantiation_str  + INSTANTIATION_LEN + pkg_instantiation_len, END_LEN + 1 , END_STR, END_LEN);
                    instantiation_str[INSTANTIATION_LEN + pkg_instantiation_len + END_LEN] = '\0';
                }

                if (yyextra->lookahead_num != 0)
                    parser_yyerror("package spec is not ended correctly");
                else
                {
                    yyextra->lookahead_token[0] = tok;
                    yyextra->lookahead_num = 1;
                }
                /* Reset the flag which mark whether we are in slash proc. */
                yyextra->core_yy_extra.in_slash_proc_body = false;
                yyextra->core_yy_extra.dolqstart = NULL;
                /*
                * Add the end location of slash proc to the locationlist for the multi-query 
                * processed.
                */
                yyextra->core_yy_extra.query_string_locationlist = 
                    lappend_int(yyextra->core_yy_extra.query_string_locationlist, yylloc);
            
                result_list = list_concat(list_make1(makeDefElem("decl", (Node *)makeString(pkg_body_str))), 
                         list_make1(makeDefElem("name", (Node *)makeString(pkg_name_str))));
                if (instantiation_start != 0)  {
                    result_list = list_concat(result_list,list_make1(makeDefElem(("init"), (Node *)makeString(instantiation_str))));
                } else {
                    result_list = list_concat(result_list,list_make1(makeDefElem(("init"), NULL)));
                }
                $$ = result_list;
            }
            ;
CreatePackageBodyStmt:
			CREATE opt_or_replace PACKAGE BODY_P pkg_name as_is {pg_yyget_extra(yyscanner)->core_yy_extra.include_ora_comment = true;} pkg_body_subprogram
				{
					char *pkgNameBegin = NULL;
					char *pkgNameEnd = NULL;
                    char *pkgName = NULL;
					DefElem *def = NULL;
					u_sess->plsql_cxt.package_as_line = GetLineNumber(t_thrd.postgres_cxt.debug_query_string, @6);
					switch (list_length($5)) {
						case 1:
							pkgName = strVal(linitial($5));
							break;
						case 2:
							pkgName = strVal(lsecond($5));
							break;
						case 3:
							pkgName = strVal(lthird($5));
							break;
						default:
							parser_yyerror("package name is invalid!");
							break;
					}
                    pkgNameBegin = (char *)palloc(strlen(pkgName) + 1);
                    strcpy(pkgNameBegin, pkgName);
					pkgNameBegin = pg_strtolower(pkgNameBegin);
                    int length = list_length($8);
					def = (DefElem *)lsecond($8);
					if (strcmp(def->defname,"name") != 0)
					{
						parser_yyerror("internal grammer error!");
					}
					pkgNameEnd = GetPkgName(strVal(def->arg));
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_common.plsql_show_all_error == true) {
						if (pkgNameBegin != NULL && pkgNameEnd != NULL) {
							if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
							{
								parser_yyerror("package name end is not match the one begin!");
							}
						} else {
							parser_yyerror("package name end is not match the one begin!");
						}
					} else {
						if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
						{
							parser_yyerror("package name end is not match the one begin!");
						}
					}
#else
					if (strcmp(pkgNameBegin, pkgNameEnd) != 0)
					{
						parser_yyerror("package name end is not match the one begin!");
					}
#endif
					CreatePackageBodyStmt *n = makeNode(CreatePackageBodyStmt);
					n->replace = $2;
					n->pkgname = $5;
					def = (DefElem *)linitial($8);
					if (strcmp(def->defname,"decl") != 0)
					{
						parser_yyerror("internal grammer error!");
					}
					n->pkgbody = strVal(def->arg);
                    def = (DefElem *)lthird($8);
                    if (strcmp(def->defname,"init") != 0) 
                    {     
                        parser_yyerror("internal grammer error!");
                    } 
                    if (def->arg) {
                        n->pkginit = strVal(def->arg);
                    } else {
                        n->pkginit = NULL;
                    }
					$$ = (Node *)n;
				}
		;
opt_or_replace:
			OR REPLACE								{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

func_args:	'(' func_args_list ')'					{ $$ = $2; }
			| '(' ')'								{ $$ = NIL; }
		;

proc_args:  {
				pg_yyget_extra(yyscanner)->core_yy_extra.func_param_begin = yylloc;
			} func_args_with_defaults				{ pg_yyget_extra(yyscanner)->core_yy_extra.func_param_end = yylloc; $$ = $2;  }
			|/*EMPTY*/								{ $$ = NIL; }
		;

func_args_list:
			func_arg								{ $$ = list_make1($1); }
			| func_args_list ',' func_arg			{ $$ = lappend($1, $3); }
		;

as_is:
		AS
		| IS
		;

as_empty:
                AS
                | /*EMPTY*/     { $$ = NULL; }
                ;

/*
 * func_args_with_defaults is separate because we only want to accept
 * defaults in CREATE FUNCTION, not in ALTER etc.
 */
func_args_with_defaults:
		'(' func_args_with_defaults_list ')'		{ $$ = $2; }
		| '(' ')'									{ $$ = NIL; }
		;

func_args_with_defaults_list:
		func_arg_with_default						{ $$ = list_make1($1); }
		| func_args_with_defaults_list ',' func_arg_with_default
													{ $$ = lappend($1, $3); }
		;

/*
 * The style with arg_class first is SQL99 standard, but A db puts
 * param_name first; accept both since it's likely people will try both
 * anyway.  Don't bother trying to save productions by letting arg_class
 * have an empty alternative ... you'll get shift/reduce conflicts.
 *
 * We can catch over-specified arguments here if we want to,
 * but for now better to silently swallow typmod, etc.
 * - thomas 2000-03-22
 */
func_arg:
			arg_class param_name func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = $2;
					n->argType = $3;
					n->mode = $1;
					n->defexpr = NULL;
					$$ = n;
				}
			| param_name arg_class func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = $1;
					n->argType = $3;
					n->mode = $2;
					n->defexpr = NULL;
					$$ = n;
				}
			| param_name func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = $1;
					n->argType = $2;
					n->mode = FUNC_PARAM_IN;
					n->defexpr = NULL;
					$$ = n;
				}
			| arg_class func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = NULL;
					n->argType = $2;
					n->mode = $1;
					n->defexpr = NULL;
					$$ = n;
				}
			| func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = NULL;
					n->argType = $1;
					n->mode = FUNC_PARAM_IN;
					n->defexpr = NULL;
					$$ = n;
				}
		;

/* INOUT is SQL99 standard, IN OUT is for A db compatibility */
arg_class:	IN_P								{ $$ = FUNC_PARAM_IN; }
			| OUT_P								{ $$ = FUNC_PARAM_OUT; }
			| INOUT								{ $$ = FUNC_PARAM_INOUT; }
			| IN_P OUT_P						{ $$ = FUNC_PARAM_INOUT; }
			| VARIADIC							{ $$ = FUNC_PARAM_VARIADIC; }
		;

/*
 * Ideally param_name should be ColId, but that causes too many conflicts.
 */
param_name:	type_function_name %prec lower_than_zerofill
		;

func_return:
			func_type
				{
					/* We can catch over-specified results here if we want to,
					 * but for now better to silently swallow typmod, etc.
					 * - thomas 2000-03-22
					 */
					$$ = $1;
				}

		;

/*
 * We would like to make the %TYPE productions here be ColId attrs etc,
 * but that causes reduce/reduce conflicts.  type_function_name
 * is next best choice.
 */
func_type:	Typename								{ $$ = $1; }
        | type_function_name attrs '%' ROWTYPE_P opt_array_bounds
            {
                $$ = makeTypeNameFromNameList(lcons(makeString($1), $2));
                $$->location = @1;
                $$->arrayBounds = $5;
                $$->pct_rowtype = true;
            }
        | type_function_name '%' ROWTYPE_P opt_array_bounds
            {
                $$ = makeTypeName($1);
                $$->location = @1;
                $$->arrayBounds = $4;
                $$->pct_rowtype = true;
            }
		| type_function_name attrs '%' TYPE_P opt_array_bounds
	        {
                $$ = makeTypeNameFromNameList(lcons(makeString($1), $2));
                $$->pct_type = true;
                $$->location = @1;
                $$->end_location = @4 + TYPE_LEN;
                $$->arrayBounds = $5;
		    }
        | type_function_name '%' TYPE_P opt_array_bounds
	        {
                $$ = makeTypeName($1);
                $$->pct_type = true;
			    $$->location = @1;
			    $$->end_location = @3 + TYPE_LEN;
                $$->arrayBounds = $4;
		    }
		| SETOF type_function_name attrs '%' TYPE_P opt_array_bounds
		    {
                $$ = makeTypeNameFromNameList(lcons(makeString($2), $3));
                $$->pct_type = true;
                $$->setof = TRUE;
                $$->location = @2;
                $$->end_location = @5 + TYPE_LEN;
                $$->arrayBounds = $6;
		    }
		;

func_arg_with_default:
		func_arg
				{
					$$ = $1;
				}
		| func_arg DEFAULT a_expr
				{
					$$ = $1;
					$$->defexpr = $3;
				}
		| func_arg '=' a_expr
				{
					$$ = $1;
					$$->defexpr = $3;
				}
		| func_arg COLON_EQUALS a_expr
				{
					$$ = $1;
					$$->defexpr = $3;
				}
		;

createfunc_opt_list:
			/* Must be at least one to prevent conflict */
			createfunc_opt_item						{ $$ = list_make1($1); }
			| createfunc_opt_list createfunc_opt_item { $$ = lappend($1, $2); }
	;

opt_createfunc_opt_list:
			createfunc_opt_list		{ $$ = $1; }
			| /* EMPTY */			{ $$ = NIL; }

opt_createproc_opt_list:
			opt_createproc_opt_list createproc_opt_item
				{
					$$ = lappend($1, $2);
				}
			| /* EMPTY */
				{
					$$ = NIL;
				}
 	 ;

/*
 * Options common to both CREATE FUNCTION and ALTER FUNCTION
 */
common_func_opt_item:
			CALLED ON NULL_P INPUT_P
				{
					$$ = makeDefElem("strict", (Node *)makeInteger(FALSE));
				}
			| RETURNS NULL_P ON NULL_P INPUT_P
				{
					$$ = makeDefElem("strict", (Node *)makeInteger(TRUE));
				}
			| STRICT_P
				{
					$$ = makeDefElem("strict", (Node *)makeInteger(TRUE));
				}
			| IMMUTABLE
				{
					$$ = makeDefElem("volatility", (Node *)makeString("immutable"));
				}
			| STABLE
				{
					$$ = makeDefElem("volatility", (Node *)makeString("stable"));
				}
			| VOLATILE
				{
					$$ = makeDefElem("volatility", (Node *)makeString("volatile"));
				}
			| SHIPPABLE
				{
					$$ = makeDefElem("shippable", (Node*)makeInteger(TRUE));
				}
			| NOT SHIPPABLE
				{
					$$ = makeDefElem("shippable", (Node*)makeInteger(FALSE));
				}
			| DETERMINISTIC
				{
					$$ = makeDefElem("deterministic", (Node*)makeInteger(TRUE));
				}
			| NOT DETERMINISTIC
				{
					$$ = makeDefElem("deterministic", (Node*)makeInteger(FALSE));
				}
			| EXTERNAL SECURITY DEFINER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(TRUE));
				}
			| EXTERNAL SECURITY INVOKER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(FALSE));
				}
			| SECURITY DEFINER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(TRUE));
				}
			| SECURITY INVOKER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(FALSE));
				}
			| AUTHID DEFINER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(TRUE));
				}
			| AUTHID CURRENT_USER
				{
					$$ = makeDefElem("security", (Node *)makeInteger(FALSE));
				}
			| LEAKPROOF
				{
					$$ = makeDefElem("leakproof", (Node *)makeInteger(TRUE));
				}
			| NOT LEAKPROOF
				{
					$$ = makeDefElem("leakproof", (Node *)makeInteger(FALSE));
				}
			| COST NumericOnly
				{
					$$ = makeDefElem("cost", (Node *)$2);
				}
			| ROWS NumericOnly
				{
					$$ = makeDefElem("rows", (Node *)$2);
				}
			| FunctionSetResetClause %prec '(' ')'
				{
					/* we abuse the normal content of a DefElem here */
					$$ = makeDefElem("set", (Node *)$1);
				}
			| FENCED
				{
					$$ = makeDefElem("fenced", (Node *)makeInteger(TRUE));
				}
			| NOT FENCED
				{
					$$ = makeDefElem("fenced", (Node *)makeInteger(FALSE));
				}
			| PACKAGE
				{
					$$ = makeDefElem("package", (Node *)makeInteger(true));
				}
			| NO SQL_P
			    {
					$$ = makeDefElem("sql_opt", (Node *)makeString("nosql"));
				}
			| CONTAINS SQL_P
				{
					$$ = makeDefElem("sql_opt", (Node *)makeString("contains"));
				}
			| READS SQL_P DATA_P
				{
					$$ = makeDefElem("sql_opt", (Node *)makeString("reads"));
				}
			| MODIFIES SQL_P DATA_P
				{
					$$ = makeDefElem("sql_opt", (Node *)makeString("modify"));
				}
			| SQL_P SECURITY DEFINER
				{
                                        $$ = makeDefElem("security", (Node *)makeInteger(TRUE));
                                }
			| SQL_P SECURITY INVOKER
				{
                                        $$ = makeDefElem("security", (Node *)makeInteger(FALSE));
                                }
			| LANGUAGE ColId_or_Sconst
				{
					$$ = makeDefElem("language", (Node *)makeString($2));
			    }
			| COMMENT SCONST
				{
					BCompatibilityOptionSupportCheck($1);
					$$ = makeDefElem("comment", (Node *)makeString($2));
				}
		;

createfunc_opt_item:
			AS func_as
				{
					$$ = makeDefElem("as", (Node *)$2);
				}
			| WINDOW
				{
					$$ = makeDefElem("window", (Node *)makeInteger(TRUE));
				}
			| common_func_opt_item
				{
					$$ = $1;
				}
		;


createproc_opt_item:
			common_func_opt_item
				{
					$$ = $1;
				}
		;

func_as:	SCONST						{ $$ = list_make1(makeString($1)); }
			| SCONST ',' SCONST
				{
					$$ = list_make2(makeString($1), makeString($3));
				}
		;
subprogram_body: 	{
				int		proc_b	= 0;
				int		proc_e	= 0;
				char	*proc_body_str	= NULL;
				int		proc_body_len	= 0;
				int		blocklevel		= 0;
				bool	add_declare		= true;  /* Mark if need to add a DECLARE */
				FunctionSources *funSrc = NULL;
				char *proc_header_str = NULL;
				int rc = 0;
				rc = CompileWhich();
				int	tok = YYEMPTY;
				int	pre_tok = 0;
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);

				yyextra->core_yy_extra.in_slash_proc_body = true;
				/* the token BEGIN_P have been parsed */
				if (u_sess->parser_cxt.eaten_begin)
					blocklevel = 1;

				if (yychar == YYEOF || yychar == YYEMPTY)
					tok = YYLEX;
				else
				{
					tok = yychar;
					yychar = YYEMPTY;
				}

				if (u_sess->parser_cxt.eaten_declare || DECLARE == tok)
					add_declare = false;

				/* Save procedure header str,start with param exclude brackets */
				proc_header_str = ParseFunctionArgSrc(yyscanner);

				/* Save the beginning of procedure body. */
				proc_b = yylloc;
				if (rc != PLPGSQL_COMPILE_NULL && rc != PLPGSQL_COMPILE_PROC) {
					u_sess->plsql_cxt.procedure_first_line = GetLineNumber(yyextra->core_yy_extra.scanbuf, yylloc);
				}
				/* start procedure body scan */
				while(true)
				{
					if (tok == YYEOF) {
						proc_e = yylloc;
						parser_yyerror("subprogram body is not ended correctly");
						break;
					}

					if (tok == BEGIN_P)
						blocklevel++;

					/*
					 * End of procedure rules:
					 *	;END [;]
					 * 	| BEGIN END[;]
					 */
					if (tok == END_P)
					{
						tok = YYLEX;

						/* adapt A db's label */
						if (!(tok == ';'  || (tok == 0 || tok == END_OF_PROC))
							&& tok != IF_P
							&& tok != CASE
							&& tok != LOOP
							&& tok != WHILE_P
							&& tok != REPEAT)
						{
							tok = END_P;
							continue;
						}

					 	if (blocklevel == 1
							&& (pre_tok == ';' || pre_tok == BEGIN_P)
							&& (tok == ';' || (tok == 0 || tok == END_OF_PROC)))
						{
							/* Save the end of procedure body. */
							proc_e = yylloc;

							if (tok == ';' )
							{
								if (yyextra->lookahead_num != 0) {
									parser_yyerror("subprogram body is not ended correctly");
									break;
								}
								else
								{
									yyextra->lookahead_token[0] = tok;
									yyextra->lookahead_num = 1;
								}
							}
							break;
						}

						/* Cope with nested BEGIN/END pairs.
						 * In fact the tok can not be 0
						 */
					 	if (blocklevel > 1
							 && (pre_tok == ';' || pre_tok == BEGIN_P)
							 && (tok == ';' || tok == 0))
						{
							blocklevel--;
						}
					}

					pre_tok = tok;
					tok = YYLEX;
				}

				if (proc_e == 0) {
					ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("subprogram body is not ended correctly")));
				}

				proc_body_len = proc_e - proc_b + 1 ;

				/* Add a DECLARE in the start of the subprogram body
				 * 	to compatiable with the A db.
				 * 	XXX : It is best to change the gram.y in plpgsql.
				 */
				if (add_declare)
				{
					proc_body_str = (char *)palloc0(proc_body_len + DECLARE_LEN + 1);
					rc = strcpy_s(proc_body_str, proc_body_len + DECLARE_LEN + 1, DECLARE_STR);
					securec_check(rc, "", "");
					rc = strncpy_s(proc_body_str + DECLARE_LEN, proc_body_len + 1,
							yyextra->core_yy_extra.scanbuf + proc_b, proc_body_len - 1);
					securec_check(rc, "", "");
					proc_body_len = DECLARE_LEN + proc_body_len;
				}
				else
				{
					proc_body_str = (char *)palloc0(proc_body_len + 1);
					rc = strncpy_s(proc_body_str, proc_body_len + 1,
						yyextra->core_yy_extra.scanbuf + proc_b, proc_body_len - 1);
					securec_check(rc, "", "");
				}

				proc_body_str[proc_body_len] = '\0';

				/* Reset the flag which mark whether we are in slash proc. */
				yyextra->core_yy_extra.in_slash_proc_body = false;
				yyextra->core_yy_extra.dolqstart = NULL;

				/*
				 * Add the end location of slash proc to the locationlist for the multi-query 
				 * processed.
				 */
				yyextra->core_yy_extra.query_string_locationlist = 
					lappend_int(yyextra->core_yy_extra.query_string_locationlist, yylloc);

				funSrc = makeNode(FunctionSources);
				funSrc->bodySrc   = proc_body_str;
				funSrc->headerSrc = proc_header_str;

				/* tail plpgsql shoule not use declare rules of dolphin */

				$$ = funSrc;
			}
		;

dolphin_flow_control:
			RETURN flow_control_func_body
				{
					char* result = appendString("RETURN", $2->bodySrc, BEGIN_LEN);
					pfree($2->bodySrc);
					$2->bodySrc = result;
					$$ = $2;
				}
			| opt_label REPEAT flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString("REPEAT", $3->bodySrc, BEGIN_LEN);
					if ($1 != NULL) {
						result = appendString($1, result, BEGIN_LEN);
					}
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| DOLPHINIDENT LABEL_REPEAT flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString(":REPEAT", $3->bodySrc, BEGIN_LEN);
					result = appendString($1->str, result, BEGIN_LEN);
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| opt_label LOOP flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString("LOOP", $3->bodySrc, BEGIN_LEN);
					if ($1 != NULL) {
						result = appendString($1, result, BEGIN_LEN);
					}
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| DOLPHINIDENT LABEL_LOOP flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString(":LOOP", $3->bodySrc, BEGIN_LEN);
					result = appendString($1->str, result, BEGIN_LEN);
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| opt_label WHILE_P flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString("WHILE", $3->bodySrc, BEGIN_LEN);
					if ($1 != NULL) {
						result = appendString($1, result, BEGIN_LEN);
					}
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| DOLPHINIDENT LABEL_WHILE flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$3->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString(":WHILE", $3->bodySrc, BEGIN_LEN);
					result = appendString($1->str, result, BEGIN_LEN);
					pfree($3->bodySrc);
					$3->bodySrc = result;
					$$ = $3;
				}
			| CASE flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$2->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString("CASE", $2->bodySrc, BEGIN_LEN);
					pfree($2->bodySrc);
					$2->bodySrc = result;
					$$ = $2;
				}
			| IF_P flow_control_func_body
				{
					/* check whether function body has RETURN */
					if (!$2->hasReturn) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("no RETURN found in function body")));
					}
					char* result = appendString("IF", $2->bodySrc, BEGIN_LEN);
					pfree($2->bodySrc);
					$2->bodySrc = result;
					$$ = $2;
				}

opt_label:
			DOLPHINIDENT ':'
			{
				int rc = EOK;
				int ident_len = strlen($1->str);
				char* result = (char*)palloc0(ident_len + 2);
				rc = strcat_s(result, ident_len + 2, $1->str);
				securec_check(rc, "\0", "\0");
				rc = strcat_s(result, ident_len + 2, ":");
                                securec_check(rc, "\0", "\0");
				$$ = result;
			}
			| /* EMPTY */
			{
				$$ = NULL;
			}

flow_control_func_body:
			{
				GetSessionContext()->is_first_lable = false;
				int proc_b = 0;
				int proc_e = 0;
				char* proc_body_str = NULL;
				int proc_body_len = 0;
				int blocklevel = 1;
				FunctionSources *funSrc = NULL;
				char *proc_header_str = NULL;
				int rc = 0;
				rc = CompileWhich();
				int tok = YYEMPTY;
				int pre_tok = 0;
				base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
				yyextra->core_yy_extra.in_slash_proc_body = true;
				if (yychar == YYEOF || yychar == YYEMPTY) {
					tok = YYLEX;
				} else {
					tok = yychar;
					yychar = YYEMPTY;
				}

				/* Save procedure header str,start with param exclude brackets */
				proc_header_str = ParseFunctionArgSrc(yyscanner);

				/* Save the beginning of procedure body. */
				proc_b = yylloc;
				if (rc != PLPGSQL_COMPILE_NULL && rc != PLPGSQL_COMPILE_PROC) {
					u_sess->plsql_cxt.procedure_first_line = GetLineNumber(yyextra->core_yy_extra.scanbuf, yylloc);
				}
				bool hasReturn = false;
				/* start procedure body scan */
				while(true) {
					/* handle single SQL body like "return xxx" */
					if (tok == YYEOF || tok == END_OF_PROC) {
						proc_e = yylloc;
						if (strlen(u_sess->attr.attr_common.delimiter_name) > 1
								|| pre_tok != u_sess->attr.attr_common.delimiter_name[0]) {
							/*
							 * if length of delimiter is greater than 1, which means tok is END_OF_PROC,
							 * or token is EOF and SQL has no delimiter ended, we extend function body
							 * string so that we could correctly add ';' to the end later.
							 */
							proc_e++;
						}
						break;
					}

					if (tok == BEGIN_P) {
						blocklevel++;
					}

					if (tok == END_P) {
						tok = YYLEX;
					 	if (blocklevel == 1
							&& (pre_tok == ';' || pre_tok == BEGIN_P)
							&& (tok == ';' || (tok == 0 || tok == END_OF_PROC))) {
							/* Save the end of procedure body. */
							proc_e = yylloc;

							if (tok == ';' ) {
								if (yyextra->lookahead_num != 0) {
									parser_yyerror("subprogram body is not ended correctly");
									break;
								} else {
									yyextra->lookahead_token[0] = tok;
									yyextra->lookahead_num = 1;
								}
							}
							break;
						}

						/* Cope with nested BEGIN/END pairs.
						 * In fact the tok can not be 0
						 */
						if (blocklevel > 1
							 && (pre_tok == ';' || pre_tok == BEGIN_P)
							 && (tok == ';' || tok == 0)) {
							blocklevel--;
						}
					}

					if (tok == RETURN) {
						hasReturn = true;
					}
					pre_tok = tok;
					tok = YYLEX;
				}

				if (proc_e == 0) {
					ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("subprogram body is not ended correctly")));
				}

				proc_body_len = proc_e - proc_b + 1 ;
				rc = EOK;

				/*
				 * We surround function body with begin-end, and add a RETURN in front of function body.
				 * The final body str will be like:
				 *   BEGIN
				 *     RETURN func_body;
				 *   END
				 */
				proc_body_str = (char*)palloc0(proc_body_len + BEGIN_LEN + END_LEN + 1);
				rc = strncpy_s(proc_body_str, proc_body_len + BEGIN_LEN + END_LEN + 1, BEGIN_STR, BEGIN_LEN);
				securec_check(rc, "\0", "\0");
				rc = strncpy_s(proc_body_str + BEGIN_LEN, proc_body_len + BEGIN_LEN + END_LEN + 1,
						yyextra->core_yy_extra.scanbuf + proc_b - 1, proc_body_len);
				securec_check(rc, "\0", "\0");
				/*
				 * replace laster character of func body in case of delimiter changed.
				 * since we keep only one char for delimiter in proc_body_str, we should not concern
				 * about the length of delimiter.
				 */
				proc_body_str[BEGIN_LEN + proc_body_len - 1] = ';';

				rc = strncpy_s(proc_body_str + BEGIN_LEN + proc_body_len,
						proc_body_len + BEGIN_LEN + END_LEN + 1, END_STR, END_LEN);
				securec_check(rc, "\0", "\0");
				proc_body_len = BEGIN_LEN + proc_body_len + END_LEN;
				proc_body_str[proc_body_len] = '\0';

				/* Reset the flag which mark whether we are in slash proc. */
				yyextra->core_yy_extra.in_slash_proc_body = false;
				yyextra->core_yy_extra.dolqstart = NULL;

				/*
				 * Add the end location of slash proc to the locationlist for the multi-query
				 * processed.
				 */
				yyextra->core_yy_extra.query_string_locationlist =
					lappend_int(yyextra->core_yy_extra.query_string_locationlist, yylloc);

				funSrc = makeNode(FunctionSources);
				funSrc->bodySrc   = proc_body_str;
				funSrc->headerSrc = proc_header_str;
				funSrc->hasReturn = hasReturn;

				$$ = funSrc;
			}
		;

opt_definition:
			WITH definition							{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

table_func_column:	param_name func_type
				{
					FunctionParameter *n = makeNode(FunctionParameter);
					n->name = $1;
					n->argType = $2;
					n->mode = FUNC_PARAM_TABLE;
					n->defexpr = NULL;
					$$ = n;
				}
		;

table_func_column_list:
			table_func_column
				{
					$$ = list_make1($1);
				}
			| table_func_column_list ',' table_func_column
				{
					$$ = lappend($1, $3);
				}
		;

/*****************************************************************************
 * ALTER FUNCTION
 *
 * RENAME and OWNER subcommands are already provided by the generic
 * ALTER infrastructure, here we just specify alterations that can
 * only be applied to functions.
 *
 *****************************************************************************/

 RemovePackageStmt:
				DROP PACKAGE pkg_name 
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_PACKAGE;
					n->objects = list_make1($3);
					n->arguments = NULL;
					n->behavior = DROP_CASCADE;
					n->missing_ok = false;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
				| DROP PACKAGE IF_P EXISTS pkg_name
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_PACKAGE;
					n->objects = list_make1($5);
					n->arguments = NULL;
					n->behavior = DROP_CASCADE;
					n->missing_ok = true;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
				| DROP PACKAGE BODY_P pkg_name 
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_PACKAGE_BODY;
					n->objects = list_make1($4);
					n->arguments = NULL;
					n->behavior = DROP_CASCADE;
					n->missing_ok = false;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
				| DROP PACKAGE BODY_P IF_P EXISTS pkg_name
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_PACKAGE_BODY;
					n->objects = list_make1($6);
					n->arguments = NULL;
					n->behavior = DROP_CASCADE;
					n->missing_ok = true;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
		;

AlterFunctionStmt:
			ALTER FUNCTION function_with_argtypes alterfunc_opt_list opt_restrict
				{
					AlterFunctionStmt *n = makeNode(AlterFunctionStmt);
					n->func = $3;
					n->actions = $4;
					n->noargs = false;
					$$ = (Node *) n;
				}
			| ALTER FUNCTION func_name alterfunc_opt_list opt_restrict
				{
					AlterFunctionStmt *n = makeNode(AlterFunctionStmt);
					FuncWithArgs *narg = makeNode(FuncWithArgs);
					narg->funcname = $3;
					narg->funcargs = NIL;
					n->func = narg;
					n->actions = $4;
					n->noargs = true;
					$$ = (Node *) n;
				}
			;

AlterProcedureStmt:
			ALTER PROCEDURE function_with_argtypes alterfunc_opt_list opt_restrict
				{
					AlterFunctionStmt *n = makeNode(AlterFunctionStmt);
					n->func = $3;
					n->actions = $4;
					n->noargs = false;
					$$ = (Node *) n;
				}
			| ALTER PROCEDURE func_name alterfunc_opt_list opt_restrict
				{
					AlterFunctionStmt *n = makeNode(AlterFunctionStmt);
					FuncWithArgs *narg = makeNode(FuncWithArgs);
					narg->funcname = $3;
					narg->funcargs = NIL;
					n->func = narg;
					n->actions = $4;
					n->noargs = true;
					$$ = (Node *) n;
                                }
		;

alterfunc_opt_list:
			/* At least one option must be specified */
			common_func_opt_item					{ $$ = list_make1($1); }
			| alterfunc_opt_list common_func_opt_item { $$ = lappend($1, $2); }
		;

/* Ignored, merely for SQL compliance */
opt_restrict:
			RESTRICT
			| /* EMPTY */
		;


/*****************************************************************************
 *
 *		QUERY:
 *
 *		DROP FUNCTION funcname (arg1, arg2, ...) [ RESTRICT | CASCADE ]
 *		DROP AGGREGATE aggname (arg1, ...) [ RESTRICT | CASCADE ]
 *		DROP OPERATOR opname (leftoperand_typ, rightoperand_typ) [ RESTRICT | CASCADE ]
 *
 *****************************************************************************/

RemoveFuncStmt:
			DROP FUNCTION dolphin_func_name func_args opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($3);
					n->arguments = list_make1(extractArgTypes($4));
					n->behavior = $5;
					n->missing_ok = false;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
			| DROP FUNCTION IF_P EXISTS dolphin_func_name func_args opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($5);
					n->arguments = list_make1(extractArgTypes($6));
					n->behavior = $7;
					n->missing_ok = true;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
            | DROP PROCEDURE dolphin_func_name func_args opt_drop_behavior
                {
                    DropStmt *n = makeNode(DropStmt);
                    n->removeType = OBJECT_FUNCTION;
                    n->objects = list_make1($3);
                    n->arguments = list_make1(extractArgTypes($4));
                    n->behavior = $5; 
                    n->missing_ok = false;
                    n->concurrent = false;
                    n->isProcedure = true;
                    $$ = (Node *)n;
                }     
            | DROP PROCEDURE IF_P EXISTS dolphin_func_name func_args opt_drop_behavior
                {
                    DropStmt *n = makeNode(DropStmt);
                    n->removeType = OBJECT_FUNCTION;
                    n->objects = list_make1($5);
                    n->arguments = list_make1(extractArgTypes($6));
                    n->behavior = $7; 
                    n->missing_ok = true; 
                    n->concurrent = false;
                    n->isProcedure = true;
                    $$ = (Node *)n;
                } 
			| DROP PROCEDURE dolphin_func_name_opt_arg
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($3);
					n->arguments = NULL;
					n->behavior = DROP_RESTRICT;
					n->missing_ok = false;
					n->concurrent = false;
					n->isProcedure = true;
					$$ = (Node *)n;
				}
			| DROP PROCEDURE IF_P EXISTS dolphin_func_name_opt_arg
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($5);
					n->arguments = NULL;
					n->behavior = DROP_RESTRICT;
					n->missing_ok = true;
					n->concurrent = false;
					n->isProcedure = true;
					$$ = (Node *)n;
				}
			| DROP FUNCTION dolphin_func_name_opt_arg
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($3);
					n->arguments = NULL;
					n->behavior = DROP_RESTRICT;
					n->missing_ok = false;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
			| DROP FUNCTION IF_P EXISTS dolphin_func_name_opt_arg
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_FUNCTION;
					n->objects = list_make1($5);
					n->arguments = NULL;
					n->behavior = DROP_RESTRICT;
					n->missing_ok = true;
					n->concurrent = false;
					n->isProcedure = false;
					$$ = (Node *)n;
				}
		;

RemoveAggrStmt:
			DROP AGGREGATE func_name aggr_args opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_AGGREGATE;
					n->objects = list_make1($3);
					n->arguments = list_make1($4);
					n->behavior = $5;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *)n;
				}
			| DROP AGGREGATE IF_P EXISTS func_name aggr_args opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_AGGREGATE;
					n->objects = list_make1($5);
					n->arguments = list_make1($6);
					n->behavior = $7;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *)n;
				}
		;

RemoveOperStmt:
			DROP OPERATOR any_operator oper_argtypes opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_OPERATOR;
					n->objects = list_make1($3);
					n->arguments = list_make1($4);
					n->behavior = $5;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *)n;
				}
			| DROP OPERATOR IF_P EXISTS any_operator oper_argtypes opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_OPERATOR;
					n->objects = list_make1($5);
					n->arguments = list_make1($6);
					n->behavior = $7;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *)n;
				}
		;

oper_argtypes:
			'(' Typename ')'
				{
					const char* message = "missing argument";
                                        InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				        ereport(errstate,
						   (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("missing argument"),
							errhint("Use NONE to denote the missing argument of a unary operator."),
							parser_errposition(@3)));
				}
			| '(' Typename ',' Typename ')'
					{ $$ = list_make2($2, $4); }
			| '(' NONE ',' Typename ')'					/* left unary */
					{ $$ = list_make2(NULL, $4); }
			| '(' Typename ',' NONE ')'					/* right unary */
					{ $$ = list_make2($2, NULL); }
		;

any_operator:
			all_Op
					{ $$ = list_make1(makeString($1)); }
			| ColId '.' any_operator
					{ $$ = lcons(makeString($1), $3); }
		;

/*****************************************************************************
 *
 *		DO <anonymous code block> [ LANGUAGE language ]
 *
 * We use a DefElem list for future extensibility, and to allow flexibility
 * in the clause order.
 *
 *****************************************************************************/


DoStmt:
		DO_SCONST {GetSessionContext()->do_sconst = yylval.str; } opt_do_language
                                {
                                        char* sconst_str = GetSessionContext()->do_sconst;
                                        DoStmt *n = makeNode(DoStmt);
                                        n->args = list_make1(makeDefElem("as", (Node *)makeString(sconst_str)));
                                        if ($3)
                                                lappend(n->args, $3);
                                        $$ = (Node *)n;
                                }
                       | DO_LANGUAGE ColId_or_Sconst SCONST
                                {
                                        DoStmt *n = makeNode(DoStmt);
                                        n->args = list_make2(makeDefElem("as", (Node *)makeString($3)),
                                                makeDefElem("language", (Node *)makeString($2)));
                                        $$ = (Node *)n;
                                }
                	| DO {GetSessionContext()->single_line_proc_begin = yylloc;} expr_do_list
                                {
                                        char* strbody = NULL;
                                        base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
                                        int start_pos = GetSessionContext()->single_line_proc_begin + 3;
                                        int end_pos = yylloc;
                                        strbody = DoStmtPreformGet(start_pos, end_pos, yyextra);
                                        GetSessionContext()->single_line_proc_begin = 0;
                                        DoStmt *n = makeNode(DoStmt);
                                        DefElem* defel = makeDefElem("as", (Node *)makeString(strbody));
                                        List* deflist =  list_make1(defel);
                                        n->args = deflist;
                                        $$ = (Node *)n;
                                }
                ;
opt_do_language:
        	LANGUAGE ColId_or_Sconst
        			{
                			$$ = makeDefElem("language", (Node *)makeString($2));
        			}
        		| {$$ = NULL;}
		;
expr_do_list:
                	a_expr                       { $$ = NULL; }
                	| expr_do_list ',' a_expr            { $$ = NULL; }
                ;

dostmt_opt_list:
			dostmt_opt_item						{ $$ = list_make1($1); }
			| dostmt_opt_list dostmt_opt_item	{ $$ = lappend($1, $2); }
		;

dostmt_opt_item:
			SCONST
				{
					$$ = makeDefElem("as", (Node *)makeString($1));
				}
			| LANGUAGE ColId_or_Sconst
				{
					$$ = makeDefElem("language", (Node *)makeString($2));
				}
		;

AnonyBlockStmt:
		DECLARE { u_sess->parser_cxt.eaten_declare = true; u_sess->parser_cxt.eaten_begin = false; } subprogram_body
			{
				$$ = (Node *)MakeAnonyBlockFuncStmt(DECLARE, ((FunctionSources*)$3)->bodySrc);
			}
		| BEGIN_P { u_sess->parser_cxt.eaten_declare = true; u_sess->parser_cxt.eaten_begin = true; } subprogram_body
			{
				$$ = (Node *)MakeAnonyBlockFuncStmt(BEGIN_P, ((FunctionSources*)$3)->bodySrc);
			}
		;
/*****************************************************************************
 *
 *		CREATE CAST / DROP CAST
 *
 *****************************************************************************/

CreateCastStmt: CREATE CAST '(' Typename AS Typename ')'
					WITH FUNCTION function_with_argtypes cast_context
				{
					CreateCastStmt *n = makeNode(CreateCastStmt);
					n->sourcetype = $4;
					n->targettype = $6;
					n->func = $10;
					n->context = (CoercionContext) $11;
					n->inout = false;
					$$ = (Node *)n;
				}
			| CREATE CAST '(' Typename AS Typename ')'
					WITHOUT FUNCTION cast_context
				{
					CreateCastStmt *n = makeNode(CreateCastStmt);
					n->sourcetype = $4;
					n->targettype = $6;
					n->func = NULL;
					n->context = (CoercionContext) $10;
					n->inout = false;
					$$ = (Node *)n;
				}
			| CREATE CAST '(' Typename AS Typename ')'
					WITH INOUT cast_context
				{
					CreateCastStmt *n = makeNode(CreateCastStmt);
					n->sourcetype = $4;
					n->targettype = $6;
					n->func = NULL;
					n->context = (CoercionContext) $10;
					n->inout = true;
					$$ = (Node *)n;
				}
		;

cast_context:  AS IMPLICIT_P					{ $$ = COERCION_IMPLICIT; }
		| AS ASSIGNMENT							{ $$ = COERCION_ASSIGNMENT; }
		| /*EMPTY*/								{ $$ = COERCION_EXPLICIT; }
		;


DropCastStmt: DROP CAST opt_if_exists '(' Typename AS Typename ')' opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_CAST;
					n->objects = list_make1(list_make1($5));
					n->arguments = list_make1(list_make1($7));
					n->behavior = $9;
					n->missing_ok = $3;
					n->concurrent = false;
					$$ = (Node *)n;
				}
		;

opt_if_exists: IF_P EXISTS						{ $$ = TRUE; }
		| /*EMPTY*/								{ $$ = FALSE; }
		;

OptimizeStmt:
			OPTIMIZE opt_verbose opt_no_write_to_binlog TABLE dolphin_qualified_name
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | VACOPT_FULL | VACOPT_ANALYZE;
					if ($2) {
						n->options |= VACOPT_VERBOSE;
					}
					n->freeze_min_age = -1;
					n->freeze_table_age = -1;
					n->relation = $5;
					n->va_cols = NIL;
					$$ = (Node *)n;
				}
			;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		REINDEX type [CONCURRENTLY] <name> [FORCE]
 *
 * FORCE no longer does anything, but we accept it for backwards compatibility
 *****************************************************************************/

ReindexStmt:
			REINDEX reindex_type opt_concurrently dolphin_qualified_name opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					n->kind = $2;
					n->concurrent = $3;
					n->relation = $4;
					n->name = NULL;
					$$ = (Node *)n;
				}
			|
			REINDEX reindex_type opt_concurrently dolphin_qualified_name PARTITION ColId opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					if($2 == OBJECT_TABLE)
						n->kind  = OBJECT_TABLE_PARTITION;
					else
						n->kind  = OBJECT_INTERNAL_PARTITION;
					n->concurrent = $3;
					n->relation = $4;
					n->name = $6;
					$$ = (Node *)n;
				}
			| REINDEX INDEX opt_concurrently qualified_name opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					n->kind = OBJECT_INDEX;
					n->concurrent = $3;
					n->relation = $4;
					n->name = NULL;
					$$ = (Node *)n;
				}
			| REINDEX INDEX opt_concurrently qualified_name PARTITION ColId opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					n->kind  = OBJECT_INDEX_PARTITION;
					n->concurrent = $3;
					n->relation = $4;
					n->name = $6;
					$$ = (Node *)n;
				}
			| REINDEX SYSTEM_P opt_concurrently name opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					n->kind = OBJECT_DATABASE;
					n->concurrent = $3;
					n->name = $4;
					n->relation = NULL;
					n->do_system = true;
					n->do_user = false;
					$$ = (Node *)n;
				}
			| REINDEX DATABASE opt_concurrently name opt_force
				{
					ReindexStmt *n = makeNode(ReindexStmt);
					n->kind = OBJECT_DATABASE;
					n->concurrent = $3;
					n->name = $4;
					n->relation = NULL;
					n->do_system = true;
					n->do_user = true;
					$$ = (Node *)n;
				}
		;

reindex_type:
			TABLE									{ $$ = OBJECT_TABLE; }
			| INTERNAL TABLE						{ $$ = OBJECT_INTERNAL; }
		;

opt_force:	FORCE									{  $$ = TRUE; }
			| /* EMPTY */							{  $$ = FALSE; }
		;

to_or_as:		TO									{}
				| AS								{}
		;


/*****************************************************************************
 *
 * ALTER THING name RENAME TO newname
 *
 *****************************************************************************/

RenameStmt: ALTER AGGREGATE func_name aggr_args RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_AGGREGATE;
					n->object = $3;
					n->objarg = $4;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER COLLATION any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLLATION;
					n->object = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER CONVERSION_P any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_CONVERSION;
					n->object = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER DATABASE database_name RENAME TO database_name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_DATABASE;
					n->subname = $3;
					IsValidIdent($6);
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
            | ALTER DATA_P SOURCE_P name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_DATA_SOURCE;
					n->subname = $4;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER DOMAIN_P any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_DOMAIN;
					n->object = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER DOMAIN_P any_name RENAME CONSTRAINT name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_CONSTRAINT;
					n->relationType = OBJECT_DOMAIN;
					n->object = $3;
					n->subname = $6;
					n->newname = $8;
					$$ = (Node *)n;
				}
			| ALTER EVENT_TRIGGER name RENAME TO name
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_EVENT_TRIGGER;
					n->object = list_make1(makeString($3));
					n->newname = $6;
					$$ = (Node *)n;
				}
			| ALTER EVENT_TRIGGER name OWNER TO RoleId
				{
					if(u_sess->attr.attr_sql.sql_compatibility != PG_FORMAT)
					{
						ereport(errstate, 
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("EVENT TRIGGER is only supported in PG compatibility database")));
					}
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_EVENT_TRIGGER;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN DATA_P WRAPPER name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FDW;
					n->object = list_make1(makeString($5));
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FUNCTION function_with_argtypes RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER PROCEDURE function_with_argtypes RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER GROUP_P RoleId RENAME TO RoleId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_ROLE;
					n->subname = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER opt_procedural LANGUAGE name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_LANGUAGE;
					n->object = list_make1(makeString($4));
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR CLASS any_name USING access_method RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_OPCLASS;
					n->object = lcons(makeString($6), $4);
					n->newname = $9;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR FAMILY any_name USING access_method RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_OPFAMILY;
					n->object = lcons(makeString($6), $4);
					n->newname = $9;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER PUBLICATION name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_PUBLICATION;
					n->object = list_make1(makeString($3));
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_SUBSCRIPTION;
					n->object = list_make1(makeString($3));
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			/* Rename Row Level Security Policy */
			| ALTER RowLevelSecurityPolicyName ON dolphin_qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_RLSPOLICY;
					n->subname = $2;
					n->relation = $4;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SCHEMA DolphinColId RENAME TO DolphinColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_SCHEMA;
					n->subname = GetDolphinSchemaName($3->str, $3->is_quoted);
					n->newname = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SERVER name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FOREIGN_SERVER;
					n->object = list_make1(makeString($3));
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER MATERIALIZED VIEW qualified_name RENAME opt_column name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_MATVIEW;
					n->relation = $4;
					n->subname = $7;
					n->newname = $9;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER MATERIALIZED VIEW IF_P EXISTS qualified_name RENAME opt_column name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_MATVIEW;
					n->relation = $6;
					n->subname = $9;
					n->newname = $11;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr RENAME dolphin_qualified_name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABLE;
					n->relation = $3;
					n->subname = NULL;
					n->newname = $5->relname;
					n->newschema = $5->schemaname;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr RENAME to_or_as dolphin_qualified_name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABLE;
					n->relation = $3;
					n->subname = NULL;
					n->newname = $6->relname;
					n->newschema = $6->schemaname;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE IF_P EXISTS relation_expr RENAME dolphin_qualified_name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABLE;
					n->relation = $5;
					n->subname = NULL;
					n->newname = $7->relname;
					n->newschema = $7->schemaname;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TABLE IF_P EXISTS relation_expr RENAME to_or_as dolphin_qualified_name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABLE;
					n->relation = $5;
					n->subname = NULL;
					n->newname = $8->relname;
					n->newschema = $8->schemaname;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER SEQUENCE qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_SEQUENCE;
					n->relation = $3;
					n->subname = NULL;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_LARGE_SEQUENCE;
					n->relation = $4;
					n->subname = NULL;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SEQUENCE IF_P EXISTS qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_SEQUENCE;
					n->relation = $5;
					n->subname = NULL;
					n->newname = $8;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE IF_P EXISTS qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_LARGE_SEQUENCE;
					n->relation = $6;
					n->subname = NULL;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER opt_view_algo VIEW dolphin_qualified_name RENAME TO DolphinColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_VIEW;
					n->relation = $4;
					n->subname = NULL;
					n->newname = GetDolphinObjName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER opt_view_algo VIEW IF_P EXISTS dolphin_qualified_name RENAME TO DolphinColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_VIEW;
					n->relation = $6;
					n->subname = NULL;
					n->newname = GetDolphinObjName($9->str, $9->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER opt_view_algo VIEW dolphin_qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->view = $4;
					n->aliases = $5;
					n->query = $7;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->withCheckOption = (ViewCheckOption)$8;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node *) n;
				}
			| ALTER definer_expression VIEW dolphin_qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->definer = $2;
					n->view = $4;
					n->aliases = $5;
					n->query = $7;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					n->withCheckOption = (ViewCheckOption)$8;
					$$ = (Node *) n;
				}
			| ALTER view_security_expression VIEW qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->view = $4;
					n->aliases = $5;
					n->query = $7;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->viewSecurityOption = (ViewSecurityOption)$2;
					n->withCheckOption = (ViewCheckOption)$8;
					$$ = (Node *) n;
				}
			| ALTER definer_expression view_security_expression VIEW qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->definer = $2;
					n->view = $5;
					n->aliases = $6;
					n->query = $8;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->viewSecurityOption = (ViewSecurityOption)$3;
					n->withCheckOption = (ViewCheckOption)$9;
					$$ = (Node *) n;
				}
			| ALTER view_algo_shift_expr definer_expression VIEW dolphin_qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->definer = $3;
					n->view = $5;
					n->aliases = $6;
					n->query = $8;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->withCheckOption = (ViewCheckOption)$9;
					$$ = (Node *) n;
				}
			| ALTER view_algo_shift_expr definer_expression view_security_expression VIEW dolphin_qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->definer = $3;
					n->view = $6;
					n->aliases = $7;
					n->query = $9;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->withCheckOption = (ViewCheckOption)$10;
					n->viewSecurityOption = (ViewSecurityOption)$4;
					$$ = (Node *) n;
				}
			| ALTER view_algo_shift_expr view_security_expression VIEW dolphin_qualified_name opt_column_list AS SelectStmt opt_check_option
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility !=  B_FORMAT)
#endif
					{
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("ALTER VIEW AS is not supported.")));
					}
					ViewStmt *n = makeNode(ViewStmt);
					n->view = $5;
					n->aliases = $6;
					n->query = $8;
					n->replace = true;
					n->sql_statement = NULL;
					n->is_alter = true;
					n->withCheckOption = (ViewCheckOption)$9;
					n->viewSecurityOption = (ViewSecurityOption)$3;
					$$ = (Node *) n;
				}
			| ALTER MATERIALIZED VIEW qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_MATVIEW;
					n->relation = $4;
					n->subname = NULL;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER MATERIALIZED VIEW IF_P EXISTS qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_MATVIEW;
					n->relation = $6;
					n->subname = NULL;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER INDEX qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_INDEX;
					n->relation = $3;
					n->subname = NULL;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER INDEX IF_P EXISTS qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_INDEX;
					n->relation = $5;
					n->subname = NULL;
					n->newname = $8;
					n->missing_ok = true;
					$$ = (Node *)n;
				}

			| ALTER INDEX qualified_name RENAME_PARTITION name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_PARTITION_INDEX;
					n->relation = $3;
					n->subname = $5;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER INDEX IF_P EXISTS qualified_name RENAME_PARTITION name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_PARTITION_INDEX;
					n->relation = $5;
					n->subname = $7;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}

			| ALTER FOREIGN TABLE relation_expr RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FOREIGN_TABLE;
					n->relation = $4;
					n->subname = NULL;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_FOREIGN_TABLE;
					n->relation = $6;
					n->subname = NULL;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr RENAME DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_TABLE;
					n->relation = $3;
					n->subname = $5;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr RENAME COLUMN DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_TABLE;
					n->relation = $3;
					n->subname = $6;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE IF_P EXISTS relation_expr RENAME DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_TABLE;
					n->relation = $5;
					n->subname = $7;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TABLE IF_P EXISTS relation_expr RENAME COLUMN DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_TABLE;
					n->relation = $5;
					n->subname = $8;
					n->newname = $10;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr RENAME CONSTRAINT name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABCONSTRAINT;
					n->relation = $3;
					n->subname = $6;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}

			| ALTER TABLE IF_P EXISTS relation_expr RENAME CONSTRAINT name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABCONSTRAINT;
					n->relation = $5;
					n->subname = $8;
					n->newname = $10;
					n->missing_ok = true;
					$$ = (Node *)n;
				}

			| ALTER TABLE relation_expr RENAME_PARTITION name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_PARTITION;
					n->relationType = OBJECT_TABLE;
					n->relation = $3;
					n->subname = $5;
					n->newname = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}

			| ALTER TABLE IF_P EXISTS relation_expr RENAME_PARTITION name TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_PARTITION;
					n->relationType = OBJECT_TABLE;
					n->relation = $5;
					n->subname = $7;
					n->newname = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}

			| ALTER TABLE relation_expr RENAME_PARTITION FOR maxValueList_with_opt_parens TO name
			    {
			        RenameStmt *n = makeNode(RenameStmt);
			        n->renameType = OBJECT_PARTITION;
					n->relationType = OBJECT_TABLE;
			        n->relation = $3;
			        n->object = $6;
			        n->subname = NULL;
			        n->newname = $8;
			        n->missing_ok = false;
			        $$ = (Node *)n;
			    }

			| ALTER TABLE IF_P EXISTS relation_expr RENAME_PARTITION FOR maxValueList_with_opt_parens TO name
			    {
			        RenameStmt *n = makeNode(RenameStmt);
			        n->renameType = OBJECT_PARTITION;
					n->relationType = OBJECT_TABLE;
			        n->relation = $5;
			        n->object = $8;
			        n->subname = NULL;
			        n->newname = $10;
			        n->missing_ok = true;
			        $$ = (Node *)n;
			    }
			| ALTER TABLE relation_expr FORCE
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | VACOPT_FULL;
					n->relation = $3;
					$$ = (Node *)n;
				}

			| ALTER FOREIGN TABLE relation_expr RENAME opt_column DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_FOREIGN_TABLE;
					n->relation = $4;
					n->subname = $7;
					n->newname = $9;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr RENAME opt_column DolphinColColId TO DolphinColColId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_COLUMN;
					n->relationType = OBJECT_FOREIGN_TABLE;
					n->relation = $6;
					n->subname = $9;
					n->newname = $11;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TRIGGER qualified_trigger_name ON dolphin_qualified_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TRIGGER;
					n->relation = $5;
					n->subname = $3->relname;
					n->newname = $8;
					n->missing_ok = false;
					n->renameTargetList = list_make1($3);
					$$ = (Node *)n;
				}
			| ALTER ROLE RoleId RENAME TO RoleId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_ROLE;
					n->subname = $3;
					IsValidIdentUsername($6);
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER USER UserId RENAME TO UserId
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_USER;
					n->subname = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLESPACE name RENAME TO name alter_tblspc_option_list
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TABLESPACE;
					n->subname = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLESPACE name SET reloptions alter_tblspc_option_list
				{
					AlterTableSpaceOptionsStmt *n =
						makeNode(AlterTableSpaceOptionsStmt);
					n->tablespacename = $3;
					n->options = $5;
					n->isReset = FALSE;
					$$ = (Node *)n;
				}
			| ALTER TABLESPACE name RESET reloptions alter_tblspc_option_list
				{
					AlterTableSpaceOptionsStmt *n =
						makeNode(AlterTableSpaceOptionsStmt);
					n->tablespacename = $3;
					n->options = $5;
					n->isReset = TRUE;
					$$ = (Node *)n;
				}
			| ALTER TABLESPACE name RESIZE MAXSIZE size_clause alter_tblspc_option_list
				{
					AlterTableSpaceOptionsStmt *n =
						makeNode(AlterTableSpaceOptionsStmt);
					n->tablespacename = $3;
					n->options = NIL;
					n->isReset = FALSE;
					n->maxsize = $6;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH PARSER any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TSPARSER;
					n->object = $5;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH DICTIONARY any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TSDICTIONARY;
					n->object = $5;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH TEMPLATE any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TSTEMPLATE;
					n->object = $5;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TSCONFIGURATION;
					n->object = $5;
					n->newname = $8;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TYPE_P any_name RENAME TO name
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_TYPE;
					n->object = $3;
					n->newname = $6;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TYPE_P any_name RENAME ATTRIBUTE name TO name opt_drop_behavior
				{
					RenameStmt *n = makeNode(RenameStmt);
					n->renameType = OBJECT_ATTRIBUTE;
					n->relationType = OBJECT_TYPE;
					n->relation = makeRangeVarFromAnyName($3, @3, yyscanner);
					n->subname = $6;
					n->newname = $8;
					n->behavior = $9;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| RENAME USER rename_list
				{
					List* renamestmts = NIL;
					ListCell* lc = NULL;
					foreach (lc, $3) {
						List* names = lfirst_node(List, lc);
						RenameStmt *n = makeNode(RenameStmt);
						n->renameType = OBJECT_USER;
						n->subname = linitial_node(char, names);
						n->newname = lsecond_node(char, names);
						n->missing_ok = false;
						renamestmts = lappend(renamestmts, (Node*)n);
					}
					$$ = (Node *)renamestmts;
				}
			| RENAME TABLE rename_clause_list
				{
#ifndef ENABLE_MULTIPLE_NODES
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
						RenameStmt *n = makeNode(RenameStmt);
						n->renameType = OBJECT_TABLE;
						n->renameTargetList = $3;
						n->renameTableflag = true;
						n->missing_ok = false;
						$$ = (Node *)n;
					} else {
						const char* message = "rename table syntax is supported on dbcompatibility B.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
                                                        errcode(ERRCODE_SYNTAX_ERROR),
                                                        errmsg("rename table syntax is supported on dbcompatibility B."),
                                                        parser_errposition(@1)));
						$$ = NULL;
					}
#else
                                        const char* message = "rename table syntax don't supported on distributed database.";
                                        InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                                        ereport(errstate,
                                                (errmodule(MOD_PARSER),
                                                errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                                errmsg("rename table syntax don't supported on distributed database."),
                                                parser_errposition(@1)));
                                        $$ = NULL;
#endif
				}
		;

rename_clause_list:
		rename_clause					{ $$ = $1; }
		| rename_clause_list ',' rename_clause		{ $$ = list_concat($1, $3); }
	;

rename_clause:
		dolphin_qualified_name TO dolphin_qualified_name
		{
			RenameCell* n = makeNode(RenameCell);
			n->original_name = $1;
			n->modify_name = $3;
			$$ = list_make1(n);
		}
	;

opt_column: COLUMN									{ $$ = COLUMN; }
			| /*EMPTY*/		%prec lower_than_key	{ $$ = 0; }
		;

opt_set_data: SET DATA_P							{ $$ = 1; }
			| /*EMPTY*/								{ $$ = 0; }
		;

alter_tblspc_option_list:
			alter_tblspc_option_list alter_tblspc_option
			{
				$$ = lappend($1, $2);
			}
			| /*EMPTY*/
			{
				$$ = NULL;
			}
		;

alter_tblspc_option:
			WAIT	{ $$ = NULL; }
			| opt_engine_without_empty { $$ = $1; }
		;

/*****************************************************************************
 *
 * ALTER THING name SET SCHEMA name
 *
 *****************************************************************************/

AlterObjectSchemaStmt:
			ALTER AGGREGATE func_name aggr_args SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_AGGREGATE;
					n->object = $3;
					n->objarg = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER COLLATION any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_COLLATION;
					n->object = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER CONVERSION_P any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_CONVERSION;
					n->object = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER DOMAIN_P any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_DOMAIN;
					n->object = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER EXTENSION any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_EXTENSION;
					n->object = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FUNCTION function_with_argtypes SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER PROCEDURE function_with_argtypes SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR any_operator oper_argtypes SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_OPERATOR;
					n->object = $3;
					n->objarg = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR CLASS any_name USING access_method SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_OPCLASS;
					n->object = lcons(makeString($6), $4);
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR FAMILY any_name USING access_method SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_OPFAMILY;
					n->object = lcons(makeString($6), $4);
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE relation_expr SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TABLE;
					n->relation = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TABLE IF_P EXISTS relation_expr SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TABLE;
					n->relation = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH PARSER any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TSPARSER;
					n->object = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH DICTIONARY any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TSDICTIONARY;
					n->object = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH TEMPLATE any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TSTEMPLATE;
					n->object = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TSCONFIGURATION;
					n->object = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SEQUENCE qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_SEQUENCE;
					n->relation = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_LARGE_SEQUENCE;
					n->relation = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER SEQUENCE IF_P EXISTS qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_SEQUENCE;
					n->relation = $5;
					n->newschema = GetDolphinSchemaName($8->str, $8->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P SEQUENCE IF_P EXISTS qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_LARGE_SEQUENCE;
					n->relation = $6;
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER opt_view_algo VIEW dolphin_qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_VIEW;
					n->relation = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER opt_view_algo VIEW IF_P EXISTS dolphin_qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_VIEW;
					n->relation = $6;
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER MATERIALIZED VIEW qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_MATVIEW;
					n->relation = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER MATERIALIZED VIEW IF_P EXISTS qualified_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_MATVIEW;
					n->relation = $6;
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN TABLE relation_expr SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_FOREIGN_TABLE;
					n->relation = $4;
					n->newschema = GetDolphinSchemaName($7->str, $7->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_FOREIGN_TABLE;
					n->relation = $6;
					n->newschema = GetDolphinSchemaName($9->str, $9->is_quoted);
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			| ALTER TYPE_P any_name SET SCHEMA DolphinColId
				{
					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
					n->objectType = OBJECT_TYPE;
					n->object = $3;
					n->newschema = GetDolphinSchemaName($6->str, $6->is_quoted);
					n->missing_ok = false;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 * ALTER THING name OWNER TO newname
 *
 *****************************************************************************/

AlterOwnerStmt: ALTER AGGREGATE func_name aggr_args OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_AGGREGATE;
					n->object = $3;
					n->objarg = $4;
					n->newowner = $7;
					$$ = (Node *)n;
				}
			| ALTER COLLATION any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_COLLATION;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER CONVERSION_P any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_CONVERSION;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER DATABASE database_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_DATABASE;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}

			| ALTER DIRECTORY name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_DIRECTORY;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER DOMAIN_P any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_DOMAIN;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER FUNCTION function_with_argtypes OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER PROCEDURE function_with_argtypes OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_FUNCTION;
					n->object = $3->funcname;
					n->objarg = $3->funcargs;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER PACKAGE pkg_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_PACKAGE;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER opt_procedural LANGUAGE name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_LANGUAGE;
					n->object = list_make1(makeString($4));
					n->newowner = $7;
					$$ = (Node *)n;
				}
			| ALTER LARGE_P OBJECT_P NumericOnly OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_LARGEOBJECT;
					n->object = list_make1($4);
					n->newowner = $7;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR any_operator oper_argtypes OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_OPERATOR;
					n->object = $3;
					n->objarg = $4;
					n->newowner = $7;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR CLASS any_name USING access_method OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_OPCLASS;
					n->object = lcons(makeString($6), $4);
					n->newowner = $9;
					$$ = (Node *)n;
				}
			| ALTER OPERATOR FAMILY any_name USING access_method OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_OPFAMILY;
					n->object = lcons(makeString($6), $4);
					n->newowner = $9;
					$$ = (Node *)n;
				}
			| ALTER SCHEMA DolphinColId OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_SCHEMA;
					n->object = list_make1(makeString(GetDolphinSchemaName($3->str, $3->is_quoted)));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER TYPE_P any_name OWNER TO TypeOwner
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_TYPE;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER TABLESPACE name OWNER TO RoleId alter_tblspc_option_list
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_TABLESPACE;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH DICTIONARY any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_TSDICTIONARY;
					n->object = $5;
					n->newowner = $8;
					$$ = (Node *)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_TSCONFIGURATION;
					n->object = $5;
					n->newowner = $8;
					$$ = (Node *)n;
				}
			| ALTER FOREIGN DATA_P WRAPPER name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_FDW;
					n->object = list_make1(makeString($5));
					n->newowner = $8;
					$$ = (Node *)n;
				}
			| ALTER SERVER name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_FOREIGN_SERVER;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER DATA_P SOURCE_P name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_DATA_SOURCE;
					n->object = list_make1(makeString($4));
					n->newowner = $7;
					$$ = (Node *)n;
				}
			| ALTER SYNONYM any_name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_SYNONYM;
					n->object = $3;
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER PUBLICATION name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_PUBLICATION;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name OWNER TO RoleId
				{
					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
					n->objectType = OBJECT_SUBSCRIPTION;
					n->object = list_make1(makeString($3));
					n->newowner = $6;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 * CREATE PUBLICATION name [ FOR TABLE ] [ WITH options ]
 *
 *****************************************************************************/

CreatePublicationStmt:
			CREATE PUBLICATION name opt_publication_for_tables opt_definition
				{
					CreatePublicationStmt *n = makeNode(CreatePublicationStmt);
					n->pubname = $3;
					n->options = $5;
					if ($4 != NULL)
					{
						/* FOR TABLE */
						if (IsA($4, List))
							n->tables = (List *)$4;
						/* FOR ALL TABLES */
						else
							n->for_all_tables = TRUE;
					}
					$$ = (Node *)n;
				}
		;

opt_publication_for_tables:
			publication_for_tables					{ $$ = $1; }
			| /* EMPTY */							{ $$ = NULL; }
		;

publication_for_tables:
			FOR TABLE relation_expr_list
				{
					$$ = (Node *) $3;
				}
			| FOR ALL TABLES
				{
					$$ = (Node *) makeInteger(TRUE);
				}
		;

/*****************************************************************************
 *
 * ALTER PUBLICATION name SET ( options )
 *
 * ALTER PUBLICATION name ADD TABLE table [, table2]
 *
 * ALTER PUBLICATION name DROP TABLE table [, table2]
 *
 * ALTER PUBLICATION name SET TABLE table [, table2]
 *
 *****************************************************************************/

AlterPublicationStmt:
			ALTER PUBLICATION name SET definition
				{
					AlterPublicationStmt *n = makeNode(AlterPublicationStmt);
					n->pubname = $3;
					n->options = $5;
					$$ = (Node *)n;
				}
			| ALTER PUBLICATION name ADD_P TABLE relation_expr_list
				{
					AlterPublicationStmt *n = makeNode(AlterPublicationStmt);
					n->pubname = $3;
					n->tables = $6;
					n->tableAction = DEFELEM_ADD;
					$$ = (Node *)n;
				}
			| ALTER PUBLICATION name SET TABLE relation_expr_list
				{
					AlterPublicationStmt *n = makeNode(AlterPublicationStmt);
					n->pubname = $3;
					n->tables = $6;
					n->tableAction = DEFELEM_SET;
					$$ = (Node *)n;
				}
			| ALTER PUBLICATION name DROP TABLE relation_expr_list
				{
					AlterPublicationStmt *n = makeNode(AlterPublicationStmt);
					n->pubname = $3;
					n->tables = $6;
					n->tableAction = DEFELEM_DROP;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 * CREATE SUBSCRIPTION name ...
 *
 *****************************************************************************/

CreateSubscriptionStmt:
			CREATE SUBSCRIPTION name CONNECTION SCONST PUBLICATION publication_name_list opt_definition
				{
					CreateSubscriptionStmt *n =
						makeNode(CreateSubscriptionStmt);
					n->subname = $3;
					n->conninfo = $5;
					n->publication = $7;
					n->options = $8;
					$$ = (Node *)n;
				}
		;

publication_name_list:
			publication_name_item
				{
					$$ = list_make1($1);
				}
			| publication_name_list ',' publication_name_item
				{
					$$ = lappend($1, $3);
				}
		;

publication_name_item:
			ColLabel			{ $$ = makeString($1); };

/*****************************************************************************
 *
 * ALTER SUBSCRIPTION name ...
 *
 *****************************************************************************/

AlterSubscriptionStmt:
			ALTER SUBSCRIPTION name SET definition
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->subname = $3;
					n->refresh = false;
					n->options = $5;
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name CONNECTION SCONST
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->subname = $3;
					n->refresh = false;
					n->options = list_make1(makeDefElem("conninfo",
											(Node *)makeString($5)));
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name SET PUBLICATION publication_name_list
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->subname = $3;
					n->refresh = false;
					n->options = list_make1(makeDefElem("publication",
											(Node *)$6));
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name REFRESH PUBLICATION opt_definition
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->subname = $3;
					n->refresh = true;
					n->options = $6;
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name ENABLE_P
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->refresh = false;
					n->subname = $3;
					n->options = list_make1(makeDefElem("enabled",
											(Node *)makeInteger(TRUE)));
					$$ = (Node *)n;
				}
			| ALTER SUBSCRIPTION name DISABLE_P
				{
					AlterSubscriptionStmt *n =
						makeNode(AlterSubscriptionStmt);
					n->refresh = false;
					n->subname = $3;
					n->options = list_make1(makeDefElem("enabled",
											(Node *)makeInteger(FALSE)));
					$$ = (Node *)n;
				}		;

/*****************************************************************************
 *
 * DROP SUBSCRIPTION [ IF EXISTS ] name
 *
 *****************************************************************************/

DropSubscriptionStmt: DROP SUBSCRIPTION name opt_drop_behavior
				{
					DropSubscriptionStmt *n = makeNode(DropSubscriptionStmt);
					n->subname = $3;
					n->behavior = $4;
					n->missing_ok = false;
					$$ = (Node *) n;
				}
				|  DROP SUBSCRIPTION IF_P EXISTS name opt_drop_behavior
				{
					DropSubscriptionStmt *n = makeNode(DropSubscriptionStmt);
					n->subname = $5;
					n->missing_ok = true;
					n->behavior = $6;
					$$ = (Node *) n;
				}
		;

TypeOwner:	RoleIdWithOutCurrentUser			{ $$ = $1; }
			| CURRENT_USER opt_bracket			{ $$ = downcase_str(pstrdup($1), false); }
			| SESSION_USER						{ $$ = downcase_str(pstrdup($1), false); }
		;

/*****************************************************************************
 *
 *		QUERY:	Define Rewrite Rule
 *
 *****************************************************************************/

RuleStmt:	CREATE opt_or_replace RULE name AS
			ON event TO dolphin_qualified_name where_clause
			DO opt_instead RuleActionList
				{
					RuleStmt *n = makeNode(RuleStmt);
					n->replace = $2;
					n->relation = $9;
					n->rulename = $4;
					n->whereClause = $10;
					n->event = (CmdType)$7;
					n->instead = $12;
					n->actions = $13;
					$$ = (Node *)n;
				}
		;

RuleActionList:
			NOTHING									{ $$ = NIL; }
			| RuleActionStmt {
#ifndef ENABLE_MULTIPLE_NODES
				if (IsA($1, CopyStmt) || IsA($1, AlterTableStmt)) {
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("Unsupported feature"),
									errdetail("copy stmt or alter stmt in action is not allowed")));
				}
#endif
			    $$ = list_make1($1); 
            }
			| '(' RuleActionMulti ')'				{ $$ = $2; }
		;

/* the thrashing around here is to discard "empty" statements... */
RuleActionMulti:
			RuleActionMulti ';' RuleActionStmtOrEmpty
				{ if ($3 != NULL)
					$$ = lappend($1, $3);
				  else
					$$ = $1;
				}
			| RuleActionStmtOrEmpty
				{ if ($1 != NULL)
					$$ = list_make1($1);
				  else
					$$ = NIL;
				}
		;

RuleActionStmt:
			SelectStmt
			| InsertStmt
			| UpdateStmt
			| DeleteStmt
			| CopyStmt
			| NotifyStmt
            | AlterTableStmt
		;
RuleActionStmtOrEmpty:
			RuleActionStmt							{ $$ = $1; }
			|	/*EMPTY*/							{ $$ = NULL; }
		;

event:		SELECT									{ $$ = CMD_SELECT; }
			| UPDATE								{ $$ = CMD_UPDATE; }
			| DELETE_P								{ $$ = CMD_DELETE; }
			| INSERT								{ $$ = CMD_INSERT; }
			| COPY									{ $$ = CMD_UTILITY; }
			| ALTER									{ $$ = CMD_UTILITY; }                           
		 ;

opt_instead:
			INSTEAD									{ $$ = TRUE; }
			| ALSO									{ $$ = FALSE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;


DropRuleStmt:
			DROP RULE name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_RULE;
					n->objects = list_make1(lappend($5, makeString($3)));
					n->arguments = NIL;
					n->behavior = $6;
					n->missing_ok = false;
					n->concurrent = false;
					$$ = (Node *) n;
				}
			| DROP RULE IF_P EXISTS name ON dolphin_any_name opt_drop_behavior
				{
					DropStmt *n = makeNode(DropStmt);
					n->removeType = OBJECT_RULE;
					n->objects = list_make1(lappend($7, makeString($5)));
					n->arguments = NIL;
					n->behavior = $8;
					n->missing_ok = true;
					n->concurrent = false;
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *		QUERY:
 *				NOTIFY <identifier> can appear both in rule bodies and
 *				as a query-level command
 *
 *****************************************************************************/

NotifyStmt: NOTIFY ColId notify_payload
				{
					NotifyStmt *n = makeNode(NotifyStmt);
					n->conditionname = $2;
					n->payload = $3;
					$$ = (Node *)n;
				}
		;

notify_payload:
			',' SCONST							{ $$ = $2; }
			| /*EMPTY*/							{ $$ = NULL; }
		;

ListenStmt: LISTEN ColId
				{
					ListenStmt *n = makeNode(ListenStmt);
					n->conditionname = $2;
					$$ = (Node *)n;
				}
		;

UnlistenStmt:
			UNLISTEN ColId
				{
					UnlistenStmt *n = makeNode(UnlistenStmt);
					n->conditionname = $2;
					$$ = (Node *)n;
				}
			| UNLISTEN '*'
				{
					UnlistenStmt *n = makeNode(UnlistenStmt);
					n->conditionname = NULL;
					$$ = (Node *)n;
				}
		;


/*****************************************************************************
 *
 *		Transactions:
 *
 *		BEGIN / COMMIT / ROLLBACK
 *		(also older versions END / ABORT)
 *
 *****************************************************************************/

TransactionStmt:
			ABORT_P opt_transaction
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_ROLLBACK;
					n->options = NIL;
					$$ = (Node *)n;
				}
			| START TRANSACTION transaction_mode_list_or_empty
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_START;
					n->options = $3;
					$$ = (Node *)n;
				}
			| BEGIN_NON_ANOYBLOCK opt_transaction transaction_mode_list_or_empty
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_BEGIN;
					n->options = $3;
					$$ = (Node *)n;
				}
			| COMMIT opt_transaction
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_COMMIT;
					n->options = NIL;
					$$ = (Node *)n;
				}
			| UNLOCK opt_table_for_b
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_COMMIT;
					n->options = NIL;
					$$ = (Node *)n;
				}
			| END_P opt_transaction
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_COMMIT;
					n->options = NIL;
					$$ = (Node *)n;
				}
			| ROLLBACK opt_transaction
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_ROLLBACK;
					n->options = NIL;
					$$ = (Node *)n;
				}
			| SAVEPOINT ColId
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_SAVEPOINT;
					n->options = list_make1(makeDefElem("savepoint_name",
														(Node *)makeString($2)));
					$$ = (Node *)n;
				}
			| RELEASE SAVEPOINT ColId
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_RELEASE;
					n->options = list_make1(makeDefElem("savepoint_name",
														(Node *)makeString($3)));
					$$ = (Node *)n;
				}
			| RELEASE ColId
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_RELEASE;
					n->options = list_make1(makeDefElem("savepoint_name",
														(Node *)makeString($2)));
					$$ = (Node *)n;
				}
			| ROLLBACK opt_transaction TO SAVEPOINT ColId
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_ROLLBACK_TO;
					n->options = list_make1(makeDefElem("savepoint_name",
														(Node *)makeString($5)));
					$$ = (Node *)n;
				}
			| ROLLBACK opt_transaction TO ColId
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_ROLLBACK_TO;
					n->options = list_make1(makeDefElem("savepoint_name",
														(Node *)makeString($4)));
					$$ = (Node *)n;
				}
			| PREPARE TRANSACTION SCONST
				{   
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_PREPARE;
					n->gid = $3;
					$$ = (Node *)n;
				}
			| COMMIT PREPARED SCONST
				{   
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_COMMIT_PREPARED;
					n->gid = $3;
					n->csn = InvalidCommitSeqNo;
					$$ = (Node *)n;
				}
			| COMMIT PREPARED SCONST WITH SCONST
				{   
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_COMMIT_PREPARED;
					n->gid = $3;
					n->csn = strtoull($5, NULL, 10);
					$$ = (Node *)n;
				}
			| ROLLBACK PREPARED SCONST
				{   
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_ROLLBACK_PREPARED;
					n->gid = $3;
					$$ = (Node *)n;
				}
			| FLUSH opt_table_for_b WITH READ LOCK_P
				{
					TransactionStmt *n = makeNode(TransactionStmt);
					n->kind = TRANS_STMT_START;
					n->options = list_make1(makeDefElem("transaction_read_only", makeIntConst(TRUE, @3)));
					$$ = (Node *)n;
				}
		;

opt_transaction:	WORK							{}
			| TRANSACTION							{}
			| /*EMPTY*/								{}
		;

transaction_mode_item:
			ISOLATION LEVEL iso_level
					{ $$ = makeDefElem("transaction_isolation",
									   makeStringConst($3, @3)); }
			| READ ONLY
					{ $$ = makeDefElem("transaction_read_only",
									   makeIntConst(TRUE, @1)); }
			| READ WRITE
					{ $$ = makeDefElem("transaction_read_only",
									   makeIntConst(FALSE, @1)); }
			| DEFERRABLE
					{ $$ = makeDefElem("transaction_deferrable",
									   makeIntConst(TRUE, @1)); }
			| NOT DEFERRABLE
					{ $$ = makeDefElem("transaction_deferrable",
									   makeIntConst(FALSE, @1)); }
		;

/* Syntax with commas is SQL-spec, without commas is Postgres historical */
transaction_mode_list:
			transaction_mode_item
					{ $$ = list_make1($1); }
			| transaction_mode_list ',' transaction_mode_item
					{ $$ = lappend($1, $3); }
			| transaction_mode_list transaction_mode_item
					{ $$ = lappend($1, $2); }
		;

transaction_mode_list_or_empty:
			transaction_mode_list
			| /* EMPTY */
					{ $$ = NIL; }
		;


/*****************************************************************************
 *
 *	CONTVIEW:
 *		CREATE [ OR REPLACE ] CONTVIEW <contquery_name> [WITH ([,...])]
 *			AS <query> 
 *
 *****************************************************************************/

CreateContQueryStmt: CREATE CONTVIEW qualified_name opt_reloptions AS SelectStmt
				{
					ViewStmt *n = makeNode(ViewStmt);
					n->view = $3;
					n->relkind = OBJECT_CONTQUERY;
					n->view->relpersistence = RELPERSISTENCE_PERMANENT;
					n->aliases = NIL;
					n->query = $6;
					n->replace = false;
					n->options = $4;
                    n->sql_statement = NULL;
					$$ = (Node *) n;
                }
		    | CREATE OR REPLACE CONTVIEW qualified_name opt_reloptions AS SelectStmt
				{
					ViewStmt *n = makeNode(ViewStmt);
					n->view = $5;
					n->relkind = OBJECT_CONTQUERY;
					n->view->relpersistence = RELPERSISTENCE_PERMANENT;
					n->aliases = NIL;
					n->query = $8;
					n->replace = true;
					n->options = $6;
                    n->sql_statement = NULL;
					$$ = (Node *) n;
				}
            ;

/*****************************************************************************
 *
 *	QUERY:
 *		CREATE [ OR REPLACE ] [ TEMP ] VIEW <viewname> '('target-list ')'
 *			AS <query> [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
 *
 *****************************************************************************/

ViewStmt: CREATE OptTemp ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $3;
					n->view->relpersistence = $2;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node*) n;
				}
		| CREATE OR REPLACE OptTemp ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->view->relpersistence = $4;
					n->replace = true;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node*) n;
				}
		| CREATE opt_or_replace definer_expression OptTemp ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->view->relpersistence = $4;
					n->definer = $3;
					n->replace = $2;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node*) n;
				}
		| CREATE opt_or_replace view_algo_expr OptTemp ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->view->relpersistence = $4;
					n->replace = $2;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node*) n;
				}
		| CREATE opt_or_replace view_algo_expr definer_expression OptTemp ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $6;
					n->view->relpersistence = $5;
					n->definer = $4;
					n->replace = $2;
					n->viewSecurityOption = VIEW_SQL_SECURITY_NONE;
					$$ = (Node*) n;
				}
		| CREATE view_security_expression ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $3;
					n->viewSecurityOption = (ViewSecurityOption)$2;
					$$ = (Node*) n;
				}
		| CREATE OR REPLACE view_security_expression ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->replace = true;
					n->viewSecurityOption = (ViewSecurityOption)$4;
					$$ = (Node *) n;
				}
		| CREATE opt_or_replace definer_expression view_security_expression ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->definer = $3;
					n->replace = $2;
					n->viewSecurityOption = (ViewSecurityOption)$4;
 					$$ = (Node *) n;
 				}
		| CREATE opt_or_replace view_algo_expr view_security_expression ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $5;
					n->replace = $2;
					n->viewSecurityOption = (ViewSecurityOption)$4;
					$$ = (Node *) n;
				}
		| CREATE opt_or_replace view_algo_expr definer_expression view_security_expression ViewStmtBaseBody
				{
					ViewStmt *n = (ViewStmt*) $6;
					n->definer = $4;
					n->replace = $2;
					n->viewSecurityOption = (ViewSecurityOption)$5;
 					$$ = (Node *) n;
 				}
		;

ViewStmtBaseBody: VIEW dolphin_qualified_name opt_column_list opt_reloptions AS SelectStmt opt_check_option
	{
		ViewStmt* stmt = makeNode(ViewStmt);
		stmt->view = $2;
		stmt->aliases = $3;
		stmt->options = $4;

		/* 'AS' is here */

		stmt->query = $6;
		stmt->withCheckOption = (ViewCheckOption)$7;
		stmt->replace = false;
		stmt->sql_statement = NULL;
		stmt->view->relpersistence = RELPERSISTENCE_PERMANENT;
		$$ = (Node*)stmt;
	}

/* algorithm optionals of view statement */
view_algo_expr:
	ALGORITHM '=' UNDEFINED
	{
		$$ = 0;
	}
	| ALGORITHM '=' MERGE
	{
		$$ = 1;
	}
	| ALGORITHM '=' TEMPTABLE
	{
		$$ = 2;
	}
	;

view_algo_shift_expr:
	ALGORITHM_UNDEFINED
	{
		$$ = 0;
	}
	| ALGORITHM_MERGE
	{
		$$ = 1;
	}
	| ALGORITHM_TEMPTABLE
	{
		$$ = 2;
	}
	;

opt_view_algo:
	view_algo_shift_expr
	{
		$$ = $1;
	}
	| /* EMPTY */
	{
		$$ = 0;
	}


opt_check_option:
		WITH CHECK OPTION				{ $$ = CASCADED_CHECK_OPTION; }
		| WITH CASCADED CHECK OPTION	{ $$ = CASCADED_CHECK_OPTION; }
		| WITH LOCAL CHECK OPTION		{ $$ = LOCAL_CHECK_OPTION; }
		| /* EMPTY */					{ $$ = NO_CHECK_OPTION; }
		;

/*****************************************************************************
 *
 *		QUERY:
 *				LOAD "filename"
 *
 *****************************************************************************/

LoadStmt:	LOAD file_name
				{
					LoadStmt *n = makeNode(LoadStmt);
					n->filename = $2;
                    n->is_load_data = false;
					$$ = (Node *)n;
				}
		| LoadAct DATA_P INFILE SCONST conflict_option INTO TABLE dolphin_qualified_name opt_character opt_fields_options 
		opt_lines_options opt_ignore_number opt_column_list
				{
					CopyStmt *n = makeNode(CopyStmt);
					n->relation = $8;
					n->query = NULL;
					n->attlist = u_sess->parser_cxt.col_list;
					n->is_from = TRUE;
					n->filename = $4;
					ListCell* option = NULL;
					n->relation->length = @3;
					n->options = NIL;
					n->options = lappend(n->options, makeDefElem("format", (Node *)makeString("csv")));
					n->options = lappend(n->options, makeDefElem("compatibility", (Node *)makeInteger(TRUE)));
					/* Concatenate user-supplied flags */
					if ($5)
						n->options = lappend(n->options, $5);
					if ($9)
						n->options = lappend(n->options, $9);
					if ($12)
						n->options = lappend(n->options, $12);
					if ($10)
						n->options = list_concat(n->options, $10);
					if ($11)
						n->options = list_concat(n->options, $11);
					$$ = (Node *)n;
					u_sess->parser_cxt.is_load_copy = false;
					u_sess->parser_cxt.col_list = NULL;
				}
        | OPTIONS '(' load_options_list ')' LOAD {u_sess->parser_cxt.is_load_copy = true;} opt_load_data opt_load_data_options_list load_type_set qualified_name load_oper_table_type load_table_options_list
                {
                    LoadStmt *n = makeNode(LoadStmt);
					n->is_load_data = true;
					n->pre_load_options = $3;
                    n->load_options = $8;
					n->load_type = (LOAD_DATA_TYPE)GetLoadType($9, $11);
                    n->relation = $10;
					n->rel_options = $12;
                    $$ = (Node *)n;
					u_sess->parser_cxt.is_load_copy = false;
                }
	;

LoadAct: LOAD {u_sess->parser_cxt.is_load_copy = true;}
	;

conflict_option:
		REPLACE		{ $$ = makeDefElem("replace", (Node *)makeInteger(TRUE));}
		| IGNORE	{ $$ = makeDefElem("ignore", (Node *)makeInteger(TRUE));}
		| /* EMPTY */	{ $$ = NULL;}
	;

rows_lines:
		ROWS
		| LINES
	;

opt_ignore_number:
		IGNORE Iconst rows_lines
			{
#ifdef ENABLE_MULTIPLE_NODES
				const char* message = "SKIP is not supported";
				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("SKIP is not supported")));
#endif
				$$ = makeDefElem("skip", (Node *)makeInteger($2));
			}
		| /* EMPTY */ { $$ = NULL;}
	;

fields_list:
	fields_list fields_option
		{
			$$ = lappend($1, $2);
		}
	| fields_option
		{
			$$ = list_make1($1);
		}
	;

fields_option:
		TERMINATED BY SCONST
			{
				$$ = makeDefElem("delimiter", (Node *)makeString($3));
			}
		| OPTIONALLY ENCLOSED BY SCONST
			{
				$$ = makeDefElem("quote", (Node *)makeString($4));
			}
		| ENCLOSED BY SCONST
			{
				$$ = makeDefElem("quote", (Node *)makeString($3));
			}
		| ESCAPED BY SCONST
			{
				$$ = makeDefElem("escape", (Node *)makeString($3));
			}
	;

opt_fields_options:
		FIELDS fields_list	{ $$ = $2;}
		| COLUMNS fields_list	{ $$ = $2;}
		| /* EMPTY */	{ $$ = NIL;}
	;

lines_list:
	lines_list lines_option
		{
			$$ = lappend($1, $2);
		}
	| lines_option
		{
			$$ = list_make1($1);
		}
	;

lines_option:
		TERMINATED BY SCONST
			{
				$$ = makeDefElem("eol", (Node *)makeString($3));
			}
		| STARTING BY SCONST
			{
				$$ = makeDefElem("prefix", (Node *)makeString($3));
			}
	;

opt_lines_options:
		LINES lines_list	{$$ = $2;}
		| /* EMPTY */	{$$ = NIL;}	
	;

opt_character:
		CHARACTER SET SCONST		{ $$ = makeDefElem("encoding", (Node *)makeString($3));}
		| /* EMPTY */		{ $$ = NULL; }
	;

load_options_list:
		load_options_item							{ $$ = list_make1($1);  }
		| load_options_list ',' load_options_item 	{ $$ = lappend($1, $3); }
		| /* EMPTY */							    { $$ = NULL; }
	;

load_options_item:
		ERRORS '=' NumericOnly						{ $$ = makeDefElem("errors", (Node *)$3); }
		| SKIP '=' NumericOnly 						{ $$ = makeDefElem("skip", (Node *)$3);   }
		| DATA_P '=' load_quote_str 				{ $$ = makeDefElem("data", (Node *)makeString($3));
		}
	;

opt_load_data:
		DATA_P 									{ }
		| /* EMPTY */							{ }
	;

opt_load_data_options_list:
		opt_load_data_options_list opt_load_data_options_item
		{
			$$ = lappend($1, $2);
		}
		| /* EMPTY */							{ $$ = NIL; }
	;

opt_load_data_options_item:
		INFILE load_quote_str
		{
			$$ = makeDefElem("infile", (Node *)makeString($2));
		}
		| CHARACTERSET load_quote_str
		{
			$$ = makeDefElem("characterset", (Node *)makeString($2));
		}
	;

load_oper_table_type:
		TRUNCATE
		{
			$$ = LOAD_DATA_TRUNCATE;
		}
		| APPEND
		{
			$$ = LOAD_DATA_APPEND;
		}
		| REPLACE
		{
			$$ = LOAD_DATA_REPLACE;
		}
		| INSERT
		{
			$$ = LOAD_DATA_INSERT;
		}
		| /* EMPTY */							{ $$ = LOAD_DATA_UNKNOWN; }
	;

load_type_set:
		load_oper_table_type INTO TABLE 
		{
			$$ = $1;
		}
	;

load_table_options_list: 
		load_table_options_list load_table_options_item
		{
			$$ = lappend($1, $2);
		}
		| /* EMPTY */							{ $$ = NIL; }
	;

load_table_options_item:
		TRAILING NULLCOLS
		{
			$$ = makeDefElem("trailing_nullcols", (Node *)makeInteger(TRUE));
		}
		| FIELDS CSV
		{
			$$ = makeDefElem("fields_csv", (Node *)makeInteger(TRUE));
		}
		| FIELDS TERMINATED load_quote_str
		{
			$$ = makeDefElem("fields_terminated_by", (Node *)makeString($3));
		}
		| FIELDS TERMINATED BY load_quote_str
		{
			$$ = makeDefElem("fields_terminated_by", (Node *)makeString($4));
		}
 		| OPTIONALLY ENCLOSED BY load_quote_str
		{
			$$ = makeDefElem("optionally_enclosed_by", (Node *)makeString($4));
		}		
		| load_when_option
		{
			$$ = $1;
		}
		| '(' load_column_expr_list ')'
		{
			$$ = MakeDefElemWithLoc("fields_list", (Node *)$2, @1, @3);
		}
	;

load_column_expr_list:
		load_column_expr_item
		{
			$$ = list_make1($1);
		}
		| load_column_expr_list ',' load_column_expr_item
		{
			$$ = lappend($1, $3);
		}
	;

load_column_expr_item:
		ColId CONSTANT load_quote_str
		{
			SqlLoadColExpr* n = (SqlLoadColExpr*)MakeSqlLoadNode($1);
			n->const_info = makeStringConst($3, @3);
			$$ = (Node*)n;
		}
		| ColId load_col_sequence
		{
			SqlLoadColExpr* n = (SqlLoadColExpr*)MakeSqlLoadNode($1);
			n->sequence_info = $2;
			$$ = (Node*)n;
		}
		| ColId FILLER load_col_data_type
		{
			SqlLoadColExpr* n = (SqlLoadColExpr*)MakeSqlLoadNode($1);
			n->is_filler = true;
			$$ = (Node*)n;
		}
		| ColId load_col_scalar_spec
		{
			SqlLoadColExpr* n = (SqlLoadColExpr*)MakeSqlLoadNode($1);
			n->scalar_spec = $2;
			$$ = (Node*)n;
		}
	;

load_col_sequence_item_sart:
			Iconst			{ $$ = $1; }
			| FCONST		{ $$ = SequenceStrGetInt64($1); }
			| MAXVALUE		{ $$ = LOADER_SEQUENCE_MAX_FLAG; }
			| ROWS			{ $$ = LOADER_SEQUENCE_COUNT_FLAG; }
		;

load_col_sequence:
		SEQUENCE '(' load_col_sequence_item_sart column_sequence_item_step ')'
		{
			SqlLoadSequInfo* n = makeNode(SqlLoadSequInfo);
			n->start = $3;
			n->step = $4;
			$$ = (Node *)n;
		}
	;	

load_col_scalar_spec:
		load_col_position_spec load_col_data_type load_col_nullif_spec load_col_sql_str 
		{
			SqlLoadScalarSpec* n = makeNode(SqlLoadScalarSpec);
			n->position_info = $1;
			n->typname = $2;
			n->sqlstr = $4;
			n->nullif_col = $3;
			$$ = (Node*)n;
		}
	;

load_col_position_spec:
		POSITION '(' Iconst '-' Iconst ')'
		{
			SqlLoadColPosInfo *n =  makeNode(SqlLoadColPosInfo);
			n->start = $3;
			n->end = $5;
			$$ = (Node *)n;
		}
		| /* EMPTY */							{ $$ = NULL; }
	;

load_col_nullif_spec:
		NULLIF '(' ColId '=' BLANKS ')'
		{
			$$ = $3;
		}
		| /* EMPTY */							{ $$ = NULL; }
	;

load_col_data_type:
		Numeric					{ $$ = $1; }
		| Numeric EXTERNAL		{ $$ = $1; }
		| Character				{ $$ = $1; }
		| ConstDatetime			{ $$ = $1; }
		| ConstSet				{ $$ = $1; }
		| /*EMPTY*/				{ $$ = NULL; }
	;

load_col_sql_str:
		normal_ident
		{
			$$ = makeStringConst($1, @1);
		}
		| /* EMPTY */							{ $$ = NULL; }
	;

load_when_option:
		WHEN load_when_option_list
		{
			$$ = MakeDefElemWithLoc("when_expr", (Node *)$2, @1, @2);
		}
	;

load_when_option_list:
		load_when_option_item
		{
			$$ = list_make1($1);
		}
		| load_when_option_list AND load_when_option_item
		{
			$$ = lappend($1, $3);
		}
	;

load_when_option_item:
		'(' Iconst '-' Iconst ')' masking_policy_condition_operator load_quote_str
		{
			LoadWhenExpr *n =  makeNode(LoadWhenExpr);
			n->whentype = 0;
			n->start = $2;
			n->end = $4;
			n->oper = $6;
			n->val = $7;
			$$ = (Node*)n;
		}
		| '(' Iconst ')' masking_policy_condition_operator load_quote_str
		{
				LoadWhenExpr *n =  makeNode(LoadWhenExpr);
				n->whentype = 0;
				n->start = $2;
				n->end = $2;
				n->oper = $4;
				n->val = $5;
				$$ = (Node*)n;
		}
		| ColId masking_policy_condition_operator load_quote_str
		{
				LoadWhenExpr *n =  makeNode(LoadWhenExpr);
				n->whentype = 1;
				n->start = -1;
				n->end = -1;
				n->attname = $1;
				n->oper = $2;
				n->val = $3;
				$$ = (Node*)n;
		}
	;

/*
 three string formats used to be compatible with oracle
	1. string
	2. 'string'
	3. "string"
*/
load_quote_str:
		normal_ident			{ $$ = $1; }
		| SCONST                { $$ = $1; }

/*****************************************************************************
 *
 *		CREATE DATABASE
 *
 *****************************************************************************/

CreatedbStmt:
			CREATE DATABASE database_name createdb_opt_list
				{
					if ($4 != NIL || (GetSessionContext()->enableBCmptMode == false)) {
						CreatedbStmt *n = makeNode(CreatedbStmt);
						IsValidIdent($3);
						n->dbname = $3;
						n->missing_ok = FALSE;
						n->options = $4;
						$$ = (Node *)n;
					} else {
						CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
						n->schemaname = $3;
						n->authid = NULL;
						n->missing_ok = FALSE;
						n->charset = PG_INVALID_ENCODING;
						$$ = (Node *)n;
					}
				}
			| CREATE DATABASE database_name WITH createdb_opt_list
				{
					CreatedbStmt *n = makeNode(CreatedbStmt);
					IsValidIdent($3);
					n->dbname = $3;
					n->missing_ok = FALSE;
					n->options = $5;
					$$ = (Node *)n;
				}
			| CREATE DATABASE IF_P NOT EXISTS database_name createdb_opt_list
				{
					if ($7 != NIL || (GetSessionContext()->enableBCmptMode == false)) {
						CreatedbStmt *n = makeNode(CreatedbStmt);
						IsValidIdent($6);
						n->dbname = $6;
						n->missing_ok = TRUE;
						n->options = $7;
						$$ = (Node *)n;
					} else {
						CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
						n->schemaname = $6;
						n->authid = NULL;
						n->missing_ok = TRUE;
						n->charset = PG_INVALID_ENCODING;
						$$ = (Node *)n;
					}
				}
			| CREATE DATABASE IF_P NOT EXISTS database_name WITH createdb_opt_list
				{
					CreatedbStmt *n = makeNode(CreatedbStmt);
					IsValidIdent($6);
					n->dbname = $6;
					n->missing_ok = TRUE;
					n->options = $8;
					$$ = (Node *)n;
				}
			| CREATE DATABASE database_name CharsetCollate
				{
					if (GetSessionContext()->enableBCmptMode) {
						CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
						n->schemaname = $3;
						n->authid = NULL;
						n->missing_ok = FALSE;
						n->charset = $4->charset;
						n->collate = $4->collate;
						$$ = (Node *)n;
					} else {
						const char* message = "create schema/database with charset need to set b_compatibility_mode on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("create schema/database with charset need to set b_compatibility_mode on.")));
					}
				}
			| CREATE DATABASE IF_P NOT EXISTS database_name CharsetCollate
				{
					if (GetSessionContext()->enableBCmptMode) {
						CreateSchemaStmt *n = makeNode(CreateSchemaStmt);
						n->schemaname = $6;
						n->authid = NULL;
						n->missing_ok = TRUE;
						n->charset = $7->charset;
						n->collate = $7->collate;
						$$ = (Node *)n;
					} else {
						const char* message = "create schema/database with charset need to set b_compatibility_mode on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("create schema/database with charset need to set b_compatibility_mode on.")));
					}
				}
		;

createdb_opt_list:
			createdb_opt_list createdb_opt_item		{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

createdb_opt_item:
			TABLESPACE opt_equal name
				{
					$$ = makeDefElem("tablespace", (Node *)makeString($3));
				}
			| TABLESPACE opt_equal DEFAULT
				{
					$$ = makeDefElem("tablespace", NULL);
				}
			| LOCATION opt_equal SCONST
				{
					$$ = makeDefElem("location", (Node *)makeString($3));
				}
			| LOCATION opt_equal DEFAULT
				{
					$$ = makeDefElem("location", NULL);
				}
			| TEMPLATE opt_equal name
				{
					$$ = makeDefElem("template", (Node *)makeString($3));
				}
			| TEMPLATE opt_equal DEFAULT
				{
					$$ = makeDefElem("template", NULL);
				}
			| ENCODING opt_equal SCONST
				{
					$$ = makeDefElem("encoding", (Node *)makeString($3));
				}
			| ENCODING opt_equal Iconst
				{
					$$ = makeDefElem("encoding", (Node *)makeInteger($3));
				}
			| ENCODING opt_equal DEFAULT
				{
					$$ = makeDefElem("encoding", NULL);
				}
			| LC_COLLATE_P opt_equal SCONST
				{
					$$ = makeDefElem("lc_collate", (Node *)makeString($3));
				}
			| LC_COLLATE_P opt_equal DEFAULT
				{
					$$ = makeDefElem("lc_collate", NULL);
				}
			| DBCOMPATIBILITY_P opt_equal SCONST
				{
					if (checkCompArgs($3) == false)
					{
						const char* message = "Compatibility args %s is invalid\n";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
							 errmsg("Compatibility args %s is invalid\n", $3)));
					}
					$$ = makeDefElem("dbcompatibility", (Node *)makeString($3));
				}
			| DBCOMPATIBILITY_P opt_equal DEFAULT
				{
					$$ = makeDefElem("dbcompatibility", NULL);
				}
			| LC_CTYPE_P opt_equal SCONST
				{
					$$ = makeDefElem("lc_ctype", (Node *)makeString($3));
				}
			| LC_CTYPE_P opt_equal DEFAULT
				{
					$$ = makeDefElem("lc_ctype", NULL);
				}
			| CONNECTION LIMIT opt_equal SignedIconst
				{
					$$ = makeDefElem("connectionlimit", (Node *)makeInteger($4));
				}
			| OWNER opt_equal name
				{
					$$ = makeDefElem("owner", (Node *)makeString($3));
				}
			| OWNER opt_equal DEFAULT
				{
					$$ = makeDefElem("owner", NULL);
				}
		;

/*
 *	Though the equals sign doesn't match other WITH options, pg_dump uses
 *	equals for backward compatibility, and it doesn't seem worth removing it.
 */
opt_equal:	'='										{}
			| /*EMPTY*/								{}
		;

opt_bracket:	'(' ')'								{}
				| /*EMPTY*/							{}
		;

/*****************************************************************************
 *
 *		ALTER DATABASE
 *
 *****************************************************************************/

AlterDatabaseStmt:
			ALTER DATABASE database_name opt_with alterdb_opt_list
				 {
					AlterDatabaseStmt *n = makeNode(AlterDatabaseStmt);
					n->dbname = $3;
					n->options = $5;
					$$ = (Node *)n;
				 }
			| ALTER DATABASE database_name SET TABLESPACE name
				 {
					AlterDatabaseStmt *n = makeNode(AlterDatabaseStmt);
					n->dbname = $3;
					n->options = list_make1(makeDefElem("tablespace",
													(Node *)makeString($6)));
					$$ = (Node *)n;
				 }
			| ALTER DATABASE database_name CharsetCollate
				{
					if (GetSessionContext()->enableBCmptMode) {
						AlterSchemaStmt *n = makeNode(AlterSchemaStmt);
						n->schemaname = $3;
						n->authid = NULL;
						n->hasBlockChain = false;
						n->charset = $4->charset;
						n->collate = $4->collate;
						$$ = (Node *)n;
					} else {
						const char* message = "alter database with charset need to set b_compatibility_mode on.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("create database with charset need to set b_compatibility_mode on.")));
					}
				}
		;

AlterDatabaseSetStmt:
			ALTER DATABASE database_name SetResetClause
				{
					AlterDatabaseSetStmt *n = makeNode(AlterDatabaseSetStmt);
					n->dbname = $3;
					n->setstmt = $4;
					$$ = (Node *)n;
				}
		;


alterdb_opt_list:
			alterdb_opt_list alterdb_opt_item		{ $$ = lappend($1, $2); }
			| /* EMPTY */							{ $$ = NIL; }
		;

alterdb_opt_item:
			CONNECTION LIMIT opt_equal SignedIconst
				{
					$$ = makeDefElem("connectionlimit", (Node *)makeInteger($4));
				}
			| ENABLE_P PRIVATE OBJECT_P
				{
					$$ = makeDefElem("privateobject", (Node *)makeInteger(1));
				}
			| DISABLE_P PRIVATE OBJECT_P
				{
					$$ = makeDefElem("privateobject", (Node *)makeInteger(0));
				}
		;


/*****************************************************************************
 *
 *		DROP DATABASE [ IF EXISTS ]
 *
 * This is implicitly CASCADE, no need for drop behavior
 *****************************************************************************/

DropdbStmt: DROP DATABASE database_name
				{
					if (GetSessionContext()->enableBCmptMode) {
						DropStmt *n = makeNode(DropStmt);
						n->removeType = OBJECT_SCHEMA;
						n->missing_ok = FALSE;
						n->objects = list_make1(list_make1(makeString($3)));
						n->behavior = DROP_CASCADE;
						n->arguments = NIL;
						n->concurrent = false;
						$$ = (Node *)n;
					} else {
						DropdbStmt *n = makeNode(DropdbStmt);
						n->dbname = $3;
						n->missing_ok = FALSE;
						$$ = (Node *)n;
					}
				}
			| DROP DATABASE IF_P EXISTS database_name
				{
					if (GetSessionContext()->enableBCmptMode) {
						DropStmt *n = makeNode(DropStmt);
						n->removeType = OBJECT_SCHEMA;
						n->missing_ok = true;
						n->objects = list_make1(list_make1(makeString($5)));
						n->arguments = NIL;
						n->behavior = DROP_CASCADE;
						n->concurrent = false;
						$$ = (Node *)n;
					} else {
						DropdbStmt *n = makeNode(DropdbStmt);
						n->dbname = $5;
						n->missing_ok = TRUE;
						$$ = (Node *)n;
					}
				}
		;

/*****************************************************************************
 *
 * Manipulate a domain
 *
 *****************************************************************************/

CreateDomainStmt:
			CREATE DOMAIN_P any_name opt_as Typename ColQualList
				{
					CreateDomainStmt *n = makeNode(CreateDomainStmt);
					n->domainname = $3;
					n->typname = $5;
					SplitColQualList($6, &n->constraints, &n->collClause, NULL,
									 yyscanner);
					$$ = (Node *)n;
				}
		;

AlterDomainStmt:
			/* ALTER DOMAIN <domain> {SET DEFAULT <expr>|DROP DEFAULT} */
			ALTER DOMAIN_P any_name alter_column_default
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'T';
					n->typname = $3;
					n->def = $4;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> DROP NOT NULL */
			| ALTER DOMAIN_P any_name DROP NOT NULL_P
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'N';
					n->typname = $3;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> SET NOT NULL */
			| ALTER DOMAIN_P any_name SET NOT NULL_P
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'O';
					n->typname = $3;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> ADD CONSTRAINT ... */
			| ALTER DOMAIN_P any_name ADD_P TableConstraint
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'C';
					n->typname = $3;
					n->def = $5;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> DROP CONSTRAINT <name> [RESTRICT|CASCADE] */
			| ALTER DOMAIN_P any_name DROP CONSTRAINT name opt_drop_behavior
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'X';
					n->typname = $3;
					n->name = $6;
					n->behavior = $7;
					n->missing_ok = false;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> DROP CONSTRAINT IF EXISTS <name> [RESTRICT|CASCADE] */
			| ALTER DOMAIN_P any_name DROP CONSTRAINT IF_P EXISTS name opt_drop_behavior
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'X';
					n->typname = $3;
					n->name = $8;
					n->behavior = $9;
					n->missing_ok = true;
					$$ = (Node *)n;
				}
			/* ALTER DOMAIN <domain> VALIDATE CONSTRAINT <name> */
			| ALTER DOMAIN_P any_name VALIDATE CONSTRAINT name
				{
					AlterDomainStmt *n = makeNode(AlterDomainStmt);
					n->subtype = 'V';
					n->typname = $3;
					n->name = $6;
					$$ = (Node *)n;
				}
			;

opt_as:		AS										{}
			| /* EMPTY */							{}
		;


/*****************************************************************************
 *
 * Manipulate a text search dictionary or configuration
 *
 *****************************************************************************/

AlterTSDictionaryStmt:
			ALTER TEXT_P SEARCH DICTIONARY any_name definition
				{
					AlterTSDictionaryStmt *n = makeNode(AlterTSDictionaryStmt);
					n->dictname = $5;
					n->options = $6;
					$$ = (Node *)n;
				}
		;

AlterTSConfigurationStmt:
			ALTER TEXT_P SEARCH CONFIGURATION any_name ADD_P MAPPING FOR name_list WITH any_name_list
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_ADD_MAPPING;
					n->cfgname = $5;
					n->tokentype = $9;
					n->cfoptions = NIL;
					n->dicts = $11;
					n->override = false;
					n->replace = false;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list WITH any_name_list
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN;
					n->cfgname = $5;
					n->tokentype = $9;
					n->cfoptions = NIL;
					n->dicts = $11;
					n->override = true;
					n->replace = false;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name ALTER MAPPING REPLACE any_name WITH any_name
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_REPLACE_DICT;
					n->cfgname = $5;
					n->tokentype = NIL;
					n->cfoptions = NIL;
					n->dicts = list_make2($9,$11);
					n->override = false;
					n->replace = true;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list REPLACE any_name WITH any_name
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN;
					n->cfgname = $5;
					n->tokentype = $9;
					n->cfoptions = NIL;
					n->dicts = list_make2($11,$13);
					n->override = false;
					n->replace = true;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name DROP MAPPING FOR name_list
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_DROP_MAPPING;
					n->cfgname = $5;
					n->tokentype = $9;
					n->cfoptions = NIL;
					n->missing_ok = false;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name DROP MAPPING IF_P EXISTS FOR name_list
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_DROP_MAPPING;
					n->cfgname = $5;
					n->tokentype = $11;
					n->cfoptions = NIL;
					n->missing_ok = true;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name SET cfoptions
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN;
					n->cfgname = $5;
					n->tokentype = NIL;
					n->cfoptions = $7;
					n->missing_ok = false;
					n->override = false;
					n->replace = false;
					n->is_reset = false;
					$$ = (Node*)n;
				}
			| ALTER TEXT_P SEARCH CONFIGURATION any_name RESET cfoptions
				{
					AlterTSConfigurationStmt *n = makeNode(AlterTSConfigurationStmt);
					n->kind = ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN;
					n->cfgname = $5;
					n->tokentype = NIL;
					n->cfoptions = $7;
					n->override = false;
					n->replace = false;
					n->missing_ok = false;
					n->is_reset = true;
					$$ = (Node*)n;
				}
		;


/*****************************************************************************
 *
 * Manipulate a conversion
 *
 *		CREATE [DEFAULT] CONVERSION <conversion_name>
 *		FOR <encoding_name> TO <encoding_name> FROM <func_name>
 *
 *****************************************************************************/

CreateConversionStmt:
			CREATE opt_default CONVERSION_P any_name FOR SCONST
			TO SCONST FROM any_name
			{
				CreateConversionStmt *n = makeNode(CreateConversionStmt);
				n->conversion_name = $4;
				n->for_encoding_name = $6;
				n->to_encoding_name = $8;
				n->func_name = $10;
				n->def = $2;
				$$ = (Node *)n;
			}
		;

/*****************************************************************************
 *
 *		QUERY:
 *				CLUSTER [VERBOSE] <qualified_name> [ USING <index_name> ]
 *				CLUSTER [VERBOSE]
 *				CLUSTER [VERBOSE] <index_name> ON <qualified_name> (for pre-8.3)
 *
 *****************************************************************************/

ClusterStmt:
			CLUSTER opt_verbose_with_brance dolphin_qualified_name cluster_index_specification
				{
					ClusterStmt *n = makeNode(ClusterStmt);
					$3->partitionname = NULL;
					n->relation = $3;
					n->indexname = $4;
					n->verbose = $2;
					$$ = (Node*)n;
				}
			| CLUSTER opt_verbose_with_brance dolphin_qualified_name PARTITION '(' name ')' cluster_index_specification
				{
					ClusterStmt *n = makeNode(ClusterStmt);
					$3->partitionname = $6;
					n->relation = $3;
					n->indexname = $8;
					n->verbose = $2;
					$$ = (Node*)n;
				}
			| CLUSTER opt_verbose_with_brance
				{
					ClusterStmt *n = makeNode(ClusterStmt);
					n->relation = NULL;
					n->indexname = NULL;
					n->verbose = $2;
					$$ = (Node*)n;
				}
			/* kept for pre-8.3 compatibility, dolphin_index_name used to deal with the conflict*/
			| CLUSTER opt_verbose_with_brance dolphin_index_name ON dolphin_qualified_name
				{
					ClusterStmt *n = makeNode(ClusterStmt);
					n->relation = $5;
					n->indexname = $3;
					n->verbose = $2;
					$$ = (Node*)n;
				}
		;

cluster_index_specification:
			USING index_name		{ $$ = $2; }
			| /*EMPTY*/				{ $$ = NULL; }
		;


/*****************************************************************************
 *
 *		QUERY:
 *				VACUUM
 *				ANALYZE
 *
 *****************************************************************************/

VacuumStmt:
			VACUUM opt_deltamerge
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					if ($2)
						n->options |= VACOPT_MERGE;
					$$ = (Node *)n;
				}
			| VACUUM opt_deltamerge dolphin_qualified_name
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					if ($2)
						n->options |= VACOPT_MERGE;
					n->relation = $3;
					$$ = (Node *)n;
				}
			| VACUUM opt_hdfsdirectory
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
					{
						n->options |= VACOPT_HDFSDIRECTORY;
					}
					$$ = (Node *)n;
				}
			| VACUUM opt_hdfsdirectory dolphin_qualified_name
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
					{
						n->options |= VACOPT_HDFSDIRECTORY;
					}
					n->relation = $3;
					$$ = (Node *)n;
				}
			| VACUUM opt_full opt_freeze_empty opt_verbose_empty opt_compact
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
						n->options |= VACOPT_FULL;
					if ($4)
						n->options |= VACOPT_VERBOSE;
					if ($5)
						n->options |= VACOPT_COMPACT;
					int options = 0;
					options |= VACOPT_VACUUM | VACOPT_FULL | VACOPT_COMPACT;
					if (n->options & VACOPT_COMPACT)
					{
						if (n->options != options)
						{
						const char* message = "COMPACT can only be used with VACUUM FULL";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("COMPACT can only be used with VACUUM FULL")));
						}
						if ($3)
						{
							const char* message = "COMPACT can not be used with FREEZE";
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("COMPACT can not be used with FREEZE")));
						}
					}
					n->freeze_min_age = $3 ? 0 : -1;
					n->freeze_table_age = $3 ? 0 : -1;
					n->relation = NULL;
					n->va_cols = NIL;
					$$ = (Node *)n;
				}
			| VACUUM opt_full opt_freeze_empty opt_verbose_empty opt_compact dolphin_qualified_name
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
						n->options |= VACOPT_FULL;
					if ($4)
						n->options |= VACOPT_VERBOSE;
					if ($5)
						n->options |= VACOPT_COMPACT;
					int options = 0;
					options |= VACOPT_VACUUM | VACOPT_FULL | VACOPT_COMPACT;
					if (n->options & VACOPT_COMPACT)
					{
						if (n->options != options)
						{
							const char* message = "COMPACT can only be used with VACUUM FULL";
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("COMPACT can only be used with VACUUM FULL")));
						}
						if ($3)
						{
							const char* message = "COMPACT can not be used with FREEZE";
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("COMPACT can not be used with FREEZE")));
						}
					}
					n->freeze_min_age = $3 ? 0 : -1;
					n->freeze_table_age = $3 ? 0 : -1;
					n->relation = $6;
					n->va_cols = NIL;
					$$ = (Node *)n;
				}
			| VACUUM opt_full opt_freeze_empty opt_verbose_empty opt_compact dolphin_qualified_name PARTITION '('name')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
						n->options |= VACOPT_FULL;
					if ($4)
						n->options |= VACOPT_VERBOSE;
					if ($5)
					{
						const char* message = "COMPACT can not be used with PARTITION";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("COMPACT can not be used with PARTITION")));
					}
					n->freeze_min_age = $3 ? 0 : -1;
					n->freeze_table_age = $3 ? 0 : -1;
					n->relation = $6;
					n->va_cols = NIL;
					$6->partitionname = $9;
					$$ = (Node *)n;
				}
			| VACUUM opt_full opt_freeze_empty opt_verbose_empty opt_compact dolphin_qualified_name SUBPARTITION '('name')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM;
					if ($2)
						n->options |= VACOPT_FULL;
					if ($4)
						n->options |= VACOPT_VERBOSE;
					if ($5)
					{
						const char* message = "COMPACT can not be used with SUBPARTITION";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("COMPACT can not be used with SUBPARTITION")));
					}
					n->freeze_min_age = $3 ? 0 : -1;
					n->freeze_table_age = $3 ? 0 : -1;
					n->relation = $6;
					n->va_cols = NIL;
					$6->subpartitionname = $9;
					$$ = (Node *)n;
				}
			| VACUUM opt_full opt_freeze_empty opt_verbose_empty opt_compact AnalyzeStmt
				{
					VacuumStmt *n = (VacuumStmt *) $6;
					n->options |= VACOPT_VACUUM;
					if ($2)
						n->options |= VACOPT_FULL;
					if ($4)
						n->options |= VACOPT_VERBOSE;
					if ($5)
					{
						const char* message = "COMPACT can not be used with ANALYZE";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate, (errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("COMPACT can not be used with ANALYZE")));
					}
					n->freeze_min_age = $3 ? 0 : -1;
					n->freeze_table_age = $3 ? 0 : -1;
					$$ = (Node *)n;
				}
			| VACUUM '(' vacuum_option_list ')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | $3;
					if (n->options & VACOPT_FREEZE)
						n->freeze_min_age = n->freeze_table_age = 0;
					else
						n->freeze_min_age = n->freeze_table_age = -1;
					n->relation = NULL;
					n->va_cols = NIL;
					$$ = (Node *) n;
				}
			| VACUUM '(' vacuum_option_list ')' dolphin_qualified_name opt_name_list
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | $3;
					if (n->options & VACOPT_FREEZE)
						n->freeze_min_age = n->freeze_table_age = 0;
					else
						n->freeze_min_age = n->freeze_table_age = -1;
					n->relation = $5;
					n->va_cols = $6;
					if (n->va_cols != NIL)	/* implies analyze */
						n->options |= VACOPT_ANALYZE;
					$$ = (Node *) n;
				}
			| VACUUM '(' vacuum_option_list ')' dolphin_qualified_name opt_name_list PARTITION '('name')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | $3;
					if (n->options & VACOPT_FREEZE)
						n->freeze_min_age = n->freeze_table_age = 0;
					else
						n->freeze_min_age = n->freeze_table_age = -1;
					n->relation = $5;
					n->va_cols = $6;
					if (n->va_cols != NIL)	/* implies analyze */
						n->options |= VACOPT_ANALYZE;
					$5->partitionname = $9;
					$$ = (Node *) n;
				}
			| VACUUM '(' vacuum_option_list ')' dolphin_qualified_name opt_name_list SUBPARTITION '('name')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_VACUUM | $3;
					if (n->options & VACOPT_FREEZE)
						n->freeze_min_age = n->freeze_table_age = 0;
					else
						n->freeze_min_age = n->freeze_table_age = -1;
					n->relation = $5;
					n->va_cols = $6;
					if (n->va_cols != NIL)	/* implies analyze */
						n->options |= VACOPT_ANALYZE;
					$5->subpartitionname = $9;
					$$ = (Node *) n;
				}
		;

vacuum_option_list:
			vacuum_option_elem								{ $$ = $1; }
			| vacuum_option_list ',' vacuum_option_elem		{ $$ = $1 | $3; }
		;

vacuum_option_elem:
			analyze_keyword		{ $$ = VACOPT_ANALYZE; }
			| VERBOSE			{ $$ = VACOPT_VERBOSE; }
			| FREEZE			{ $$ = VACOPT_FREEZE; }
			| FULL				{ $$ = VACOPT_FULL; }
		;

AnalyzeStmt:
			analyze_keyword opt_verbose_with_brance
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_ANALYZE;
					if ($2)
						n->options |= VACOPT_VERBOSE;
					n->freeze_min_age = -1;
					n->freeze_table_age = -1;
					n->relation = NULL;
					n->va_cols = NIL;
					$$ = (Node *)n;
				}
			| analyze_keyword opt_verbose_with_brance dolphin_qualified_name opt_analyze_column_define
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_ANALYZE;
					if ($2)
						n->options |= VACOPT_VERBOSE;
					n->freeze_min_age = -1;
					n->freeze_table_age = -1;
					n->relation = $3;
					n->va_cols = $4;
					$$ = (Node *)n;
				}
			| analyze_keyword opt_verbose_with_brance dolphin_qualified_name opt_name_list PARTITION '('name')'
				{
					VacuumStmt *n = makeNode(VacuumStmt);
					n->options = VACOPT_ANALYZE;
					if ($2)
						n->options |= VACOPT_VERBOSE;
					n->freeze_min_age = -1;
					n->freeze_table_age = -1;
					n->relation = $3;
					n->va_cols = $4;
					$3->partitionname = $7;
					$$ = (Node *)n;
				}
			/*
			 * @hdfs Support command "analyze [verbose] foreign tables"
			 */
			| analyze_keyword opt_verbose_with_brance FOREIGN TABLES
				{
					VacuumStmt *n = (VacuumStmt*)makeNode(VacuumStmt);
					n->options = VACOPT_ANALYZE;
					if ($2)
						n->options |= VACOPT_VERBOSE;
					n->freeze_min_age = -1;
					n->freeze_table_age = -1;
					n->relation = NULL;
					n->va_cols = NIL;
					n->isForeignTables = TRUE;
					$$ = (Node *)n;

				}
			| analyze_keyword opt_verbose_with_brance opt_no_write_to_binlog TABLE qualified_name_list
				{
					SelectStmt *n = makeNode(SelectStmt);

					FuncCall *func = makeNode(FuncCall);
					func->funcname = SystemFuncName("analyze_tables");
					func->args = list_make1(makeAnalyzeTableList($5));

					RangeFunction *rangeFunc = makeNode(RangeFunction);
					rangeFunc->funccallnode = (Node*)func;

					ColumnRef *col = makeNode(ColumnRef);
					col->fields = list_make1(makeNode(A_Star));

					ResTarget *resTar = makeNode(ResTarget);
					resTar->val = (Node*)col;

					n->targetList = list_make1(resTar);
					n->fromClause = list_make1(rangeFunc);

					$$ = (Node*)n;
				}
		;

opt_no_write_to_binlog:
			NO_WRITE_TO_BINLOG
			| LOCAL
			| /* EMPTY */
		;

VerifyStmt:
            /* analyse verify fast|complete*/
            analyze_keyword opt_verify opt_verify_options
                {
                    VacuumStmt *n = makeNode(VacuumStmt);
                    n->options = VACOPT_VERIFY | $3;
                    $$ = (Node *)n;
                    n->isCascade = true;
                    n->curVerifyRel = InvalidOid;
                }

            /* analyse verify fast|complete index_name/table_name*/
            | analyze_keyword opt_verify opt_verify_options dolphin_qualified_name opt_cascade
                {
                    VacuumStmt *n = makeNode(VacuumStmt);
                    n->options = VACOPT_VERIFY | $3;
                    n->relation = $4;
                    if ($5) {
                        n->isCascade = $5;
                    }
                    n->curVerifyRel = InvalidOid;
                    $$ = (Node *)n;
                }

            /* analyse verify fast|complete table_name partition (partition_name) cascade*/
            | analyze_keyword opt_verify opt_verify_options dolphin_qualified_name PARTITION '('name')' opt_cascade
                {
                    VacuumStmt *n = makeNode(VacuumStmt);
                    n->options = VACOPT_VERIFY | $3;
                    n->relation = $4;
                    $4->partitionname = $7;
                    if ($9) {
                        n->isCascade = $9;
                    }
                    n->curVerifyRel = InvalidOid;
                    $$ = (Node *)n;
                }
        ;

analyze_keyword:
			ANALYZE									{}
		;

opt_verify_options:
        	FAST                                    { $$ = VACOPT_FAST;}
            | COMPLETE                               { $$ = VACOPT_COMPLETE;}
	    ;

opt_verbose:
			VERBOSE									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;
opt_verbose_empty:
			/*EMPTY*/								{ $$ = FALSE; }
		;
opt_verbose_with_brance:
			'(' VERBOSE ')'									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

opt_full:	FULL									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

opt_compact:	/*EMPTY*/								{ $$ = FALSE; }
		;

opt_hdfsdirectory:	HDFSDIRECTORY 					{ $$ = TRUE; }
		;

opt_freeze: FREEZE									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;
		
opt_freeze_empty:  /*EMPTY*/								{ $$ = FALSE; }
		;

opt_deltamerge: DELTAMERGE 							{$$ = TRUE;}
		;

opt_verify: 	VERIFY                                  { $$ = TRUE; }
	        ;

opt_cascade: 	CASCADE                                { $$ = TRUE; }
            	| /*EMPTY*/                            { $$ = FALSE; }
        	;
opt_name_list:
			'(' name_list ')'						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

opt_analyze_column_define:
			'(' opt_multi_name_list ')'
				{
					$$ = $2;
				}
			| '(' name_list ')'						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

opt_multi_name_list:
			'(' name_list ')'
				{
					$$ = list_make1($2);
				}
		;

/* PGXC_BEGIN */
BarrierStmt: CREATE BARRIER opt_barrier_id
				{
					BarrierStmt *n = makeNode(BarrierStmt);
					n->id = $3;
					$$ = (Node *)n;
				}
			;

opt_barrier_id:
				SCONST
				{
					$$ = pstrdup($1);
				}
			| /* EMPTY */
				{
					$$ = NULL;
				}
			;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		CREATE NODE nodename WITH
 *				(
 *					[ TYPE = ('datanode' | 'coordinator'), ]
 *					[ RW [ = boolean ], ]
 *					[ HOST = 'hostname', ]
 *					[ PORT = portnum, ]
 *					[ HOST1 = 'hostname', ]
 *					[ PORT1 = portnum, ]
 *					[ HOSTPRIMARY [ = boolean ], ]
 *					[ PRIMARY [ = boolean ], ]
 *					[ PREFERRED [ = boolean ] ]
 *					[ SCTP_PORT = portnum, ]
 *					[ CONTROL_PORT = portnum, ]
 *					[ SCTP_PORT1 = portnum, ]
 *					[ CONTROL_PORT1 = portnum, ]
 *				)
 *
 *****************************************************************************/

CreateNodeStmt: CREATE NODE pgxcnode_name OptWith
				{
					CreateNodeStmt *n = makeNode(CreateNodeStmt);
					n->node_name = $3;
					n->options = $4;
					$$ = (Node *)n;
				}
		;

pgxcnode_name:
			ColId							{ $$ = $1; };

pgxcgroup_name:
			ColId							{ $$ = $1; };

pgxcnodes:
			'(' pgxcnode_list ')'			{ $$ = $2; }
		;

pgxcnode_list:
			pgxcnode_list ',' pgxcnode_name		{ $$ = lappend($1, makeString($3)); }
			| pgxcnode_name						{ $$ = list_make1(makeString($1)); }
		;

bucket_list:
			bucket_list ',' Iconst		{ $$ = lappend($1, makeInteger($3)); }
			| Iconst					{ $$ = list_make1(makeInteger($1)); }
		;

bucket_cnt:
			BUCKETCNT Iconst			{ $$ = $2; }
			| /*EMPTY*/ 				{ $$ = -1; }
		;

pgxcgroup_parent:
			GROUPPARENT pgxcnode_name      		{ $$ = $2; }
			| /*EMPTY*/ 				{ $$ = NULL;}
		;

opt_vcgroup: 
            		VCGROUP			{$$ = TRUE;}
			| /* EMPTY */		{$$ = FALSE;}
		;

opt_to_elastic_group: 
            TO ELASTIC GROUP_P	{$$ = TRUE;}
			| /* EMPTY */		{$$ = FALSE;}
		;

opt_redistributed: 
			DISTRIBUTE FROM  ColId  {$$ = $3;}
			| /* EMPTY */      	{$$ = NULL;}
		;

opt_set_vcgroup: 
            		SET VCGROUP		{$$ = AG_SET_VCGROUP;}
            		| SET NOT VCGROUP	{$$ = AG_SET_NOT_VCGROUP;}
			| /* EMPTY */		{$$ = AG_SET_RENAME;}
		;

/*****************************************************************************
 *
 *		QUERY:
 *		ALTER NODE nodename WITH
 *				(
 *					[ TYPE = ('datanode' | 'coordinator'), ]
 *					[ HOST = 'hostname', ]
 *					[ RW [ = boolean ], ]
 *					[ PORT = portnum, ]
 *					[ HOST1 = 'hostname', ]
 *					[ PORT1 = portnum, ]
 *					[ HOSTPRIMARY [ = boolean ], ]
 *					[ PRIMARY [ = boolean ], ]
 *					[ PREFERRED [ = boolean ] ]
 *					[ SCTP_PORT = portnum, ]
 *					[ CONTROL_PORT = portnum, ]
 *					[ SCTP_PORT1 = portnum, ]
 *					[ CONTROL_PORT1 = portnum, ]
 *				)
 *
 *****************************************************************************/

AlterNodeStmt: ALTER NODE pgxcnode_name OptWith
				{
					AlterNodeStmt *n = makeNode(AlterNodeStmt);
					n->node_name = $3;
					n->options = $4;
					$$ = (Node *)n;
				}
		;
/* alter node coordinator set true/false with (cn1,...,cnN) */
AlterCoordinatorStmt: ALTER COORDINATOR pgxcnode_name SET opt_boolean_or_string WITH pgxcnodes
				{
					AlterCoordinatorStmt *n = makeNode(AlterCoordinatorStmt);
					n->node_name = $3;
					n->set_value = $5;
					n->coor_nodes = $7;
					$$ = (Node *)n;	
				}
		;
	

/*****************************************************************************
 *
 *		QUERY:
 *				DROP NODE [IF EXISTS] nodename [WITH (cn1,...,cnN)]
 *
 *****************************************************************************/

DropNodeStmt: DROP NODE pgxcnode_name opt_pgxcnodes
				{
					DropNodeStmt *n = makeNode(DropNodeStmt);
					n->node_name = $3;
					n->missing_ok = FALSE;
					n->remote_nodes = $4;
					$$ = (Node *)n;
				}
			| DROP NODE IF_P EXISTS pgxcnode_name opt_pgxcnodes
				{
					DropNodeStmt *n = makeNode(DropNodeStmt);
					n->node_name = $5;
					n->missing_ok = TRUE;
					n->remote_nodes = $6;
					$$ = (Node *)n;
				}
		;

opt_pgxcnodes:	WITH pgxcnodes
				{
					$$ = $2;
				}
				| /*EMPTY*/
				{
					$$ = NIL;
				}
		;
/*****************************************************************************
 *
 *		QUERY:
 *				ALTER NODE GROUP groupname SET DEFAULT
 *
 *****************************************************************************/

AlterNodeGroupStmt: ALTER NODE GROUP_P pgxcgroup_name SET DEFAULT
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->alter_type = AG_SET_DEFAULT;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name opt_set_vcgroup RENAME TO pgxcgroup_name
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = $8;
					n->alter_type = (AlterGroupType)$5;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name SET NOT VCGROUP
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = NULL;
					n->alter_type = AG_SET_NOT_VCGROUP;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name SET TABLE GROUP_P pgxcgroup_name
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = $8;
					n->alter_type = AG_SET_TABLE_GROUP;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name ADD_P NODE pgxcnodes
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = NULL;
					n->alter_type = AG_ADD_NODES;
					n->nodes = $7;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name DELETE_P NODE pgxcnodes
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = NULL;
					n->alter_type = AG_DELETE_NODES;
					n->nodes = $7;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name RESIZE TO pgxcgroup_name
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = $7;
					n->alter_type = AG_RESIZE_GROUP;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name opt_set_vcgroup WITH GROUP_P pgxcgroup_name
				{
					AlterGroupStmt *n = makeNode(AlterGroupStmt);
					n->group_name = $4;
					n->install_name = $8;
					n->alter_type = AG_CONVERT_VCGROUP;
					$$ = (Node *)n;
				}
				| ALTER NODE GROUP_P pgxcgroup_name SET SEQUENCE TO ALL NODE
                                {
                                	AlterGroupStmt *n = makeNode(AlterGroupStmt);
                                        n->group_name = $4;
                                        n->install_name = NULL;
                                        n->alter_type = AG_SET_SEQ_ALLNODES;
                                        $$ = (Node *)n;
                                }
                                | ALTER NODE GROUP_P pgxcgroup_name SET SEQUENCE TO LOCAL
                                {
                                        AlterGroupStmt *n = makeNode(AlterGroupStmt);
                                        n->group_name = $4;
                                        n->install_name = NULL;
                                        n->alter_type = AG_SET_SEQ_SELFNODES;
                                        $$ = (Node *)n;
                                }
		;

/*****************************************************************************
 *
 *		QUERY:
 *				DROP NODE GROUP groupname
 *
 *****************************************************************************/

DropNodeGroupStmt: DROP NODE GROUP_P pgxcgroup_name opt_redistributed opt_to_elastic_group
				{
					DropGroupStmt *n = makeNode(DropGroupStmt);
					n->group_name = $4;
					n->src_group_name = $5;
					n->to_elastic_group = $6;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
/*****************************************************************************
 *
 *     QUERY:
 *
 *     CREATE AUDIT POLICY policy_name
 *
 *****************************************************************************/
CreateAuditPolicyStmt:
        CREATE AUDIT POLICY policy_name PRIVILEGES policy_privileges_list policy_filter_opt policy_status_opt
                {
                    CreateAuditPolicyStmt *n = makeNode(CreateAuditPolicyStmt);
                    n->policy_type = "privileges";
                    n->if_not_exists = false;
                    IsValidIdent($4);
                    n->policy_name = $4;
                    n->policy_targets = $6;
                    n->policy_filters = $7;
                    n->policy_enabled = $8;
                    $$ = (Node *) n;
                }
        | CREATE AUDIT POLICY IF_P NOT EXISTS policy_name PRIVILEGES policy_privileges_list policy_filter_opt policy_status_opt
                {
                    CreateAuditPolicyStmt *n = makeNode(CreateAuditPolicyStmt);
                    n->policy_type = "privileges";
                    n->if_not_exists = true;
                    IsValidIdent($7);
                    n->policy_name = $7;
                    n->policy_targets = $9;
                    n->policy_filters = $10;
                    n->policy_enabled = $11;
                    $$ = (Node *) n;
                }
        | CREATE AUDIT POLICY policy_name ACCESS policy_access_list policy_filter_opt policy_status_opt
                {
                    CreateAuditPolicyStmt *n = makeNode(CreateAuditPolicyStmt);
                    n->policy_type = "access";
                    n->if_not_exists = false;
                    IsValidIdent($4);
                    n->policy_name = $4;
                    n->policy_targets = $6;
                    n->policy_filters = $7;
                    n->policy_enabled = $8;
                    $$ = (Node *) n;
                }
        | CREATE AUDIT POLICY IF_P NOT EXISTS policy_name ACCESS policy_access_list policy_filter_opt policy_status_opt
                {
                    CreateAuditPolicyStmt *n = makeNode(CreateAuditPolicyStmt);
                    n->policy_type = "access";
                    n->if_not_exists = true;
                    IsValidIdent($7);
                    n->policy_name = $7;
                    n->policy_targets = $9;
                    n->policy_filters = $10;
                    n->policy_enabled = $11;
                    $$ = (Node *) n;
                }
        ;

policy_privileges_list:
        policy_privilege_elem
            {
                $$ = list_make1($1);
            }
        | policy_privileges_list ',' policy_privilege_elem
            {
                $$ = lappend($1, $3);
            }
        ;

policy_privilege_elem:
        policy_privilege_type policy_target_elem_opt
            {
                $$ = makeDefElem($1, (Node *)$2);
            }
        ;

policy_privilege_type:
        ALL             { $$ = "all"; }
        | ALTER         { $$ = "alter"; }
        | ANALYZE       { $$ = "analyze"; }
        | COMMENT       { $$ = "comment"; }
        | CREATE        { $$ = "create"; }
        | DROP          { $$ = "drop"; }
        | GRANT         { $$ = "grant"; }
        | REVOKE        { $$ = "revoke"; }
        | SET           { $$ = "set"; }
        | SHOW          { $$ = "show"; }
        | LOGIN_ANY     { $$ = "login_any"; }
        | LOGIN_FAILURE { $$ = "login_failure"; }
        | LOGIN_SUCCESS { $$ = "login_success"; }
        | LOGOUT        { $$ = "logout"; }
        ;

policy_access_list:
        policy_access_elem
            {
                $$ = list_make1($1);
            }
        | policy_access_list ',' policy_access_elem
            {
                $$ = lappend($1, $3);
            }
        ;

policy_access_elem:
        policy_access_type policy_target_elem_opt
            {
                $$ = makeDefElem($1, (Node *)$2);
            }
        ;

// Commented out will be supported in future releases / upon client request
policy_access_type:
        ALL             { $$ = "all"; }
        | COPY          { $$ = "copy"; }
        | DEALLOCATE    { $$ = "deallocate"; }
        | DELETE_P      { $$ = "delete"; }
        | EXECUTE       { $$ = "execute"; }
        | INSERT        { $$ = "insert"; }
        | PREPARE       { $$ = "prepare"; }
        | REINDEX       { $$ = "reindex"; }
        | SELECT        { $$ = "select"; }
        | TRUNCATE      { $$ = "truncate"; }
        | UPDATE        { $$ = "update"; }
        ;

policy_target_elem_opt:
        ON policy_target_type '(' policy_targets_list ')'
            {
                $$ = makeDefElem($2, (Node *)$4);
            }
        | /* EMPTY */ { $$ = NULL; }
		;

policy_targets_list:
        policy_target_name
            {
                $$ = list_make1($1);
            }
        | policy_targets_list ',' policy_target_name
            {
                $$ = lappend($1, $3);
            }
        ;
policy_target_type:
        LABEL         { $$ = "label"; }
        ;

policy_target_name:
        qualified_name     { $$ = $1; }
        ;

policy_filter_opt:
         FILTER ON policy_filter_value
            {
                $$ = list_make1((Node *)$3);
            }
        | /* EMPTY */ { $$ = NULL; }
        ;

policy_filter_value:
        filter_expr     { $$ = $1; }
        | filter_set    { $$ = $1; }
        ; 

filter_set:
        filter_paren                { $$ = $1; }
        | '(' filter_expr_list ')'  { $$ = $2; }
        | filter_expr_list          { $$ = $1; }
        ;

filter_expr_list: 
        filter_expr ',' filter_expr
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "op";
                n->op_value = "and";
                n->left = $1;
                n->right = $3;
                $$ = (Node *) n;
            }
        | filter_expr_list ',' filter_expr
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "op";
                n->op_value = "and";
                n->left = $1;
                n->right = $3;
                $$ = (Node *) n;
            }
        ;

filter_paren:
        '(' filter_expr ')' { $$ = $2; }
        ;

policy_filters_list:
        policy_filter_name
            {
                $$ = list_make1(makeString($1));
            }
        | policy_filters_list ',' policy_filter_name
            {
                $$ = lappend($1, makeString($3));
            }
        ;

policy_filter_type:
          IP            { $$ = "ip"; }
        | APP           { $$ = "app"; }
        | ROLES         { $$ = "roles"; }
        ;

policy_filter_name:
        ColId_or_Sconst { $$ = $1; }
        ;

policy_name:
        ColLabel        { $$ = $1; }
        ;

policy_status_opt:
        ENABLE_P        {$$ = TRUE;}
        | DISABLE_P     {$$ = FALSE;}
        | /* EMPTY */   {$$ = TRUE;}
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     ALTER AUDIT POLICY policy_name
 *
 *****************************************************************************/
AlterAuditPolicyStmt:
        /* alter comments */
        ALTER AUDIT POLICY policy_name policy_comments_alter_clause
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->policy_name = $4;
                    n->policy_action = "add";
                    n->policy_comments = $5;
                    $$ = (Node *) n;
                }
        |        
        ALTER AUDIT POLICY IF_P EXISTS policy_name policy_comments_alter_clause
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_name = $6;
                    n->policy_action = "add";
                    n->policy_comments = $7;
                    $$ = (Node *) n;
                }
        |        
        /* alter add/remove privilege */
        ALTER AUDIT POLICY policy_name alter_policy_action_clause alter_policy_privileges_list
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->policy_type = "privileges";
                    n->policy_name = $4;
                    n->policy_action = $5;
                    n->policy_items = $6;
                    $$ = (Node *) n;
                }
        |
        ALTER AUDIT POLICY IF_P EXISTS policy_name alter_policy_action_clause alter_policy_privileges_list
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_type = "privileges";
                    n->policy_name = $6;
                    n->policy_action = $7;
                    n->policy_items = $8;
                    $$ = (Node *) n;
                }
        |
        /* alter add/remove access */
        ALTER AUDIT POLICY policy_name alter_policy_action_clause alter_policy_access_list
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->policy_type = "access";
                    n->policy_name = $4;
                    n->policy_action = $5;
                    n->policy_items = $6;
                    $$ = (Node *) n;
                }
        |
        ALTER AUDIT POLICY IF_P EXISTS policy_name alter_policy_action_clause alter_policy_access_list
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_type = "access";
                    n->policy_name = $6;
                    n->policy_action = $7;
                    n->policy_items = $8;
                    $$ = (Node *) n;
                }
        |
        /* alter modify filter */
        ALTER AUDIT POLICY policy_name MODIFY_P '(' alter_policy_filter_list ')'
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->policy_name = $4;
                    n->policy_action = "modify";
                    n->policy_filters = $7;
                    $$ = (Node *) n;
                }
        |
        ALTER AUDIT POLICY IF_P EXISTS policy_name MODIFY_P '(' alter_policy_filter_list ')'
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_name = $6;
                    n->policy_action = "modify";
                    n->policy_filters = $9;
                    $$ = (Node *) n;
                }
        |
        /* alter remove filter */
        ALTER AUDIT POLICY policy_name DROP FILTER
            {
                AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "drop_filter";
                $$ = (Node *) n;
            }

        |
        ALTER AUDIT POLICY IF_P EXISTS policy_name DROP FILTER
            {
                AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                n->missing_ok = true;
                n->policy_name = $6;
                n->policy_action = "drop_filter";
                $$ = (Node *) n;
            }

        |
        /* alter policy status */
        ALTER AUDIT POLICY policy_name policy_status_alter_clause
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->policy_name = $4;
                    n->policy_action = "add";
                    n->policy_comments = "";
                    n->policy_enabled = (Node *)$5;
                    $$ = (Node *) n;
                }
        |
        ALTER AUDIT POLICY IF_P EXISTS policy_name policy_status_alter_clause
                {
                    AlterAuditPolicyStmt *n = makeNode(AlterAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_name = $6;
                    n->policy_action = "add";
                    n->policy_comments = "";
                    n->policy_enabled = (Node *)$7;
                    $$ = (Node *) n;
                }

        ;


alter_policy_access_list:
        ACCESS '(' policy_access_list ')' {$$ = $3;}
        ;

alter_policy_privileges_list:
        PRIVILEGES '(' policy_privileges_list ')' {$$ = $3;}
        ;
        
alter_policy_filter_list:
        FILTER ON policy_filter_value
        {
            $$ = list_make1((Node *)$3);
        }
        ;

alter_policy_action_clause:
        ADD_P   { $$ = "add";  }
        | REMOVE  { $$ = "remove"; } 
        ;

policy_status_alter_clause:
        ENABLE_P        { $$ = makeDefElem("status", (Node *)makeString("enable")); } 
        | DISABLE_P     { $$ = makeDefElem("status", (Node *)makeString("disable")); }
        ;

policy_comments_alter_clause:
        COMMENTS SCONST   { $$ = $2; }
        ;
    
    

/*****************************************************************************
 *
 *     QUERY:
 *
 *     DROP AUDIT POLICY policy_name
 *
 *****************************************************************************/
DropAuditPolicyStmt:
        DROP AUDIT POLICY policy_names_list
                {
                    DropAuditPolicyStmt *n = makeNode(DropAuditPolicyStmt);
                    n->policy_names = $4;
                    $$ = (Node *) n;
                }
        | DROP AUDIT POLICY IF_P EXISTS policy_names_list
                {
                    DropAuditPolicyStmt *n = makeNode(DropAuditPolicyStmt);
                    n->missing_ok = true;
                    n->policy_names = $6;
                    $$ = (Node *) n;
                }
        ;
policy_names_list:
        policy_name { $$ = list_make1(makeString($1)); }
        | policy_names_list ',' policy_name { $$ = lappend($1, makeString($3)); }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     CREATE MASKING POLICY policy_name
 *
 *****************************************************************************/
CreateMaskingPolicyStmt:
        CREATE MASKING POLICY policy_name masking_clause policy_condition_opt policy_filter_opt policy_status_opt
                {
                    CreateMaskingPolicyStmt *n = makeNode(CreateMaskingPolicyStmt);
                    n->if_not_exists = false;
                    IsValidIdent($4);
                    n->policy_name = $4;
                    n->policy_data = $5;
                    n->policy_condition = $6;
                    n->policy_filters = $7;
                    n->policy_enabled = $8;
                    $$ = (Node *) n;
                }
        ;

masking_clause:
        masking_clause_elem 
            {
                $$ = list_make1($1);
            }
        | masking_clause ',' masking_clause_elem
            {
                $$ = lappend($1, $3);
            }
        ;

masking_clause_elem:
        /*FUNCTION*/ masking_func masking_func_params_opt ON masking_target
            {
                $$ = makeDefElem($1, (Node *)lappend(list_make1($2) , $4));
            }
        | masking_func_nsp '.' masking_func masking_func_params_opt ON masking_target
            {
                $$ = makeDefElemExtended($1, $3, (Node *)lappend(list_make1($4) , $6), DEFELEM_UNSPEC);
            }
        ;

masking_func_nsp:
        ColLabel        { IsValidIdent($1); $$ = $1; }
        ;

masking_func:
        ColLabel        { IsValidIdent($1); $$ = $1; }
        ;

masking_func_params_opt:
        '(' masking_func_params_list ')'    { $$ = $2; }
        | /* EMPTY */                       { $$ = list_make1(NIL); }
        ;

masking_func_params_list:
        masking_func_param
            { 
                 $$ = list_make1($1);
            }
        | masking_func_params_list ',' masking_func_param
            { 
                $$ = lappend($1, $3);
            }
        ;

masking_func_param:
        Iconst
            {
                char buf[64];
                snprintf(buf, sizeof(buf), "%d", $1);
                $$ = makeDefElem("i"/*int*/, (Node *)makeString(pstrdup(buf)));
            }
        | FCONST         { $$ = makeDefElem("f" /*float*/, (Node *)makeString($1)); }
        | SCONST         { $$ = makeDefElem("s" /*string*/, (Node *)makeString($1)); }
        | ColLabel       { $$ = makeDefElem("q" /*fqdn*/, (Node *)makeString($1)); }
        ;

masking_target:
        masking_policy_target_type '(' policy_targets_list ')'
            {
                $$ = makeDefElem($1, (Node *)$3);
            }
        ;

masking_policy_target_type:
        LABEL         { $$ = "label"; }
        ;

alter_policy_condition:

		    CONDITION '(' policy_label_item masking_policy_condition_operator masking_policy_condition_value ')'
            {
                MaskingPolicyCondition *n = makeNode(MaskingPolicyCondition);
                n->fqdn = $3;
                n->_operator = $4;
                n->arg = $5;
                $$ = (Node *) n;
            }
        ;

policy_condition_opt:
	
		    CONDITION '(' policy_label_item masking_policy_condition_operator masking_policy_condition_value ')'
            {
                MaskingPolicyCondition *n = makeNode(MaskingPolicyCondition);
                n->fqdn = $3;
                n->_operator = $4;
                n->arg = $5;
                $$ = (Node *) n;
            }
			;
	
        | /* EMPTY */
        {
            $$ = NULL;
        }
        ;

masking_policy_condition_operator:
    CmpOp       { $$ = $1; }
    | '<'       { $$ = "<"; }
    | '>'       { $$ = ">"; }
    | '='       { $$ = "="; }
    | '@'       { $$ = "@"; }
    ;

masking_policy_condition_value:
		opt_boolean_or_string
			{ 
				$$ = makeStringConst($1, @1);
			}
		| NumericOnly
			{ 
				$$ = makeAConst($1, @1);
			}
		| CURRENT_USER
			{
				$$ = makeStringConst("current_user", @1);
			}
		;

pp_filter_expr:
        filter_expr         { $$ = $1; }
        | filter_paren      { $$ = $1; }
        ;

filter_expr:
        filter_term
            {
                $$ = $1;
            }
        | pp_filter_expr OR pp_filter_term
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "op";
                n->op_value = "or";
                n->left = $1;
                n->right = $3;
                $$ = (Node *) n;
            }
        ;

pp_filter_term:
        filter_term         { $$ = $1; }
        | filter_paren      { $$ = $1; }
        ;

filter_term:
        policy_filter_elem
            {
                $$ = $1;
            }
        | pp_filter_term AND pp_policy_filter_elem
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "op";
                n->op_value = "and";
                n->left = $1;
                n->right = $3;
                $$ = (Node *) n;
            }
        ;

pp_policy_filter_elem:
        policy_filter_elem  { $$ = $1; }
        | filter_paren      { $$ = $1; }
        ;

policy_filter_elem:
        policy_filter_type '(' policy_filters_list ')'
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "filter";
                n->filter_type = $1;
                n->values = $3;
                n->has_not_operator = false;
                $$ = (Node *) n;
            }
        | policy_filter_type NOT '(' policy_filters_list ')'
            {
                PolicyFilterNode *n = makeNode(PolicyFilterNode);
                n->node_type = "filter";
                n->filter_type = $1;
                n->values = $4;
                n->has_not_operator = true;
                $$ = (Node *) n;
            }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     ALTER MASKING POLICY policy_name
 *
 *****************************************************************************/
AlterMaskingPolicyStmt:
		/* alter comments*/
 ALTER MASKING POLICY policy_name policy_comments_alter_clause
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "add";
                n->policy_comments = $5;
                $$ = (Node *) n;
            }
		|
		
        /* alter modify/add/remove policy actions */
        ALTER MASKING POLICY policy_name alter_masking_policy_action_clause alter_masking_policy_func_items_list
        {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = $5;
                n->policy_items = $6;
                $$ = (Node *) n;
            }
		|

        /* alter modify filter */
        ALTER MASKING POLICY policy_name MODIFY_P '(' alter_policy_filter_list ')'
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "modify";
                n->policy_filters = $7;
                $$ = (Node *) n;
            }
        |
        /* alter remove filter */
        ALTER MASKING POLICY policy_name DROP FILTER
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "drop_filter";
                $$ = (Node *) n;
            }
        |
        /* alter modify condition */
        ALTER MASKING POLICY policy_name MODIFY_P '(' alter_policy_condition ')'
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "modify";
                n->policy_condition = $7;
                $$ = (Node *) n;
            }
        |
        /* alter remove condition */
        ALTER MASKING POLICY policy_name DROP CONDITION
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "drop_condition";
                $$ = (Node *) n;
            }
        |

        /* alter policy status */
        ALTER MASKING POLICY policy_name policy_status_alter_clause
            {
                AlterMaskingPolicyStmt *n = makeNode(AlterMaskingPolicyStmt);
                n->policy_name = $4;
                n->policy_action = "add";
                n->policy_comments = "";
                n->policy_enabled = (Node *)$5;
                $$ = (Node *) n;
            }
        ;

alter_masking_policy_action_clause:
        MODIFY_P { $$ = "modify"; }   /* Modifying is supported only by masking policy */
        | alter_policy_action_clause { $$ = $1; }
        ;

alter_masking_policy_func_items_list:
        alter_masking_policy_func_item { $$ =  list_make1($1); }
        | alter_masking_policy_func_items_list ',' alter_masking_policy_func_item { $$ = lappend($1, $3); }
        ;

alter_masking_policy_func_item:
         masking_clause_elem 
        	{
                $$ = $1;
            }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     DROP MASKING POLICY policy_name 
 *
 *****************************************************************************/
DropMaskingPolicyStmt:
        DROP MASKING POLICY policy_names_list
                {
                    DropMaskingPolicyStmt *n = makeNode(DropMaskingPolicyStmt);
                    n->if_exists = false;
                    n->policy_names = $4;
                    $$ = (Node *) n;
                }
        |   DROP MASKING POLICY IF_P EXISTS policy_names_list
            {
                DropMaskingPolicyStmt *n = makeNode(DropMaskingPolicyStmt);
                n->if_exists = true;
                n->policy_names = $6;
                $$ = (Node *) n;
            }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     CREATE RESOURCE LABEL label_name 
 *
 *****************************************************************************/
CreatePolicyLabelStmt:
        CREATE RESOURCE LABEL policy_label_name opt_add_resources_to_label
                {
                    CreatePolicyLabelStmt *n = makeNode(CreatePolicyLabelStmt);
                    n->label_type = "resource";
                    n->if_not_exists = false; 
                    IsValidIdent($4);
                    n->label_name = $4;
                    n->label_items = $5;
                    $$ = (Node *)n;
                }
        | CREATE RESOURCE LABEL IF_P NOT EXISTS policy_label_name opt_add_resources_to_label
                {
                    CreatePolicyLabelStmt *n = makeNode(CreatePolicyLabelStmt);
                    n->label_type = "resource";
                    n->if_not_exists = true;
                    IsValidIdent($7);
                    n->label_name = $7;
                    n->label_items = $8;
                    $$ = (Node *)n;
                }
        ;

policy_label_name:
        ColLabel        { $$ = $1; }
        ;

opt_add_resources_to_label:
        ADD_P resources_to_label_list { $$ = $2; }
        | /* EMPTY */ { $$ = NULL; }
        ;

resources_to_label_list:
        resources_to_label_list_item { $$ =  list_make1($1); }
        | resources_to_label_list ',' resources_to_label_list_item { $$ = lappend($1, $3); }
        ;

resources_to_label_list_item:
        policy_label_resource_type  '(' policy_label_items ')' { $$ = makeDefElem($1, (Node *)$3); }
        | policy_label_resource_type '(' policy_label_any_resource_item ')' { $$ = makeDefElem($1,  (Node *)list_make1($3)); }
        ;

policy_label_resource_type:
                TABLE     { $$ = "table"; }
                | COLUMN    { $$ = "column"; }
                | SCHEMA    { $$ = "schema"; }
                | VIEW      { $$ = "view"; }
                | FUNCTION  { $$ = "function"; }
        ;

policy_label_any_resource_item:
        policy_label_any_resource { $$ = makeRangeVar(NULL, $1, @1); }
        ;

policy_label_any_resource:
        ALL { $$ = "all"; }
        ;

policy_label_items:
        policy_label_item { $$ = list_make1($1); }
        | policy_label_items ',' policy_label_item { $$ =  lappend($1, $3); }
        ;

filters_to_label_list:
        filters_to_label_list_item { $$ =  list_make1($1); }
        | filters_to_label_list ',' filters_to_label_list_item { $$ = lappend($1, $3); }
        ;

filters_to_label_list_item:
        policy_label_filter_type  '(' policy_label_items ')' { $$ = makeDefElem($1, (Node *)$3); }
        ;

policy_label_filter_type: 
          IP            { $$ = "ip"; }
        | APP           { $$ = "app"; }
        | ROLES         { $$ = "roles"; }
        ;

policy_label_item:
        qualified_name     { $$ = $1; }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     ALTER RESOURCE LABEL label_name
 *
 *****************************************************************************/
AlterPolicyLabelStmt:
        ALTER RESOURCE LABEL policy_label_name ADD_P resources_or_filters_to_label_list
                {
                    AlterPolicyLabelStmt *n = makeNode(AlterPolicyLabelStmt);
                    n->stmt_type = "add";
                    n->label_name = $4;
                    n->label_items = $6;
                    $$ = (Node *)n;
                }
        | ALTER RESOURCE LABEL policy_label_name REMOVE resources_or_filters_to_label_list
                {
                    AlterPolicyLabelStmt *n = makeNode(AlterPolicyLabelStmt);
                    n->stmt_type = "remove";
                    n->label_name = $4;
                    n->label_items = $6;
                    $$ = (Node *)n;
                }
        ;

resources_or_filters_to_label_list:
        resources_to_label_list  { $$ = $1; }
        | filters_to_label_list  { $$ = $1; }
        ;

/*****************************************************************************
 *
 *     QUERY:
 *
 *     DROP RESOURCE LABEL label_name
 *
 *****************************************************************************/
DropPolicyLabelStmt:
        DROP RESOURCE LABEL policy_labels_list
            {
                    DropPolicyLabelStmt *n = makeNode(DropPolicyLabelStmt);
                    n->if_exists = false;
                    n->label_names = $4;
                    $$ = (Node *) n;
            }
        | DROP RESOURCE LABEL IF_P EXISTS policy_labels_list
            {
                DropPolicyLabelStmt *n = makeNode(DropPolicyLabelStmt);
                n->if_exists = true;
                n->label_names = $6;
                $$ = (Node *) n;
            }
        ;

policy_labels_list:
        policy_label_name { $$ = list_make1(makeString($1)); }
        | policy_labels_list ',' policy_label_name { $$ =  lappend($1, makeString($3)); }
        ;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		CREATE RESOURCE POOL pool_name WITH
 *				(
 *					[ MEM_PERCENT = mem_percent, ]
 *					[ CPU_AFFINITY = cpu_affinity, ]
 *				)
 *
 *****************************************************************************/

CreateResourcePoolStmt: CREATE RESOURCE POOL resource_pool_name OptWith
				{
					CreateResourcePoolStmt *n = makeNode(CreateResourcePoolStmt);
					n->pool_name = $4;
					n->options = $5;
					$$ = (Node *)n;
				}
		;


 /*****************************************************************************
 *
 *		QUERY:
 *
 *		ALTER RESOURCE POOL pool_name WITH
 *				(
 *					[ MEM_PERCENT = mem_percent, ]
 *					[ CPU_AFFINITY = cpu_affinity, ]
 *				)
 *
 *****************************************************************************/

AlterResourcePoolStmt: ALTER RESOURCE POOL resource_pool_name OptWith
				{
					AlterResourcePoolStmt *n = makeNode(AlterResourcePoolStmt);
					n->pool_name = $4;
					n->options = $5;
					$$ = (Node *)n;
				}
		;

AlterGlobalConfigStmt: ALTER GLOBAL CONFIGURATION OptWith
				{
					AlterGlobalConfigStmt *n = makeNode(AlterGlobalConfigStmt);
					n->options = $4;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *				DROP RESOURCE POOL [IF EXISTS] pool_name
 *
 *****************************************************************************/

DropResourcePoolStmt: DROP RESOURCE POOL resource_pool_name
				{
					DropResourcePoolStmt *n = makeNode(DropResourcePoolStmt);
					n->missing_ok = false;
					n->pool_name = $4;
					$$ = (Node *)n;
				}
			| DROP RESOURCE POOL IF_P EXISTS resource_pool_name
				{
					DropResourcePoolStmt *n = makeNode(DropResourcePoolStmt);
					n->missing_ok = true;
					n->pool_name = $6;
					$$ = (Node *)n;
				}
		;

resource_pool_name:
			ColId							{ $$ = $1; };

DropGlobalConfigStmt: DROP GLOBAL CONFIGURATION name_list
				{
					DropGlobalConfigStmt *n = makeNode(DropGlobalConfigStmt);
					n->options = $4;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		CREATE WORKLOAD GROUP group_name USING RESOURCE POOL pool_name WITH
 *				(
 *					[ ACT_STATEMENTS  = act_statements, ]
 *				)
 *
 *****************************************************************************/

CreateWorkloadGroupStmt: CREATE WORKLOAD GROUP_P workload_group_name USING RESOURCE POOL resource_pool_name OptWith
				{
					CreateWorkloadGroupStmt *n = makeNode(CreateWorkloadGroupStmt);
					n->group_name = $4;
					n->pool_name = $8;
					n->options = $9;
					$$ = (Node *)n;
				}
			| CREATE WORKLOAD GROUP_P workload_group_name OptWith
				{
					CreateWorkloadGroupStmt *n = makeNode(CreateWorkloadGroupStmt);
					n->group_name = $4;
					n->pool_name = NULL;
					n->options = $5;
					$$ = (Node *)n;
				}
		;

 /*****************************************************************************
 *
 *		QUERY:
 *
 *		ALTER WORKLOAD GROUP group_name [USING RESOURCE POOL pool_name] WITH
 *				(
 *					[ ACT_STATEMENTS  = act_statements, ]
 *				)
 *
 *****************************************************************************/

AlterWorkloadGroupStmt: ALTER WORKLOAD GROUP_P workload_group_name USING RESOURCE POOL resource_pool_name OptWith
				{
					AlterWorkloadGroupStmt *n = makeNode(AlterWorkloadGroupStmt);
					n->group_name = $4;
					n->pool_name = $8;
					n->options = $9;
					$$ = (Node *)n;
				}
 			| ALTER WORKLOAD GROUP_P workload_group_name OptWith
 				{
 					AlterWorkloadGroupStmt *n = makeNode(AlterWorkloadGroupStmt);
					n->group_name = $4;
					n->pool_name = NULL;
					n->options = $5;
					$$ = (Node *)n;
 				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *				DROP WORKLOAD GROUP [IF EXISTS] group_name
 *
 *****************************************************************************/

DropWorkloadGroupStmt: DROP WORKLOAD GROUP_P workload_group_name
				{
					DropWorkloadGroupStmt *n = makeNode(DropWorkloadGroupStmt);
					n->missing_ok = false;
					n->group_name = $4;
					$$ = (Node *)n;
				}
			| DROP WORKLOAD GROUP_P IF_P EXISTS workload_group_name
				{
					DropWorkloadGroupStmt *n = makeNode(DropWorkloadGroupStmt);
					n->missing_ok = true;
					n->group_name = $6;
					$$ = (Node *)n;
				}
		;

workload_group_name:
			ColId							{ $$ = $1; };


/*****************************************************************************
 *
 *		QUERY:
 *
 *		CREATE APP WORKLOAD GROUP MAPPING app_name WITH
 *				(
 *					[ WORKLOAD_GPNAME  = workload_gpname, ]
 *				)
 *
 *****************************************************************************/

CreateAppWorkloadGroupMappingStmt: CREATE APP WORKLOAD GROUP_P MAPPING application_name OptWith
				{
					CreateAppWorkloadGroupMappingStmt *n = makeNode(CreateAppWorkloadGroupMappingStmt);
					n->app_name = $6;
					n->options = $7;
					$$ = (Node *)n;
				}
		;

 /*****************************************************************************
 *
 *		QUERY:
 *
 *		ALTER APP WORKLOAD GROUP MAPPING app_name WITH
 *				(
 *					[ WORKLOAD_GPNAME  = workload_gpname, ]
 *				)
 *
 *****************************************************************************/

AlterAppWorkloadGroupMappingStmt: ALTER APP WORKLOAD GROUP_P MAPPING application_name OptWith
				{
					AlterAppWorkloadGroupMappingStmt *n = makeNode(AlterAppWorkloadGroupMappingStmt);
					n->app_name = $6;
					n->options = $7;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *		QUERY:
 *				DROP APP WORKLOAD GROUP MAPPING [IF EXISTS] app_name
 *
 *****************************************************************************/

DropAppWorkloadGroupMappingStmt: DROP APP WORKLOAD GROUP_P MAPPING application_name
				{
					DropAppWorkloadGroupMappingStmt *n = makeNode(DropAppWorkloadGroupMappingStmt);
					n->missing_ok = false;
					n->app_name = $6;
					$$ = (Node *)n;
				}
			| DROP APP WORKLOAD GROUP_P MAPPING IF_P EXISTS application_name
				{
					DropAppWorkloadGroupMappingStmt *n = makeNode(DropAppWorkloadGroupMappingStmt);
					n->missing_ok = true;
					n->app_name = $8;
					$$ = (Node *)n;
				}
		;

application_name:
			ColId							{ $$ = $1; };

/* PGXC_END */

/*****************************************************************************
 *
 *		QUERY:
 *				EXPLAIN [ANALYZE] [VERBOSE] query
 *				EXPLAIN ( options ) query
 *
 *****************************************************************************/

ExplainStmt:
		EXPLAIN ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->query = $2;
					n->options = NIL;
					$$ = (Node *) n;
				}
		| EXPLAIN EXTENDED ExplainableStmt
				{
					ExplainStmt* stmt = makeNode(ExplainStmt);
					stmt->query = $3;
					stmt->options = NIL;
					$$ = (Node*)stmt;
				}
		| EXPLAIN PERFORMANCE ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->query = $3;
					n->options = list_make1(makeDefElem("performance",NULL));
					$$ = (Node *) n;
				}
		| EXPLAIN analyze_keyword opt_verbose ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->query = $4;
					n->options = list_make1(makeDefElem("analyze", NULL));
					if ($3)
						n->options = lappend(n->options,
											 makeDefElem("verbose", NULL));
					$$ = (Node *) n;
				}
		| EXPLAIN VERBOSE ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->query = $3;
					n->options = list_make1(makeDefElem("verbose", NULL));
					$$ = (Node *) n;
				}
		| EXPLAIN '(' explain_option_list ')' ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->query = $5;
					n->options = $3;
					$$ = (Node *) n;
				}
		| EXPLAIN DB_B_FORMAT '=' ColId_or_Sconst ExplainableStmt
				{
					ExplainStmt* stmt = makeNode(ExplainStmt);
					stmt->query = $5;
					if (pg_strcasecmp($4, "json") == 0) {
						DefElem* def = makeDefElem(downcase_str((char*)$2, false), (Node*)makeString("json"));
						stmt->options = list_make1(def);
					} else if (pg_strcasecmp($4, "traditional") == 0) {
                                         	stmt->options = NIL;
					} else if (pg_strcasecmp($4, "tree") == 0) {
                                         	stmt->options = NIL;
					} else {
						DefElem* def = makeDefElem(downcase_str((char*)$2, false), (Node*)makeString($4));
						stmt->options = list_make1(def);					
					}

					$$ = (Node*)stmt;					
				}
		| EXPLAIN PLAN SET STATEMENT_ID '=' SCONST FOR ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->statement = makeStringConst($6, @6);
					n->query = $8;
					n->options = list_make1(makeDefElem("plan", NULL));
					$$ = (Node *) n;
				}
		| EXPLAIN PLAN FOR ExplainableStmt
				{
					ExplainStmt *n = makeNode(ExplainStmt);
					n->statement = NULL;
					n->query = $4;
					n->options = list_make1(makeDefElem("plan", NULL));
					$$ = (Node *) n;
				}
		| describe_command dolphin_qualified_name
				{
					SelectStmt *n = checkTableExistence($2);
					$$ = (Node *) n;
				}
		;

ExplainableStmt:
			SelectStmt
			| InsertStmt
			| UpdateStmt
			| DeleteStmt
			| MergeStmt
			| DeclareCursorStmt
			| CreateAsStmt
			| CreateModelStmt
			| SnapshotStmt
			| ExecuteStmt					/* by default all are $$=$1 */
		;

explain_option_list:
			explain_option_elem
				{
					$$ = list_make1($1);
				}
			| explain_option_list ',' explain_option_elem
				{
					$$ = lappend($1, $3);
				}
		;

explain_option_elem:
			explain_option_name explain_option_arg
				{
					$$ = makeDefElem($1, $2);
				}
		;

explain_option_name:
			ColId					{ $$ = $1; }
			| analyze_keyword		{ $$ = "analyze"; }
		;

explain_option_arg:
			opt_boolean_or_string	{ $$ = (Node *) makeString($1); }
			| NumericOnly			{ $$ = (Node *) $1; }
			| /* EMPTY */			{ $$ = NULL; }
		;

describe_command:
          		DESC
       			| DESCRIBE
        	;

/*****************************************************************************
 *
 *		QUERY:
 *				EXECUTE DIRECT ON ( nodename [, ... ] ) query
 *				EXECUTE DIRECT ON  [ COORDINATORS | DATANODES | ALL ] query
 *
 *****************************************************************************/

ExecDirectStmt: 
		EXECUTE DIRECT ON pgxcnodes DirectStmt
			{
				ExecDirectStmt *n = makeNode(ExecDirectStmt);
			
				n->node_names = $4;
				n->exec_option = EXEC_DIRECT_ON_LIST;
				n->query = $5;
				n->location = @5;
				$$ = (Node *)n;
				parameter_check_execute_direct(n->query);
			}
		| EXECUTE DIRECT ON COORDINATORS DirectStmt
			{
				ExecDirectStmt *n = makeNode(ExecDirectStmt);
				
				n->exec_option = EXEC_DIRECT_ON_ALL_CN;
				n->query = $5;
				n->location = @5;
				$$ = (Node *)n;
				parameter_check_execute_direct(n->query);
			}
		| EXECUTE DIRECT ON DATANODES DirectStmt
			{
				ExecDirectStmt *n = makeNode(ExecDirectStmt);
			
				n->exec_option = EXEC_DIRECT_ON_ALL_DN;
				n->query = $5;
				n->location = @5;
				$$ = (Node *)n;
				parameter_check_execute_direct(n->query);
			}
		| EXECUTE DIRECT ON ALL DirectStmt
			{
				ExecDirectStmt *n = makeNode(ExecDirectStmt);
				
				n->exec_option = EXEC_DIRECT_ON_ALL_NODES;
				n->query = $5;
				n->location = @5;
				$$ = (Node *)n;
				parameter_check_execute_direct(n->query);
			}
		;

DirectStmt:
			SCONST					/* by default all are $$=$1 */
		;

/*****************************************************************************
 *
 *		QUERY:
 *
 *		CLEAN CONNECTION TO { COORDINATOR ( nodename ) | NODE ( nodename ) | ALL [ CHECK ] [ FORCE ] }
 *				[ FOR DATABASE dbname ]
 *				[ TO USER username ]
 *
 *****************************************************************************/

CleanConnStmt: CLEAN CONNECTION TO COORDINATOR pgxcnodes CleanConnDbName CleanConnUserName
				{
					CleanConnStmt *n = makeNode(CleanConnStmt);
					n->is_coord = true;
					n->nodes = $5;
					n->is_check = false;
					n->is_force = false;
					n->dbname = $6;
					n->username = $7;
					$$ = (Node *)n;
				}
				| CLEAN CONNECTION TO NODE pgxcnodes CleanConnDbName CleanConnUserName
				{
					CleanConnStmt *n = makeNode(CleanConnStmt);
					n->is_coord = false;
					n->nodes = $5;
					n->is_check = false;
					n->is_force = false;
					n->dbname = $6;
					n->username = $7;
					$$ = (Node *)n;
				}
				| CLEAN CONNECTION TO ALL opt_check opt_force CleanConnDbName CleanConnUserName
				{
					CleanConnStmt *n = makeNode(CleanConnStmt);
					n->is_coord = true;
					n->nodes = NIL;
					n->is_check = $5;
					n->is_force = $6;
					n->dbname = $7;
					n->username = $8;
					$$ = (Node *)n;
				}
		;

CleanConnDbName: FOR DATABASE database_name		{ $$ = $3; }
				| FOR database_name				{ $$ = $2; }
				| /* EMPTY */					{ $$ = NULL; }
		;

CleanConnUserName: TO USER RoleId				{ $$ = $3; }
				| TO RoleId						{ $$ = $2; }
				| /* EMPTY */					{ $$ = NULL; }
		;

opt_check:	CHECK								{  $$ = TRUE; }
			| /* EMPTY */						{  $$ = FALSE; }
		;
/* PGXC_END */

/*****************************************************************************
 *
 *		QUERY:
 *				PREPARE <plan_name> [(args, ...)] AS <query>
 *
 *****************************************************************************/

PrepareStmt: PREPARE name prep_type_clause as_or_from PreparableStmt
				{
					PrepareStmt *n = makeNode(PrepareStmt);
					n->name = $2;
					n->argtypes = $3;
					n->query = $5;
					$$ = (Node *) n;
				}
			| PREPARE name prep_type_clause as_or_from SCONST
				{
					PrepareStmt *n = makeNode(PrepareStmt);
					n->name = $2;
					n->argtypes = $3;
					List *parsetreeList = pg_parse_query($5);
					if (list_length(parsetreeList) != 1) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("PREPARE can contain only one SQL statement.")));
					}
					pfree($5);
					n->query = (Node *)linitial(parsetreeList);
					$$ = (Node *) n;
				}
		;

prep_type_clause: '(' type_list ')'			{ $$ = $2; }
				| /* EMPTY */				{ $$ = NIL; }
		;

as_or_from:
		AS
		|FROM
	;

PreparableStmt:
			SelectStmt
			| InsertStmt
			| UpdateStmt
			| DeleteStmt					/* by default all are $$=$1 */
			| MergeStmt
			| uservar_name
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "@var_name is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("@var_name is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						$$ = $1;
					} else {
						const char* message = "@var_name is supported only in B-format database, and enable_set_variable_b_format = on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("@var_name is supported only in B-format database, and enable_set_variable_b_format = on."),
								parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
				}
			;

/*****************************************************************************
 *
 * EXECUTE <plan_name> [(params, ...)]
 * CREATE TABLE <name> AS EXECUTE <plan_name> [(params, ...)]
 *
 *****************************************************************************/

ExecuteStmt: EXECUTE name execute_param_clause
				{
					ExecuteStmt *n = makeNode(ExecuteStmt);
					n->name = $2;
					n->params = $3;
					$$ = (Node *) n;
				}
			| EXECUTE name USING expr_list
				{
					ExecuteStmt *n = makeNode(ExecuteStmt);
					n->name = $2;
					n->params = $4;
					$$ = (Node *) n;
				}
			| CREATE OptTemp TABLE create_as_target AS
				EXECUTE name execute_param_clause opt_with_data
				{
					CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);
					ExecuteStmt *n = makeNode(ExecuteStmt);
					n->name = $7;
					n->params = $8;
					ctas->query = (Node *) n;
					ctas->into = $4;
					ctas->relkind = OBJECT_TABLE;
					ctas->is_select_into = false;
					/* cram additional flags into the IntoClause */
					$4->rel->relpersistence = $2;
#ifdef PGXC
					const char* message = "CREATE TABLE AS EXECUTE not yet supported";
    				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("CREATE TABLE AS EXECUTE not yet supported")));
#endif
					$4->skipData = !($9);
					$$ = (Node *) ctas;
				}
		;

execute_param_clause: '(' expr_list ')'				{ $$ = $2; }
					| /* EMPTY */					{ $$ = NIL; }
					;

/*****************************************************************************
 *
 *		QUERY:
 *				DEALLOCATE [PREPARE] <plan_name>
 *
 *****************************************************************************/

DeallocateStmt: DEALLOCATE name
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = $2;
						$$ = (Node *) n;
					}
				| DEALLOCATE PREPARE name
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = $3;
						$$ = (Node *) n;
					}
				| DROP PREPARE name
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = $3;
						$$ = (Node *) n;
					}
				| DEALLOCATE ALL
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = NULL;
						$$ = (Node *) n;
					}
				| DEALLOCATE PREPARE ALL
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = NULL;
						$$ = (Node *) n;
					}
				| DROP PREPARE ALL
					{
						DeallocateStmt *n = makeNode(DeallocateStmt);
						n->name = NULL;
						$$ = (Node *) n;
					}
		;

insert_partition_clause: update_delete_partition_clause
						{
#ifdef ENABLE_MULTIPLE_NODES
					    const char* message = "In distributed mode, insert/update/delete does not support specified partitions.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
							  errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							  errmsg("In distributed mode, insert/update/delete does not support specified partitions."),
							  errdetail("N/A"),errcause("Feature is not supported this operation."),
							  erraction("Contact engineer to support.")));
#endif
							$$ = $1;
						}
					| /* EMPTY */	{ $$ = NULL; }
					;

update_delete_partition_clause: PARTITION '(' name ')'
						{
							$$ = makeRangeVar(NULL, NULL, @3);
							$$->partitionname = $3;
							$$->ispartition = true;
						}
					| SUBPARTITION '(' name ')'
						{
							$$ = makeRangeVar(NULL, NULL, @3);
							$$->subpartitionname = $3;
							$$->issubpartition = true;
						}
					| PARTITION_FOR '(' expr_list ')'
						{
							$$ = makeRangeVar(NULL, NULL, @3);
							$$->partitionKeyValuesList = $3;
							$$->ispartition = true;
						}
					| SUBPARTITION_FOR '(' expr_list ')'
						{
							$$ = makeRangeVar(NULL, NULL, @3);
							$$->partitionKeyValuesList = $3;
							$$->issubpartition = true;
						}
					;


/*****************************************************************************
 *
 *		QUERY:
 *				INSERT STATEMENTS
 *
 *****************************************************************************/

InsertStmt: opt_with_clause INSERT hint_string opt_ignore into_empty insert_target insert_mysql_rest returning_clause
			{
				$7->relation = $6;
				$7->returningList = $8;
				$7->withClause = $1;
				$7->isReplace = false;
				$7->hintState = create_hintstate($3);
				$7->hasIgnore = $4;
				$$ = (Node *) $7;
			}
            | REPLACE hint_string replace_empty insert_target insert_rest returning_clause
            {
#ifndef ENABLE_MULTIPLE_NODES
                if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
                {
                    $5->relation = $4;
                    $5->returningList = $6;
                    $5->hintState = create_hintstate($2);
                    $5->isReplace = true;
                    $$ = (Node *) $5;
                }
                else
#endif
                {
                    const char* message = "REPLACE INTO syntax is not supported.";
                    InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                    ereport(errstate,
                            (errmodule(MOD_PARSER),
                            errcode(ERRCODE_SYNTAX_ERROR),
                            errmsg("REPLACE INTO syntax is not supported."),
                            parser_errposition(@1)));
                    $$ = NULL;/* not reached */
                }

            }
            | REPLACE hint_string replace_empty insert_target SET set_clause_list
            {
#ifndef ENABLE_MULTIPLE_NODES
                if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
                {
                     InsertStmt* n = makeNode(InsertStmt);
                     n->relation = $4;
                     n->targetList = $6;
                     n->hintState = create_hintstate($2);
                     n->isReplace = true;
                     $$ = (Node*)n;
                }
                else
#endif
                {
                    const char* message = "REPLACE INTO syntax is not supported.";
                    InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                    ereport(errstate,
                            (errmodule(MOD_PARSER),
                            errcode(ERRCODE_SYNTAX_ERROR),
                            errmsg("REPLACE INTO syntax is not supported."),
                            parser_errposition(@1)));
                    $$ = NULL;/* not reached */
                }

            }
			| opt_with_clause INSERT hint_string opt_ignore into_empty insert_target insert_mysql_rest upsert_clause returning_clause
				{
					if ($9 != NIL) {
						const char* message = "RETURNING clause is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
							  errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							  errmsg("RETURNING clause is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.")));
					}
					if ($1 != NULL) {
						const char* message = "WITH clause is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
							 errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("WITH clause is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.")));
					}
					/* enable_upsert_to_merge is always false */ 
					if (u_sess->attr.attr_sql.enable_upsert_to_merge
#ifdef ENABLE_MULTIPLE_NODES					
					    ||t_thrd.proc->workingVersionNum < UPSERT_ROW_STORE_VERSION_NUM
#endif						
					    ) {

						if ($7 != NULL && $7->cols != NIL) {
							ListCell *c = NULL;
							List *cols = $7->cols;
							foreach (c, cols) {
								ResTarget *rt = (ResTarget *)lfirst(c);
								if (rt->indirection != NIL) {
									const char* message = "Try assign a composite or an array expression to column ";
    								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
									ereport(errstate,
										(errmodule(MOD_PARSER),
										 errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
										 errmsg("Subfield name or array subscript of column \"%s\" "
											"is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.",
											rt->name),
										 errhint("Try assign a composite or an array expression to column \"%s\".", rt->name)));
								}
							}
						}


						MergeStmt *m = makeNode(MergeStmt);
						m->is_insert_update = true;

						/* for UPSERT, keep the INSERT statement as well */
						$7->relation = $6;
						$7->returningList = $9;
						$7->isReplace = false;
						$7->withClause = $1;
						$7->hasIgnore = $4;
#ifdef ENABLE_MULTIPLE_NODES						
						if (t_thrd.proc->workingVersionNum >= UPSERT_ROW_STORE_VERSION_NUM) {
							UpsertClause *uc = makeNode(UpsertClause);
							if ($8 == NULL)
								uc->targetList = NIL;
							else
								uc->targetList = ((MergeWhenClause *)$8)->targetList;
							$7->upsertClause = uc;
						}
#endif						
						m->insert_stmt = (Node *)copyObject($7);

						/* fill a MERGE statement*/
						m->relation = $6;

						Alias *a1 = makeAlias(($6->relname), NIL);
						$6->alias = a1;

						RangeSubselect *r = makeNode(RangeSubselect);
						r->alias = GetSessionContext()->upSertAliasName;
						r->subquery = (Node *) ($7->selectStmt);
						m->source_relation = (Node *) r;

						MergeWhenClause *n = makeNode(MergeWhenClause);
						n->matched = false;
						n->commandType = CMD_INSERT;
						n->cols = $7->cols;
						n->values = NULL;

						m->mergeWhenClauses = list_make1((Node *) n);
						if ($8 != NULL)
							m->mergeWhenClauses = list_concat(list_make1($8), m->mergeWhenClauses);

						m->hintState = create_hintstate($3);
						GetSessionContext()->upSertAliasName = NULL;
						GetSessionContext()->isUpsert = false;
						$$ = (Node *)m;
					} else {
						$7->relation = $6;
						$7->returningList = $9;
						$7->withClause = $1;
						$7->upsertClause = (UpsertClause *)$8;
						$7->upsertClause->aliasName = GetSessionContext()->upSertAliasName;
						$7->isReplace = false;
						$7->hintState = create_hintstate($3);
						$7->hasIgnore = $4;
						GetSessionContext()->upSertAliasName = NULL;
						GetSessionContext()->isUpsert = false;
						$$ = (Node *) $7;
					}
				}
		;

replace_empty:DELAYED into_empty
				{
					$$ = $1;
				}
			| LOW_PRIORITY into_empty
				{
					$$ = $1;
				}
			| into_empty
				{
					$$ = $1;
				}
		;

into_empty: INTO
			| /*EMPTY*/		{ $$ = NULL; }

/*
 * It is difficult to use relation_expr_opt_alias as update or delete statement,
 * because VALUES in insert_rest would have a shift/reduce conflict with VALUES
 * as alias if as is optional.
 * We tried to fix such conflict by adding noassoc/left priority to VALUES, but
 * it will make delete statement with VALUES as alias name unable to be resolved.
 * So AS is required for now.
 */
insert_target:
			dolphin_qualified_name insert_partition_clause
				{
					if ($2 != NULL) {
						$1->partitionname = $2->partitionname;
						$1->ispartition = $2->ispartition;
						$1->partitionKeyValuesList = $2->partitionKeyValuesList;
						$1->subpartitionname = $2->subpartitionname;
						$1->issubpartition = $2->issubpartition;
					}
					$$ = $1;
				}
			| dolphin_qualified_name insert_partition_clause AS ColId
				{
					if ($2 != NULL) {
						$1->partitionname = $2->partitionname;
						$1->ispartition = $2->ispartition;
						$1->partitionKeyValuesList = $2->partitionKeyValuesList;
						$1->subpartitionname = $2->subpartitionname;
						$1->issubpartition = $2->issubpartition;
					}
					$1->alias = makeAlias($4, NIL);
					$$ = $1;
				}
		;

insert_mysql_rest:
	insert_rest
		{ $$ = $1; }
	| SET insert_set_list
		{
			$$ = makeNode(InsertStmt);
			SelectStmt *n = makeNode(SelectStmt);
			List *temp_N = NIL;
			ListCell* cell = NULL;
			ResTarget* temp_val = NULL;
			foreach(cell, $2) {
				temp_val = (ResTarget*)lfirst(cell);
				temp_N = lappend(temp_N, (Node*)temp_val->val);
			}
			n->valuesLists = lappend(n->valuesLists, temp_N);
			$$->cols = $2;
			$$->selectStmt = (Node*)n;
			$$->isRewritten = false;
		}
	;

insert_rest:
			SelectStmt
				{
					$$ = makeNode(InsertStmt);
					$$->cols = NIL;
					$$->selectStmt = $1;
					$$->isRewritten = false;
				}
			| '(' insert_column_list ')' SelectStmt
				{
					$$ = makeNode(InsertStmt);
					$$->cols = $2;
					$$->selectStmt = $4;
					$$->isRewritten = false;
				}
			| '(' ')' SelectStmt
				{
					$$ = makeNode(InsertStmt);
					$$->cols = NIL;
					$$->selectStmt = $3;
					$$->isRewritten = false;
				}
			| DEFAULT VALUES
				{
					$$ = makeNode(InsertStmt);
					$$->cols = NIL;
					$$->selectStmt = NULL;
					$$->isRewritten = false;
				}
			| insert_empty_values
				{
						$$ = makeNode(InsertStmt);
						$$->cols = NIL;
						if (list_length(((SelectStmt *)$1)->valuesLists) == 1) {
							$$->selectStmt = NULL;
						} else {
							$$->selectStmt = $1;
						}
						$$->isRewritten = false;
				}
			| '(' ')' insert_empty_values
				{
					$$ = makeNode(InsertStmt);
					$$->cols = NIL;
					if (list_length(((SelectStmt *)$3)->valuesLists) == 1) {
						$$->selectStmt = NULL;
					} else {
						$$->selectStmt = $3;
					}
					$$->isRewritten = false;
				}
		;

insert_set_list:
			insert_set_clause
				{ $$ = $1; }
			| insert_set_list ',' insert_set_clause
				{ $$ = list_concat($1, $3); }
		;

insert_set_clause:
			set_target assign_operator ctext_expr
				{
					$1->val = (Node *) $3;
					$$ = list_make1($1);
				}
		;

insert_empty_values:
			VALUES empty_value
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->valuesLists = list_make1($2);
					$$ = (Node *) n;
				}
			| VALUE_P empty_value
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->valuesLists = list_make1($2);
					$$ = (Node *) n;
				} 
			| insert_empty_values ',' empty_value
				{
					SelectStmt *n = (SelectStmt *) $1;
					n->valuesLists = lappend(n->valuesLists, $3);
					$$ = (Node *) n;
				}
		;

empty_value:
			'(' ')'  {$$ = NIL; }
		;

insert_column_list:
			insert_column_item
					{ $$ = list_make1($1); }
			| insert_column_list ',' insert_column_item
					{ $$ = lappend($1, $3); }
		;

insert_column_item:
			ColId opt_indirection
				{
					$$ = makeNode(ResTarget);
					$$->name = $1;
					$$->indirection = check_indirection($2, yyscanner);
					$$->val = NULL;
					$$->location = @1;
				}
		;

returning_clause:
			RETURNING target_list		{ $$ = $2; }
			| /* EMPTY */				{ $$ = NIL; }
		;

upsert_clause:
			UPSERT set_clause_list where_clause
				{
					if (u_sess->attr.attr_sql.enable_upsert_to_merge
#ifdef ENABLE_MULTIPLE_NODES					
					    || t_thrd.proc->workingVersionNum < UPSERT_ROW_STORE_VERSION_NUM
#endif					    
						) {
						MergeWhenClause *n = makeNode(MergeWhenClause);
						n->matched = true;
						n->commandType = CMD_UPDATE;
						n->targetList = $2;
						$$ = (Node *) n;
					} else {
#ifdef ENABLE_MULTIPLE_NODES
						/* check subquery in set clause*/
						ListCell* cell = NULL;
						ResTarget* res = NULL;
						foreach (cell, $2) {
							res = (ResTarget*)lfirst(cell);
							if (IsA(res->val,SubLink)) {
								const char* message = "Update with subquery is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.";
    								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
									(errmodule(MOD_PARSER),
									errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
									errmsg("Update with subquery is not yet supported whithin INSERT ON DUPLICATE KEY UPDATE statement.")));
							}
						}
#endif

						UpsertClause *uc = makeNode(UpsertClause);
						uc->targetList = $2;
						uc->location = @1;
						uc->whereClause = $3;
						$$ = (Node *) uc;
					}
				}
			| UPSERT NOTHING
				{
					if (unlikely(u_sess->attr.attr_sql.enable_upsert_to_merge ||
						t_thrd.proc->workingVersionNum < UPSERT_ROW_STORE_VERSION_NUM)) {
						$$ = NULL;
					} else {
						UpsertClause *uc = makeNode(UpsertClause);
						uc->targetList = NIL;
						uc->location = @1;
						$$ = (Node *) uc;
					}
				}
		;

UPSERT:
	ON DUPLICATE KEY UPDATE { 
		GetSessionContext()->isUpsert = true;
                GetSessionContext()->upSertAliasName = GetSessionContext()->upSertAliasName = makeAlias("delay", NIL);
	}
	;

/*****************************************************************************
 *
 *		QUERY:
 *				DELETE STATEMENTS
 *
 *****************************************************************************/

DeleteStmt: opt_with_clause DELETE_P hint_string FROM relation_expr_opt_alias_list
			using_clause where_or_current_clause opt_sort_clause opt_delete_limit returning_clause
				{
					DeleteStmt *n = makeNode(DeleteStmt);
					n->relations = $5;
					if (list_length(n->relations) > 1) {
						checkDeleteRelationError();
					}
					n->usingClause = $6;
					n->whereClause = $7;
					n->sortClause = $8;
					n->limitClause = (Node*)list_nth($9, 1);
					n->returningList = $10;
					n->withClause = $1;
					n->hintState = create_hintstate($3);					
					$$ = (Node *)n;
				}
		| opt_with_clause DELETE_P hint_string relation_expr_opt_alias_list
			using_clause where_or_current_clause opt_sort_clause opt_delete_limit returning_clause
				{
					DeleteStmt *n = makeNode(DeleteStmt);
					n->relations = $4;
					if (list_length(n->relations) > 1) {
						checkDeleteRelationError();
					}
					n->usingClause = $5;
					n->whereClause = $6;
					n->sortClause = $7;
					n->limitClause = (Node*)list_nth($8, 1);
					n->returningList = $9;
					n->withClause = $1;
					n->hintState = create_hintstate($3);				
					$$ = (Node *)n;
				}
		/* this is only used in multi-relation DELETE for compatibility B database. */
		| opt_with_clause DELETE_P hint_string relation_expr_opt_alias_list
			FROM from_list where_or_current_clause
				{
					DeleteStmt *n = makeNode(DeleteStmt);
					n->relations = $4;
					checkDeleteRelationError();
					n->usingClause = $6;
					n->whereClause = $7;
					n->withClause = $1;
					n->hintState = create_hintstate($3);				
					$$ = (Node *)n;
				}
		;

using_clause:
				USING from_list						{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;


/*****************************************************************************
 *
 *		QUERY:
 *				LOCK TABLE
 *
 *****************************************************************************/

LockStmt:	LOCK_P TABLE relation_expr_list opt_lock opt_nowait opt_cancelable
				{
					LockStmt *n = makeNode(LockStmt);

					n->relations = $3;
					n->mode = $4;
					n->nowait = $5;
					n->cancelable = $6;
					$$ = (Node *)n;
				}
			| LOCK_P relation_expr_list opt_lock opt_nowait opt_cancelable
				{
					LockStmt *n = makeNode(LockStmt);

					n->relations = $2;
					n->mode = $3;
					n->nowait = $4;
					n->cancelable = $5;
					$$ = (Node *)n;
				}
			| LOCK_P TABLE relation_expr_list opt_lock_for_b opt_nowait opt_cancelable
				{
					LockStmt *n = makeNode(LockStmt);

					n->relations = $3;
					n->mode = $4;
					n->nowait = $5;
					n->cancelable = $6;
					n->isLockTables = true;
					$$ = (Node *)n;
				}
			| LOCK_TABLES relation_expr_list opt_lock_for_b opt_nowait opt_cancelable
				{
					LockStmt *n = makeNode(LockStmt);

					n->relations = $2;
					n->mode = $3;
					n->nowait = $4;
					n->cancelable = $5;
					n->isLockTables = true;
					$$ = (Node *)n;
				}
		;

opt_lock_for_b:
			READ					{ $$ = AccessShareLock; }
			| WRITE					{ $$ = AccessExclusiveLock; }
		;
		;

opt_lock:	IN_P lock_type MODE				{ $$ = $2; }
			| /*EMPTY*/						{ $$ = AccessExclusiveLock; }
		;

lock_type:	ACCESS SHARE					{ $$ = AccessShareLock; }
			| ROW SHARE						{ $$ = RowShareLock; }
			| ROW EXCLUSIVE					{ $$ = RowExclusiveLock; }
			| SHARE UPDATE EXCLUSIVE		{ $$ = ShareUpdateExclusiveLock; }
			| SHARE							{ $$ = ShareLock; }
			| SHARE ROW EXCLUSIVE			{ $$ = ShareRowExclusiveLock; }
			| EXCLUSIVE						{ $$ = ExclusiveLock; }
			| ACCESS EXCLUSIVE				{ $$ = AccessExclusiveLock; }
		;

opt_nowait:	NOWAIT							{ $$ = TRUE; }
			| /*EMPTY*/						{ $$ = FALSE; }
		;

opt_cancelable: CANCELABLE                                              { $$ = TRUE; }
                        | /*EMPTY*/                                             { $$ = FALSE; }
                ;

opt_wait:	WAIT Iconst						{ $$ = $2; }
opt_nowait_or_skip:
			NOWAIT							{ $$ = LockWaitError; }
			| SKIP LOCKED					{ $$ = LockWaitSkip; }
			| /*EMPTY*/						{ $$ = LockWaitBlock; }
		;

/*****************************************************************************
 *
 *		QUERY:
 *				UpdateStmt (UPDATE)
 *
 *****************************************************************************/

UpdateStmt: opt_with_clause UPDATE hint_string opt_ignore from_list
			SET set_clause_list
			from_clause
			where_or_current_clause
			opt_sort_clause
			opt_delete_limit
			returning_clause
				{
					UpdateStmt *n = makeNode(UpdateStmt);
					n->relation = NULL;
#ifdef ENABLE_MULTIPLE_NODES
					if (list_length($5) > 1) {
						ereport(errstate, 
							    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("multi-relation update is not yet supported.")));
					}
					if (!IsA(linitial($5), RangeVar)) {
							ereport(errstate,
								    (errcode(ERRCODE_SYNTAX_ERROR),
								     errmsg("invalid target relation name."),
								     parser_errposition(@5)));
					}
#else
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						if (list_length($5) > 1) {
							ereport(errstate, 
									(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
									 errmsg("multi-relation update only support in B-format database")));
						}
						if (!IsA(linitial($5), RangeVar)) {
							ereport(errstate,
								    (errcode(ERRCODE_SYNTAX_ERROR),
								     errmsg("invalid target relation name."),
								     parser_errposition(@5)));
						}
					}
#endif
					n->relationClause = $5;
					n->targetList = $7;
					n->fromClause = $8;
					n->whereClause = $9;
					n->sortClause = $10;
					n->limitClause = (Node*)list_nth($11, 1);
					n->returningList = $12;
					n->withClause = $1;
					n->hintState = create_hintstate($3);
					n->hasIgnore = $4;
					$$ = (Node *)n;
				}
		;

set_clause_list:
			set_clause							{ $$ = $1; }
			| set_clause_list ',' set_clause	{ $$ = list_concat($1,$3); }
		;

set_clause:
			single_set_clause						{ $$ = list_make1($1); }
			| multiple_set_clause					{ $$ = $1; }
		;

single_set_clause:
			set_target assign_operator ctext_expr
				{
					$$ = $1;
					$$->val = (Node *) $3;
				}
		;

multiple_set_clause:
			'(' set_target_list ')' assign_operator ctext_row
				{
					ListCell *col_cell;
					ListCell *val_cell;

					/*
					 * Break the ctext_row apart, merge individual expressions
					 * into the destination ResTargets.  XXX this approach
					 * cannot work for general row expressions as sources.
					 */
					if (list_length($2) != list_length($5)) {
						const char* message = "number of columns does not match number of values";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("number of columns does not match number of values"),
								 parser_errposition(@1)));
					}
					forboth(col_cell, $2, val_cell, $5)
					{
						ResTarget *res_col = (ResTarget *) lfirst(col_cell);
						Node *res_val = (Node *) lfirst(val_cell);

						res_col->val = res_val;
					}

					$$ = $2;
				}
			|	'(' set_target_list ')' assign_operator '(' SELECT hint_string opt_distinct target_list
					from_clause where_clause group_clause having_clause ')'
					{
						SelectStmt *select = makeNode(SelectStmt);
						select->distinctClause = $8;
						select->targetList = $9;
						select->intoClause = NULL;
						select->fromClause = $10;
						select->whereClause = $11;
						select->groupClause = $12;
						select->havingClause = $13;

						if (list_length($2) != list_length($9)) {
							const char* message = "number of columns does not match number of values";
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									errmsg("number of columns does not match number of values")));
						}
						ParseUpdateMultiSet($2, select, yyscanner);

						$$ = $2;
					}

		;

set_target:
			DolphinColId opt_dolphin_indirection
				{
					$$ = makeNode(ResTarget);
					if ($2 == NIL) {
						$$->name = downcase_str($1->str, $1->is_quoted);
					} else {
						$$->name = GetDolphinObjName($1->str, $1->is_quoted);
					}
					List* result = NIL;
					ListCell* cell = NULL;
					foreach(cell, $2) {
						DolphinString* item = (DolphinString*)lfirst(cell);
						if (IsA(item->node, String)) {
							Value* value = (Value*)(item->node);
							value->val.str = downcase_str(value->val.str, item->is_quoted);
						}
						result = lappend(result, item->node);
					}
					$$->indirection = check_indirection(result, yyscanner);
					$$->val = NULL;	/* upper production sets this */
					$$->location = @1;
				}
		;

set_target_list:
			set_target								{ $$ = list_make1($1); }
			| set_target_list ',' set_target		{ $$ = lappend($1,$3); }
		;

/*****************************************************************************
 *
 *		QUERY:
 *				MERGE STATEMENTS
 *
 *****************************************************************************/
MergeStmt:
			MERGE hint_string INTO relation_expr_opt_alias
			USING table_ref
			ON a_expr
			merge_when_list
				{
					MergeStmt *m = makeNode(MergeStmt);

					m->relation = $4;
					m->source_relation = $6;
					m->join_condition = $8;
					m->mergeWhenClauses = $9;

					m->hintState = create_hintstate($2);

					$$ = (Node *)m;
				}
			;

merge_when_list:
			merge_when_clause						{ $$ = list_make1($1); }
			| merge_when_list merge_when_clause 	{ $$ = lappend($1,$2); }
			;

merge_when_clause:
			WHEN MATCHED THEN merge_update opt_merge_where_condition
				{
					$4->matched = true;
					$4->commandType = CMD_UPDATE;
					$4->condition = $5;

					$$ = (Node *) $4;
				}
			| WHEN NOT MATCHED THEN merge_insert opt_merge_where_condition
				{
					$5->matched = false;
					$5->commandType = CMD_INSERT;
					$5->condition = $6;

					$$ = (Node *) $5;
				}
			;

opt_merge_where_condition:
			WHERE a_expr			{ $$ = $2; }
			|						{ $$ = NULL; }
			;

merge_update:
			UPDATE SET set_clause_list
				{
					MergeWhenClause *n = makeNode(MergeWhenClause);
					n->targetList = $3;

					$$ = n;
				}
			;

merge_insert:
			INSERT merge_values_clause
				{
					MergeWhenClause *n = makeNode(MergeWhenClause);
					n->cols = NIL;
					n->values = $2;

					$$ = n;
				}
			| INSERT '(' insert_column_list ')' merge_values_clause
				{
					MergeWhenClause *n = makeNode(MergeWhenClause);
					n->cols = $3;
					n->values = $5;

					$$ = n;
				}
			| INSERT DEFAULT VALUES
				{
					MergeWhenClause *n = makeNode(MergeWhenClause);
					n->cols = NIL;
					n->values = NIL;
					$$ = n;
				}
			;

merge_values_clause:
			VALUES ctext_row
				{
					$$ = $2;
				}
			;

/*****************************************************************************
 *
 *		QUERY:
 *				CURSOR STATEMENTS
 *
 *****************************************************************************/
DeclareCursorStmt: CURSOR cursor_name cursor_options opt_hold FOR SelectStmt
				{
					DeclareCursorStmt *n = makeNode(DeclareCursorStmt);
					n->portalname = $2;
					/* currently we always set FAST_PLAN option */
					n->options = $3 | $4 | CURSOR_OPT_FAST_PLAN;
					n->query = $6;
					$$ = (Node *)n;
				}
			| DECLARE_CURSOR cursor_name cursor_options CURSOR opt_hold FOR SelectStmt
			{
				DeclareCursorStmt *n = makeNode(DeclareCursorStmt);
				n->portalname = $2;
				/* currently we always set FAST_PLAN option */
				n->options = $3 | $5 | CURSOR_OPT_FAST_PLAN;
				n->query = $7;
				$$ = (Node *)n;
			}
	;

cursor_name:	name						{ $$ = $1; }
		;

cursor_options: /*EMPTY*/					{ $$ = 0; }
			| cursor_options NO SCROLL		{ $$ = $1 | CURSOR_OPT_NO_SCROLL; }
			| cursor_options SCROLL
				{
					const char* message = "SCROLL CURSOR is not yet supported";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("SCROLL CURSOR is not yet supported.")));
					$$ = $1 | CURSOR_OPT_SCROLL;
				}
			| cursor_options BINARY			{ $$ = $1 | CURSOR_OPT_BINARY; }
			| cursor_options INSENSITIVE
				{
					const char* message = "INSENSITIVE CURSOR is not yet supported.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("INSENSITIVE CURSOR is not yet supported.")));
					$$ = $1 | CURSOR_OPT_INSENSITIVE;
				}
		;

opt_hold: /* EMPTY */						{ $$ = 0; }
			| WITH HOLD				{$$ = CURSOR_OPT_HOLD; }
			| WITHOUT HOLD				{ $$ = 0; }
		;

/*****************************************************************************
 *
 *		QUERY:
 *				SELECT STATEMENTS
 *
 *****************************************************************************/

/* A complete SELECT statement looks like this.
 *
 * The rule returns either a single SelectStmt node or a tree of them,
 * representing a set-operation tree.
 *
 * There is an ambiguity when a sub-SELECT is within an a_expr and there
 * are excess parentheses: do the parentheses belong to the sub-SELECT or
 * to the surrounding a_expr?  We don't really care, but bison wants to know.
 * To resolve the ambiguity, we are careful to define the grammar so that
 * the decision is staved off as long as possible: as long as we can keep
 * absorbing parentheses into the sub-SELECT, we will do so, and only when
 * it's no longer possible to do that will we decide that parens belong to
 * the expression.	For example, in "SELECT (((SELECT 2)) + 3)" the extra
 * parentheses are treated as part of the sub-select.  The necessity of doing
 * it that way is shown by "SELECT (((SELECT 2)) UNION SELECT 2)".	Had we
 * parsed "((SELECT 2))" as an a_expr, it'd be too late to go back to the
 * SELECT viewpoint when we see the UNION.
 *
 * This approach is implemented by defining a nonterminal select_with_parens,
 * which represents a SELECT with at least one outer layer of parentheses,
 * and being careful to use select_with_parens, never '(' SelectStmt ')',
 * in the expression grammar.  We will then have shift-reduce conflicts
 * which we can resolve in favor of always treating '(' <select> ')' as
 * a select_with_parens.  To resolve the conflicts, the productions that
 * conflict with the select_with_parens productions are manually given
 * precedences lower than the precedence of ')', thereby ensuring that we
 * shift ')' (and then reduce to select_with_parens) rather than trying to
 * reduce the inner <select> nonterminal to something else.  We use UMINUS
 * precedence for this, which is a fairly arbitrary choice.
 *
 * To be able to define select_with_parens itself without ambiguity, we need
 * a nonterminal select_no_parens that represents a SELECT structure with no
 * outermost parentheses.  This is a little bit tedious, but it works.
 *
 * In non-expression contexts, we use SelectStmt which can represent a SELECT
 * with or without outer parentheses.
 */

SelectStmtWithoutWithClause:
			select_no_parens_without_withclause
			| select_with_parens
		;

SelectStmt: select_no_parens			%prec UMINUS
			| select_with_parens		%prec UMINUS
		;

select_with_parens:
			'(' select_no_parens ')'				{ $$ = $2; }
			| '(' select_with_parens ')'			{ $$ = $2; }
		;

/*
 * This rule parses the equivalent of the standard's <query expression>.
 * The duplicative productions are annoying, but hard to get rid of without
 * creating shift/reduce conflicts.
 *
 *	The locking clause (FOR UPDATE etc) may be before or after LIMIT/OFFSET.
 *	In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
 *	We now support both orderings, but prefer LIMIT/OFFSET before the locking clause.
 *	2002-08-28 bjm
 */

 select_no_parens_without_withclause:
			simple_select						{ $$ = $1; }
                        | select_clause siblings_clause opt_select_limit
                                {
                                        SelectStmt* stmt = (SelectStmt *) $1;
                                        insertSelectOptions((SelectStmt *) $1, NIL, NIL,
                                            (Node*)list_nth($3, 0), (Node*)list_nth($3, 1), NULL,
                                            yyscanner);
                                        StartWithClause* swc = (StartWithClause*) stmt->startWithClause;
                                        if (swc == NULL) {
                                            ereport(errstate,
                                                    (errcode(ERRCODE_SYNTAX_ERROR),
                                                     errmsg("order siblings by clause can only be used on start-with qualifed relations"),
                                                     parser_errposition(@2)));
                                        } else {
                                            swc->siblingsOrderBy = $2;
                                        }
                                        $$ = $1;
                                }
                        | select_clause siblings_clause sort_clause opt_select_limit
                                {
                                        SelectStmt* stmt = (SelectStmt *) $1;
					insertSelectOptions((SelectStmt *) $1, $3, NIL,
										(Node*)list_nth($4, 0), (Node*)list_nth($4, 1), NULL,
										yyscanner);
                                        StartWithClause* swc = (StartWithClause*) stmt->startWithClause;
                                        if (swc == NULL) {
                                            ereport(errstate,
                                                    (errcode(ERRCODE_SYNTAX_ERROR),
                                                     errmsg("order siblings by clause can only be used on start-with qualifed relations"),
                                                     parser_errposition(@2)));
                                        } else {
                                            swc->siblingsOrderBy = $2;
                                        }
                                        $$ = $1;
                                }
			| select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $1, $2, NIL,
										NULL, NULL, NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause for_locking_clause opt_select_limit opt_into_clause
				{
					FilterStartWithUseCases((SelectStmt *) $1, $3, yyscanner, @3);
					insertSelectOptions((SelectStmt *) $1, $2, $3,
										(Node*)list_nth($4, 0), (Node*)list_nth($4, 1),
										NULL,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $1, (IntoClause *) $5);
				}
			| select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
					FilterStartWithUseCases((SelectStmt *) $1, $4, yyscanner, @4);
					insertSelectOptions((SelectStmt *) $1, $2, $4,
										(Node*)list_nth($3, 0), (Node*)list_nth($3, 1),
										NULL,
										yyscanner);
					$$ = $1;
				}
			| select_clause opt_sort_clause select_limit for_locking_clause into_clause
				{
					FilterStartWithUseCases((SelectStmt *) $1, $4, yyscanner, @4);
					insertSelectOptions((SelectStmt *) $1, $2, $4,
										(Node*)list_nth($3, 0), (Node*)list_nth($3, 1),
										NULL,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $1, (IntoClause *) $5);
				}
			| select_clause opt_sort_clause opt_select_limit into_clause opt_for_locking_clause
				{
					FilterStartWithUseCases((SelectStmt *) $1, $5, yyscanner, @5);
					insertSelectOptions((SelectStmt *) $1, $2, $5,
										(Node*)list_nth($3, 0), (Node*)list_nth($3, 1),
										NULL,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $1, (IntoClause *) $4);
				}
 		;

select_no_parens:
			select_no_parens_without_withclause			{ $$ = $1; }
			| with_clause select_clause
				{
					insertSelectOptions((SelectStmt *) $2, NULL, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause sort_clause
				{
					insertSelectOptions((SelectStmt *) $2, $3, NIL,
										NULL, NULL,
										$1,
										yyscanner);
					$$ = $2;
				}
			| with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit opt_into_clause
				{
					FilterStartWithUseCases((SelectStmt *) $2, $4, yyscanner, @4);
					insertSelectOptions((SelectStmt *) $2, $3, $4,
										(Node*)list_nth($5, 0), (Node*)list_nth($5, 1),
										$1,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $2, (IntoClause *) $6);
				}
			| with_clause select_clause opt_sort_clause select_limit for_locking_clause into_clause
				{
                    FilterStartWithUseCases((SelectStmt *) $2, $5, yyscanner, @5);
					insertSelectOptions((SelectStmt *) $2, $3, $5,
										(Node*)list_nth($4, 0), (Node*)list_nth($4, 1),
										$1,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $2, (IntoClause *) $6);
				}
			| with_clause select_clause opt_sort_clause opt_select_limit into_clause opt_for_locking_clause
				{
                    FilterStartWithUseCases((SelectStmt *) $2, $6, yyscanner, @6);
					insertSelectOptions((SelectStmt *) $2, $3, $6,
										(Node*)list_nth($4, 0), (Node*)list_nth($4, 1),
										$1,
										yyscanner);
					$$ = processIntoClauseInSelectStmt((SelectStmt *) $2, (IntoClause *) $5);
				}
			| with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause
				{
                    FilterStartWithUseCases((SelectStmt *) $2, $5, yyscanner, @5);
					insertSelectOptions((SelectStmt *) $2, $3, $5,
										(Node*)list_nth($4, 0), (Node*)list_nth($4, 1),
										$1,
										yyscanner);
					$$ = $2;
				}
		;

select_clause:
			simple_select							{ $$ = $1; }
			| select_with_parens					{ $$ = $1; }
		;

/*
 * This rule parses SELECT statements that can appear within set operations,
 * including UNION, INTERSECT and EXCEPT.  '(' and ')' can be used to specify
 * the ordering of the set operations.	Without '(' and ')' we want the
 * operations to be ordered per the precedence specs at the head of this file.
 *
 * As with select_no_parens, simple_select cannot have outer parentheses,
 * but can have parenthesized subclauses.
 *
 * Note that sort clauses cannot be included at this level --- SQL92 requires
 *		SELECT foo UNION SELECT bar ORDER BY baz
 * to be parsed as
 *		(SELECT foo UNION SELECT bar) ORDER BY baz
 * not
 *		SELECT foo UNION (SELECT bar ORDER BY baz)
 * Likewise for WITH, FOR UPDATE and LIMIT.  Therefore, those clauses are
 * described as part of the select_no_parens production, not simple_select.
 * This does not limit functionality, because you can reintroduce these
 * clauses inside parentheses.
 *
 * NOTE: only the leftmost component SelectStmt should have INTO.
 * However, this is not checked by the grammar; parse analysis must check it.
 */
simple_select:
			SELECT hint_string opt_distinct target_list
			opt_into_clause from_clause where_clause start_with_clause
			group_clause having_clause window_clause
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->distinctClause = $3;
					n->targetList = $4;
					n->intoClause = $5;
					n->fromClause = $6;
					n->whereClause = $7;
					n->startWithClause = $8;
					n->groupClause = $9;
					n->havingClause = $10;
					n->windowClause = $11;
					n->hintState = create_hintstate($2);
					n->hasPlus = getOperatorPlusFlag();
					$$ = (Node *)n;
				}
			| values_clause							{ $$ = $1; }
			| TABLE relation_expr
				{
					/* same as SELECT * FROM relation_expr */
					ColumnRef *cr = makeNode(ColumnRef);
					ResTarget *rt = makeNode(ResTarget);
					SelectStmt *n = makeNode(SelectStmt);

					cr->fields = list_make1(makeNode(A_Star));
					cr->location = -1;
					cr->indnum = 0;

					rt->name = NULL;
					rt->indirection = NIL;
					rt->val = (Node *)cr;
					rt->location = -1;

					n->targetList = list_make1(rt);
					n->fromClause = list_make1($2);
					$$ = (Node *)n;
				}
			| select_clause UNION opt_all select_clause
				{
					$$ = makeSetOp(SETOP_UNION, $3, $1, $4);
				}
			| select_clause INTERSECT opt_all select_clause
				{
					$$ = makeSetOp(SETOP_INTERSECT, $3, $1, $4);
				}
			| select_clause EXCEPT opt_all select_clause
				{
					$$ = makeSetOp(SETOP_EXCEPT, $3, $1, $4);
				}
		;

hint_string:
		COMMENTSTRING
			{
				$$ = $1;
			}
		|
			{ 
				$$ = NULL;
			}
		;
/*
 * SQL standard WITH clause looks like:
 *
 * WITH [ RECURSIVE ] <query name> [ (<column>,...) ]
 *		AS (query) [ SEARCH or CYCLE clause ]
 *
 * We don't currently support the SEARCH or CYCLE clause.
 */
with_clause:
		WITH cte_list
			{
				$$ = makeNode(WithClause);
				$$->ctes = $2;
				$$->recursive = false;
				$$->location = @1;
			}
		| WITH RECURSIVE cte_list
			{
				$$ = makeNode(WithClause);
				$$->ctes = $3;
				$$->recursive = true;
				$$->location = @1;
			}
		;

cte_list:
		common_table_expr						{ $$ = list_make1($1); }
		| cte_list ',' common_table_expr		{ $$ = lappend($1, $3); }
		;

common_table_expr:  name opt_name_list AS opt_materialized '(' PreparableStmt ')'
			{
				CommonTableExpr *n = makeNode(CommonTableExpr);
				n->ctename = $1;
				n->aliascolnames = $2;
				n->ctematerialized = (CTEMaterialize)$4;
				n->ctequery = $6;
				n->location = @1;
				n->locator_type = LOCATOR_TYPE_NONE;
				$$ = (Node *) n;
			}
		;

opt_materialized:
		MATERIALIZED							{ $$ = CTEMaterializeAlways; }
		| NOT MATERIALIZED						{ $$ = CTEMaterializeNever; }
		| /*EMPTY*/								{ $$ = CTEMaterializeDefault; }
		;

opt_with_clause:
		with_clause								{ $$ = $1; }
		| /*EMPTY*/								{ $$ = NULL; }
		;

opt_into_clause:
		into_clause								{ $$ = $1; }
		| /*EMPTY*/								%prec INTO
			{ $$ = NULL; }
		;

opt_ignore:
		IGNORE								    {  $$ = TRUE; }
		| /*EMPTY*/							    {  $$ = FALSE; }
		;

into_clause:
			INTO OptTempTableName
				{
					$$ = makeNode(IntoClause);
					$$->rel = $2;
					$$->colNames = NIL;
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					/* Here $$ is a temp table, so row_compress can be any value. To be safe, REL_CMPRS_PAGE_PLAIN is used. */
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
					$$->skipData = false;
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
				}
			| INTO into_user_var_list
				{
					$$ = makeNode(IntoClause);
					$$->rel = NULL;
					$$->colNames = NIL;
					$$->options = NIL;
					$$->onCommit = ONCOMMIT_NOOP;
					$$->row_compress = REL_CMPRS_PAGE_PLAIN;
					$$->tableSpaceName = NULL;
					$$->skipData = false;
					$$->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
					$$->userVarList = $2;
				}
			| INTO OUTFILE SCONST characterset_option fields_options_fin lines_options_fin
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "SELECT INTO OUTFILE is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SELECT INTO OUTFILE is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("SELECT INTO OUTFILE is only supported in B_FORMAT.")));
					}
					IntoClause *n = makeNode(IntoClause);
					n->filename = $3;
					n->copyOption = $5;
					n->is_outfile = true;
					if ($4)
						n->copyOption = lappend(n->copyOption, $4);
					if ($6)
						n->copyOption = lappend3(n->copyOption, $6);
					n->rel = NULL;
					n->colNames = NIL;
					n->options = NIL;
					n->onCommit = ONCOMMIT_NOOP;
					n->row_compress = REL_CMPRS_PAGE_PLAIN;
					n->tableSpaceName = NULL;
					n->skipData = false;
					n->relkind = INTO_CLAUSE_RELKIND_DEFAULT;
					$$ = n;
				}
			| INTO DUMPFILE SCONST
				{
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "SELECT INTO DUMPFILE is not yet supported in distributed database.";
					gsplsql_insert_error_msg(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("SELECT INTO DUMPFILE is not yet supported in distributed database.")));
#endif
					if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
						ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("SELECT INTO DUMPFILE is only supported in B_FORMAT.")));
					}
					$$ = makeNode(IntoClause);
					$$->is_outfile = false;
					$$->filename = $3;
				}
		;
characterset_option:
			CHARACTER SET SCONST
				{
					$$ = makeDefElem("encoding", (Node *)makeString($3));
				}
			| /*EMPTY*/			{ $$ = NULL; }
		;
fields_options_fin:
			FIELDS fields_options_list			{ $$ = $2; }
			| /*EMPTY*/							{ $$ = NIL; }
		;
fields_options_list:
			fields_options_list fields_options_item		{ $$ = lappend($1, $2); }
			| /*EMPTY*/			{ $$ = NIL; }
		;
fields_options_item:
			TERMINATED BY SCONST
				{
					$$ = makeDefElem("delimiter", (Node *)makeString($3));
				}
			| OPTIONALLY ENCLOSED BY SCONST
				{
					$$ = makeDefElem("o_enclosed", (Node *)makeString($4));
				}
			| ENCLOSED BY SCONST
				{
					$$ = makeDefElem("enclosed", (Node *)makeString($3));
				}
			| ESCAPED BY SCONST
				{
					$$ = makeDefElem("escape", (Node *)makeString($3));
				}
		;
lines_options_fin:
			LINES lines_options_list	{ $$ = $2; }
			| /*EMPTY*/			{ $$ = NIL; }
		;
lines_options_list:
			lines_options_list lines_option_item	{ $$ = lappend($1, $2); }
			| /*EMPTY*/			{ $$ = NIL; }
		;
lines_option_item:
			STARTING BY SCONST
				{
					$$ = makeDefElem("line_start", (Node *)makeString($3));
				}
			| TERMINATED BY SCONST
				{
					$$ = makeDefElem("eol", (Node *)makeString($3));
				}
 		;
into_user_var_list:
		uservar_name									{ $$ = list_make1($1); }
		| into_user_var_list ',' uservar_name			{ $$ = lappend($1,$3); }
	;

/*
 * Redundancy here is needed to avoid shift/reduce conflicts,
 * since TEMP is not a reserved word.  See also OptTemp.
 */
OptTempTableName:
			TEMPORARY opt_table dolphin_qualified_name
				{
					$$ = $3;
					$$->relpersistence = RELPERSISTENCE_TEMP;
				}
			| TEMP opt_table dolphin_qualified_name
				{
					$$ = $3;
					$$->relpersistence = RELPERSISTENCE_TEMP;
				}
			| LOCAL TEMPORARY opt_table dolphin_qualified_name
				{
					$$ = $4;
					$$->relpersistence = RELPERSISTENCE_TEMP;
				}
			| LOCAL TEMP opt_table dolphin_qualified_name
				{
					$$ = $4;
					$$->relpersistence = RELPERSISTENCE_TEMP;
				}
			| GLOBAL TEMPORARY opt_table dolphin_qualified_name
				{
					$$ = $4;
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "GLOBAL is deprecated in temporary table creation";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(WARNING,
							(errmsg("GLOBAL is deprecated in temporary table creation"),
							 parser_errposition(@1)));
					$$->relpersistence = RELPERSISTENCE_TEMP;
#else
					$$->relpersistence = RELPERSISTENCE_GLOBAL_TEMP;
#endif
				}
			| GLOBAL TEMP opt_table dolphin_qualified_name
				{
					$$ = $4;
#ifdef ENABLE_MULTIPLE_NODES
					const char* message = "GLOBAL is deprecated in temporary table creation";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(WARNING,
							(errmsg("GLOBAL is deprecated in temporary table creation"),
							 parser_errposition(@1)));
					$$->relpersistence = RELPERSISTENCE_TEMP;
#else
					$$->relpersistence = RELPERSISTENCE_GLOBAL_TEMP;
#endif
				}
			| UNLOGGED opt_table dolphin_qualified_name
				{
					$$ = $3;
					$$->relpersistence = RELPERSISTENCE_UNLOGGED;
				}
			| TABLE dolphin_qualified_name
				{
					$$ = $2;
					$$->relpersistence = RELPERSISTENCE_PERMANENT;
				}
			| dolphin_qualified_name
				{
					$$ = $1;
					$$->relpersistence = RELPERSISTENCE_PERMANENT;
				}
		;

opt_table:	TABLE									{}
			| /*EMPTY*/								{}
		;

opt_table_for_b:	
			TABLE									{}
			|TABLES									{}
		;


opt_all:	ALL										{ $$ = TRUE; }
			| DISTINCT								{ $$ = FALSE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

/* We use (NIL) as a placeholder to indicate that all target expressions
 * should be placed in the DISTINCT list during parsetree analysis.
 */
opt_distinct:
			DISTINCT									{ $$ = list_make1(NIL); }
			| DISTINCTROW								{ $$ = list_make1(NIL); }
			| DISTINCT ON '(' expr_list ')'				{ $$ = $4; }
			| DISTINCTROW ON '(' expr_list ')'			{ $$ = $4; }
			| ALL										{ $$ = NIL; }
			| /*EMPTY*/									{ $$ = NIL; }
		;

opt_sort_clause:
			sort_clause								{ $$ = $1;}
			| /*EMPTY*/								{ $$ = NIL; }
		;

sort_clause:
			ORDER BY sortby_list					{ $$ = $3; }
		;

siblings_clause:
                        ORDER SIBLINGS BY sortby_list                           { $$ = (Node*)$4; }
                ;

sortby_list:
			sortby									{ $$ = list_make1($1); }
			| sortby_list ',' sortby				{ $$ = lappend($1, $3); }
		;

sortby:		a_expr USING qual_all_Op opt_nulls_order
				{
					$$ = makeNode(SortBy);
					$$->node = $1;
					$$->sortby_dir = SORTBY_USING;
					$$->sortby_nulls = (SortByNulls)$4;
					$$->useOp = $3;
					$$->location = @3;
				}
			| a_expr opt_asc_desc opt_nulls_order
				{
					$$ = makeNode(SortBy);
					$$->node = $1;
					$$->sortby_dir = (SortByDir)$2;
					$$->sortby_nulls = GetNullOrderRule($$->sortby_dir, (SortByNulls)$3);;
					$$->useOp = NIL;
					$$->location = -1;		/* no operator */
				}
		;


select_limit:
			limit_clause offset_clause				{ $$ = list_make2($2, $1); }
			| offset_clause limit_clause				{ $$ = list_make2($1, $2); }
			| limit_clause						{ $$ = list_make2(NULL, $1); }
			| limit_offcnt_clause					{ $$ = $1; }
			| offset_clause						{ $$ = list_make2($1, NULL); }
		;

opt_select_limit:
			select_limit						{ $$ = $1; }
			| /* EMPTY */						{ $$ = list_make2(NULL,NULL); }
		;

opt_delete_limit:
			LIMIT a_expr						{ $$ = list_make2(NULL, $2); }
			| /* EMPTY */						{ $$ = list_make2(NULL, NULL); }
		;

limit_clause:
			LIMIT select_limit_value
				{ $$ = $2; }
			/* SQL:2008 syntax */
			| FETCH first_or_next opt_select_fetch_first_value row_or_rows ONLY
				{ $$ = $3; }
		;

limit_offcnt_clause:
			LIMIT select_offset_value ',' select_limit_value
				{
					$$ = list_make2($2, $4);
				}
		;

offset_clause:
			OFFSET select_offset_value
				{ $$ = $2; }
			/* SQL:2008 syntax */
			| OFFSET select_offset_value2 row_or_rows
				{ $$ = $2; }
		;

select_limit_value:
			a_expr									{ $$ = $1; }
			| ALL
				{
					/* LIMIT ALL is represented as a NULL constant */
					$$ = makeNullAConst(@1);
				}
		;

select_offset_value:
			a_expr									{ $$ = $1; }
		;

/*
 * Allowing full expressions without parentheses causes various parsing
 * problems with the trailing ROW/ROWS key words.  SQL only calls for
 * constants, so we allow the rest only with parentheses.  If omitted,
 * default to 1.
 */
opt_select_fetch_first_value:
			SignedIconst						{ $$ = makeIntConst($1, @1); }
			| '(' a_expr ')'					{ $$ = $2; }
			| /*EMPTY*/							{ $$ = makeIntConst(1, -1); }
		;

/*
 * Again, the trailing ROW/ROWS in this case prevent the full expression
 * syntax.  c_expr is the best we can do.
 */
select_offset_value2:
			c_expr									{ $$ = $1; }
		;

/* noise words */
row_or_rows: ROW									{ $$ = 0; }
			| ROWS									{ $$ = 0; }
		;

first_or_next: FIRST_P								{ $$ = 0; }
			| NEXT									{ $$ = 0; }
		;

/*
 * This syntax for group_clause tries to follow the spec quite closely.
 * However, the spec allows only column references, not expressions,
 * which introduces an ambiguity between implicit row constructors
 * (a,b) and lists of column references.
 *
 * We handle this by using the a_expr production for what the spec calls
 * <ordinary grouping set>, which in the spec represents either one column
 * reference or a parenthesized list of column references. Then, we check the
 * top node of the a_expr to see if it's an implicit RowExpr, and if so, just
 * grab and use the list, discarding the node. (this is done in parse analysis,
 * not here)
 *
 * (we abuse the row_format field of RowExpr to distinguish implicit and
 * explicit row constructors; it's debatable if anyone sanely wants to use them
 * in a group clause, but if they have a reason to, we make it possible.)
 *
 * Each item in the group_clause list is either an expression tree or a
 * GroupingSet node of some type.
 */

group_clause:
			GROUP_P BY group_by_list				{ $$ = $3; }
			| /*EMPTY*/								{ $$ = NIL; }
		;
group_by_list:
			group_by_item							{ $$ = list_make1($1); }
			| group_by_list ',' group_by_item		{ $$ = lappend($1,$3); }
			| a_expr WITH_ROLLUP
			{
				with_rollup_check_elems_count($1);
				$$ = list_make1((Node *) makeGroupingSet(GROUPING_SET_ROLLUP, list_make1($1), @1));
			}
			| a_expr					{ $$ = list_make1($1); }
			| group_by_list ',' a_expr WITH_ROLLUP
			{
				with_rollup_check_elems_count($3);
				List* whole_list = NIL;
				ListCell* cell = NULL;
				List* last_expr_list = NIL;
				foreach (cell, $1) {
					if (IsA(lfirst(cell), GroupingSet)) {
						/* fill up whole_list before clearing last_expr_list */
						whole_list = list_concat(whole_list, last_expr_list);
						whole_list = lappend(whole_list, lfirst(cell));
						last_expr_list = NIL;
					} else {
						/* cell is an expr */
						if (last_expr_list == NIL) {
							last_expr_list = list_make1(lfirst(cell));
						} else {
							last_expr_list = lappend(last_expr_list, lfirst(cell));
						}
					}
				}
				last_expr_list = lappend(last_expr_list, $3);
				Node* with_rollup = (Node *) makeGroupingSet(GROUPING_SET_ROLLUP, last_expr_list, @1);
				whole_list = lappend(whole_list, with_rollup);
				$$ = whole_list;
			}
			| group_by_list ',' a_expr			{ $$ = lappend($1, $3); }
		;

group_by_item:
			empty_grouping_set						{ $$ = $1; }
			| cube_clause							{ $$ = $1; }
			| rollup_clause 						{ $$ = $1; }
			| grouping_sets_clause					{ $$ = $1; }
		;

empty_grouping_set:
			'(' ')'
				{
					$$ = (Node *) makeGroupingSet(GROUPING_SET_EMPTY, NIL, @1);
				}
		;
/*
 * These hacks rely on setting precedence of CUBE and ROLLUP below that of '(',
 * so that they shift in these rules rather than reducing the conflicting
 * unreserved_keyword rule.
 */

rollup_clause:
			ROLLUP '(' expr_list ')'
				{
					$$ = (Node *) makeGroupingSet(GROUPING_SET_ROLLUP, $3, @1);
				}
		;

cube_clause:
			CUBE '(' expr_list ')'
				{
					$$ = (Node *) makeGroupingSet(GROUPING_SET_CUBE, $3, @1);
				}
		;

grouping_sets_clause:
			GROUPING_P SETS '(' group_by_list ')'
				{
					$$ = (Node *) makeGroupingSet(GROUPING_SET_SETS, $4, @1);
				}
		;


having_clause:
			HAVING a_expr							{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

start_with_clause:
            START_WITH start_with_expr connect_by_expr
                {
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = $2;
                    n->connectByExpr = $3;
                    n->siblingsOrderBy = NULL;
                    n->priorDirection = false;
                    n->nocycle = false;
                    $$ = (Node *) n;
                }
            | START_WITH start_with_expr CONNECT_BY NOCYCLE a_expr
                {
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = $2;
                    n->connectByExpr = $5;
                    n->siblingsOrderBy = NULL;
                    n->priorDirection = false;
                    n->nocycle = true;
                    $$ = (Node *) n;
                }
            | connect_by_expr START_WITH start_with_expr
                {
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = $3;
                    n->connectByExpr = $1;
                    n->siblingsOrderBy = NULL;
                    n->priorDirection = false;
                    n->nocycle = false;
                    $$ = (Node *) n;
                }
            | CONNECT_BY NOCYCLE a_expr START_WITH start_with_expr
                {
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = $5;
                    n->connectByExpr = $3;
                    n->siblingsOrderBy = NULL;
                    n->priorDirection = false;
                    n->nocycle = true;
                    $$ = (Node *) n;
                }
            | CONNECT_BY NOCYCLE a_expr
                {
#ifdef ENABLE_MULTIPLE_NODES
                      const char* message = "START WITH CONNECT BY is not yet supported.";
                      InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                      ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                         errmsg("START WITH CONNECT BY is not yet supported.")));
#endif
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = NULL;
                    n->connectByExpr = $3;
                    n->siblingsOrderBy = NULL;
                    n->priorDirection = false;
                    n->nocycle = true;
                    $$ = (Node *) n;
                }
            | connect_by_expr
                {
                    StartWithClause *n = makeNode(StartWithClause);
                    n->startWithExpr = NULL;
                    n->connectByExpr = $1;
                    $$ = (Node *) n;
                }
            |  /*EMPTY*/                            { $$ = NULL; }
        ;
start_with_expr:
            a_expr                                  { $$ = $1; }
        ;

connect_by_expr:
            CONNECT_BY a_expr
                {
#ifdef ENABLE_MULTIPLE_NODES
                      const char* message = "START WITH CONNECT BY is not yet supported.";
                      InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
                      ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                         errmsg("START WITH CONNECT BY is not yet supported.")));
#endif
                    $$ = $2;
                }
        ;

for_locking_clause:
			for_locking_items						{ $$ = $1; }
			| FOR READ ONLY							{ $$ = NIL; }
		;

opt_for_locking_clause:
			for_locking_clause						{ $$ = $1; }
			| /* EMPTY */							{ $$ = NIL; }
		;

for_locking_items:
			for_locking_item						{ $$ = list_make1($1); }
			| for_locking_items for_locking_item	{ $$ = lappend($1, $2); }
		;

for_locking_item:
			FOR UPDATE hint_string locked_rels_list opt_nowait_or_skip
				{
                    if (u_sess->parser_cxt.isTimeCapsule) {
						u_sess->parser_cxt.isTimeCapsule = false;
                      	ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                         errmsg("SELECT TIMECAPSULE FOR UPDATE is not supported.")));
                    }
					LockingClause *n = makeNode(LockingClause);
					n->lockedRels = $4;
					n->forUpdate = TRUE;
					n->strength = LCS_FORUPDATE;
					n->waitPolicy = (LockWaitPolicy)$5;
					n->waitSec = 0;
#ifdef ENABLE_MULTIPLE_NODES
					if (n->waitPolicy == LockWaitSkip) {
						DISTRIBUTED_FEATURE_NOT_SUPPORTED();
					}
#endif
					$$ = (Node *) n;
				}
			| FOR UPDATE hint_string locked_rels_list opt_wait
				{
					LockingClause *n = makeNode(LockingClause);
					n->lockedRels = $4;
					n->forUpdate = TRUE;
					n->strength = LCS_FORUPDATE;
					n->waitSec = $5;
					/* When the delay time is 0, the processing is based on the nowait logic. */
					if (n->waitSec == 0) {
						n->waitPolicy = LockWaitError;
					} else {
						n->waitPolicy = LockWaitBlock;
					}
					$$ = (Node *) n;
				}
			| for_locking_strength locked_rels_list opt_nowait_or_skip
				{
					LockingClause *n = makeNode(LockingClause);
					n->lockedRels = $2;
					n->strength = $1;
					n->forUpdate = FALSE;
					if (n->strength == LCS_FORUPDATE) {
						n->forUpdate = true;
					}
					n->waitPolicy = (LockWaitPolicy)$3;
                    n->waitSec = 0;
#ifdef ENABLE_MULTIPLE_NODES
					if (n->waitPolicy == LockWaitSkip) {
						DISTRIBUTED_FEATURE_NOT_SUPPORTED();
					}
#endif
					$$ = (Node *) n;
				}
		;

for_locking_strength:
			FOR NO KEY UPDATE
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("SELECT FOR NO KEY UPDATE is not yet supported.")));
#else
					$$ = LCS_FORNOKEYUPDATE;
#endif
				}
			| FOR SHARE							{ $$ = LCS_FORSHARE; }
			| FOR KEY SHARE
				{
#ifdef ENABLE_MULTIPLE_NODES
					ereport(ERROR,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("SELECT FOR KEY SHARE is not yet supported.")));
#else
					$$ = LCS_FORKEYSHARE;
#endif
				}
 		;

locked_rels_list:
			OF dolphin_qualified_name_list					{ $$ = $2; }
			| /* EMPTY */							{ $$ = NIL; }
		;


values_clause:
			VALUES ctext_row
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->valuesLists = list_make1($2);
					$$ = (Node *) n;
				}
			| VALUE_P ctext_row
				{
					SelectStmt *n = makeNode(SelectStmt);
					n->valuesLists = list_make1($2);
					$$ = (Node *) n;
				}
			| values_clause ',' ctext_row
				{
					SelectStmt *n = (SelectStmt *) $1;
					n->valuesLists = lappend(n->valuesLists, $3);
					$$ = (Node *) n;
				}
		;


/*****************************************************************************
 *
 *	clauses common to all Optimizable Stmts:
 *		from_clause		- allow list of both JOIN expressions and table names
 *		where_clause	- qualifications for joins or restrictions
 *
 *****************************************************************************/

from_clause:
			FROM from_list							{ $$ = $2; }
			| FROM from_list_parens						{ $$ = $2; }
			| FROM DUAL_P							{ $$ = NIL; }
			| /*EMPTY*/								%prec EMPTY_FROM_CLAUSE
				{ $$ = NIL; }
		;

from_list:
			table_ref								{ $$ = list_make1($1); }
			| from_list ',' table_ref				{ $$ = lappend($1, $3); }
		;

/*
 * table_ref is where an alias clause can be attached.	Note we cannot make
 * alias_clause have an empty production because that causes parse conflicts
 * between table_ref := '(' joined_table ')' alias_clause
 * and joined_table := '(' joined_table ')'.  So, we must have the
 * redundant-looking productions here instead.
 */

from_list_parens:
			'(' from_list_parens ')' 					{ $$ = $2; }
			| '(' from_list ',' table_ref ')'				{ $$ = lappend($2, $4); }
		;

single_table:	relation_expr		%prec UMINUS
				{
#ifndef ENABLE_MULTIPLE_NODES
        			StringInfoData detailInfo;
        			initStringInfo(&detailInfo);
					RangeVar* r = $1;
					int rc = CompileWhich();
        			if (rc != PLPGSQL_COMPILE_NULL && u_sess->attr.attr_common.plsql_show_all_error) {
						Relation rel = HeapOpenrvExtended(r, NoLock, true, true, &detailInfo);
						CatCList* catlist = SearchSysCacheList1(PROCNAMEARGSNSP, CStringGetDatum(r->relname));

						if (catlist->n_members == 0 && rel == NULL) {
        					char message[MAXFNAMELEN];
        					int rc = sprintf_s(message, MAXFNAMELEN, "relation \"%s\" does not exist", r->relname);
        					securec_check_ss(rc, "", "");
							ReleaseSysCacheList(catlist);
        					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
            				ereport(ERROR,
                				(errcode(ERRCODE_UNDEFINED_TABLE),
                    				errmsg("relation \"%s\" does not exist", r->relname),
                    				errdetail("%s", detailInfo.data)));
						} 
						if (rel != NULL) {
							heap_close(rel, NoLock);
						}
						if (catlist != NULL) {
							ReleaseSysCacheList(catlist);
						}
        			}
#endif
					$$ = (Node *) $1;
				}
			| relation_expr dolphin_alias_clause opt_index_hint_list
				{
					$1->alias = $2;
					$1->indexhints = $3;
					$$ = (Node *) $1;
				}
			| relation_expr index_hint_list
				{
					$1->indexhints = $2;
					$$ = (Node *) $1;
				}
			| relation_expr opt_dolphin_alias_clause tablesample_clause
				{
					RangeTableSample *n = (RangeTableSample *) $3;
					$1->alias = $2;
					/* relation_expr goes inside the RangeTableSample node */
					n->relation = (Node *) $1;
					$$ = (Node *) n;
				}
			| relation_expr opt_dolphin_alias_clause timecapsule_clause
				{
					RangeTimeCapsule *n = (RangeTimeCapsule *) $3;
					$1->alias = $2;
					/* relation_expr goes inside the RangeTimeCapsule node */
					n->relation = (Node *) $1;

					if (IsA($1, RangeVar)) {
						RangeVar *rv = (RangeVar *)$1;
						rv->withVerExpr = true;
					}

					$$ = (Node *) n;
				}
			| relation_expr PARTITION '(' name_list ')'
				{
					$1->partitionNameList = $4;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION '(' name ')'
				{
					$1->subpartitionname = $4;
					$1->issubpartition = true;
					$$ = (Node *)$1;
				}
			| relation_expr PARTITION_FOR '(' expr_list ')'
				{
					$1->partitionKeyValuesList = $4;
					$1->ispartition = true;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION_FOR '(' expr_list ')'
				{
					$1->partitionKeyValuesList = $4;
					$1->issubpartition = true;
					$$ = (Node *)$1;
				}
			| relation_expr PARTITION '(' name_list ')' index_hint_list
				{
					$1->partitionNameList = $4;
					$1->indexhints = $6;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION '(' name ')' index_hint_list
				{
					$1->subpartitionname = $4;
					$1->issubpartition = true;
					$1->indexhints = $6;
					$$ = (Node *)$1;
				}
			| relation_expr PARTITION_FOR '(' expr_list ')' index_hint_list
				{
					$1->partitionKeyValuesList = $4;
					$1->ispartition = true;
					$1->indexhints = $6;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION_FOR '(' expr_list ')' index_hint_list
				{
					$1->partitionKeyValuesList = $4;
					$1->issubpartition = true;
					$1->indexhints = $6;
					$$ = (Node *)$1;
				}
			| relation_expr PARTITION '(' name_list ')' dolphin_alias_clause opt_index_hint_list
				{
					$1->alias = $6;
					$1->partitionNameList = $4;
					$1->indexhints = $7;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION '(' name ')' dolphin_alias_clause opt_index_hint_list
				{
					$1->subpartitionname = $4;
					$1->alias = $6;
					$1->issubpartition = true;
					$1->indexhints = $7;
					$$ = (Node *)$1;
				}
			| relation_expr PARTITION_FOR '(' expr_list ')' dolphin_alias_clause opt_index_hint_list
				{
					$1->partitionKeyValuesList = $4;
					$1->alias = $6;
					$1->ispartition = true;
					$1->indexhints = $7;
					$$ = (Node *)$1;
				}
			| relation_expr SUBPARTITION_FOR '(' expr_list ')' dolphin_alias_clause opt_index_hint_list
				{
					$1->partitionKeyValuesList = $4;
					$1->alias = $6;
					$1->issubpartition = true;
					$1->indexhints = $7;
					$$ = (Node *)$1;
				}
			| '(' single_table ')'
				{
					$$ = $2;
				}
		;

table_ref:		single_table
				{
					$$ = $1;
				}
			| func_table		%prec UMINUS
				{
					RangeFunction *n = makeNode(RangeFunction);
					n->funccallnode = $1;
					n->coldeflist = NIL;
					$$ = (Node *) n;
				}
			| func_table alias_clause
				{
					RangeFunction *n = makeNode(RangeFunction);
					n->funccallnode = $1;
					n->alias = $2;
					n->coldeflist = NIL;
					$$ = (Node *) n;
				}
			| func_table AS '(' TableFuncElementList ')'
				{
					RangeFunction *n = makeNode(RangeFunction);
					n->funccallnode = $1;
					n->coldeflist = $4;
					$$ = (Node *) n;
				}
			| func_table AS ColId '(' TableFuncElementList ')'
				{
					RangeFunction *n = makeNode(RangeFunction);
					Alias *a = makeNode(Alias);
					n->funccallnode = $1;
					a->aliasname = $3;
					n->alias = a;
					n->coldeflist = $5;
					$$ = (Node *) n;
				}
			| func_table ColId '(' TableFuncElementList ')'
				{
					RangeFunction *n = makeNode(RangeFunction);
					Alias *a = makeNode(Alias);
					n->funccallnode = $1;
					a->aliasname = $2;
					n->alias = a;
					n->coldeflist = $4;
					$$ = (Node *) n;
				}
			| select_with_parens		%prec UMINUS
				{
					/*
					 * The SQL spec does not permit a subselect
					 * (<derived_table>) without an alias clause,
					 * so we don't either.  This avoids the problem
					 * of needing to invent a unique refname for it.
					 * That could be surmounted if there's sufficient
					 * popular demand, but for now let's just implement
					 * the spec and see if anyone complains.
					 * However, it does seem like a good idea to emit
					 * an error message that's better than "syntax error".
					 */
					/* add select_with_parens whthout alias_clause adapt A db for procedure dubug */
					$$ = NULL;
					if (IsA($1, SelectStmt) &&
						((SelectStmt *) $1)->valuesLists) {
						const char* message = "VALUES in FROM must have an alias";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("VALUES in FROM must have an alias"),
								 errhint("For example, FROM (VALUES ...) [AS] foo."),
								 parser_errposition(@1)));
					}
					else
					{
						/*
						* add a anonymous table name for this subquery
						* simulate A db to support no alias for subquery,
						* give the suqquery a default name "anonymous_table"
						*/
						RangeSubselect *n = makeNode(RangeSubselect);
						Alias *a = makeNode(Alias);
						n->subquery = $1;
						n->alias = NULL;
						a->aliasname = pstrdup("__unnamed_subquery__");
						n->alias = a;
						$$ = (Node *) n;
					}
				}
			| select_with_parens alias_clause
				{
					RangeSubselect *n = makeNode(RangeSubselect);
					n->subquery = $1;
					n->alias = $2;
					$$ = (Node *) n;
				}
			| joined_table
				{
					$$ = (Node *) $1;
				}
			| '(' joined_table ')' dolphin_alias_clause
				{
					$2->alias = $4;
					$$ = (Node *) $2;
				}
		;


/*
 * It may seem silly to separate joined_table from table_ref, but there is
 * method in SQL92's madness: if you don't do it this way you get reduce-
 * reduce conflicts, because it's not clear to the parser generator whether
 * to expect alias_clause after ')' or not.  For the same reason we must
 * treat 'JOIN' and 'join_type JOIN' separately, rather than allowing
 * join_type to expand to empty; if we try it, the parser generator can't
 * figure out when to reduce an empty join_type right after table_ref.
 *
 * Note that a CROSS JOIN is the same as an unqualified
 * INNER JOIN, and an INNER JOIN/ON has the same shape
 * but a qualification expression to limit membership.
 * A NATURAL JOIN implicitly matches column names between
 * tables and the shape is determined by which columns are
 * in common. We'll collect columns during the later transformations.
 */

joined_table:
			'(' joined_table ')'
				{
					$$ = $2;
				}
			| table_ref CROSS JOIN table_ref
				{
					/* CROSS JOIN is same as unqualified inner join */
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $4;
					n->usingClause = NIL;
					n->quals = NULL;
					$$ = n;
				}
			| table_ref join_type JOIN table_ref join_qual
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = $2;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $4;
					if ($5 != NULL && IsA($5, List))
						n->usingClause = (List *) $5; /* USING clause */
					else
						n->quals = $5; /* ON clause */
					$$ = n;
				}
			| table_ref JOIN table_ref join_qual
				{
					/* letting join_type reduce to empty doesn't work */
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $3;
					if ($4 != NULL && IsA($4, List))
						n->usingClause = (List *) $4; /* USING clause */
					else
						n->quals = $4; /* ON clause */
					$$ = n;
				}
			| table_ref JOIN table_ref 
			%prec lower_than_on
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $3;
					n->usingClause = NIL;
					n->quals = NULL;
					if (IsA($3, JoinExpr))
					{
						JoinExpr* join = (JoinExpr*)$3;
						n->rarg = join->larg;
						join->larg = (Node *)n;
						$$ = join;
					}
					else
					$$ = n;	
				}
			| table_ref NATURAL join_type JOIN table_ref
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = $3;
					n->isNatural = TRUE;
					n->larg = $1;
					n->rarg = $5;
					n->usingClause = NIL; /* figure out which columns later... */
					n->quals = NULL; /* fill later */
					$$ = n;
				}
			| table_ref NATURAL JOIN table_ref
				{
					/* letting join_type reduce to empty doesn't work */
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = TRUE;
					n->larg = $1;
					n->rarg = $4;
					n->usingClause = NIL; /* figure out which columns later... */
					n->quals = NULL; /* fill later */
					$$ = n;
				}
			| table_ref INNER_P JOIN table_ref join_qual
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $4;
					if ($5 != NULL && IsA($5, List))
						n->usingClause = (List *) $5; /* USING clause */
					else
						n->quals = $5; /* ON clause */
					$$ = n;
				}
			| table_ref INNER_P JOIN table_ref 
			%prec lower_than_on
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = FALSE;
					n->larg = $1;
					n->rarg = $4;
					n->usingClause = NIL;
					n->quals = NULL;
					if (IsA($4, JoinExpr))
					{
						JoinExpr* join = (JoinExpr*)$4;
						n->rarg = join->larg;
						join->larg = (Node *)n;
						$$ = join;
					}
					else
					$$ = n;
				}
			| table_ref NATURAL INNER_P JOIN table_ref
				{
					JoinExpr *n = makeNode(JoinExpr);
					n->jointype = JOIN_INNER;
					n->isNatural = TRUE;
					n->larg = $1;
					n->rarg = $5;
					n->usingClause = NIL; /* figure out which columns later... */
					n->quals = NULL; /* fill later */
					$$ = n;
				}
		;

alias_clause:
			AS ColId '(' name_list ')'
				{
					$$ = makeNode(Alias);
					$$->aliasname = $2;
					$$->colnames = $4;
				}
			| AS ColId
				{
					$$ = makeNode(Alias);
					$$->aliasname = $2;
				}
			| ColId '(' name_list ')'
				{
					$$ = makeNode(Alias);
					$$->aliasname = $1;
					$$->colnames = $3;
				}
			| ColId
				{
					$$ = makeNode(Alias);
					$$->aliasname = $1;
				}
		;

dolphin_alias_clause:
			AS DolphinColId '(' name_list ')'
				{
					$$ = makeNode(Alias);
					$$->aliasname = GetDolphinObjName($2->str, $2->is_quoted);
					$$->colnames = $4;
				}
			| AS DolphinColId
				{
					$$ = makeNode(Alias);
					$$->aliasname = GetDolphinObjName($2->str, $2->is_quoted);
				}
			| DolphinColId '(' name_list ')'
				{
					$$ = makeNode(Alias);
					$$->aliasname = GetDolphinObjName($1->str, $1->is_quoted);
					$$->colnames = $3;
				}
			| DolphinColId
				{
					$$ = makeNode(Alias);
					$$->aliasname = GetDolphinObjName($1->str, $1->is_quoted);
				}
		;

opt_alias_clause: alias_clause		{ $$ = $1; }
			| /*EMPTY*/	{ $$ = NULL; }
		;

opt_dolphin_alias_clause: dolphin_alias_clause		{ $$ = $1; }
			| /*EMPTY*/	{ $$ = NULL; }
		;

join_type:	FULL join_outer							{ $$ = JOIN_FULL; }
			| LEFT join_outer						{ $$ = JOIN_LEFT; }
			| RIGHT join_outer						{ $$ = JOIN_RIGHT; }
			| FULL_OUTER                            { $$ = JOIN_FULL; }
		;

/* OUTER is just noise... */
join_outer: OUTER_P									{ $$ = NULL; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

/* JOIN qualification clauses
 * Possibilities are:
 *	USING ( column list ) allows only unqualified column names,
 *						  which must match between tables.
 *	ON expr allows more general qualifications.
 *
 * We return USING as a List node, while an ON-expr will not be a List.
 */

join_qual:	USING '(' name_list ')'					{ $$ = (Node *) $3; }
			| ON a_expr								{ $$ = $2; }
		;


relation_expr:
			dolphin_qualified_name OptSnapshotVersion
				{
					/* default inheritance */
					$$ = $1;
					if ($2 != NULL)
					{
						char *snapshot_name = (char *)palloc0(strlen($1->relname) + 1 + strlen($2) + 1);
						sprintf(snapshot_name, "%s%c%s", $1->relname, DB4AI_SNAPSHOT_VERSION_DELIMITER, $2);
						$$->relname = snapshot_name;
					}
					$$->inhOpt = INH_DEFAULT;
					$$->alias = NULL;
				}
			| dolphin_qualified_name '*'
				{
					/* inheritance query */
					$$ = $1;
					$$->inhOpt = INH_YES;
					$$->alias = NULL;
				}
			/* remove ONLY dolphin_qualified_name: RESERVED_KEYWORD(only)->UNRESERVED_KEYWORD */
			| ONLY '(' dolphin_qualified_name ')'
				{
					/* no inheritance, SQL99-style syntax */
					$$ = $3;
					$$->inhOpt = INH_NO;
					$$->alias = NULL;
				}
		;


relation_expr_list:
			relation_expr							{ $$ = list_make1($1); }
			| relation_expr_list ',' relation_expr	{ $$ = lappend($1, $3); }
		;

delete_relation_expr_opt_alias:
    relation_expr_opt_alias                 %prec UMINUS
        {
            /*
             * When sql_compatibility is B, name in PARTITION(name) can be
             * a subpartition name instead of a strict partition name.
             * Put it in partitionNameList to avoid error reporting.
             */
            if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT &&
                $1->partitionname != NULL && $1->alias == NULL) {
                $1->partitionNameList = list_make1(makeString($1->partitionname));
                $1->partitionname = NULL;
                $1->ispartition = FALSE;
            }
            $$ = $1;
        }
    | relation_expr PARTITION '(' name ',' name_list ')'
        {
#ifdef ENABLE_MULTIPLE_NODES
        const char* message = "partition syntax is not yet supported";
        InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
            ereport(errstate,
                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                errmsg("partition syntax is not yet supported")));
#endif
	    if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
	        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
	                        errmsg("this partition syntax is supported only in B-format database")));
	    }
            $1->partitionNameList = lcons(makeString($4), $6);
            $$ = $1;
        }
    | relation_expr ColId PARTITION '(' name_list ')'
        {
#ifdef ENABLE_MULTIPLE_NODES
        const char* message = "partition syntax is not yet supported";
        InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
            ereport(errstate,
                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                errmsg("partition syntax is not yet supported")));
#endif
	    if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
	        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
	                        errmsg("this partition syntax is supported only in B-format database")));
	    }
            Alias *alias = makeNode(Alias);
            alias->aliasname = $2;
            $1->alias = alias;
            $1->partitionNameList = $5;
            $$ = $1;
        }
    | relation_expr AS ColId PARTITION '(' name_list ')'
        {
#ifdef ENABLE_MULTIPLE_NODES
        const char* message = "partition syntax is not yet supported";
        InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
            ereport(errstate,
                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                errmsg("partition syntax is not yet supported")));
#endif
	    if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
	        ereport(errstate, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
	                        errmsg("this partition syntax is supported only in B-format database")));
	    }
            Alias *alias = makeNode(Alias);
            alias->aliasname = $3;
            $1->alias = alias;
            $1->partitionNameList = $6;
            $$ = $1;
        }
;

/*
 * Given "UPDATE foo set set ...", we have to decide without looking any
 * further ahead whether the first "set" is an alias or the UPDATE's SET
 * keyword.  Since "set" is allowed as a column name both interpretations
 * are feasible.  We resolve the shift/reduce conflict by giving the first
 * relation_expr_opt_alias production a higher precedence than the SET token
 * has, causing the parser to prefer to reduce, in effect assuming that the
 * SET is not an alias.
 */
relation_expr_opt_alias: relation_expr					%prec UMINUS
				{
					$$ = $1;
				}
			| relation_expr DolphinColId
				{
					Alias *alias = makeNode(Alias);
					alias->aliasname = GetDolphinObjName($2->str, $2->is_quoted);
					$1->alias = alias;
					$$ = $1;
				}
			| relation_expr AS DolphinColId
				{
					Alias *alias = makeNode(Alias);
					alias->aliasname = GetDolphinObjName($3->str, $3->is_quoted);
					$1->alias = alias;
					$$ = $1;
				}
			| relation_expr  update_delete_partition_clause 			%prec UMINUS
				{
					if ($2 != NULL) {
						$1->partitionname = $2->partitionname;
						$1->ispartition = $2->ispartition;
						$1->partitionKeyValuesList = $2->partitionKeyValuesList;
						$1->subpartitionname = $2->subpartitionname;
						$1->issubpartition = $2->issubpartition;
					}
					$$ = $1;
				}
			| relation_expr update_delete_partition_clause DolphinColId
				{
					if ($2 != NULL) {
						$1->partitionname = $2->partitionname;
						$1->ispartition = $2->ispartition;
						$1->partitionKeyValuesList = $2->partitionKeyValuesList;
						$1->subpartitionname = $2->subpartitionname;
						$1->issubpartition = $2->issubpartition;
					}
					Alias *alias = makeNode(Alias);
					alias->aliasname = GetDolphinObjName($3->str, $3->is_quoted);
					$1->alias = alias;
					$$ = $1;
				}
			| relation_expr update_delete_partition_clause AS DolphinColId
				{
					if ($2 != NULL) {
						$1->partitionname = $2->partitionname;
						$1->ispartition = $2->ispartition;
						$1->partitionKeyValuesList = $2->partitionKeyValuesList;
						$1->subpartitionname = $2->subpartitionname;
						$1->issubpartition = $2->issubpartition;
					}
					Alias *alias = makeNode(Alias);
					alias->aliasname = GetDolphinObjName($4->str, $4->is_quoted);
					$1->alias = alias;
					$$ = $1;
				}
		;

relation_expr_opt_alias_list: 
			delete_relation_expr_opt_alias                                      { $$ = list_make1($1); }
			| relation_expr_opt_alias_list ',' delete_relation_expr_opt_alias   { $$ = lappend($1, $3); }
		;
/*
 * TABLESAMPLE decoration in a FROM item
 */
tablesample_clause:
			TABLESAMPLE func_name '(' expr_list ')' opt_repeatable_clause
				{
					RangeTableSample *n = makeNode(RangeTableSample);
					/* n->relation will be filled in later */
					n->method = $2;
					n->args = $4;
					n->repeatable = $6;
					n->location = @2;
					$$ = (Node *) n;
				}
		;

/*
 * TIMECAPSULE decoration in a FROM item
 */
timecapsule_clause:
			TIMECAPSULE opt_timecapsule_clause { $$ = $2; }
		;

opt_timecapsule_clause:
			 CSN {u_sess->parser_cxt.isTimeCapsule = true;} a_expr
				{
					TcapFeatureEnsure();
					RangeTimeCapsule *n = makeNode(RangeTimeCapsule);
					n->tvtype = TV_VERSION_CSN;
					n->tvver = (Node *)$3;
					n->location = @3;
					$$ = (Node *) n;
				}
			| TIMESTAMP {u_sess->parser_cxt.isTimeCapsule = true;} a_expr
				{
					TcapFeatureEnsure();
					RangeTimeCapsule *n = makeNode(RangeTimeCapsule);
					n->tvtype = TV_VERSION_TIMESTAMP;
					n->tvver = (Node *)$3;
					n->location = @3;
					$$ = (Node *) n;
				}
		;

opt_repeatable_clause:
			REPEATABLE '(' a_expr ')'	{ $$ = (Node *) $3; }
			| /*EMPTY*/			{ $$ = NULL; }
		;


func_table: func_expr_windowless					{ $$ = $1; }
		;


where_clause:
			WHERE a_expr							{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

/* variant for UPDATE and DELETE */
where_or_current_clause:
			WHERE a_expr							{ $$ = $2; }
			| WHERE CURRENT_P OF cursor_name
				{
					CurrentOfExpr *n = makeNode(CurrentOfExpr);
					/* cvarno is filled in by parse analysis */
					n->cursor_name = $4;
					n->cursor_param = 0;
					$$ = (Node *) n;
				}
			| /*EMPTY*/								{ $$ = NULL; }
		;


OptTableFuncElementList:
			TableFuncElementList				{ $$ = $1; }
			| /*EMPTY*/							{ $$ = NIL; }
		;

TableFuncElementList:
			TableFuncElement
				{
					$$ = list_make1($1);
				}
			| TableFuncElementList ',' TableFuncElement
				{
					$$ = lappend($1, $3);
				}
		;

TableFuncElement:	ColId func_type opt_collate_clause
				{
					ColumnDef *n = makeNode(ColumnDef);
					n->colname = $1;
					n->typname = $2;
					n->inhcount = 0;
					n->is_local = true;
					n->is_not_null = false;
					n->is_from_type = false;
					n->storage = 0;
					n->raw_default = NULL;
					n->cooked_default = NULL;
					n->collClause = (CollateClause *) $3;
					n->clientLogicColumnRef=NULL;
					n->collOid = InvalidOid;
					n->constraints = NIL;
					$$ = (Node *)n;
				}
		;

/*****************************************************************************
 *
 *	Type syntax
 *		SQL92 introduces a large amount of type-specific syntax.
 *		Define individual clauses to handle these cases, and use
 *		 the generic case to handle regular type-extensible Postgres syntax.
 *		- thomas 1997-10-10
 *
 *****************************************************************************/

Typename:	SimpleTypename opt_array_bounds
				{
					$$ = $1;
					$$->arrayBounds = $2;
				}
			| SETOF SimpleTypename opt_array_bounds
				{
					$$ = $2;
					$$->arrayBounds = $3;
					$$->setof = TRUE;
				}
			/* SQL standard syntax, currently only one-dimensional */
			| SimpleTypename ARRAY '[' Iconst ']'
				{
					$$ = $1;
					$$->arrayBounds = list_make1(makeInteger($4));
				}
			| SETOF SimpleTypename ARRAY '[' Iconst ']'
				{
					$$ = $2;
					$$->arrayBounds = list_make1(makeInteger($5));
					$$->setof = TRUE;
				}
			| SimpleTypename ARRAY
				{
					$$ = $1;
					$$->arrayBounds = list_make1(makeInteger(-1));
				}
			| SETOF SimpleTypename ARRAY
				{
					$$ = $2;
					$$->arrayBounds = list_make1(makeInteger(-1));
					$$->setof = TRUE;
				}
		;

opt_array_bounds:
			opt_array_bounds '[' ']'
					{  $$ = lappend($1, makeInteger(-1)); }
			| opt_array_bounds '[' Iconst ']'
					{  $$ = lappend($1, makeInteger($3)); }
			| /*EMPTY*/
					{  $$ = NIL; }
		;

SimpleTypename:
			GenericType								{ $$ = $1; }
			| Numeric								{ $$ = $1; }
			| Bit									{ $$ = $1; }
			| Character								{ $$ = $1; }
			| ConstDatetime							{ $$ = $1; }
			| ConstSet								{ $$ = $1; }
			| INTERVAL opt_interval
				{
					$$ = SystemTypeName("interval");
					$$->location = @1;
					$$->typmods = $2;
				}
			| INTERVAL '(' Iconst ')' opt_interval
				{
					$$ = SystemTypeName("interval");
					$$->location = @1;
					if ($5 != NIL)
					{
						if (list_length($5) != 1) {
							const char* message = "interval precision specified twice";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("interval precision specified twice"),
									 parser_errposition(@1)));
						}
						$$->typmods = lappend($5, makeIntConst($3, @3));
					}
					else
						$$->typmods = list_make2(makeIntConst(INTERVAL_FULL_RANGE, -1),
												 makeIntConst($3, @3));
				}
			| VARBINARY opt_type_modifiers
				{
					$$ = SystemTypeName("varbinary");
					$$->location = @1;
					$$->typmods = $2;
					Type typtup = LookupTypeName(NULL, $$, NULL);
					if (typtup) {
						if ($$->typmods == NIL) {
							$$->typmods = list_make1((Node*)makeIntConst(1, 1));
						}
						ReleaseSysCache(typtup);
					}
				}
			| BINARY opt_type_modifiers
				{
					$$ = SystemTypeName("binary");
                                        $$->typmods = $2;
					$$->location = @1;
				}
			| EnumType  '(' opt_enum_val_list ')'
				{
					$$ = $1;
					$$->typmods = $3;
				}

		;

/* We have a separate ConstTypename to allow defaulting fixed-length
 * types such as CHAR() and BIT() to an unspecified length.
 * SQL9x requires that these default to a length of one, but this
 * makes no sense for constructs like CHAR 'hi' and BIT '0101',
 * where there is an obvious better choice to make.
 * Note that ConstInterval is not included here since it must
 * be pushed up higher in the rules to accommodate the postfix
 * options (e.g. INTERVAL '1' YEAR). Likewise, we have to handle
 * the generic-type-name case in AExprConst to avoid premature
 * reduce/reduce conflicts against function names.
 */
ConstTypename:
			NumericNoConflict						{ $$ = $1; }
			| ConstSet								{ $$ = $1; }
		;

/*
 * GenericType covers all type names that don't have special syntax mandated
 * by the standard, including qualified names.  We also allow type modifiers.
 * To avoid parsing conflicts against function invocations, the modifiers
 * have to be shown as expr_list here, but parse analysis will only accept
 * constants for them.
 */
GenericType:
			type_function_name opt_type_modifiers
				{
					/* for B_FORMAT compatibility, float4(n) refers to float4 */
					if (($1 != NULL) && (strcmp($1, "float4") == 0 || strcmp($1, "float") == 0)) {
						$$ = transferFloat4TypeInBFormat($1, $2, @2, yyscanner);
					} else if (($1 != NULL) && (strcmp($1, "double") == 0) && ($2 != NULL) && (list_length($2) == 2)) {
						if ((*(A_Const*)list_nth($2, 1)).val.val.ival == 0) {
							$$ = parseFloatTypeByPrecision((*(A_Const*)list_nth($2, 0)).val.val.ival, @2, yyscanner, false);
							$$->location = @1;
						} else {
							$$ = SystemTypeName("numeric");
							$$->typmods = $2;
							$$->location = @1;
						}
						/* for B_FORMAT compatibility, real and double refer to float8 */
					} else if (($1 != NULL) && ((strcmp($1, "real") == 0 || strcmp($1, "double") == 0))) {
						$$ = makeTypeName("float8");
					$$->typmods = $2;
					} else if (($1 != NULL) && (strcasecmp($1, "blob") == 0) && ($2 != NULL) && (list_length($2) == 1)) {
						Node* node = (Node*)linitial($2);
						if (IsA(node, A_Const)) {
							A_Const* cnt = (A_Const*)node;
							uint n;
							switch (nodeTag(&cnt->val)) {
								case T_Integer: {
									long ival = cnt->val.val.ival;
									if (ival >= MIN_TINYBLOB && ival <= MAX_LONGBLOB) {
										n = (uint)ival;
									} else {
										ereport(ERROR, (errmsg("Out of range for the parameter value of blob(n)")));
									}
									break;
								}
								case T_Float: {
									double ft = atof(cnt->val.val.str);
									if (ft >= MIN_TINYBLOB && ft < MAX_LONGBLOB + 1) {
										n = (uint)ft;
									} else {
										ereport(ERROR, (errmsg("Out of range for the parameter value of blob(n)")));
									}
									break;
								}
								default:
									ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
										errmsg("Invalid parameter for blob(n)")));
									break;
							}

							if (n < MIN_BLOB) {
								$$ = makeTypeName("tinyblob");
							} else if (n < MIN_MEDIUMBLOB) {
								$$ = makeTypeName("blob");
							} else if (n < MIN_LONGBLOB) {
								$$ = makeTypeName("mediumblob");
							} else {
								$$ = makeTypeName("longblob");
							}
						} else {
							ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
								errmsg("Invalid parameter for blob(n)")));
						}
					} else {
						$$ = makeTypeName($1);
						$$->typmods = $2;
					}
				}
			| type_function_name attrs opt_type_modifiers
				{
					$$ = makeTypeNameFromNameList(lcons(makeString($1), $2));
					$$->typmods = $3;
					$$->location = @1;
				}
			| type_function_name unsigned_list
			{
				if (($1 != NULL) && (strcmp($1, "int1") == 0)) {
					$$ = SystemTypeName("uint1");
					$$->location = @1;
				} else if (($1 != NULL) && (strcmp($1, "int2") == 0)) {
					$$ = SystemTypeName("uint2");
					$$->location = @1;
				} else if (($1 != NULL) && (strcmp($1, "int4") == 0)) {
					$$ = SystemTypeName("uint4");
					$$->location = @1;
				} else if (($1 != NULL) && (strcmp($1, "int8") == 0)) {
					$$ = SystemTypeName("uint8");
					$$->location = @1;
				} else {
					ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("syntax error"),
						parser_errposition(@2)));
				}
			}
		;

/*
	enum type
*/
EnumType:
			ENUM_P
				{
					$$ = makeTypeName("enum");
					$$->location = @1;
				}
		;

opt_type_modifiers: '(' expr_list ')'				{ $$ = $2; }
					| /* EMPTY */					{ $$ = NIL; }
		;

field_unsigned:
		unsigned_list							{ $$ = TRUE; }
		| /* empty */							{ $$ = FALSE; }
		;

unsigned_list:
		opt_unsigned
		| unsigned_list opt_unsigned
		;

opt_unsigned:		%prec UMINUS
		UNSIGNED
		| ZEROFILL
		;

NumericNoConflict:	INT_P unsigned_list
				{
					$$ = SystemTypeName("uint4");
					$$->location = @1;
				}
			| INT_P '(' expr_list ')' field_unsigned
				{
					if ($5) {
						$$ = SystemTypeName("uint4");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int4");
						$$->location = @1;
					}
				}
			| INTEGER unsigned_list
				{
					$$ = SystemTypeName("uint4");
					$$->location = @1;
				}
			| INTEGER '(' expr_list ')' field_unsigned
				{
					if ($5) {
						$$ = SystemTypeName("uint4");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int4");
						$$->location = @1;
					}
				}
			| TINYINT unsigned_list 
				{
					$$ = SystemTypeName("uint1");
					$$->location = @1;
				}
			| TINYINT '(' expr_list ')' field_unsigned 
				{
					if ($5) {
						$$ = SystemTypeName("uint1");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int1");
						$$->location = @1;
					}
				}
			| SMALLINT unsigned_list
				{
					$$ = SystemTypeName("uint2");
					$$->location = @1;
				}
			| SMALLINT '(' expr_list ')' field_unsigned
				{
					if ($5) {
						$$ = SystemTypeName("uint2");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int2");
						$$->location = @1;
					}
				}
			| MEDIUMINT unsigned_list
				{
					$$ = SystemTypeName("uint4");
					$$->location = @1;
				}
			| MEDIUMINT '(' expr_list ')' field_unsigned
				{
					if ($5) {
						$$ = SystemTypeName("uint4");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int4");
						$$->location = @1;
					}
				}
			| BIGINT unsigned_list
				{
					$$ = SystemTypeName("uint8");
					$$->location = @1;
				}
			| BIGINT '(' expr_list ')' field_unsigned
				{
					if ($5) {
						$$ = SystemTypeName("uint8");
						$$->location = @1;
					} else {
						$$ = SystemTypeName("int8");
						$$->location = @1;
					}
				}
			| REAL dolphin_float
				{
					$$ = $2;
					$$->location = @1;
				}
			| FLOAT_P opt_float_noempty
				{
					$$ = $2;
					$$->location = @1;
				}
			| DOUBLE_P PRECISION
				{
					$$ = SystemTypeName("float8");
					$$->location = @1;
				}
			| DOUBLE_P PRECISION dolphin_float
				{
					$$ = $3;
					$$->location = @1;
				}
			| DECIMAL_P '(' expr_list ')'
				{
					$$ = SystemTypeName("numeric");
					$$->typmods = $3;
					$$->location = @1;
				}
			| NUMBER_P '(' expr_list ')'
				{
					$$ = SystemTypeName("numeric");
					$$->typmods = $3;
					$$->location = @1;
				}
			| DEC '(' expr_list ')'
				{
					$$ = SystemTypeName("numeric");			
					$$->typmods = $3;
					$$->location = @1;
				}
			| NUMERIC '(' expr_list ')'
				{
					$$ = SystemTypeName("numeric");			
					$$->typmods = $3;
					$$->location = @1;
				}
			| FIXED_P '(' expr_list ')'
				{
					$$ = SystemTypeName("numeric");
					$$->typmods = $3;
					$$->location = @1;
				}
		;

/*
 * SQL92 numeric data types
 */
Numeric:	NumericNoConflict { $$ = $1; }
			| INT_P
				{
					$$ = SystemTypeName("int4");
					$$->location = @1;
				}
			| INTEGER
				{
					$$ = SystemTypeName("int4");
					$$->location = @1;
				}
			| TINYINT
				{
					$$ = SystemTypeName("int1");
					$$->location = @1;
				}
			| SMALLINT
				{
					$$ = SystemTypeName("int2");
					$$->location = @1;
				}
			| MEDIUMINT
				{
					$$ = SystemTypeName("int4");
					$$->location = @1;
				}
			| BIGINT
				{
					$$ = SystemTypeName("int8");
					$$->location = @1;
				}
			| REAL
				{
					$$ = SystemTypeName("float4");
					$$->location = @1;
				}
			| FLOAT_P
				{
					/* for B_FORMAT compatibility, float refers to float4 */
					$$ = SystemTypeName("float4");
					$$->location = @1;
				}
			| BINARY_DOUBLE
				{
					$$ = SystemTypeName("float8");
					$$->location = @1;
				}
			| BINARY_INTEGER
				{
					$$ = SystemTypeName("int4");
					$$->location = @1;
				}
			| DECIMAL_P
				{
					$$ = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmp = list_make1(makeIntConst(10, -1));
					tmp = lappend(tmp, makeIntConst(0, -1));  
					$$->typmods = tmp;
					$$->location = @1;
				}
			| NUMBER_P
				{
					$$ = SystemTypeName("numeric");
					$$->typmods = NULL;
					$$->location = @1;
				}
			| DEC
				{
					$$ = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmp = list_make1(makeIntConst(10, -1));
					tmp = lappend(tmp, makeIntConst(0, -1));  
					$$->typmods = tmp;
					$$->location = @1;
				}
			| NUMERIC
				{
					$$ = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmp = list_make1(makeIntConst(10, -1));
					tmp = lappend(tmp, makeIntConst(0, -1));  
					$$->typmods = tmp;
					$$->location = @1;
				}
			| FIXED_P
				{
					$$ = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmp = list_make1(makeIntConst(10, -1));
					tmp = lappend(tmp, makeIntConst(0, -1));  
					$$->typmods = tmp;
					$$->location = @1;
				}
			| BOOLEAN_P
				{
					$$ = SystemTypeName("bool");
					$$->location = @1;
				}
		;

dolphin_float: '(' Iconst ',' Iconst ')'
				{
					if ($4 == 0) {
						$$ = parseFloatTypeByPrecision($2, @2, yyscanner, false);
					} else {
						$$ = SystemTypeName("numeric");
						$$->typmods = list_make2(makeIntConst($2, @2), makeIntConst($4, @4));
					}
				}
		;

opt_float_noempty:	'(' Iconst ')'
				{
					/*
					 * Check FLOAT() precision limits assuming IEEE floating
					 * types - thomas 1997-09-18
					 */
					$$ = parseFloatTypeByPrecision($2, @2, yyscanner);
				}
			| dolphin_float {$$ = $1;}
		;

opt_float:	opt_float_noempty {$$ = $1;}
			| /*EMPTY*/
				{
					/* for B_FORMAT compatibility, float refers to float4 */
					$$ = SystemTypeName("float4");
				}
		;

/*
 * SQL92 bit-field data types
 * The following implements BIT() and BIT VARYING().
 */
Bit:		BitWithLength
				{
					$$ = $1;
				}
			| BitWithoutLength
				{
					$$ = $1;
				}
		;

/* ConstBit is like Bit except "BIT" defaults to unspecified length */
/* See notes for ConstCharacter, which addresses same issue for "CHAR" */
ConstBit:	BitWithLength
				{
					$$ = $1;
				}
			| BitWithoutLength
				{
					$$ = $1;
					$$->typmods = NIL;
				}
		;

BitWithLength:
			BIT opt_varying '(' expr_list ')'
				{
					char *typname;

					typname = (char *)($2 ? "varbit" : "bit");
					$$ = SystemTypeName(typname);
					$$->typmods = $4;
					$$->location = @1;
				}
		;

BitWithoutLength:
			BIT opt_varying
				{
					/* bit defaults to bit(1), varbit to no limit */
					if ($2)
					{
						$$ = SystemTypeName("varbit");
					}
					else
					{
						$$ = SystemTypeName("bit");
						$$->typmods = list_make1(makeIntConst(1, -1));
					}
					$$->location = @1;
				}
		;


/*
 * SQL92 character data types
 * The following implements CHAR() and VARCHAR().
 */
Character:  CharacterWithLength
				{
					$$ = $1;
				}
			| CharacterWithoutLength
				{
					$$ = $1;
				}
		;

ConstCharacter:  CharacterWithLength
				{
					$$ = $1;
				}
			| CharacterWithoutLength
				{
					/* Length was not specified so allow to be unrestricted.
					 * This handles problems with fixed-length (bpchar) strings
					 * which in column definitions must default to a length
					 * of one, but should not be constrained if the length
					 * was not specified.
					 */
					$$ = $1;
					$$->typmods = NIL;
				}
		;

CharacterWithLength:  character '(' a_expr ')'
				{
					$$ = SystemTypeName($1);
					$$->typmods = list_make1($3);
					$$->location = @1;
				}
			| CHAR_P '(' a_expr ')'
			{
				// If the type of $3 is not Iconst, an error is reported
				CheckIconstType($3);

				$$ = SystemTypeName((char *)("bpchar"));
				$$->typmods = list_make1($3);
				$$->location = @1;
			}
			| CHAR_P VARYING '(' a_expr ')'
			{
				// If the type of $4 is not Iconst, an error is reported
				CheckIconstType($4);

				$$ = SystemTypeName((char *)("varchar"));
				$$->typmods = list_make1($4);
				$$->location = @1;
			}
			| TEXT_P '(' a_expr ')'
			{
				$$ = SystemTypeName("text");
				$$->location = @1;
			}
		;

CharacterWithoutLength:	 character
				{
					$$ = SystemTypeName($1);

					/* char defaults to char(1), varchar to no limit */
					if (!ENABLE_B_CMPT_MODE && strcmp($1, "bpchar") == 0) {
						$$->typmods = list_make1(makeIntConst(1, -1));
					}

					$$->location = @1;
				}
			| CHAR_P
				{
					$$ = SystemTypeName((char *)("bpchar"));

					/* char defaults to char(1), varchar to no limit */
					if (!ENABLE_B_CMPT_MODE) {
						$$->typmods = list_make1(makeIntConst(1, -1));
					}

					$$->location = @1;
				}
			| CHAR_P VARYING
				{
					$$ = SystemTypeName((char *)("varchar"));

					$$->location = @1;
				}
			| TEXT_P
				{
					$$ = SystemTypeName("text");
					$$->location = @1;
				}
		;

character:	CHARACTER opt_varying
										{ $$ = (char *)($2 ? "varchar": "bpchar"); }
			| NVARCHAR
										{ $$ = "nvarchar2"; }
			| NVARCHAR2
										{ $$ = "nvarchar2"; }
			| NATIONAL VARCHAR
										{ $$ = "nvarchar2"; }
			| VARCHAR
										{ $$ = "varchar"; }
			| VARCHAR2
										{ $$ = "varchar"; }
			| NATIONAL CHARACTER opt_varying
										{ $$ = (char *)($3 ? "varchar": "bpchar"); }
			| NATIONAL CHAR_P opt_varying
										{ $$ = (char *)($3 ? "varchar": "bpchar"); }
			| NCHAR opt_varying
										{ $$ = (char *)($2 ? "varchar": "bpchar"); }
		;

opt_varying:
			VARYING									{ $$ = TRUE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

character_set:
			CHARACTER SET
			| CHARSET
		;

charset_collate_name:
			ColId									{ $$ = $1; }
			| SCONST								{ $$ = $1; }
		;

charset:
			character_set charset_collate_name
			{
#ifdef ENABLE_MULTIPLE_NODES
				const char* message = "specifying character sets and collations is not yet supported";
				InsertErrorMessage(message, u_sess->plsql_cxt.gsplsql_yylloc);
				ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("specifying character sets and collations is not yet supported")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("specifying character sets and collations is supported only in B-format database")));
				}
				int encoding = pg_valid_server_encoding($2);
				if (encoding < 0) {
					ereport(WARNING, (errmsg("%s is not a valid encoding name. default value set", $2)));
					$$ = PG_INVALID_ENCODING;
				} else {
					$$ = encoding;
				}
			}
		;

convert_charset:
			charset
			{
				$$ = $1;
			}
			| character_set DEFAULT
			{
#ifdef ENABLE_MULTIPLE_NODES
				const char* message = "specifying character sets and collations is not yet supported";
				InsertErrorMessage(message, u_sess->plsql_cxt.gsplsql_yylloc);
				ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("specifying character sets and collations is not yet supported")));
#endif
				if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
					ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
						errmsg("specifying character sets and collations is supported only in B-format database")));
				}
				$$ = PG_INVALID_ENCODING;
			}
		;

opt_charset:
			charset
			{
				$$ = $1;
			}
			| /*EMPTY*/
			{
				$$ = PG_INVALID_ENCODING;
			}
		;

default_charset:
			DEFAULT character_set opt_equal charset_collate_name
			{
				int encoding = pg_valid_server_encoding($4);
				if (encoding < 0) {		
					ereport(WARNING, (errmsg("%s is not a valid encoding name. default value set", $4)));
					$$ = PG_INVALID_ENCODING;
				} else {
					$$ = encoding;
				}
			}
			| character_set opt_equal charset_collate_name
			{
				int encoding = pg_valid_server_encoding($3);
				if (encoding < 0) {
					ereport(WARNING, (errmsg("%s is not a valid encoding name. default value set", $3)));
					$$ = PG_INVALID_ENCODING;
				} else {
					$$ = encoding;
				}
			}
		;

optCharsetCollate:
			CharsetCollate			{ $$ = $1; }
			| /* EMPTY */			{ $$ = NULL;}
		;

CharsetCollate:
			charset_collate
			{
				$$ = MakeCharsetCollateOptions(NULL, $1);
			}
			| CharsetCollate charset_collate
			{
				$$ = MakeCharsetCollateOptions($1, $2);
			}
		;

charset_collate:
			default_charset
			{
				CharsetCollateOptions *n = (CharsetCollateOptions*)palloc0(sizeof(CharsetCollateOptions));
				n->cctype = OPT_CHARSET;
				n->charset = $1;
				$$ = n;
			}
			| default_collate
			{
				CharsetCollateOptions *n = (CharsetCollateOptions*)palloc0(sizeof(CharsetCollateOptions));
				n->cctype = OPT_COLLATE;
				n->collate = $1;
				$$ = n;
			}
		;

/*
 * SQL92 date/time types: compatiable for b format database(default typmod set to zero)
 */
ConstDatetime:
			TIMESTAMP '(' a_expr ')' selected_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					CheckIconstType($3);

					if ($5 == NULL) {
						$$ = SystemTypeName("timestamptz");
					} else {
						if (strcmp($5, "TRUE") == 0)
							$$ = SystemTypeName("timestamptz");
						else
							$$ = SystemTypeName("timestamp");
					}
					$$->typmods = list_make1($3);
					$$->location = @1;
				}
			| TIMESTAMP selected_timezone
				{
					if ($2 == NULL) {
						$$ = SystemTypeName("timestamptz");
						$$->typmods = list_make1(makeIntConst(0, -1));
					} else {
						if (strcmp($2, "TRUE") == 0)
							$$ = SystemTypeName("timestamptz");
						else
							$$ = SystemTypeName("timestamp");
					}
					$$->location = @1;
				}
			| TIME '(' a_expr ')' opt_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					CheckIconstType($3);

					if ($5)
						$$ = SystemTypeName("timetz");
					else
						$$ = SystemTypeName("time");
					$$->typmods = list_make1($3);
					$$->location = @1;
				}
			| TIME selected_timezone
				{
					if ($2 == NULL) {
						$$ = SystemTypeName("time");
						$$->typmods = list_make1(makeIntConst(0, -1));
					} else {
						if (strcmp($2, "TRUE") == 0)
							$$ = SystemTypeName("timetz");
						else 
							$$ = SystemTypeName("time");
					}
					$$->location = @1;
				}
			| DATE_P
				{
					if (u_sess->attr.attr_sql.sql_compatibility == A_FORMAT)
					{
						$$ = SystemTypeName("timestamp");
						$$->typmods = list_make1(makeIntConst(0,-1));
					}
					else
						$$ = SystemTypeName("date");
					$$->location = @1;
					$$->end_location = @1 + DATE_LEN;
				}
			| SMALLDATETIME
				{
					$$ = SystemTypeName("smalldatetime");
					$$->location = @1;
				}
			| DATETIME '(' Iconst ')'
			    {
					$$ = SystemTypeName("timestamp");
					$$->typmods = list_make1(makeIntConst($3,@3));
					$$->location = @1;
			    }
			| DATETIME
			    {
					$$ = SystemTypeName("timestamp");
					$$->typmods = list_make1(makeIntConst(0,-1));
					$$->location = @1;
			    }
		;

/*
 * SQL92 date/time types: default typmod set to six
 */
PreciseConstDatetime: 
			TIMESTAMP '(' a_expr ')' opt_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					CheckIconstType($3);

					if ($5)
						$$ = SystemTypeName("timestamptz");
					else
						$$ = SystemTypeName("timestamp");
					$$->typmods = list_make1($3);
					$$->location = @1;
				}
			| TIMESTAMP opt_timezone
				{
					if ($2)
						$$ = SystemTypeName("timestamptz");
					else
						$$ = SystemTypeName("timestamp");
					$$->location = @1;
				}
			| TIME '(' a_expr ')' opt_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					CheckIconstType($3);
					
					if ($5)
						$$ = SystemTypeName("timetz");
					else
						$$ = SystemTypeName("time");
					$$->typmods = list_make1($3);
					$$->location = @1;
				}
			| TIME opt_timezone
				{
					if ($2)
						$$ = SystemTypeName("timetz");
					else
						$$ = SystemTypeName("time");
					$$->location = @1;
				}
			| DATE_P
				{
					if (u_sess->attr.attr_sql.sql_compatibility == A_FORMAT)
					{
						$$ = SystemTypeName("timestamp");
						$$->typmods = list_make1(makeIntConst(0,-1));
					}
					else
						$$ = SystemTypeName("date");
					$$->location = @1;
					$$->end_location = @1 + DATE_LEN;
				}
			| SMALLDATETIME
				{
					$$ = SystemTypeName("smalldatetime");
					$$->location = @1;
				}
			| DATETIME '(' Iconst ')'
			    {
					$$ = SystemTypeName("timestamp");
					$$->typmods = list_make1(makeIntConst($3,@3));
					$$->location = @1;
			    }
			| DATETIME
			    {
					$$ = SystemTypeName("timestamp");
					$$->location = @1;
			    }
		;

ConstSet:
            SET '(' opt_enum_val_list ')'
                {
#ifdef ENABLE_MULTIPLE_NODES
                    ereport(ERROR,
                        (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                        errmsg("set type is not yet supported."),
                        parser_errposition(@1)));
#else
                    if (!DB_IS_CMPT(B_FORMAT)) {
                        ereport(ERROR,
                            (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                            errmsg("set type is not yet supported."),
                            parser_errposition(@1)));
                    } else {
                        $$ = makeTypeName("set");
                        $$->typmods = $3;
                        $$->location = @1;
                    }
#endif
                }
        ;

opt_timezone:
			WITH_TIME ZONE							{ $$ = TRUE; }
			| WITHOUT TIME ZONE						{ $$ = FALSE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

opt_evtime_unit:
			DAY_HOUR_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR), @1));
			}
			| DAY_MINUTE_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
			}
			| DAY_SECOND_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE) |
												 INTERVAL_MASK(SECOND), @1));
			}
			| HOUR_MINUTE_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
			}
			| HOUR_SECOND_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE) |
												 INTERVAL_MASK(SECOND), @1));
			}
			| MINUTE_SECOND_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(MINUTE) |
												 INTERVAL_MASK(SECOND), @1));
			}
			| YEAR_MONTH_P
			{
				$$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR) |
												 INTERVAL_MASK(MONTH), @1));
			}
		;

selected_timezone:
			WITH_TIME ZONE							{ $$ = "TRUE"; }
			| WITHOUT TIME ZONE						{ $$ = "FALSE"; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

opt_single_interval:
			/* Interval units containing only a single part */
			YEAR_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR), @1)); }
			| MONTH_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MONTH), @1)); }
			| DAY_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(DAY), @1)); }
			| HOUR_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR), @1)); }
			| MINUTE_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MINUTE), @1)); }
			| YEAR_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR), @1)); }
			| MONTH_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MONTH), @1)); }
			| DAY_P '(' Iconst ')'
				{  $$ = list_make1(makeIntConst(INTERVAL_MASK(DAY), @1));   }
			| HOUR_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR), @1)); }
			| MINUTE_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MINUTE), @1)); }
		;

opt_multipart_interval:
			/* Interval units containing multiple parts */
			interval_second /* Second contain integer and fraction parts */
				{ $$ = $1; }
			| YEAR_P TO MONTH_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR) |
												 INTERVAL_MASK(MONTH), @1));
				}
			| DAY_P TO HOUR_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR), @1));
				}
			| DAY_P TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| DAY_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(DAY) |
												INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| HOUR_P TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| HOUR_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| MINUTE_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| YEAR_P '(' Iconst ')' TO MONTH_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR) |
												 INTERVAL_MASK(MONTH), @1));
				}
			| DAY_P '(' Iconst ')'  TO HOUR_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR), @1));
				}
			| DAY_P '(' Iconst ')'   TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| DAY_P '(' Iconst ')' TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(DAY) |
												INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| HOUR_P '(' Iconst ')'  TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| HOUR_P '(' Iconst ')'   TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| MINUTE_P  '(' Iconst ')'  TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| /*EMPTY*/
				{ $$ = NIL; }
		;

opt_interval:
			YEAR_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR), @1)); }
			| MONTH_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MONTH), @1)); }
			| DAY_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(DAY), @1)); }
			| HOUR_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR), @1)); }
			| MINUTE_P
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MINUTE), @1)); }
			| interval_second
				{ $$ = $1; }
			| YEAR_P TO MONTH_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR) |
												 INTERVAL_MASK(MONTH), @1));
				}
			| DAY_P TO HOUR_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR), @1));
				}
			| DAY_P TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| DAY_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(DAY) |
												INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| HOUR_P TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| HOUR_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| MINUTE_P TO interval_second
				{
					$$ = $3;
					linitial($$) = makeIntConst(INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| YEAR_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR), @1)); }
			| MONTH_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MONTH), @1)); }
			| DAY_P '(' Iconst ')'
				{  $$ = list_make1(makeIntConst(INTERVAL_MASK(DAY), @1));   }
			| HOUR_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR), @1)); }
			| MINUTE_P '(' Iconst ')'
				{ $$ = list_make1(makeIntConst(INTERVAL_MASK(MINUTE), @1)); }
			| YEAR_P '(' Iconst ')' TO MONTH_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(YEAR) |
												 INTERVAL_MASK(MONTH), @1));
				}
			| DAY_P '(' Iconst ')'  TO HOUR_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR), @1));
				}
			| DAY_P '(' Iconst ')'   TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(DAY) |
												 INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| DAY_P '(' Iconst ')' TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(DAY) |
												INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| HOUR_P '(' Iconst ')'  TO MINUTE_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(HOUR) |
												 INTERVAL_MASK(MINUTE), @1));
				}
			| HOUR_P '(' Iconst ')'   TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(HOUR) |
												INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| MINUTE_P  '(' Iconst ')'  TO interval_second
				{
					$$ = $6;
					linitial($$) = makeIntConst(INTERVAL_MASK(MINUTE) |
												INTERVAL_MASK(SECOND), @1);
				}
			| /*EMPTY*/
				{ $$ = NIL; }
		;

interval_second:
			SECOND_P
				{
					$$ = list_make1(makeIntConst(INTERVAL_MASK(SECOND), @1));
				}
			| SECOND_P '(' Iconst ')'
				{
					$$ = list_make2(makeIntConst(INTERVAL_MASK(SECOND), @1),
									makeIntConst($3, @3));
				}
		;

client_logic_type:
			BYTEAWITHOUTORDER
			{
					$$ = SystemTypeName("byteawithoutordercol");
					$$->location = @1;
			}
			| BYTEAWITHOUTORDERWITHEQUAL
			{
					$$ = SystemTypeName("byteawithoutorderwithequalcol");
					$$->location = @1;
			}
		;

/*****************************************************************************
 *
 *	expression grammar
 *
 *****************************************************************************/

/*
 * General expressions
 * This is the heart of the expression syntax.
 *
 * We have two expression types: a_expr is the unrestricted kind, and
 * b_expr is a subset that must be used in some places to avoid shift/reduce
 * conflicts.  For example, we can't do BETWEEN as "BETWEEN a_expr AND a_expr"
 * because that use of AND conflicts with AND as a boolean operator.  So,
 * b_expr is used in BETWEEN and we remove boolean keywords from b_expr.
 *
 * Note that '(' a_expr ')' is a b_expr, so an unrestricted expression can
 * always be used by surrounding it with parens.
 *
 * c_expr is all the productions that are common to a_expr and b_expr;
 * it's factored out just to eliminate redundant coding.
 */
a_expr:		a_expr_without_sconst 	{ $$ = $1; }
			/* Sconst precedence should lower than SCONST, so when we meet SCONST, we will try to do shift, to read more SCONST as possible */
			|	Sconst %prec TEXT_P { $$ = makeStringConst($1, @1); }
		;

a_expr_without_sconst:		c_expr_without_sconst		{ $$ = $1; }
			| PRIOR '(' a_expr ')'
                                {
                                    List *argList = list_make1($3);
                                    FuncCall *funcNode = MakePriorAsFunc();
                                    funcNode->args = argList;
                                    $$ = (Node *)funcNode;
                                }
			| a_expr TYPECAST Typename
				{
					ChangeBpcharCastType($3);
					$$ = makeTypeCast($1, $3, @2);
				}
			| a_expr COLLATE collate_name
				{
					CollateClause *n = makeNode(CollateClause);
					n->arg = $1;
					n->collname = $3;
					n->location = @2;
					$$ = (Node *) n;
				}
			| BINARY a_expr					%prec UMINUS
				{
					$$ = makeTypeCast($2, SystemTypeName("binary"), -1); 
				}
			| a_expr AT TIME ZONE a_expr			%prec AT
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("timezone");
					n->args = list_make2($5, $1);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
		/*
		 * These operators must be called out explicitly in order to make use
		 * of bison's automatic operator-precedence handling.  All other
		 * operator names are handled by the generic productions using "Op",
		 * below; and all those operators will have the same precedence.
		 *
		 * If you add more explicitly-known operators, be sure to add them
		 * also to b_expr and to the MathOp list above.
		 */
			| '+' a_expr					%prec UMINUS
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", NULL, $2, @1); }
			| '-' a_expr					%prec UMINUS
				{ $$ = doNegate($2, @1); }
			| '@' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", NULL, $2, @1); }
			| a_expr '+' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", $1, $3, @2); }
			| a_expr '-' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "-", $1, $3, @2); }
			| a_expr '*' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "*", $1, $3, @2); }
			| a_expr '/' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "/", $1, $3, @2); }
			| a_expr '%' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "%", $1, $3, @2); }
			| a_expr '^' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "^", $1, $3, @2); }
			| a_expr '<' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "<", $1, $3, @2); }
			| a_expr '>' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, ">", $1, $3, @2); }
			| a_expr '=' a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "=", $1, $3, @2); }
			 | a_expr '@' a_expr
				 { $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", $1, $3, @2); }
			| a_expr CmpNullOp a_expr    %prec IS
				{
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL,
							NULL, (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $3, @2), @2);
					}
					else
					{
						const char* message = "<=> operator is supported only in B-format database";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errmodule(MOD_PARSER),
                                                                 errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                                                 errmsg("<=> operator is supported only in B-format database"),
                                                                 parser_errposition(@2)));
						$$ = NULL;/* not reached */
					}
				}
			| uservar_name COLON_EQUALS a_expr
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "@var_name := expr is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("@var_name := expr is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						u_sess->parser_cxt.has_equal_uservar = true;
						UserSetElem *n = makeNode(UserSetElem);
						n->name = list_make1((Node *)$1);
						n->val = (Expr *)$3;
						$$ = (Node *) n;
					} else {
						const char* message = "@var_name := expr is supported only in B-format database, and enable_set_variable_b_format = on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("@var_name := expr is supported only in the SET syntax of B-format database, and enable_set_variable_b_format = on."),
								parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
				}
            | a_expr CmpOp a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| a_expr JsonOp a_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| a_expr JsonOpText a_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field_text");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| a_expr qual_Op a_expr				%prec Op
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| qual_Op a_expr					%prec Op
				{
					char* op_str = ((Value*)lfirst($1->head))->val.str;
					/* see if condition satisfied for special handling of b_compatibility mode */
					bool is_satisfied = (GetSessionContext()->enableBCmptMode && $1->length == 1);
					if (is_satisfied && strcmp("!", op_str) == 0) {
						$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL, $2, @1);
					} else if (is_satisfied && strcmp("!!", op_str) == 0) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("Operator '!!' is deprecated when b_compatibility_mode is on. Please use function factorial().")));
					} else {
						$$ = (Node *) makeA_Expr(AEXPR_OP, $1, NULL, $2, @1);
					}
				}
			| a_expr qual_Op					%prec POSTFIXOP
				{
					char* op_str = ((Value*)lfirst($2->head))->val.str;
					/* deprecate use of expr! when b_compatibility_mode is on */
					if (GetSessionContext()->enableBCmptMode && $2->length == 1 && strcmp("!", op_str) == 0) {
						ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("Operator '!' behind expression is deprecated when b_compatibility_mode is on. Please use function factorial().")));
					}
					$$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, NULL, @2);
				}

			| a_expr AND a_expr
				{ $$ = (Node *) makeA_Expr(AEXPR_AND, NIL, $1, $3, @2); }
			| a_expr OR a_expr
				{ $$ = (Node *) makeA_Expr(AEXPR_OR, NIL, $1, $3, @2); }
			| NOT a_expr
				{ $$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL, $2, @1); }
			| a_expr DIV a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("div");
					n->args = list_make2($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr MOD a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_mod");
					n->args = list_make2($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr REGEXP a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("regexp");
					n->args = list_make2($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr NOT REGEXP a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("not_regexp");
					n->args = list_make2($1, $4);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr RLIKE a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("rlike");
					n->args = list_make2($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr XOR a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("xor");
					n->args = list_make2($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| a_expr LIKE a_expr
				{ 
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~~", $1, $3, @2); 
				}
			| a_expr LIKE a_expr ESCAPE a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("like_escape");
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~~", $1, (Node *) n, @2);
				}
			| a_expr NOT_LIKE a_expr	%prec NOT_LIKE
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~~", $1, $3, @2);
				}
			| a_expr NOT_LIKE a_expr ESCAPE a_expr	%prec NOT_LIKE
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("like_escape");
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~~", $1, (Node *) n, @2);
				}
			| a_expr ILIKE a_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~~*", $1, $3, @2); }
			| a_expr ILIKE a_expr ESCAPE a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("like_escape");
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~~*", $1, (Node *) n, @2);
				}
			| a_expr NOT_ILIKE a_expr	%prec NOT_ILIKE
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~~*", $1, $3, @2); }
			| a_expr NOT_ILIKE a_expr ESCAPE a_expr		%prec NOT_ILIKE
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("like_escape");
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~~*", $1, (Node *) n, @2);
				}

			| a_expr SIMILAR TO a_expr				%prec SIMILAR
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("similar_escape");
					n->args = list_make2($4, makeNullAConst(-1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~", $1, (Node *) n, @2);
				}
			| a_expr SIMILAR TO a_expr ESCAPE a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("similar_escape");
					n->args = list_make2($4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "~", $1, (Node *) n, @2);
				}
			| a_expr NOT_SIMILAR TO a_expr			%prec NOT_SIMILAR
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("similar_escape");
					n->args = list_make2($4, makeNullAConst(-1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~", $1, (Node *) n, @2);
				}
			| a_expr NOT_SIMILAR TO a_expr ESCAPE a_expr	%prec NOT_SIMILAR
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("similar_escape");
					n->args = list_make2($4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "!~", $1, (Node *) n, @2);
				}

			/* NullTest clause
			 * Define SQL92-style Null test clause.
			 * Allow two forms described in the standard:
			 *	a IS NULL
			 *	a IS NOT NULL
			 * Allow two SQL extensions
			 *	a ISNULL
			 *	a NOTNULL
			 */
			| a_expr IS NULL_P							%prec IS
				{
					NullTest *n = makeNode(NullTest);
					n->arg = (Expr *) $1;
					n->nulltesttype = IS_NULL;
					$$ = (Node *)n;
				}
			| a_expr ISNULL
				{
					NullTest *n = makeNode(NullTest);
					n->arg = (Expr *) $1;
					n->nulltesttype = IS_NULL;
					$$ = (Node *)n;
				}
			| a_expr IS NOT NULL_P						%prec IS
				{
					NullTest *n = makeNode(NullTest);
					n->arg = (Expr *) $1;
					n->nulltesttype = IS_NOT_NULL;
					$$ = (Node *)n;
				}
			| a_expr NOTNULL
				{
					NullTest *n = makeNode(NullTest);
					n->arg = (Expr *) $1;
					n->nulltesttype = IS_NOT_NULL;
					$$ = (Node *)n;
				}
			| row OVERLAPS row
				{
					/* Create and populate a FuncCall node to support the OVERLAPS operator. */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("overlaps");
					if (list_length($1) != 2) {
						const char* message = "wrong number of parameters on left side of OVERLAPS expression";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("wrong number of parameters on left side of OVERLAPS expression"),
								parser_errposition(@1)));
					}
					if (list_length($3) != 2) {
						const char* message = "wrong number of parameters on left side of OVERLAPS expression";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("wrong number of parameters on right side of OVERLAPS expression"),
								parser_errposition(@3)));
					}
					n->args = list_concat($1, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| a_expr IS TRUE_P							%prec IS
				{
					BooleanTest *b = makeNode(BooleanTest);
					b->arg = (Expr *) $1;
					b->booltesttype = IS_TRUE;
					$$ = (Node *)b;
				}
			| a_expr IS NOT TRUE_P						%prec IS
				{
					BooleanTest *b = makeNode(BooleanTest);
					b->arg = (Expr *) $1;
					b->booltesttype = IS_NOT_TRUE;
					$$ = (Node *)b;
				}
			| a_expr IS FALSE_P							%prec IS
				{
					BooleanTest *b = makeNode(BooleanTest);
					b->arg = (Expr *) $1;
					b->booltesttype = IS_FALSE;
					$$ = (Node *)b;
				}
			| a_expr IS NOT FALSE_P						%prec IS
				{
					BooleanTest *b = makeNode(BooleanTest);
					b->arg = (Expr *) $1;
					b->booltesttype = IS_NOT_FALSE;
					$$ = (Node *)b;
				}
			| a_expr IS UNKNOWN							%prec IS
				{
					if (GetSessionContext()->enableBCmptMode) {
						NullTest *n = makeNode(NullTest);
						n->arg = (Expr *) $1;
						n->nulltesttype = IS_NULL;
						$$ = (Node *)n;
					} else {
						BooleanTest *b = makeNode(BooleanTest);
						b->arg = (Expr *) $1;
						b->booltesttype = IS_UNKNOWN;
						$$ = (Node *)b;
					}
				}
			| a_expr IS NOT UNKNOWN						%prec IS
				{
					if (GetSessionContext()->enableBCmptMode) {
						NullTest *n = makeNode(NullTest);
						n->arg = (Expr *) $1;
						n->nulltesttype = IS_NOT_NULL;
						$$ = (Node *)n;
					} else {
						BooleanTest *b = makeNode(BooleanTest);
						b->arg = (Expr *) $1;
						b->booltesttype = IS_NOT_UNKNOWN;
						$$ = (Node *)b;
					}
				}
			| a_expr IS DISTINCT FROM a_expr			%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $5, @2);
				}
			| a_expr IS NOT DISTINCT FROM a_expr		%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL,
									(Node *) makeSimpleA_Expr(AEXPR_DISTINCT,
															  "=", $1, $6, @2),
											 @2);

				}
			| a_expr IS OF '(' type_list ')'			%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "=", $1, (Node *) $5, @2);
				}
			| a_expr IS NOT OF '(' type_list ')'		%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "<>", $1, (Node *) $6, @2);
				}
			/*
			 *	Ideally we would not use hard-wired operators below but
			 *	instead use opclasses.  However, mixed data types and other
			 *	issues make this difficult:
			 *	http://archives.postgresql.org/pgsql-hackers/2008-08/msg01142.php
			 */
			| a_expr BETWEEN opt_asymmetric b_expr AND b_expr       %prec BETWEEN
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_between_and");
					n->args = list_make3($1, $4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| a_expr NOT_BETWEEN opt_asymmetric b_expr AND b_expr   %prec NOT_BETWEEN
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_not_between_and");
					n->args = list_make3($1, $4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| a_expr BETWEEN SYMMETRIC b_expr AND b_expr            %prec BETWEEN
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_sym_between_and");
					n->args = list_make3($1, $4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| a_expr NOT_BETWEEN SYMMETRIC b_expr AND b_expr        %prec NOT_BETWEEN
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_not_sym_between_and");
					n->args = list_make3($1, $4, $6);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| a_expr IN_P in_expr
				{
					/* in_expr returns a SubLink or a list of a_exprs */
					if (IsA($3, SubLink))
					{
						/* generate foo = ANY (subquery) */
						SubLink *n = (SubLink *) $3;
						n->subLinkType = ANY_SUBLINK;
						n->testexpr = $1;
						n->operName = list_make1(makeString("="));
						n->location = @2;
						$$ = (Node *)n;
					}
					else
					{
						/* generate scalar IN expression */
						$$ = (Node *) makeSimpleA_Expr(AEXPR_IN, "=", $1, $3, @2);
					}
				}
			| a_expr NOT_IN in_expr		%prec NOT_IN
				{
					/* in_expr returns a SubLink or a list of a_exprs */
					if (IsA($3, SubLink))
					{
						/* generate NOT (foo = ANY (subquery)) */
						/* Make an = ANY node */
						SubLink *n = (SubLink *) $3;
						n->subLinkType = ANY_SUBLINK;
						n->testexpr = $1;
						n->operName = list_make1(makeString("="));
						n->location = @2;
						/* Stick a NOT on top */
						$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL, (Node *) n, @2);
					}
					else
					{
						/* generate scalar NOT IN expression */
						$$ = (Node *) makeSimpleA_Expr(AEXPR_IN, "<>", $1, $3, @2);
					}
				}
			| a_expr qual_Op sub_type select_with_parens	%prec Op
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = (SubLinkType)$3;
					n->testexpr = $1;
					n->operName = $2;
					n->subselect = $4;
					n->location = @2;
					$$ = (Node *)n;
				}
			| a_expr qual_Op sub_type '(' a_expr ')'		%prec Op
				{
					if ($3 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, $2, $1, $5, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, $2, $1, $5, @2);
				}
			| a_expr LIKE sub_type select_with_parens	%prec Op
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = (SubLinkType)$3;
					n->operName = NakeLikeOpList();
					n->testexpr = $1;
					n->operName = NakeLikeOpList();
					n->subselect = $4;
					n->location = @2;
					$$ = (Node *)n;
				}
			| a_expr LIKE sub_type '(' a_expr ')'		%prec Op
				{
					if ($3 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, NakeLikeOpList(), $1, $5, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, NakeLikeOpList(), $1, $5, @2);
				}
			| a_expr NOT_LIKE sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "!~~*", $4, @2);
				}
			| a_expr NOT_LIKE sub_type '(' a_expr ')'		%prec Op
				{
					if ($3 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, MakeNotLikeOpList(), $1, $5, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, MakeNotLikeOpList(), $1, $5, @2);
				}
			| a_expr ILIKE sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "~~*", $4, @2);
				}
			| a_expr ILIKE sub_type '(' a_expr ')'		%prec Op
				{
					if ($3 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, list_make1(makeString("~~*")), $1, $5, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, list_make1(makeString("~~*")), $1, $5, @2);
				}
			| a_expr NOT_ILIKE sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "!~~*", $4, @2);
				}
			| a_expr NOT_ILIKE sub_type '(' a_expr ')'		%prec Op
				{
					if ($3 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, list_make1(makeString("!~~*")), $1, $5, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, list_make1(makeString("!~~*")), $1, $5, @2);
				}
			| a_expr CmpOp sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, $2, $4, @2);
				}
			| a_expr CmpNullOp sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, $2, $4, @2);
				}
			| a_expr '+' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "+", $4, @2);
				}
			| a_expr '-' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "-", $4, @2);
				}
			| a_expr '*' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "*", $4, @2);
				}
			| a_expr '/' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "/", $4, @2);
				}
			| a_expr '%' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "%", $4, @2);
				}
			| a_expr '^' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "^", $4, @2);
				}
			| a_expr '<' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "<", $4, @2);
				}
			| a_expr '>' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, ">", $4, @2);
				}
			| a_expr '=' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "=", $4, @2);
				}
			| a_expr '@' sub_type select_with_parens	%prec Op
				{
					$$ = MakeSubLinkWithOp((SubLinkType)$3, $1, "@", $4, @2);
				}
			| a_expr CmpOp sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString($2)), $1, $5, @2);
				}
			| a_expr CmpNullOp sub_type '(' a_expr ')'	%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString($2)), $1, $5, @2);
				}
			| a_expr '+' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("+")), $1, $5, @2);
				}
			| a_expr '-' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("-")), $1, $5, @2);
				}
			| a_expr '*' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("*")), $1, $5, @2);
				}
			| a_expr '/' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("/")), $1, $5, @2);
				}
			| a_expr '%' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("%")), $1, $5, @2);
				}
			| a_expr '^' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("^")), $1, $5, @2);
				}
			| a_expr '<' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("<")), $1, $5, @2);
				}
			| a_expr '=' sub_type '(' a_expr ')'		%prec Op
				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("=")), $1, $5, @2);
				}
			| a_expr '@' sub_type '(' a_expr ')'		%prec Op

				{
					$$ = (Node *) makeA_Expr($3 == ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL,
						list_make1(makeString("@")), $1, $5, @2);
				}
			| a_expr LIKE BINARY sub_type select_with_parens	%prec Op
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = (SubLinkType)$4;
					n->testexpr = $1;
					n->operName = list_make1(makeString("~~"));
					n->subselect = $5;
					n->location = @2;
					$$ = (Node *)n;
				}
			| a_expr LIKE BINARY sub_type '(' a_expr ')'		%prec Op
				{
					if ($4 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, list_make1(makeString("~~")), $1, $6, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, list_make1(makeString("~~")), $1, $6, @2);
				}
			| a_expr NOT_LIKE BINARY sub_type select_with_parens	%prec Op
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = (SubLinkType)$4;
					n->testexpr = $1;
					n->operName = list_make1(makeString("!~~"));
					n->subselect = $5;
					n->location = @2;
					$$ = (Node *)n;
				}
			| a_expr NOT_LIKE BINARY sub_type '(' a_expr ')'		%prec Op
				{
					if ($4 == ANY_SUBLINK)
						$$ = (Node *) makeA_Expr(AEXPR_OP_ANY, list_make1(makeString("!~~")), $1, $6, @2);
					else
						$$ = (Node *) makeA_Expr(AEXPR_OP_ALL, list_make1(makeString("!~~")), $1, $6, @2);
				}
			| UNIQUE select_with_parens
				{
					/* Not sure how to get rid of the parentheses
					 * but there are lots of shift/reduce errors without them.
					 *
					 * Should be able to implement this by plopping the entire
					 * select into a node, then transforming the target expressions
					 * from whatever they are into count(*), and testing the
					 * entire result equal to one.
					 * But, will probably implement a separate node in the executor.
					 */
					const char* message = "UNIQUE predicate is not yet implemented";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							 errmsg("UNIQUE predicate is not yet implemented"),
							 parser_errposition(@1)));
				}
			| a_expr IS DOCUMENT_P					%prec IS
				{
					$$ = makeXmlExpr(IS_DOCUMENT, NULL, NIL,
									 list_make1($1), @2);
				}
			| a_expr IS NOT DOCUMENT_P				%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL,
											 makeXmlExpr(IS_DOCUMENT, NULL, NIL,
														 list_make1($1), @2),
											 @2);
				}
			| PREDICT BY ColId '(' FEATURES func_arg_list ')'
				{
					PredictByFunction * n = makeNode(PredictByFunction);
					n->model_name = $3;
					n->model_name_location = @3;
					n->model_args = $6;	
					n->model_args_location = @6;
					$$ = (Node*) n;				
				}
			| a_expr SOUNDS LIKE a_expr
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("soundex_difference");
					n->args = list_make2($1, $4);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *) n;
				}
			| VALUES '(' columnref ')'
				{
					if (!GetSessionContext()->isUpsert)
						ereport(errstate, 
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("VALUES only support in UPSERT clause")));

					ColumnRef *c = NULL;
					int nfields = 0;
					if (IsA($3, ColumnRef))
						c = (ColumnRef *) $3;
					else if (IsA($3, A_Indirection))
						c = (ColumnRef *)(((A_Indirection *)$3)->arg);
					nfields = list_length(c->fields);
					/* only allow col.*, col[...], col */
					if (nfields > 1)
					{
						const char* message = "only allow column name within VALUES";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("only allow column name within VALUES"),
								 parser_errposition(@3)));
					}

					c->fields = lcons((Node *)makeString(GetSessionContext()->upSertAliasName->aliasname), c->fields);
					$$ = (Node *) $3;
				}
			| MATCH_FUNC fulltext_match_params ')' AGAINST '(' SCONST search_modifier ')'
				{
					FuncCall *lexpr_func = makeNode(FuncCall);
					lexpr_func->funcname = SystemFuncName("to_tsvector");
					lexpr_func->args = lappend(lexpr_func->args, makeStringConst("ngram", -1));
					lexpr_func->args = lappend(lexpr_func->args, $2);
					FuncCall *rexpr_func = makeNode(FuncCall);
					rexpr_func->funcname = SystemFuncName("to_tsquery");
					rexpr_func->args = lappend(rexpr_func->args, makeStringConst("ngram", -1));
					rexpr_func->args = lappend(rexpr_func->args, makeStringConst($6, @6));
					A_Expr *match_against = makeSimpleA_Expr(AEXPR_OP, "@@", (Node *)lexpr_func, (Node *)rexpr_func, -1);
					$$ = (Node *)match_against;
				}
		;

/*
 * Restricted expressions
 *
 * b_expr is a subset of the complete expression syntax defined by a_expr.
 *
 * Presently, AND, NOT, IS, and IN are the a_expr keywords that would
 * cause trouble in the places where b_expr is used.  For simplicity, we
 * just eliminate all the boolean-keyword-operator productions from b_expr.
 */
b_expr:		c_expr
				{ $$ = $1; }
			| b_expr TYPECAST Typename
				{
					ChangeBpcharCastType($3);
					$$ = makeTypeCast($1, $3, @2);
				}
			| '+' b_expr					%prec UMINUS
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", NULL, $2, @1); }
			| '-' b_expr					%prec UMINUS
				{ $$ = doNegate($2, @1); }
			| '@' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", NULL, $2, @1); }
			| b_expr '+' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "+", $1, $3, @2); }
			| b_expr '-' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "-", $1, $3, @2); }
			| b_expr '*' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "*", $1, $3, @2); }
			| b_expr '/' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "/", $1, $3, @2); }
			| b_expr '%' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "%", $1, $3, @2); }
			| b_expr '^' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "^", $1, $3, @2); }
			| b_expr '<' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "<", $1, $3, @2); }
			| b_expr '>' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, ">", $1, $3, @2); }
			| b_expr '=' b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "=", $1, $3, @2); }
                        | b_expr '@' b_expr
                                { $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, "@", $1, $3, @2); }
			| b_expr CmpOp b_expr
				{ $$ = (Node *) makeSimpleA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| b_expr JsonOp b_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| b_expr JsonOpText b_expr
				{   
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("json_object_field_text");
					n->args = list_make2($1, $3);;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @2;
					n->call_func = false;
					$$ = (Node *)n; 
				}
			| b_expr qual_Op b_expr				%prec Op
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, $3, @2); }
			| b_expr CmpNullOp b_expr    %prec IS
				{
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT)
					{
						$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL,
							NULL, (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $3, @2), @2);
					}
					else
					{
						const char* message = "<=> operator is supported only in B-format database";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errmodule(MOD_PARSER),
                                                                 errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                                                                 errmsg("<=> operator is supported only in B-format database"),
                                                                 parser_errposition(@2)));
						$$ = NULL;/* not reached */
					}
				}
			| qual_Op b_expr					%prec Op
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $1, NULL, $2, @1); }
			| b_expr qual_Op					%prec POSTFIXOP
				{ $$ = (Node *) makeA_Expr(AEXPR_OP, $2, $1, NULL, @2); }
			| b_expr IS DISTINCT FROM b_expr		%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $5, @2);
				}
			| b_expr IS NOT DISTINCT FROM b_expr	%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL,
						NULL, (Node *) makeSimpleA_Expr(AEXPR_DISTINCT, "=", $1, $6, @2), @2);
				}
			| b_expr IS OF '(' type_list ')'		%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "=", $1, (Node *) $5, @2);
				}
			| b_expr IS NOT OF '(' type_list ')'	%prec IS
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_OF, "<>", $1, (Node *) $6, @2);
				}
			| b_expr IS DOCUMENT_P					%prec IS
				{
					$$ = makeXmlExpr(IS_DOCUMENT, NULL, NIL,
									 list_make1($1), @2);
				}
			| b_expr IS NOT DOCUMENT_P				%prec IS
				{
					$$ = (Node *) makeA_Expr(AEXPR_NOT, NIL, NULL,
											 makeXmlExpr(IS_DOCUMENT, NULL, NIL,
														 list_make1($1), @2),
											 @2);
				}
		;

/*
 * Productions that can be used in both a_expr and b_expr.
 *
 * Note: productions that refer recursively to a_expr or b_expr mostly
 * cannot appear here.	However, it's OK to refer to a_exprs that occur
 * inside parentheses, such as function arguments; that cannot introduce
 * ambiguity to the b_expr syntax.
 */
c_expr:		c_expr_without_sconst { $$ = $1; }
			/* Sconst precedence should lower than SCONST, so when we meet SCONST, we will try to do shift, to read more SCONST as possible */
			| Sconst %prec TEXT_P { $$ = makeStringConst($1, @1); }
		;

c_expr_without_sconst:
			columnref %prec UMINUS						        { $$ = $1; }
			| AexprConst_without_Sconst							{ $$ = $1; }
                        | PRIOR '(' columnref ')'
                                {
                                    ColumnRef *col = (ColumnRef *)$3;
                                    col->prior = true;
                                    /*
                                     * Setting the location to a non-default 0
                                     * to indicate that this is a parenthetical
                                     * case of PRIOR reference.
                                     */
                                    col->location = 0;
                                    $$ = (Node *)col;
                                }
                        | PRIOR '(' c_expr ',' func_arg_list ')'
                                {
                                    List* argList = list_concat(list_make1($3), $5);
                                    FuncCall* funcNode = MakePriorAsFunc();
                                    funcNode->args = argList;
                                    $$ = (Node *)funcNode;
                                }
		        | PRIOR columnref
		                {
		                    ColumnRef *n = (ColumnRef *)$2;
		                    n->prior = true;
		                    $$ = (Node *)n;
		                }
			| PARAM opt_indirection
				{
					if (u_sess->parser_cxt.is_load_copy == false) {
						ParamRef *p = makeNode(ParamRef);
						p->number = $1;
						p->location = @1;
						if ($2)
						{
							A_Indirection *n = makeNode(A_Indirection);
							n->arg = (Node *) p;
							n->indirection = check_indirection($2, yyscanner);
							$$ = (Node *) n;
						}
						else
							$$ = (Node *) p;
#ifndef ENABLE_MULTIPLE_NODES
					} 
					else {
						char *colname = u_sess->parser_cxt.copy_fieldname;
						if (CheckWhetherInColList(colname, u_sess->parser_cxt.col_list) == true) {
							$$ = makeColumnRef(colname, NIL, @1, yyscanner);
						} else {
							ereport(errstate,
									(errcode(ERRCODE_INVALID_COLUMN_REFERENCE),
									 errmsg("Col \"%s\" is not in the col list", colname),
									 parser_errposition(@1)));
						}
#endif
					}
				}
			| '(' a_expr ')' opt_indirection
				{
					if ($4)
					{
						A_Indirection *n = makeNode(A_Indirection);
						n->arg = $2;
						n->indirection = check_indirection($4, yyscanner);
						$$ = (Node *)n;
					}
					else
						$$ = $2;
				}
			| case_expr
				{ $$ = $1; }
			| func_expr
				{ $$ = $1; }
			| select_with_parens			%prec UMINUS
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					$$ = (Node *)n;
				}
			| select_with_parens indirection
				{
					/*
					 * Because the select_with_parens nonterminal is designed
					 * to "eat" as many levels of parens as possible, the
					 * '(' a_expr ')' opt_indirection production above will
					 * fail to match a sub-SELECT with indirection decoration;
					 * the sub-SELECT won't be regarded as an a_expr as long
					 * as there are parens around it.  To support applying
					 * subscripting or field selection to a sub-SELECT result,
					 * we need this redundant-looking production.
					 */
					SubLink *n = makeNode(SubLink);
					A_Indirection *a = makeNode(A_Indirection);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					a->arg = (Node *)n;
					a->indirection = check_indirection($2, yyscanner);
					$$ = (Node *)a;
				}
			| EXISTS select_with_parens
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = EXISTS_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $2;
					n->location = @1;
					$$ = (Node *)n;
				}
			| ARRAY select_with_parens
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = ARRAY_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $2;
					n->location = @1;
					$$ = (Node *)n;
				}
			| ARRAY array_expr
				{
					A_ArrayExpr *n = (A_ArrayExpr *) $2;
					AssertEreport(IsA(n, A_ArrayExpr),
									MOD_OPT,
									"Node type inconsistant");
					/* point outermost A_ArrayExpr to the ARRAY keyword */
					n->location = @1;
					$$ = (Node *)n;
				}
			| explicit_row
				{
					RowExpr *r = makeNode(RowExpr);
					r->args = $1;
					r->row_typeid = InvalidOid;	/* not analyzed yet */
					r->colnames = NIL;	/* to be filled in during analysis */
					r->row_format = COERCE_EXPLICIT_CALL; /* abuse */
					r->location = @1;
					$$ = (Node *)r;
				}
			| implicit_row
				{
					RowExpr *r = makeNode(RowExpr);
					r->args = $1;
					r->row_typeid = InvalidOid;	/* not analyzed yet */
					r->colnames = NIL;	/* to be filled in during analysis */
					r->row_format = COERCE_IMPLICIT_CAST; /* abuse */
					r->location = @1;
					$$ = (Node *)r;
				}
			| GROUPING_P '(' expr_list ')'
			  {
				  GroupingFunc *g = makeNode(GroupingFunc);
				  g->args = $3;
				  g->location = @1;
				  $$ = (Node *)g;
			  }
			| uservar_name           %prec UMINUS
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "@var_name is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("@var_name is not yet supported in distributed database.")));
#endif
					if (DB_IS_CMPT(B_FORMAT) && (u_sess->attr.attr_common.enable_set_variable_b_format || ENABLE_SET_VARIABLES)) {
						$$ = $1;
					} else {
						const char* message = "@var_name is supported only in B-format database, and enable_set_variable_b_format = on.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
							(errmodule(MOD_PARSER),
								errcode(ERRCODE_SYNTAX_ERROR),
								errmsg("@var_name is supported only in B-format database, and enable_set_variable_b_format = on."),
								parser_errposition(@1)));
						$$ = NULL;/* not reached */
					}
				}
			| set_ident_expr
				{
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "@@config_parameter is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("@@config_parameter is not yet supported in distributed database.")));
#endif
					$$ = $1;
				}
		;


/* Used for List Distribution to avoid reduce/reduce conflict. This is unavoidable, since Bison is LALR(1) compiler */
c_expr_noparen:		columnref								{ $$ = $1; }
			| AexprConst							{ $$ = $1; }
			| PARAM opt_indirection
				{
					ParamRef *p = makeNode(ParamRef);
					p->number = $1;
					p->location = @1;
					if ($2)
					{
						A_Indirection *n = makeNode(A_Indirection);
						n->arg = (Node *) p;
						n->indirection = check_indirection($2, yyscanner);
						$$ = (Node *) n;
					}
					else
						$$ = (Node *) p;
				}
			| case_expr
				{ $$ = $1; }
			| func_expr
				{ $$ = $1; }
			| select_with_parens			%prec UMINUS
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					$$ = (Node *)n;
				}
			| select_with_parens indirection
				{
					/*
					 * Because the select_with_parens nonterminal is designed
					 * to "eat" as many levels of parens as possible, the
					 * '(' a_expr ')' opt_indirection production above will
					 * fail to match a sub-SELECT with indirection decoration;
					 * the sub-SELECT won't be regarded as an a_expr as long
					 * as there are parens around it.  To support applying
					 * subscripting or field selection to a sub-SELECT result,
					 * we need this redundant-looking production.
					 */
					SubLink *n = makeNode(SubLink);
					A_Indirection *a = makeNode(A_Indirection);
					n->subLinkType = EXPR_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $1;
					n->location = @1;
					a->arg = (Node *)n;
					a->indirection = check_indirection($2, yyscanner);
					$$ = (Node *)a;
				}
			| EXISTS select_with_parens
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = EXISTS_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $2;
					n->location = @1;
					$$ = (Node *)n;
				}
			| ARRAY select_with_parens
				{
					SubLink *n = makeNode(SubLink);
					n->subLinkType = ARRAY_SUBLINK;
					n->testexpr = NULL;
					n->operName = NIL;
					n->subselect = $2;
					n->location = @1;
					$$ = (Node *)n;
				}
			| ARRAY array_expr
				{
					A_ArrayExpr *n = (A_ArrayExpr *) $2;
					AssertEreport(IsA(n, A_ArrayExpr),
									MOD_OPT,
									"Node type inconsistant");
					/* point outermost A_ArrayExpr to the ARRAY keyword */
					n->location = @1;
					$$ = (Node *)n;
				}
			| explicit_row
				{
					RowExpr *r = makeNode(RowExpr);
					r->args = $1;
					r->row_typeid = InvalidOid;	/* not analyzed yet */
					r->colnames = NIL;	/* to be filled in during analysis */
					r->row_format = COERCE_EXPLICIT_CALL; /* abuse */
					r->location = @1;
					$$ = (Node *)r;
				}
			| GROUPING_P '(' expr_list ')'
			  {
				  GroupingFunc *g = makeNode(GroupingFunc);
				  g->args = $3;
				  g->location = @1;
				  $$ = (Node *)g;
			  }
		;

fulltext_match_params:
			columnref
			{
				ColumnRef *fulltext_col = (ColumnRef *)$1;
				$$ = (Node *)fulltext_col;
			}
			| fulltext_match_params ',' columnref
			{
				A_Expr *matchFollowCol =  makeSimpleA_Expr(AEXPR_OP, "||", (Node *)$1, (Node *)$3, @2);
				$$ = (Node *)matchFollowCol;
			}
		;

/*
 * func_expr and its cousin func_expr_windowless are split out from c_expr just
 * so that we have a classification for "everything that is a function call or
 * looks like one". This isn't very important, but it saves us having to
 * document which variants are legal in places like "FROM functions()" or the
 * backwards-compatible functional-index syntax for CREATE INDEX.
 * (Note that many of the special SQL functions wouldn't actually make any
 * sense as functional index entries, but we ignore that consideration here.)
 */
func_expr:	func_application within_group_clause over_clause
				{
					FuncCall *n = (FuncCall *) $1;

					/*
					 * We currently only use listagg function with WITHIN GROUP. Besides, this function
					 * has up to 2 parameters and cannot use DISTINCT, VARIADIC and ORDER BY clauses.
					 */
					if (pg_strcasecmp(strVal(linitial(n->funcname)), "listagg") == 0)
					{
						if ($2 == NIL)
						{
							const char* message = "missing WITHIN keyword.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
								(errcode(ERRCODE_SYNTAX_ERROR),
								 errmsg("missing WITHIN keyword."),
								 parser_errposition(@2)));
						}
						else
						{
							if (n->agg_order != NIL)
							{
								const char* message = "cannot use multiple ORDER BY clauses with WITHIN GROUP.";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use multiple ORDER BY clauses with WITHIN GROUP."),
									 parser_errposition(@2)));
							}
							if (n->agg_distinct)
							{
								const char* message = "cannot use DISTINCT with WITHIN GROUP.";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use DISTINCT with WITHIN GROUP."),
									 parser_errposition(@2)));
							}
							if (n->func_variadic)
							{
								const char* message = "cannot use VARIADIC with WITHIN GROUP.";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use VARIADIC with WITHIN GROUP."),
									 parser_errposition(@2)));
							}
						}
						n->agg_order = $2;
						
						WindowDef *wd = (WindowDef*) $3;
						if (wd != NULL)
							wd->frameOptions = FRAMEOPTION_NONDEFAULT | FRAMEOPTION_ROWS | 
												FRAMEOPTION_START_UNBOUNDED_PRECEDING |
												(FRAMEOPTION_START_UNBOUNDED_FOLLOWING << 1) | 
												FRAMEOPTION_BETWEEN;
						n->over = wd;
					}
					else if ($2 != NIL)
					{
						if (n->agg_order != NIL) {
							const char* message = "cannot use multiple ORDER BY clauses with WITHIN GROUP";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use multiple ORDER BY clauses with WITHIN GROUP"),
									 parser_errposition(@2)));
						}
						if (n->agg_distinct) {
							const char* message = "cannot use DISTINCT with WITHIN GROUP.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use DISTINCT with WITHIN GROUP"),
									 parser_errposition(@2)));
						}
						if (n->func_variadic) {
							const char* message = "cannot use VARIADIC with WITHIN GROUP.";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("cannot use VARIADIC with WITHIN GROUP"),
									 parser_errposition(@2)));
						}
						n->agg_order = $2;
						n->agg_within_group = TRUE;
						n->over = $3;
						$$ = (Node *) n;
					}
					else
					{
						n->over = $3;
					}
					if (pg_strcasecmp(strVal(linitial(n->funcname)), "group_concat") == 0)
					{
#ifdef			ENABLE_MULTIPLE_NODES
						const char* message = "group_concat is not yet supported in distributed database.";
						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								errmsg("group_concat is not yet supported in distributed database.")));
#endif
						WindowDef *wd = (WindowDef*) $3;
						if (wd != NULL) {
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("group_concat does not support window function"),
									 parser_errposition(@1)));
						}
						n->args = lappend3(list_make1(makeStringConst(",", n->location)), n->args);
					}
				}
			| func_with_separator
				{ 
#ifdef			ENABLE_MULTIPLE_NODES
					const char* message = "group_concat is not yet supported in distributed database.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);			
					ereport(errstate,
							(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
							errmsg("group_concat is not yet supported in distributed database.")));
#endif
					$$ = $1; 
				}
			| func_expr_common_subexpr
				{ $$ = $1; }
		;

func_application:	dolphin_func_name '(' func_arg_list opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = $3;
					n->agg_order = $4;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| func_application_special { $$ = $1; }
		;

func_application_special:	dolphin_func_name '(' ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| dolphin_func_name '(' VARIADIC func_arg_expr opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = list_make1($4);
					n->agg_order = $5;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = TRUE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| dolphin_func_name '(' func_arg_list ',' VARIADIC func_arg_expr opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = lappend($3, $6);
					n->agg_order = $7;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = TRUE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| dolphin_func_name '(' ALL func_arg_list opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = $4;
					n->agg_order = $5;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					/* Ideally we'd mark the FuncCall node to indicate
					 * "must be an aggregate", but there's no provision
					 * for that in FuncCall at the moment.
					 */
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| dolphin_func_name '(' DISTINCT func_arg_list opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = $4;
					n->agg_order = $5;
					n->agg_star = FALSE;
					n->agg_distinct = TRUE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| dolphin_func_name '(' '*' ')'
				{
					/*
					 * We consider AGGREGATE(*) to invoke a parameterless
					 * aggregate.  This does the right thing for COUNT(*),
					 * and there are no other aggregates in SQL92 that accept
					 * '*' as parameter.
					 *
					 * The FuncCall node is also marked agg_star = true,
					 * so that later processing can detect what the argument
					 * really was.
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = $1;
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = TRUE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
		;

/*
 * Function with SEPARATOR keword arguments;
 */
func_with_separator:
		dolphin_func_name '(' func_arg_list opt_sort_clause SEPARATOR_P SCONST ')'
			{
				if (pg_strcasecmp(strVal(linitial($1)), "group_concat") != 0)
				{
					const char* message = "SEPARATOR can only be used in GROUP_CONCAT.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
							(errcode(ERRCODE_SYNTAX_ERROR),
							errmsg("SEPARATOR can only be used in GROUP_CONCAT."),
							parser_errposition(@5)));
				} else {
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("group_concat");
					n->args = lappend3(list_make1(makeStringConst($6, @6)), $3);
					n->agg_order = $4;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			}
		| dolphin_func_name '(' DISTINCT func_arg_list opt_sort_clause SEPARATOR_P SCONST ')'
			{
				if (pg_strcasecmp(strVal(linitial($1)), "group_concat") != 0)
				{
					const char* message = "SEPARATOR can only be used in GROUP_CONCAT.";
					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
					ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						errmsg("SEPARATOR can only be used in GROUP_CONCAT."),
						parser_errposition(@6)));
				} else {
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("group_concat");
					n->args = lappend3(list_make1(makeStringConst($7, @7)), $4);
					n->agg_order = $5;
					n->agg_star = FALSE;
					n->agg_distinct = TRUE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			}
	;

/*
 * As func_expr but does not accept WINDOW functions directly
 * (but they can still be contained in arguments for functions etc).
 * Use this when window expressions are not allowed, where needed to disambiguate the grammar.
 * e.g. in FROM clause, window function or function with 'within group' clause are not allowed.
 * in CREATE INDEX, they are also not allowed.
 */
func_expr_windowless:
            func_application            { $$ = $1; }
            | func_expr_common_subexpr  { $$ = $1; }
        ;

/*
 * Special expressions that are considered to be functions;
 */
func_expr_common_subexpr:
			current_date_func
				{
					/*
					 * Translate as "text_date('now'::text)".
					 *
					 * Notice that we cannot use 'now'::text::date because when 
					 * we go FQS plan, it will deparsed as 'now'::text::date which is
					 * equal to 'now'::text::timestamp under A_FORMAT.
					 *
					 * We cannot use "text_date('now')" because it will
					 * immediately reduce that to a constant representing
					 * today's date.  We need to delay the conversion until
					 * runtime, else the wrong things will happen when
					 * CURRENT_DATE is used in a column default value or rule.
					 *
					 * This could be simplified if we had a way to generate
					 * an expression tree representing runtime application
					 * of type-input conversion functions.  (As of PG 7.3
					 * that is actually possible, but not clear that we want
					 * to rely on it.)
					 *
					 * The token location is attached to the run-time
					 * typecast, not to the Const, for the convenience of
					 * pg_stat_statements (which doesn't want these constructs
					 * to appear to be replaceable constants).
					 */
					FuncCall *n = makeNode(FuncCall);
					Node *d = makeStringConstCast("now", -1, SystemTypeName("text"));

					n->funcname = SystemFuncName("text_date");
					n->colname = pstrdup("date");
					n->args = list_make1(d);
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CONVERT '(' a_expr USING Typename ')'
			{
			        TypeName* typname = (TypeName*)$5;
				Type typtup = LookupTypeName(NULL, typname, NULL);
				FuncCall *n = makeNode(FuncCall);
				if (NULL == typtup) {
					n->funcname = SystemFuncName("convert");
					TypeName * tmp = SystemTypeName("name");
					tmp->location = @5;
					n->args = list_make2($3, makeStringConstCast(strVal(linitial(typname->names)), -1, tmp));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				} else {
				        ReleaseSysCache(typtup);
				        $$ = makeTypeCast($3, $5, @1);
				}

			}
			| CONVERT '(' a_expr USING SCONST ')'
			{
			        FuncCall *n = makeNode(FuncCall);
				n->funcname = SystemFuncName("convert");
				TypeName * tmp = SystemTypeName("name");
				tmp->location = @5;
				n->args = list_make2($3, makeStringConstCast($5, -1, tmp));
				n->agg_order = NIL;
				n->agg_star = FALSE;
				n->agg_distinct = FALSE;
				n->func_variadic = FALSE;
				n->over = NULL;
				n->location = @1;
				n->call_func = false;
				$$ = (Node *)n;
			}
			| CONVERT '(' a_expr ',' Typename ')'
			{
				ChangeBpcharCastType($5);
				$$ = makeTypeCast($3, $5, @1);
			}
			| CONVERT '(' a_expr ',' UNSIGNED INTEGER ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("uint8"), @1);
			}
			| CONVERT '(' a_expr ',' SIGNED INTEGER ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("int8"), @1);
			}
			| CONVERT '(' a_expr ',' INTEGER UNSIGNED ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("uint8"), @1);
			}
			| CONVERT '(' a_expr ',' INTEGER SIGNED ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("int8"), @1);
			}
			| CONVERT '(' a_expr ',' UNSIGNED INT_P ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("uint8"), @1);
			}
			| CONVERT '(' a_expr ',' SIGNED INT_P ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("int8"), @1);
			}
			| CONVERT '(' a_expr ',' UNSIGNED ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("uint8"), @1);
			}
			| CONVERT '(' a_expr ',' SIGNED ')'
			{
			        $$ = makeTypeCast($3, SystemTypeName("int8"), @1);
			}
			| CURRENT_TIME
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_time");
					n->colname = pstrdup("current_time");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_TIME '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_time");

					if (!$3) {
						b_db_ColnameWithoutPrecision("current_time");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("current_time", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURTIME '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_time");

					if (!$3) {
						b_db_ColnameWithoutPrecision("curtime");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("curtime", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DEFAULT_FUNC columnref ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = list_make1(makeString("mode_b_default"));
					ColumnRef *temp_col = (ColumnRef *)$2;
					n->args = list_make1((Node *)temp_col);
					n->agg_order = NIL;
					n->agg_star = TRUE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_TIMESTAMP
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");
					n->colname = pstrdup("current_timestamp");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_TIMESTAMP '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");

					if (!$3) {
						b_db_ColnameWithoutPrecision("current_timestamp");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("current_timestamp", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| utc_date_func
				{
					/*
					 * Translate as "utc_date_func()".
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("utc_date_func");
					n->colname = pstrdup("utc_date");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| utc_time_func
				{
					/*
					 * Translate as "utc_time_func(0)".
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("utc_time_func");
					n->colname = pstrdup("utc_time");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| UTC_TIME '(' Iconst ')'
				{
					/*
					 * Translate as "utc_time_func(Iconst)".
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("utc_time_func");
					n->colname = pstrdup("utc_time");
					n->args = list_make1(makeIntConst($3, @3));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| utc_timestamp_func
				{
					/*
					 * Translate as "utc_timestamp_func(0)".
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("utc_timestamp_func");
					n->colname = pstrdup("utc_timestamp");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| UTC_TIMESTAMP '(' Iconst ')'
				{
					/*
					 * Translate as "utc_timestamp_func(Iconst)".
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("utc_timestamp_func");
					n->colname = pstrdup("utc_timestamp");
					n->args = list_make1(makeIntConst($3, @3));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCALTIME
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");
					n->colname = pstrdup("localtime");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCALTIME '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");

					if (!$3) {
						b_db_ColnameWithoutPrecision("localtime");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("localtime", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCALTIMESTAMP
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");
					n->colname = pstrdup("localtimestamp");
					n->args = list_make1(makeIntConst(0, -1));
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCALTIMESTAMP '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");

					if (!$3) {
						b_db_ColnameWithoutPrecision("localtimestamp");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("localtimestamp", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| NOW_FUNC '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_statement_start_timestamp");

					if(!$3) {
						b_db_ColnameWithoutPrecision("now");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("now", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DATE_P '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_date");
					n->colname = pstrdup("date");
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| SYSDATE '(' optional_precision ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("b_db_sys_real_timestamp");

					if (!$3) {
						b_db_ColnameWithoutPrecision("sysdate");
						n->args = list_make1(makeIntConst(0, -1));
					} else {
						b_db_ColnameWithPrecision("sysdate", $3);
						n->args = list_make1($3);
					}

					n->agg_order = NIL;
					n->agg_star = false;
					n->agg_distinct = false;
					n->func_variadic = false;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_ROLE opt_bracket
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("current_user");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_USER opt_bracket
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("current_user");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DB_B_FORMAT '(' func_arg_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT && GetSessionContext()->enableBCmptMode
						&& (list_length($3) == 2 || list_length($3) == 3))
					{
						n->funcname = SystemFuncName("db_b_format");
						n->colname = "format";
					}
					else
					{
						n->funcname = SystemFuncName("format");
					}
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DB_B_FORMAT '(' func_arg_list ',' VARIADIC func_arg_expr opt_sort_clause ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("format");;
					n->args = lappend($3, $6);
					n->agg_order = $7;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = TRUE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DB_B_JSOBJ '(' func_arg_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if (GetSessionContext()->enableBCmptMode) {
						n->funcname = SystemFuncName("json_object_mysql");
						n->colname = "json_object";
					}
					else {
						n->funcname = SystemFuncName("json_object");
					}
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| DB_B_JSOBJ '(' ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if (GetSessionContext()->enableBCmptMode) {
						n->funcname = SystemFuncName("json_object_noarg");
						n->colname = "json_object";
					}
					else {
						n->funcname = SystemFuncName("json_object");
					}
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| SESSION_USER opt_bracket
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("session_user");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_CATALOG
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("current_database");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CURRENT_SCHEMA
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("current_schema");
					n->args = NIL;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CAST '(' a_expr AS Typename ')'
				{
					ChangeBpcharCastType($5);
					$$ = makeTypeCast($3, $5, @1);
				}
			| CAST '(' a_expr AS Character charset ')'
				{
					$5->charset = $6;
					ChangeBpcharCastType($5);
					$$ = makeTypeCast($3, $5, @1);
				}
			| CAST '(' a_expr AS UNSIGNED ')'
				{ $$ = makeTypeCast($3, SystemTypeName("uint8"), @1); }
			| CAST '(' a_expr AS SIGNED ')'
				{ $$ = makeTypeCast($3, SystemTypeName("int8"), @1); }
			| CAST '(' a_expr AS UNSIGNED INTEGER ')'
				{ $$ = makeTypeCast($3, SystemTypeName("uint8"), @1); }
			| CAST '(' a_expr AS SIGNED INTEGER ')'
				{ $$ = makeTypeCast($3, SystemTypeName("int8"), @1); }
			| CAST '(' a_expr AS UNSIGNED INT_P ')'
				{ $$ = makeTypeCast($3, SystemTypeName("uint8"), @1); }
			| CAST '(' a_expr AS SIGNED INT_P ')'
				{ $$ = makeTypeCast($3, SystemTypeName("int8"), @1); }
			| CAST '(' a_expr AS INTEGER UNSIGNED ')'
				{ $$ = makeTypeCast($3, SystemTypeName("uint8"), @1); }
			| CAST '(' a_expr AS INTEGER SIGNED ')'
				{ $$ = makeTypeCast($3, SystemTypeName("int8"), @1); }
			| EXTRACT '(' extract_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if (list_length($3) == 2) {

						A_Const* con = (A_Const*)linitial($3);
						char* argname = strVal(&con->val);
						b_units enum_unit;
						if (resolve_units(argname, &enum_unit)) {
							if (GetSessionContext()->enableBCmptMode) {
								n->funcname = SystemFuncName("b_extract");
								n->colname = "extract";
							} else {
								n->funcname = SystemFuncName("date_part");
							}
						} else {
							n->funcname = SystemFuncName("date_part");
						}
					} else {
						if (GetSessionContext()->enableBCmptMode) {
							n->funcname = SystemFuncName("b_extract");
							n->colname = "extract";
						} else {
							n->funcname = SystemFuncName("date_part");
						}
					}
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LAST_DAY_FUNC '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if(GetSessionContext()->enableBCmptMode) {
						n->funcname = SystemFuncName("b_db_last_day");
						n->colname = pstrdup("last_day");
					} else {
						n->funcname = SystemFuncName("last_day");
					}
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIMESTAMP '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("timestamp_mysql");
					n->colname = "timestamp";
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIMESTAMP '(' a_expr ',' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("timestamp_mysql");
					n->colname = "timestamp";
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIME '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("time_mysql");
					n->colname = "time";
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIMESTAMPADD '(' timestamp_arg_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("timestamp_add");
					n->colname = "timestampadd";
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIMESTAMPDIFF '(' timestamp_arg_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					if (GetSessionContext()->enableBCmptMode) {
						n->funcname = SystemFuncName("b_timestampdiff");
						n->colname = "timestampdiff";
					} else {
						n->funcname = SystemFuncName("timestamp_diff");
					}
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| OVERLAY '(' overlay_list ')'
				{
					/* overlay(A PLACING B FROM C FOR D) is converted to
					 * overlay(A, B, C, D)
					 * overlay(A PLACING B FROM C) is converted to
					 * overlay(A, B, C)
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("overlay");
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| POSITION '(' position_list ')'
				{
					/* position(A in B) is converted to position(B, A) */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("position");
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCATE '(' b_expr ',' b_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("locate");
					n->args = list_make2($5, $3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| LOCATE '(' b_expr ',' b_expr ',' b_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("locate");
					n->args = list_make3($5, $3, $7);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| SUBSTRING '(' substr_list ')'
				{
					/* substring(A from B for C) is converted to
					 * substring(A, B, C) - thomas 2000-11-28
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("substring");
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| SUBSTR '(' substr_list ')'
				{
					/* substr(A from B for C) is converted to
					 * substr(A, B, C)
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("substr");
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| MID '(' substr_list ')'
				{
					/* mid(A from B for C) is converted to
					 * mid(A, B, C)
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("mid");
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TREAT '(' a_expr AS Typename ')'
				{
					/* TREAT(expr AS target) converts expr of a particular type to target,
					 * which is defined to be a subtype of the original expression.
					 * In SQL99, this is intended for use with structured UDTs,
					 * but let's make this a generally useful form allowing stronger
					 * coercions than are handled by implicit casting.
					 */
					FuncCall *n = makeNode(FuncCall);
					/* Convert SystemTypeName() to SystemFuncName() even though
					 * at the moment they result in the same thing.
					 */
					n->funcname = SystemFuncName(((Value *)llast($5->names))->val.str);
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TRIM '(' BOTH trim_list ')'
				{
					/* various trim expressions are defined in SQL92
					 * - thomas 1997-07-19
					 */
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("btrim");
					n->colname = "trim";
					n->args = $4;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TRIM '(' LEADING trim_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("ltrim");
					n->colname = "trim";
					n->args = $4;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TRIM '(' TRAILING trim_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("rtrim");
					n->colname = "trim";
					n->args = $4;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TRIM '(' trim_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("btrim");
					n->colname = "trim";
					n->args = $3;
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| NULLIF '(' a_expr ',' a_expr ')'
				{
					$$ = (Node *) makeSimpleA_Expr(AEXPR_NULLIF, "=", $3, $5, @1);
				}
			| NVL '(' a_expr ',' a_expr ')'
				{
					CoalesceExpr *c = makeNode(CoalesceExpr);
					c->args = list_make2($3,$5);
					// modify NVL display to A db's style "NVL" instead of "COALESCE"
					c->isnvl = true;
					$$ = (Node *)c;
				}
			| IFNULL '(' a_expr ',' a_expr ')'
				{
					CoalesceExpr *c = makeNode(CoalesceExpr);
					c->args = list_make2($3,$5);
					// modify NVL display to A db's style "NVL" instead of "COALESCE"
					c->isnvl = true;
					$$ = (Node *)c;
				}
			| COALESCE '(' expr_list ')'
				{
					CoalesceExpr *c = makeNode(CoalesceExpr);
					c->args = $3;
					c->location = @1;
					// modify NVL display to A db's style "NVL" instead of "COALESCE"
					c->isnvl = false;
					$$ = (Node *)c;
				}
			| ISNULL '(' a_expr ')'
				{
					NullTest *n = makeNode(NullTest);
					n->arg = (Expr *)$3;
					n->nulltesttype = IS_NULL;
					$$ = (Node *)n;
				}
			| GET_FORMAT '(' get_format_time_type ',' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("get_format");
					n->args = list_make2($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| GREATEST '(' expr_list ')'
				{
					MinMaxExpr *v = makeNode(MinMaxExpr);
					v->args = $3;
					v->op = IS_GREATEST;
					v->location = @1;
					$$ = (Node *)v;
				}
			| LEAST '(' expr_list ')'
				{
					MinMaxExpr *v = makeNode(MinMaxExpr);
					v->args = $3;
					v->op = IS_LEAST;
					v->location = @1;
					$$ = (Node *)v;
				}
			| XMLCONCAT '(' expr_list ')'
				{
					$$ = makeXmlExpr(IS_XMLCONCAT, NULL, NIL, $3, @1);
				}
			| XMLELEMENT '(' NAME_P ColLabel ')'
				{
					$$ = makeXmlExpr(IS_XMLELEMENT, $4, NIL, NIL, @1);
				}
			| XMLELEMENT '(' NAME_P ColLabel ',' xml_attributes ')'
				{
					$$ = makeXmlExpr(IS_XMLELEMENT, $4, $6, NIL, @1);
				}
			| XMLELEMENT '(' NAME_P ColLabel ',' expr_list ')'
				{
					$$ = makeXmlExpr(IS_XMLELEMENT, $4, NIL, $6, @1);
				}
			| XMLELEMENT '(' NAME_P ColLabel ',' xml_attributes ',' expr_list ')'
				{
					$$ = makeXmlExpr(IS_XMLELEMENT, $4, $6, $8, @1);
				}
			| XMLEXISTS '(' c_expr xmlexists_argument ')'
				{
					/* xmlexists(A PASSING [BY REF] B [BY REF]) is
					 * converted to xmlexists(A, B)*/
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("xmlexists");
					n->args = list_make2($3, $4);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| XMLFOREST '(' xml_attribute_list ')'
				{
					$$ = makeXmlExpr(IS_XMLFOREST, NULL, $3, NIL, @1);
				}
			| XMLPARSE '(' document_or_content a_expr xml_whitespace_option ')'
				{
					XmlExpr *x = (XmlExpr *)
						makeXmlExpr(IS_XMLPARSE, NULL, NIL,
									list_make2($4, makeBoolAConst($5, -1)),
									@1);
					x->xmloption = (XmlOptionType)$3;
					$$ = (Node *)x;
				}
			| XMLPI '(' NAME_P ColLabel ')'
				{
					$$ = makeXmlExpr(IS_XMLPI, $4, NULL, NIL, @1);
				}
			| XMLPI '(' NAME_P ColLabel ',' a_expr ')'
				{
					$$ = makeXmlExpr(IS_XMLPI, $4, NULL, list_make1($6), @1);
				}
			| XMLROOT '(' a_expr ',' xml_root_version opt_xml_root_standalone ')'
				{
					$$ = makeXmlExpr(IS_XMLROOT, NULL, NIL,
									 list_make3($3, $5, $6), @1);
				}
			| XMLSERIALIZE '(' document_or_content a_expr AS SimpleTypename ')'
				{
					XmlSerialize *n = makeNode(XmlSerialize);
					n->xmloption = (XmlOptionType)$3;
					n->expr = $4;
					n->typname = $6;
					n->location = @1;
					$$ = (Node *)n;
				}
			| TEXT_P '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("text");
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| INTERVAL '(' a_expr ',' expr_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("gs_interval");
					n->colname = "interval";
					n->args = lcons($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CHAR_P '(' a_expr ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("chara");
					n->colname = "char";
					n->args = list_make1($3);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| CHAR_P '(' a_expr ',' expr_list ')'
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("chara");
					n->colname = "char";
					n->args = lcons($3, $5);
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
		;

current_date_func:	CURRENT_DATE
			| CURRENT_DATE '(' ')'
		;

utc_date_func:	UTC_DATE
			| UTC_DATE '(' ')'
		;

utc_time_func:	UTC_TIME
			| UTC_TIME '(' ')'
		;

utc_timestamp_func:	UTC_TIMESTAMP
			| UTC_TIMESTAMP '(' ')'
		;

/*
 * SQL/XML support
 */
xml_root_version: VERSION_P a_expr
				{ $$ = $2; }
			| VERSION_P NO VALUE_P
				{ $$ = makeNullAConst(-1); }
		;

opt_xml_root_standalone: ',' STANDALONE_P YES_P
				{ $$ = makeIntConst(XML_STANDALONE_YES, -1); }
			| ',' STANDALONE_P NO
				{ $$ = makeIntConst(XML_STANDALONE_NO, -1); }
			| ',' STANDALONE_P NO VALUE_P
				{ $$ = makeIntConst(XML_STANDALONE_NO_VALUE, -1); }
			| /*EMPTY*/
				{ $$ = makeIntConst(XML_STANDALONE_OMITTED, -1); }
		;

xml_attributes: XMLATTRIBUTES '(' xml_attribute_list ')'	{ $$ = $3; }
		;

xml_attribute_list:	xml_attribute_el					{ $$ = list_make1($1); }
			| xml_attribute_list ',' xml_attribute_el	{ $$ = lappend($1, $3); }
		;

xml_attribute_el: a_expr AS ColLabel
				{
					$$ = makeNode(ResTarget);
					$$->name = $3;
					$$->indirection = NIL;
					$$->val = (Node *) $1;
					$$->location = @1;
				}
			| a_expr
				{
					$$ = makeNode(ResTarget);
					$$->name = NULL;
					$$->indirection = NIL;
					$$->val = (Node *) $1;
					$$->location = @1;
				}
		;

document_or_content: DOCUMENT_P						{ $$ = XMLOPTION_DOCUMENT; }
			| CONTENT_P								{ $$ = XMLOPTION_CONTENT; }
		;

xml_whitespace_option: PRESERVE WHITESPACE_P		{ $$ = TRUE; }
			| STRIP_P WHITESPACE_P					{ $$ = FALSE; }
			| /*EMPTY*/								{ $$ = FALSE; }
		;

/* We allow several variants for SQL and other compatibility. */
xmlexists_argument:
			PASSING c_expr
				{
					$$ = $2;
				}
			| PASSING c_expr BY REF
				{
					$$ = $2;
				}
			| PASSING BY REF c_expr
				{
					$$ = $4;
				}
			| PASSING BY REF c_expr BY REF
				{
					$$ = $4;
				}
		;

/*
 * Aggregate decoration clauses
 */
within_group_clause:
			WITHIN GROUP_P '(' sort_clause ')'		{ $$ = $4; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

/*
 * Window Definitions
 */
window_clause:
			WINDOW window_definition_list			{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

window_definition_list:
			window_definition						{ $$ = list_make1($1); }
			| window_definition_list ',' window_definition
													{ $$ = lappend($1, $3); }
		;

window_definition:
			ColId AS window_specification
				{
					WindowDef *n = $3;
					n->name = $1;
					$$ = n;
				}
		;

over_clause: OVER window_specification
				{ $$ = $2; }
			| OVER ColId
				{
					WindowDef *n = makeNode(WindowDef);
					n->name = $2;
					n->refname = NULL;
					n->partitionClause = NIL;
					n->orderClause = NIL;
					n->frameOptions = FRAMEOPTION_DEFAULTS;
					n->startOffset = NULL;
					n->endOffset = NULL;
					n->location = @2;
					$$ = n;
				}
			| /*EMPTY*/
				{ $$ = NULL; }
		;

window_specification: '(' opt_existing_window_name opt_partition_clause
						opt_sort_clause opt_frame_clause ')'
				{
					WindowDef *n = makeNode(WindowDef);
					n->name = NULL;
					n->refname = $2;
					n->partitionClause = $3;
					n->orderClause = $4;
					/* copy relevant fields of opt_frame_clause */
					n->frameOptions = $5->frameOptions;
					n->startOffset = $5->startOffset;
					n->endOffset = $5->endOffset;
					n->location = @1;
					$$ = n;
				}
		;

/*
 * If we see PARTITION, RANGE, or ROWS as the first token after the '('
 * of a window_specification, we want the assumption to be that there is
 * no existing_window_name; but those keywords are unreserved and so could
 * be ColIds.  We fix this by making them have the same precedence as IDENT
 * and giving the empty production here a slightly higher precedence, so
 * that the shift/reduce conflict is resolved in favor of reducing the rule.
 * These keywords are thus precluded from being an existing_window_name but
 * are not reserved for any other purpose.
 */
opt_existing_window_name: ColId						{ $$ = $1; }
			| /*EMPTY*/				%prec Op		{ $$ = NULL; }
		;

opt_partition_clause: PARTITION BY expr_list		{ $$ = $3; }
			| /*EMPTY*/								{ $$ = NIL; }
		;

/*
 * For frame clauses, we return a WindowDef, but only some fields are used:
 * frameOptions, startOffset, and endOffset.
 *
 * This is only a subset of the full SQL:2008 frame_clause grammar.
 * We don't support <window frame exclusion> yet.
 */
opt_frame_clause:
			RANGE frame_extent
				{
					WindowDef *n = $2;
					n->frameOptions |= FRAMEOPTION_NONDEFAULT | FRAMEOPTION_RANGE;
					if (n->frameOptions & (FRAMEOPTION_START_VALUE_PRECEDING |
										   FRAMEOPTION_END_VALUE_PRECEDING)) {
        				const char* message = "RANGE PRECEDING is only supported with UNBOUNDED";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("RANGE PRECEDING is only supported with UNBOUNDED"),
								 parser_errposition(@1)));
					}
					if (n->frameOptions & (FRAMEOPTION_START_VALUE_FOLLOWING |
										   FRAMEOPTION_END_VALUE_FOLLOWING)) {
        				const char* message = "RANGE PRECEDING is only supported with UNBOUNDED";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
								 errmsg("RANGE FOLLOWING is only supported with UNBOUNDED"),
								 parser_errposition(@1)));
					}
					$$ = n;
				}
			| ROWS frame_extent
				{
					WindowDef *n = $2;
					n->frameOptions |= FRAMEOPTION_NONDEFAULT | FRAMEOPTION_ROWS;
					$$ = n;
				}
			| /*EMPTY*/
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_DEFAULTS;
					n->startOffset = NULL;
					n->endOffset = NULL;
					$$ = n;
				}
		;

frame_extent: frame_bound
				{
					WindowDef *n = $1;
					/* reject invalid cases */
					if (n->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING) {
        				const char* message = "frame start cannot be UNBOUNDED FOLLOWING";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame start cannot be UNBOUNDED FOLLOWING"),
								 parser_errposition(@1)));
					}
					if (n->frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING) {
        				const char* message = "frame starting from following row cannot end with current row";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame starting from following row cannot end with current row"),
								 parser_errposition(@1)));
					}
					n->frameOptions |= FRAMEOPTION_END_CURRENT_ROW;
					$$ = n;
				}
			| BETWEEN frame_bound AND frame_bound
				{
					WindowDef *n1 = $2;
					WindowDef *n2 = $4;
					/* form merged options */
					int		frameOptions = n1->frameOptions;
					/* shift converts START_ options to END_ options */
					frameOptions |= n2->frameOptions << 1;
					frameOptions |= FRAMEOPTION_BETWEEN;
					/* reject invalid cases */
					if (frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING) {
        				const char* message = "frame start cannot be UNBOUNDED FOLLOWING";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame start cannot be UNBOUNDED FOLLOWING"),
								 parser_errposition(@2)));
					}
					if (frameOptions & FRAMEOPTION_END_UNBOUNDED_PRECEDING) {
        				const char* message = "frame start cannot be UNBOUNDED PRECEDING";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame end cannot be UNBOUNDED PRECEDING"),
								 parser_errposition(@4)));
					}
					if ((frameOptions & FRAMEOPTION_START_CURRENT_ROW) &&
						(frameOptions & FRAMEOPTION_END_VALUE_PRECEDING)) {
        				const char* message = "frame starting from current row cannot have preceding rows";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame starting from current row cannot have preceding rows"),
								 parser_errposition(@4)));
					}
					if ((frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING) &&
						(frameOptions & (FRAMEOPTION_END_VALUE_PRECEDING |
										 FRAMEOPTION_END_CURRENT_ROW))) {
        				const char* message = "frame starting from current row cannot have preceding rows";
    					InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
						ereport(errstate,
								(errcode(ERRCODE_WINDOWING_ERROR),
								 errmsg("frame starting from following row cannot have preceding rows"),
								 parser_errposition(@4)));
					}
					n1->frameOptions = frameOptions;
					n1->endOffset = n2->startOffset;
					$$ = n1;
				}
		;

/*
 * This is used for both frame start and frame end, with output set up on
 * the assumption it's frame start; the frame_extent productions must reject
 * invalid cases.
 */
frame_bound:
			UNBOUNDED PRECEDING
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_START_UNBOUNDED_PRECEDING;
					n->startOffset = NULL;
					n->endOffset = NULL;
					$$ = n;
				}
			| UNBOUNDED FOLLOWING
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_START_UNBOUNDED_FOLLOWING;
					n->startOffset = NULL;
					n->endOffset = NULL;
					$$ = n;
				}
			| CURRENT_P ROW
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_START_CURRENT_ROW;
					n->startOffset = NULL;
					n->endOffset = NULL;
					$$ = n;
				}
			| a_expr PRECEDING
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_START_VALUE_PRECEDING;
					n->startOffset = $1;
					n->endOffset = NULL;
					$$ = n;
				}
			| a_expr FOLLOWING
				{
					WindowDef *n = makeNode(WindowDef);
					n->frameOptions = FRAMEOPTION_START_VALUE_FOLLOWING;
					n->startOffset = $1;
					n->endOffset = NULL;
					$$ = n;
				}
		;


/*
 * Supporting nonterminals for expressions.
 */

/* Explicit row production.
 *
 * SQL99 allows an optional ROW keyword, so we can now do single-element rows
 * without conflicting with the parenthesized a_expr production.  Without the
 * ROW keyword, there must be more than one a_expr inside the parens.
 */
row:		ROW '(' expr_list ')'					{ $$ = $3; }
			| ROW '(' ')'							{ $$ = NIL; }
			| '(' expr_list ',' a_expr ')'			{ $$ = lappend($2, $4); }
		;
explicit_row:	ROW '(' expr_list ')'				{ $$ = $3; }
			| ROW '(' ')'							{ $$ = NIL; }
		;

implicit_row:	'(' expr_list ',' a_expr ')'		{ $$ = lappend($2, $4); }
		;

sub_type:	ANY										{ $$ = ANY_SUBLINK; }
			| SOME									{ $$ = ANY_SUBLINK; }
			| ALL									{ $$ = ALL_SUBLINK; }
		;

all_Op:		Op										{ $$ = $1; }
			| CmpOp									{ $$ = $1; }
			| CmpNullOp								{ $$ = $1; }
			| MathOp								{ $$ = $1; }
		;

assign_operator: 	'='								{ }
			| COLON_EQUALS							{ }
			;

MathOp:		 '+'									{ $$ = "+"; }
			| '-'									{ $$ = "-"; }
			| '*'									{ $$ = "*"; }
			| '/'									{ $$ = "/"; }
			| '%'									{ $$ = "%"; }
			| '^'									{ $$ = "^"; }
			| '<'									{ $$ = "<"; }
			| '>'									{ $$ = ">"; }
			| '='									{ $$ = "="; }
			| '@'									{ $$ = "@"; }
		;

qual_Op:	Op
					{ $$ = list_make1(makeString($1)); }
			| OPERATOR '(' any_operator ')'
					{ $$ = $3; }
		;

qual_all_Op:
			all_Op
					{ $$ = list_make1(makeString($1)); }
			| OPERATOR '(' any_operator ')'
					{ $$ = $3; }
		;
/* cannot put SIMILAR TO here, because SIMILAR TO is a hack.
 * the regular expression is preprocessed by a function (similar_escape),
 * and the ~ operator for posix regular expressions is used.
 *        x SIMILAR TO y     ->    x ~ similar_escape(y)
 * this transformation is made on the fly by the parser upwards.
 * however the SubLink structure which handles any/some/all stuff
 * is not ready for such a thing.
 */

expr_list:	a_expr
				{
					$$ = list_make1($1);
				}
			| expr_list ',' a_expr
				{
					$$ = lappend($1, $3);
				}
		;

/* function arguments can have names */
func_arg_list:  func_arg_expr
				{
					$$ = list_make1($1);
				}
			| func_arg_list ',' func_arg_expr
				{
					$$ = lappend($1, $3);
				}
		;

func_arg_expr:  a_expr
				{
					$$ = $1;
				}
			| param_name COLON_EQUALS a_expr
				{
					NamedArgExpr *na = makeNode(NamedArgExpr);
					na->name = $1;
					na->arg = (Expr *) $3;
					na->argnumber = -1;		/* until determined */
					na->location = @1;
					$$ = (Node *) na;
				}
			/* add PARA_EQUALS for simulating A db assignment with argument name as "=>"*/
			| param_name PARA_EQUALS a_expr
				{
					NamedArgExpr *na = makeNode(NamedArgExpr);
					na->name = $1;
					na->arg = (Expr *) $3;
					na->argnumber = -1;		/* until determined */
					na->location = @1;
					$$ = (Node *) na;
				}
		;

type_list:	Typename								{ $$ = list_make1($1); }
			| type_list ',' Typename				{ $$ = lappend($1, $3); }
		;

array_expr: '[' expr_list ']'
				{
					$$ = makeAArrayExpr($2, @1);
				}
			| '[' array_expr_list ']'
				{
					$$ = makeAArrayExpr($2, @1);
				}
			| '[' ']'
				{
					$$ = makeAArrayExpr(NIL, @1);
				}
		;

array_expr_list: array_expr							{ $$ = list_make1($1); }
			| array_expr_list ',' array_expr		{ $$ = lappend($1, $3); }
		;


extract_list:
			extract_arg FROM a_expr
				{
					$$ = list_make2(makeStringConst($1, @1), $3);
				}
			| /*EMPTY*/								{ $$ = NIL; }
		;

/* Allow delimited string SCONST in extract_arg as an SQL extension.
 * - thomas 2001-04-12
 */
extract_arg:
			normal_ident							{ $$ = $1; }
			| msq_extract_arg                       { $$ = $1; }
			| YEAR_P								{ $$ = "year"; }
			| MONTH_P								{ $$ = "month"; }
			| DAY_P									{ $$ = "day"; }
			| HOUR_P								{ $$ = "hour"; }
			| MINUTE_P								{ $$ = "minute"; }
			| SECOND_P								{ $$ = "second"; }
			| QUARTER								{ $$ = "quarter"; }
			| MICROSECOND_P							{ $$ = "microsecond"; }
			| SCONST								{ $$ = $1; }
		;

msq_extract_arg:
			SECOND_MICROSECOND_P                    { $$ = "second_microsecond"; }
			| MINUTE_MICROSECOND_P					{ $$ = "minute_microsecond"; }
			| MINUTE_SECOND_P						{ $$ = "minute_second"; }
			| HOUR_MICROSECOND_P					{ $$ = "hour_microsecond"; }
			| HOUR_SECOND_P                         { $$ = "hour_second"; }
			| HOUR_MINUTE_P							{ $$ = "hour_minute"; }
			| DAY_MICROSECOND_P						{ $$ = "day_microsecond"; }
			| DAY_SECOND_P							{ $$ = "day_second"; }
			| DAY_MINUTE_P							{ $$ = "day_minute"; }
			| DAY_HOUR_P							{ $$ = "day_hour"; }
			| YEAR_MONTH_P							{ $$ = "year_month"; }
		;

timestamp_arg_list:
			timestamp_units ',' a_expr ',' a_expr
				{
					$$ = list_make3(makeStringConst($1, @1), $3, $5);
				}
			| /*EMPTY*/								{ $$ = NIL; }
		;

timestamp_units:
			normal_ident							{ $$ = $1; }
			| YEAR_P								{ $$ = "year"; }
			| MONTH_P								{ $$ = "month"; }
			| DAY_P									{ $$ = "day"; }
			| HOUR_P								{ $$ = "hour"; }
			| MINUTE_P								{ $$ = "minute"; }
			| SECOND_P								{ $$ = "second"; }
			| QUARTER								{ $$ = "quarter"; }
			| MICROSECOND_P							{ $$ = "microsecond"; }
			| SCONST								{ $$ = $1; }
		;

optional_precision:
    		Iconst
				{
					$$ = makeIntConst($1, @1);
				}
			|/*EMPTY*/								{ $$ = NULL; }

get_format_time_type:
			DATE_P									{ $$ = makeIntConst(DTK_DATE, @1); }
			| TIME									{ $$ = makeIntConst(DTK_TIME, @1); }
			| DATETIME								{ $$ = makeIntConst(DTK_DATE_TIME, @1); }
			| TIMESTAMP								{ $$ = makeIntConst(DTK_DATE_TIME, @1); }
		;

/* OVERLAY() arguments
 * SQL99 defines the OVERLAY() function:
 * o overlay(text placing text from int for int)
 * o overlay(text placing text from int)
 * and similarly for binary strings
 */
overlay_list:
			a_expr overlay_placing substr_from substr_for
				{
					$$ = list_make4($1, $2, $3, $4);
				}
			| a_expr overlay_placing substr_from
				{
					$$ = list_make3($1, $2, $3);
				}
		;

overlay_placing:
			PLACING a_expr
				{ $$ = $2; }
		;

/* position_list uses b_expr not a_expr to avoid conflict with general IN */

position_list:
			b_expr IN_P b_expr						{ $$ = list_make2($3, $1); }
			| /*EMPTY*/								{ $$ = NIL; }
		;

/* SUBSTRING() arguments
 * SQL9x defines a specific syntax for arguments to SUBSTRING():
 * o substring(text from int for int)
 * o substring(text from int) get entire string from starting point "int"
 * o substring(text for int) get first "int" characters of string
 * o substring(text from pattern) get entire string matching pattern
 * o substring(text from pattern for escape) same with specified escape char
 * We also want to support generic substring functions which accept
 * the usual generic list of arguments. So we will accept both styles
 * here, and convert the SQL9x style to the generic list for further
 * processing. - thomas 2000-11-28
 */
substr_list:
			a_expr substr_from substr_for
				{
					$$ = list_make3($1, $2, $3);
				}
			| a_expr substr_for substr_from
				{
					/* not legal per SQL99, but might as well allow it */
					$$ = list_make3($1, $3, $2);
				}
			| a_expr substr_from
				{
					$$ = list_make2($1, $2);
				}
			| a_expr substr_for
				{
					/*
					 * Since there are no cases where this syntax allows
					 * a textual FOR value, we forcibly cast the argument
					 * to int4.  The possible matches in pg_proc are
					 * substring(text,int4) and substring(text,text),
					 * and we don't want the parser to choose the latter,
					 * which it is likely to do if the second argument
					 * is unknown or doesn't have an implicit cast to int4.
					 */
					$$ = list_make3($1, makeIntConst(1, -1),
									makeTypeCast($2,
												 SystemTypeName("int4"), -1));
				}
			| expr_list
				{
					$$ = $1;
				}
			| /*EMPTY*/
				{ $$ = NIL; }
		;

substr_from:
			FROM a_expr								{ $$ = $2; }
		;

substr_for: FOR a_expr								{ $$ = $2; }
		;

trim_list:	a_expr FROM expr_list					{ $$ = lappend($3, $1); }
			| FROM expr_list						{ $$ = $2; }
			| expr_list								{ $$ = $1; }
		;

in_expr:	select_with_parens
				{
					SubLink *n = makeNode(SubLink);
					n->subselect = $1;
					/* other fields will be filled later */
					$$ = (Node *)n;
				}
			| '(' expr_list ')'						{ $$ = (Node *)$2; }
		;

/*
 * Define SQL92-style case clause.
 * - Full specification
 *	CASE WHEN a = b THEN c ... ELSE d END
 * - Implicit argument
 *	CASE a WHEN b THEN c ... ELSE d END
 */
case_expr:	CASE case_arg when_clause_list case_default END_P
				{
					CaseExpr *c = makeNode(CaseExpr);
					c->casetype = InvalidOid; /* not analyzed yet */
					c->arg = (Expr *) $2;
					c->args = $3;
					c->defresult = (Expr *) $4;
					c->location = @1;
					$$ = (Node *)c;
				}
			| IF_P '(' a_expr ',' a_expr ',' a_expr ')'
				{
					CaseExpr *c = makeNode(CaseExpr);
					c->casetype = InvalidOid; /* not analyzed yet */
					c->arg = NULL;
					CaseWhen *w = makeNode(CaseWhen);
					w->expr = (Expr *) $3;
					w->result = (Expr *) $5;
					c->args = list_make1(w);
					c->defresult = (Expr *) $7;
					c->location = @1;
					$$ = (Node *)c;
				}
		| DECODE '(' a_expr ',' expr_list ')'
				{
					if(list_length($5) < 2)
					{
						FuncCall *n = makeNode(FuncCall);
						n->funcname = SystemFuncName("decode");
						n->args = list_concat(list_make1($3), $5);
						n->agg_order = NIL;
						n->agg_star = FALSE;
						n->agg_distinct = FALSE;
						n->func_variadic = FALSE;
						n->over = NULL;
						n->location = @1;
						n->call_func = false;
						$$ = (Node *)n;
					}
					else
					{
						ListCell *cell = NULL;
						CaseExpr *c = makeNode(CaseExpr);
						c->casetype = InvalidOid; /* not analyzed yet */
						c->arg = NULL;
						c->args = NULL;
						c->defresult = NULL;
						c->fromDecode = true;

						foreach(cell,$5)
						{
							Expr *expr1 = NULL;
							Expr *expr2 = NULL;
							CaseWhen *w = NULL;
							expr1 = (Expr*) lfirst(cell);
							cell = lnext(cell);
							if(NULL == cell)
							{
								c->defresult = expr1;
								break;
							}
							expr2 = (Expr*) lfirst(cell);
							w = makeNode(CaseWhen);
							w->expr = makeNodeDecodeCondtion((Expr*)$3,expr1);
							w->result = expr2;
							c->args = lappend(c->args,w);
						}
						$$ = (Node *)c;
					}
				}
		;

when_clause_list:
			/* There must be at least one */
			when_clause								{ $$ = list_make1($1); }
			| when_clause_list when_clause			{ $$ = lappend($1, $2); }
		;

when_clause:
			WHEN a_expr THEN a_expr
				{
					CaseWhen *w = makeNode(CaseWhen);
					w->expr = (Expr *) $2;
					w->result = (Expr *) $4;
					w->location = @1;
					$$ = (Node *)w;
				}
		;

case_default:
			ELSE a_expr								{ $$ = $2; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

case_arg:	a_expr									{ $$ = $1; }
			| /*EMPTY*/								{ $$ = NULL; }
		;

columnref:	DolphinColId
				{
					$$ = makeColumnRef($1->str, NIL, @1, yyscanner);
				}
			| DolphinColId dolphin_indirection %prec IDENT
				{
					List* result = NIL;
					ListCell* cell = NULL;
					char* first_word = NULL;
					int schema_index = -1;
					int table_index = -1;
					int col_index = -1;
					int count = 0;
					int indices = 0;
					foreach (cell, $2) {
						DolphinString* dolphinString = (DolphinString*)lfirst(cell);
						if (IsA(dolphinString->node, A_Indices)) {
							indices++;
						}
					}
					cell = NULL;
					switch (list_length($2) - indices)
					{
						case 0:
							/* column */
							first_word = $1->str;
							break;
						case 1:
							/* table.column */
							first_word = GetDolphinObjName($1->str, $1->is_quoted);
							col_index = 0;
							break;
						case 2:
							/* schema.table.column */
							first_word = GetDolphinSchemaName($1->str, $1->is_quoted);
							col_index = 1;
							table_index = 0;
							break;
						default:
							/* catalog.schema.table.column. ... */
							first_word = downcase_str($1->str, $1->is_quoted);
							schema_index = 0;
							table_index = 1;
							col_index = 2;
							break;
					}
					foreach (cell, $2) {
						DolphinString* dolphinString = (DolphinString*)lfirst(cell);
						if (IsA(dolphinString->node, String)) {
							Value* value = (Value*)(dolphinString->node);
							char* text = strVal(value);
							bool is_quoted = dolphinString->is_quoted;
							if (count == schema_index) {
								text = GetDolphinSchemaName(text, is_quoted);
							} else if (count == table_index) {
								text = GetDolphinObjName(text, is_quoted);
							} else if (count != col_index) {
								text = downcase_str(text, is_quoted);
							}
							count++;
							result = lappend(result, (Node*)makeString(text));
						} else {
							result = lappend(result, dolphinString->node);
						}
					}
					$$ = makeColumnRef(first_word, result, @1, yyscanner);
				}
		;

indirection_el:
			'.' attr_name
				{
					$$ = (Node *) makeString($2);
				}
			| ORA_JOINOP
				{
					$$ = (Node *) makeString("(+)");
				}
			| '.' '*'
				{
					$$ = (Node *) makeNode(A_Star);
				}
			| '[' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = NULL;
					ai->uidx = $2;
					$$ = (Node *) ai;
				}
			| '[' a_expr ':' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = $2;
					ai->uidx = $4;
					$$ = (Node *) ai;
				}
			| '[' a_expr ',' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = $2;
					ai->uidx = $4;
					$$ = (Node *) ai;
				}
		;

indirection:
			indirection_el							{ $$ = list_make1($1); }
			| indirection indirection_el			{ $$ = lappend($1, $2); }
		;

dolphin_indirection:
			dolphin_indirection_el									{ $$ = list_make1($1); }
			| dolphin_indirection dolphin_indirection_el			{ $$ = lappend($1, $2); }
		;

dolphin_indirection_el:
			'.' DolphinColLabel
				{
					if ($2->is_sconst)
						ereport(ERROR,(errcode(ERRCODE_SYNTAX_ERROR), errmsg("syntax error at or near \"%s\"", $2->str), parser_errposition(@2)));
					$$ = $2;
				}
			| ORA_JOINOP
				{
					$$ = MakeDolphinStringByNode((Node *) makeString(pstrdup("(+)")), false);
				}
			| '.' '*'
				{
					$$ = MakeDolphinStringByNode((Node *) makeNode(A_Star), false);
				}
			| '[' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = NULL;
					ai->uidx = $2;
					$$ = MakeDolphinStringByNode((Node *) ai, false);
				}
			| '[' a_expr ':' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = $2;
					ai->uidx = $4;
					$$ = MakeDolphinStringByNode((Node *) ai, false);
				}
			| '[' a_expr ',' a_expr ']'
				{
					A_Indices *ai = makeNode(A_Indices);
					ai->lidx = $2;
					ai->uidx = $4;
					$$ = MakeDolphinStringByNode((Node *) ai, false);
				}
		;

opt_indirection:
			/*EMPTY*/								{ $$ = NIL; }
			| opt_indirection indirection_el		{ $$ = lappend($1, $2); }
		;

opt_dolphin_indirection:
			/*EMPTY*/								{ $$ = NIL; }
			| opt_dolphin_indirection dolphin_indirection_el		{ $$ = lappend($1, $2); }
		;

opt_asymmetric: ASYMMETRIC
			| /*EMPTY*/
		;

/*
 * The SQL spec defines "contextually typed value expressions" and
 * "contextually typed row value constructors", which for our purposes
 * are the same as "a_expr" and "row" except that DEFAULT can appear at
 * the top level.
 */

ctext_expr:
			a_expr					{ $$ = (Node *) $1; }
			| DEFAULT
				{
					SetToDefault *n = makeNode(SetToDefault);
					n->location = @1;
					$$ = (Node *) n;
				}
		;

ctext_expr_list:
			ctext_expr								{ $$ = list_make1($1); }
			| ctext_expr_list ',' ctext_expr		{ $$ = lappend($1, $3); }
		;

/*
 * We should allow ROW '(' ctext_expr_list ')' too, but that seems to require
 * making VALUES a fully reserved word, which will probably break more apps
 * than allowing the noise-word is worth.
 */
ctext_row: '(' ctext_expr_list ')'					{ $$ = $2; }
		;


/*****************************************************************************
 *
 *	target list for SELECT
 *
 *****************************************************************************/

target_list:
			target_el								{ $$ = list_make1($1); }
			| target_list ',' target_el				{ $$ = lappend($1, $3); }
		;

target_el:	a_expr AS DolphinColLabel
				{
					$$ = makeNode(ResTarget);
					$$->name = $3->str;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
			/*
			 * We support omitting AS only for column labels that aren't
			 * any known keyword.  There is an ambiguity against postfix
			 * operators: is "a ! b" an infix expression, or a postfix
			 * expression and a column label?  We prefer to resolve this
			 * as an infix expression, which we accomplish by assigning
			 * IDENT a precedence higher than POSTFIXOP.
			 */
			| a_expr DOLPHINIDENT
				{
					$$ = makeNode(ResTarget);
					$$->name = $2->str;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
					if (IsConnectByRootIdent($1)) {
						Node* cr = (Node*) makeColumnRef($2->str, NIL, @1, yyscanner);
						Node* n = MakeConnectByRootNode((ColumnRef*) cr, @1);
						$$->name = MakeConnectByRootColName(NULL, $2->str);
						$$->val = (Node*) n;
					}
				}
			| a_expr_without_sconst SCONST
				{
					$$ = makeNode(ResTarget);
					$$->name = $2;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
					if (IsConnectByRootIdent($1)) {
						Node* cr = (Node*) makeColumnRef($2, NIL, @1, yyscanner);
						Node* n = MakeConnectByRootNode((ColumnRef*) cr, @1);
						$$->name = MakeConnectByRootColName(NULL, $2);
						$$->val = (Node*) n;
					}
				}
			| Sconst
				{
					$$ = makeNode(ResTarget);
					$$->name = NULL;
					$$->indirection = NIL;
					$$->val = (Node *)makeStringConst($1, @1);
					$$->location = @1;
				}
			| a_expr_without_sconst
				{
					$$ = makeNode(ResTarget);
					$$->name = NULL;
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;

					ColumnRef* cr = (ColumnRef*) $1;
					/* PRIOR(x) in target list implies func call */
					if (IsA($1, ColumnRef) && cr->prior && cr->location == 0) {
						FuncCall *fn = MakePriorAsFunc();
						cr->prior = false;
						fn->args = list_make1(cr);
						$$->val = (Node *)fn;
					}
				}
			| '*'
				{
					ColumnRef *n = makeNode(ColumnRef);
					n->fields = list_make1(makeNode(A_Star));
					n->location = @1;
					n->indnum = 0;

					$$ = makeNode(ResTarget);
					$$->name = NULL;
					$$->indirection = NIL;
					$$->val = (Node *)n;
					$$->location = @1;
				}
			| c_expr_without_sconst VALUE_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
			| c_expr_without_sconst NAME_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
			| c_expr_without_sconst TYPE_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)$1;
					$$->location = @1;
				}
			| Sconst VALUE_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)makeStringConst($1, @1);
					$$->location = @1;
				}
			| Sconst NAME_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)makeStringConst($1, @1);
					$$->location = @1;
				}
			| Sconst TYPE_P
				{
					$$ = makeNode(ResTarget);
					$$->name = pstrdup($2);
					$$->indirection = NIL;
					$$->val = (Node *)makeStringConst($1, @1);
					$$->location = @1;
				}
                        | connect_by_root_expr
                                {
                                        $$ = (ResTarget*) $1;
                                }
		;

connect_by_root_expr:   a_expr normal_ident '.' normal_ident
                                {
                                       ValidateTripleTuple((Node*)$1, yyscanner, @2, $2);
                                       Node* cr = (Node*) makeColumnRef($2, list_make1(makeString($4)), @1, yyscanner);
                                       Node* n = MakeConnectByRootNode((ColumnRef*) cr, @1);
                                       $$ = makeNode(ResTarget);
                                       $$->name = MakeConnectByRootColName($2, $4);
                                       $$->val = (Node*) n; 
                                       $$->indirection = NIL;
                                       $$->location = @1;
                                }
                        | a_expr normal_ident '.' normal_ident as_empty normal_ident
                                {
                                       ValidateTripleTuple((Node*)$1, yyscanner, @2, $2);
                                       Node* cr = (Node*) makeColumnRef($2, list_make1(makeString($4)), @1, yyscanner);
                                       Node* n = MakeConnectByRootNode((ColumnRef*) cr, @1);
                                       $$ = makeNode(ResTarget);
                                       $$->name = $6;
                                       $$->val = (Node*) n;
                                       $$->indirection = NIL;
                                       $$->location = @1;
                                }
                        | a_expr normal_ident as_empty normal_ident
                                {
                                       ValidateTripleTuple((Node*) $1, yyscanner, @2, $2);
                                       Node* cr = (Node*) makeColumnRef($2, NIL, @1, yyscanner);
                                       Node* n = MakeConnectByRootNode((ColumnRef*) cr, @1);
                                       $$ = makeNode(ResTarget);
                                       $$->name = $4;
                                       $$->val = (Node *) n;
                                       $$->indirection = NIL;
                                       $$->location = @1;
				}
                ;

/*****************************************************************************
 *
 *	Names and constants
 *
 *****************************************************************************/

qualified_name_list:
			qualified_name							{ $$ = list_make1($1); }
			| qualified_name_list ',' qualified_name { $$ = lappend($1, $3); }
		;

dolphin_qualified_name_list:
			dolphin_qualified_name										{ $$ = list_make1($1); }
			| dolphin_qualified_name_list ',' dolphin_qualified_name	{ $$ = lappend($1, $3); }
		;

/*
 * The production for a qualified relation name has to exactly match the
 * production for a qualified func_name, because in a FROM clause we cannot
 * tell which we are parsing until we see what comes after it ('(' for a
 * func_name, something else for a relation). Therefore we allow 'indirection'
 * which may contain subscripts, and reject that case in the C code.
 */
qualified_name:
			ColId
				{
					$$ = makeRangeVar(NULL, $1, @1);
				}
			| ColId indirection
				{
					check_qualified_name($2, yyscanner);
					$$ = makeRangeVar(NULL, NULL, @1);
					const char* message = "improper qualified name (too many dotted names)";
					switch (list_length($2))
					{
						case 1:
							$$->catalogname = NULL;
							$$->schemaname = $1;
							$$->relname = strVal(linitial($2));
							break;
						case 2:
							$$->catalogname = $1;
							$$->schemaname = strVal(linitial($2));
							$$->relname = strVal(lsecond($2));
							break;
						default:
    						InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper qualified name (too many dotted names): %s",
											NameListToString(lcons(makeString($1), $2))),
									 parser_errposition(@1)));
							break;
					}
				}
		;

dolphin_qualified_name:
			DolphinColId
				{
					$$ = makeRangeVar(NULL, GetDolphinObjName($1->str, $1->is_quoted), @1);
				}
			| DolphinColId dolphin_indirection
				{
					check_dolphin_qualified_name($2, yyscanner);
					$$ = makeRangeVar(NULL, NULL, @1);
					const char* message = "improper qualified name (too many dotted names)";
					DolphinString* first = NULL;
					DolphinString* second = NULL;
					switch (list_length($2))
					{
						case 1:
							$$->catalogname = NULL;
							$$->schemaname = GetDolphinSchemaName($1->str, $1->is_quoted);
							first = (DolphinString*)linitial($2);
							$$->relname = GetDolphinObjName(first->str, first->is_quoted);
							break;
						case 2:
							$$->catalogname = downcase_str($1->str, $1->is_quoted);
							first = (DolphinString*)linitial($2);
							second = (DolphinString*)lsecond($2);
							$$->schemaname = GetDolphinSchemaName(first->str, first->is_quoted);
							$$->relname = GetDolphinObjName(second->str, second->is_quoted);
							break;
						default:
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("improper qualified name (too many dotted names): %s",
											NameListToString(lcons(makeString($1->str), GetNameListFromDolphinString($2)))),
									 parser_errposition(@1)));
							break;
					}
				}
		;

name_list:	name
					{ $$ = list_make1(makeString($1)); }
			| name_list ',' name
					{ $$ = lappend($1, makeString($3)); }
		;

dolphin_schema_name_list:	DolphinColId
						{ $$ = list_make1(makeString(GetDolphinSchemaName($1->str, $1->is_quoted))); }
					| dolphin_schema_name_list ',' DolphinColId
						{ $$ = lappend($1, makeString(GetDolphinSchemaName($3->str, $3->is_quoted))); }
		;


name:		ColId									{ $$ = $1; };

database_name:
			ColId									{ $$ = $1; };

access_method:
			ColId									{ $$ = $1; };

attr_name:	ColLabel								{ $$ = $1; };

index_name: ColId									{ $$ = $1; };

dolphin_force_index_name:
			index_name								{ $$ = $1; }
			| PRIMARY								{ $$ = downcase_str(pstrdup($1), false);}
			;

dolphin_index_name: DolphinColId					{ $$ = downcase_str($1->str, $1->is_quoted); };

file_name:	SCONST									{ $$ = $1; };

/*
 * The production for a qualified func_name has to exactly match the
 * production for a qualified columnref, because we cannot tell which we
 * are parsing until we see what comes after it ('(' or SCONST for a func_name,
 * anything else for a columnref).  Therefore we allow 'indirection' which
 * may contain subscripts, and reject that case in the C code.  (If we
 * ever implement SQL99-like methods, such syntax may actually become legal!)
 */
func_name:	type_function_name
					{ $$ = list_make1(makeString($1)); }
			| ColId indirection
					{
						$$ = check_func_name(lcons(makeString($1), $2),
											 yyscanner);
					}
		;

dolphin_func_name:	type_function_name
						{ $$ = list_make1(makeString($1)); }
					| DolphinColId dolphin_indirection
						{
							int len = list_length($2);
							if (len == 1) {
								/* schema_name.func_name */
								$$ = check_func_name(lcons(makeString(GetDolphinSchemaName($1->str, $1->is_quoted)),
														GetNameListFromDolphinString($2)), yyscanner);
							} else {
								/* category_name.schema_name.func_name */
								DolphinString* element = (DolphinString*)lsecond($2);
								element->str = GetDolphinSchemaName(element->str, element->is_quoted);
								$$ = check_func_name(lcons(makeString(downcase_str($1->str, $1->is_quoted)),
														GetNameListFromDolphinString($2)), yyscanner);
							}
						}
		;

func_name_opt_arg:
						func_name
						/* This rule is never used. */
						| normal_ident BOGUS							{ $$ = NIL; }
						/* This rule is never used. */
						| unreserved_keyword BOGUS				{ $$ = NIL; };
dolphin_func_name_opt_arg:
						dolphin_func_name
						/* This rule is never used. */
						| DOLPHINIDENT BOGUS							{ $$ = NIL; }
						/* This rule is never used. */
						| unreserved_keyword BOGUS				{ $$ = NIL; };

/*
 * Constants
 */

DOLPHINIDENT: IDENT
				{
					$$ = $1;
				}
			| DB_B_JSON
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_JSONB
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_BOX
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_CIRCLE
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_POLYGON
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_BYTEA
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_TIMETZ
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_TIMESTAMPTZ
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			| DB_B_CIDR
				{
					$$ = CreateDolphinIdent(pstrdup($1), false);
				}
			;

AexprConst:
			AexprConst_without_Sconst	{ $$ = $1; }
			| Sconst /* special case, allow SCONST SCONST, means concat the string */
				{
					$$ = makeStringConst($1, @1);
				}
			;

AexprConst_without_Sconst: Iconst
				{
					$$ = makeIntConst($1, @1);
				}
			| FCONST
				{
					$$ = makeFloatConst($1, @1);
				}
			| BCONST
				{
					$$ = makeBitStringConst($1, @1);
				}
			| XCONST
				{
					/* This is a bit constant per SQL99:
					 * Without Feature F511, "BIT data type",
					 * a <general literal> shall not be a
					 * <bit string literal> or a <hex string literal>.
					 */
					$$ = makeBitStringConst($1, @1);
				}
			| UNDERSCORE_CHARSET SCONST
				{
					const char* encoding_name = $1;
					char *original_str = pg_server_to_client($2, strlen($2));
					int encoding = pg_valid_server_encoding(encoding_name);
					Assert(encoding >= 0);

					A_Const *con = makeNode(A_Const);
					con->val.type = T_String;
					con->val.val.str = original_str;
					con->location = @2;

					CharsetClause *n = makeNode(CharsetClause);
					n->arg = (Node *)con;
					n->charset = encoding;
					n->is_binary = (strcmp(encoding_name, "binary") == 0);
					n->location = @1;
					$$ = (Node *) n;
				}
			| UNDERSCORE_CHARSET BCONST
				{
					const char* encoding_name = $1;
					int encoding = pg_valid_server_encoding(encoding_name);
					Assert(encoding >= 0);

					CharsetClause *n = makeNode(CharsetClause);
					n->arg = makeBitStringConst($2, @2);
					n->charset = encoding;
					n->is_binary = (strcmp(encoding_name, "binary") == 0);
					n->location = @1;
					$$ = (Node *) n;
				}
			| UNDERSCORE_CHARSET XCONST
				{
					const char* encoding_name = $1;
					int encoding = pg_valid_server_encoding(encoding_name);
					Assert(encoding >= 0);

					CharsetClause *n = makeNode(CharsetClause);
					n->arg = makeBitStringConst($2, @2);
					n->charset = encoding;
					n->is_binary = (strcmp(encoding_name, "binary") == 0);
					n->location = @1;
					$$ = (Node *) n;
				}
			| YEAR_P SCONST
				{
					char* tmp = downcase_str(pstrdup($1), false);
					TypeName *t = makeTypeNameFromNameList(list_make1(makeString(tmp)));
					t->location = @1;
					$$ = makeStringConstCast($2, @2, t);
				}
			| type_func_name_keyword_without_current_schema SCONST
				{
					char* tmp = downcase_str(pstrdup($1), false);
					TypeName *t = makeTypeNameFromNameList(list_make1(makeString(tmp)));
					t->location = @1;
					$$ = makeStringConstCast($2, @2, t);
				}
			| dolphin_func_name '(' func_arg_list opt_sort_clause ')' SCONST
				{
					TypeName *t = makeTypeNameFromNameList($1);
					Type typtup = LookupTypeName(NULL, t, NULL, false);
					if (typtup) {
						/* generic syntax with a type modifier, if the type exists */
						ListCell* lc = NULL;
						ReleaseSysCache(typtup);
						/*
						 * We must use func_arg_list and opt_sort_clause in the production to avoid
						 * reduce/reduce conflicts, but we don't actually wish
						 * to allow NamedArgExpr in this context, nor ORDER BY.
						 */
						foreach(lc, $3) {
							NamedArgExpr *arg = (NamedArgExpr *) lfirst(lc);

							if (IsA(arg, NamedArgExpr)) {
								const char* message = "type modifier cannot have parameter name";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
										(errcode(ERRCODE_SYNTAX_ERROR),
										 errmsg("type modifier cannot have parameter name"),
										 parser_errposition(arg->location)));
							}
						}

						if ($4 != NIL) {
								const char* message = "type modifier cannot have ORDER BY";
								InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
								ereport(errstate,
										(errcode(ERRCODE_SYNTAX_ERROR),
										 errmsg("type modifier cannot have ORDER BY"),
										 parser_errposition(@4)));
						}
						t->typmods = $3;
						t->location = @1;
						$$ = makeStringConstCast($6, @6, t);
					} else {
						/* otherwise, treat sconst as alias of funcion() */
						FuncCall *n = makeNode(FuncCall);
						n->funcname = $1;
						n->colname = $6;
						n->args = $3;
						n->agg_order = $4;
						n->agg_star = FALSE;
						n->agg_distinct = FALSE;
						n->func_variadic = FALSE;
						n->over = NULL;
						n->location = @1;
						n->call_func = false;
						$$ = (Node *)n;
					}
				}
			| DB_B_JSON SCONST
				{
					TypeName * tmp = SystemTypeName("json");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_JSONB SCONST
				{
					TypeName * tmp = SystemTypeName("jsonb");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_BOX SCONST
				{
					TypeName * tmp = SystemTypeName("box");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_CIRCLE SCONST
				{
					TypeName * tmp = SystemTypeName("circle");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_POLYGON SCONST
				{
					TypeName * tmp = SystemTypeName("polygon");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_BYTEA SCONST
				{
					TypeName * tmp = SystemTypeName("bytea");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_TIMETZ SCONST
				{
					TypeName * tmp = SystemTypeName("timetz");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_TIMESTAMPTZ SCONST
				{
					TypeName * tmp = SystemTypeName("timestamptz");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DB_B_CIDR SCONST
				{
					TypeName * tmp = SystemTypeName("cidr");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			/* promote and expand CharacterWithoutLength to AexprConst */
			| CHARACTER VARYING SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($3, @3, tmp);
				}
			| CHARACTER SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("bpchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NVARCHAR SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("nvarchar2"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NVARCHAR2 SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("nvarchar2"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NATIONAL VARCHAR SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("nvarchar2"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($3, @3, tmp);
				}
			| VARCHAR SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| VARCHAR2 SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NATIONAL CHARACTER opt_varying SCONST
				{
					char* tmp_str = (char *)($3 ? "varchar": "bpchar");
					TypeName * tmp = SystemTypeName(tmp_str);
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($4, @4, tmp);
				}
			| NATIONAL CHAR_P opt_varying SCONST
				{
					char* tmp_str = (char *)($3 ? "varchar": "bpchar");
					TypeName * tmp = SystemTypeName(tmp_str);
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($4, @4, tmp);
				}
			| NCHAR VARYING SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($3, @3, tmp);
				}
			| NCHAR SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("bpchar"));
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| CHAR_P SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("bpchar"));
					/* char defaults to char(1), varchar to no limit */
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| CHAR_P VARYING SCONST
				{
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->location = @1;
					$$ = makeStringConstCast($3, @3, tmp);
				}
			| TEXT_P SCONST
				{
					TypeName * tmp = SystemTypeName("text");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			/* promote and expand CharacterWithLength to AexprConst */
			| character '(' a_expr ')' SCONST
				{
					TypeName * tmp = SystemTypeName($1);
					tmp->typmods = list_make1($3);
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| TEXT_P '(' a_expr ')' SCONST
				{
					TypeName * tmp = SystemTypeName("text");
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| CHAR_P '(' a_expr ')' SCONST
				{
					// If the type of $3 is not Iconst, an error is reported
					CheckIconstType($3);
					TypeName * tmp = SystemTypeName((char *)("bpchar"));
					tmp->location = @1;
					tmp->typmods = list_make1($3);
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| CHAR_P VARYING '(' a_expr ')' SCONST
				{
					// If the type of $4 is not Iconst, an error is reported
					CheckIconstType($4);
					TypeName * tmp = SystemTypeName((char *)("varchar"));
					tmp->typmods = list_make1($4);
					tmp->location = @1;
					$$ = makeStringConstCast($6, @6, tmp);
				}
			/* promote and expand PreciseConstDatetime to AexprConst */
			| TIMESTAMP '(' a_expr ')' SCONST opt_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					TypeName * tmp = NULL;
					CheckIconstType($3);
					if ($6)
						tmp = SystemTypeName("timestamptz");
					else
						tmp = SystemTypeName("timestamp");
					tmp->typmods = list_make1($3);
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| TIME '(' a_expr ')' SCONST opt_timezone
				{
					// If the type of $3 is not Iconst, an error is reported
					TypeName * tmp = NULL;
					CheckIconstType($3);
					if ($6)
						tmp = SystemTypeName("timetz");
					else
						tmp = SystemTypeName("time");
					tmp->typmods = list_make1($3);
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| TIMESTAMP SCONST
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("timestamp_cast");
					n->colname = pstrdup("timestamp");
					n->args = list_make4(makeStringConst($2, @2), makeIntConst(-1, -1), makeIntConst(-1, -1), makeBoolAConst(FALSE, -1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIMESTAMP WITH_TIME ZONE SCONST
				{
					TypeName * tmp = SystemTypeName("timestamptz");
					tmp->location = @1;
					$$ = makeStringConstCast($4, @4, tmp);
				}
			| TIMESTAMP WITHOUT TIME ZONE SCONST
				{
					TypeName * tmp = SystemTypeName("timestamp");
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| TIME SCONST
				{
					FuncCall *n = makeNode(FuncCall);
					n->funcname = SystemFuncName("time_cast");
					n->colname = pstrdup("time");
					n->args = list_make2(makeStringConst($2, @2), makeBoolAConst(TRUE, -1));
					n->agg_order = NIL;
					n->agg_star = FALSE;
					n->agg_distinct = FALSE;
					n->func_variadic = FALSE;
					n->over = NULL;
					n->location = @1;
					n->call_func = false;
					$$ = (Node *)n;
				}
			| TIME WITH_TIME ZONE SCONST
				{
					TypeName * tmp = SystemTypeName("timetz");
					tmp->location = @1;
					$$ = makeStringConstCast($4, @4, tmp);
				}
			| TIME WITHOUT TIME ZONE SCONST
				{
					TypeName * tmp = SystemTypeName("time");
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
				}
			| DATE_P SCONST
				{
					if (u_sess->attr.attr_sql.sql_compatibility == A_FORMAT)
					{
						TypeName * tmp = NULL;
						tmp = SystemTypeName("timestamp");
						tmp->typmods = list_make1(makeIntConst(0,-1));
						tmp->location = @1;
						tmp->end_location = @1 + DATE_LEN;
						$$ = makeStringConstCast($2, @2, tmp);
					}
					else {
						FuncCall *n = makeNode(FuncCall);
						n->funcname = SystemFuncName("date_cast");
						n->colname = pstrdup("date");
						n->args = list_make2(makeStringConst($2, @2), makeBoolAConst(TRUE, -1));
						n->agg_order = NIL;
						n->agg_star = FALSE;
						n->agg_distinct = FALSE;
						n->func_variadic = FALSE;
						n->over = NULL;
						n->location = @1;
						n->call_func = false;
						$$ = (Node *)n;
					}
				}
			| SMALLDATETIME SCONST
				{
					TypeName * tmp = SystemTypeName("smalldatetime");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DATETIME '(' Iconst ')' SCONST
			    {
					TypeName * tmp = SystemTypeName("timestamp");
					tmp->typmods = list_make1(makeIntConst($3,@3));
					tmp->location = @1;
					$$ = makeStringConstCast($5, @5, tmp);
			    }
			| DATETIME SCONST
			    {
					TypeName * tmp = SystemTypeName("timestamp");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
			    }
			/* promote and expand Numeric to AexprConst */
			| INT_P SCONST
				{
					TypeName * tmp = SystemTypeName("int4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| INTEGER SCONST
				{
					TypeName * tmp = SystemTypeName("int4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| TINYINT SCONST
				{
					TypeName * tmp = SystemTypeName("int1");
					tmp->location = @2;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| SMALLINT SCONST
				{
					TypeName * tmp = SystemTypeName("int2");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| MEDIUMINT SCONST
				{
					TypeName * tmp = SystemTypeName("int4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| BIGINT SCONST
				{
					TypeName * tmp = SystemTypeName("int8");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| REAL SCONST
				{
					TypeName * tmp = SystemTypeName("float4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| FLOAT_P SCONST
				{
					/* for B_FORMAT compatibility, float refers to float4 */
					TypeName * tmp = SystemTypeName("float4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| BINARY_DOUBLE SCONST
				{
					TypeName * tmp = SystemTypeName("float8");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| BINARY_INTEGER SCONST
				{
					TypeName * tmp = SystemTypeName("int4");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DECIMAL_P SCONST
				{
					TypeName * tmp = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmplist = list_make1(makeIntConst(10, -1));
					tmplist = lappend(tmplist, makeIntConst(0, -1));  
					tmp->typmods = tmplist;
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NUMBER_P SCONST
				{
					TypeName * tmp = SystemTypeName("numeric");
					tmp->typmods = NULL;
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| DEC SCONST
				{
					TypeName * tmp = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmplist = list_make1(makeIntConst(10, -1));
					tmplist = lappend(tmplist, makeIntConst(0, -1));  
					tmp->typmods = tmplist;
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| NUMERIC SCONST
				{
					TypeName * tmp = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmplist = list_make1(makeIntConst(10, -1));
					tmplist = lappend(tmplist, makeIntConst(0, -1));  
					tmp->typmods = tmplist;
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| FIXED_P SCONST
				{
					TypeName * tmp = SystemTypeName("numeric");
					/* for B_FORMAT compatibility, default (p, s) of decimal is (10, 0) */
					List* tmplist = list_make1(makeIntConst(10, -1));
					tmplist = lappend(tmplist, makeIntConst(0, -1));  
					tmp->typmods = tmplist;
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| BOOLEAN_P SCONST
				{
					TypeName * tmp = SystemTypeName("bool");
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| BIT opt_varying '(' expr_list ')' SCONST
				{
					char *typname = (char *)($2 ? "varbit" : "bit");
					TypeName * tmp = SystemTypeName(typname);
					tmp->typmods = $4;
					tmp->location = @1;
					$$ = makeStringConstCast($6, @6, tmp);
				}
			| BIT VARYING SCONST
				{
					TypeName * tmp = SystemTypeName("varbit");
					tmp->location = @1;
					$$ = makeStringConstCast($3, @3, tmp);
				}
			| BIT SCONST
				{
					TypeName * tmp = SystemTypeName("bit");
					tmp->typmods = list_make1(makeIntConst(1, -1));
					tmp->location = @1;
					$$ = makeStringConstCast($2, @2, tmp);
				}
			| ConstTypename SCONST
				{
					$$ = makeStringConstCast($2, @2, $1);
				}
			| INTERVAL SCONST opt_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					t->typmods = $3;
					$$ = makeStringConstCast($2, @2, t);
				}
			| INTERVAL NumericOnly opt_single_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					t->typmods = $3;
					long ival;
					char buf[64];
					int rc;
					if ($2->type == T_Integer) {
						ival = $2->val.ival;
					} else if ($2->type == T_Float) {
						int frac_part = 0;
						rc = sscanf_s($2->val.str, "%ld.%1d", &ival, &frac_part);
						securec_check_ss(rc, "", "");
						if (frac_part >= 5) {
							/* rounding */
							ival += (ival >= 0L ? 1 : -1);
						}
					}
					rc = snprintf_s(buf, sizeof(buf), sizeof(buf) - 1, "%ld", ival);
					securec_check_ss(rc, "", "");
					$$ = makeStringConstCast(pstrdup(buf), @2, t);
				}
			| INTERVAL NumericOnly opt_multipart_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					t->typmods = $3;
					if ($2->type == T_Integer) {
						char buf[64];
						snprintf(buf, sizeof(buf), "%ld", $2->val.ival);
						$$ = makeStringConstCast(pstrdup(buf), @2, t);
					} else if ($2->type == T_Float) {
						$$ = makeStringConstCast($2->val.str, @2, t);
					}
				}
			| INTERVAL '(' Iconst ')' SCONST opt_interval
				{
					TypeName *t = SystemTypeName("interval");
					t->location = @1;
					if ($6 != NIL)
					{
						if (list_length($6) != 1) {
							const char* message = "interval precision specified twice";
							InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
							ereport(errstate,
									(errcode(ERRCODE_SYNTAX_ERROR),
									 errmsg("interval precision specified twice"),
									 parser_errposition(@1)));
						}
						t->typmods = lappend($6, makeIntConst($3, @3));
					}
					else
						t->typmods = list_make2(makeIntConst(INTERVAL_FULL_RANGE, -1),
												makeIntConst($3, @3));
					$$ = makeStringConstCast($5, @5, t);
				}
			| TRUE_P
				{
					$$ = makeBoolAConst(TRUE, @1);
				}
			| FALSE_P
				{
					$$ = makeBoolAConst(FALSE, @1);
				}
			| NULL_P
				{
					$$ = makeNullAConst(@1);
				}
		;

Iconst:		ICONST									{ $$ = $1; };
/*
 * SCONST is a single string, like 'a', while Sconst can be multiple string, like 'a' 'b' 'c'.
 * In most cases we should use SCONST, please make sure it is what you want when you use Sconst.
 */
Sconst:		SCONST 									{ $$ = $1; }
			| Sconst SCONST
				{
					Size len = strlen($1) + strlen($2) + 1;
					$$ = (char *)palloc(len);
					int rc = sprintf_s($$, len, "%s%s", $1, $2);
					securec_check_ss(rc, "", "");
				}
		;


DolphinUserId:		DolphinRoleId					{ $$ = $1; }
					| SCONST SET_USER_IDENT
							{
								$$ = CreateDolphinIdent(GetValidUserHostId($1, $2), false);
							}
					| SCONST '@' SCONST
							{
								$$ = CreateDolphinIdent(GetValidUserHostId($1, $3), false);
							}
					| SCONST
							{
								CheckUserHostIsValid();
								if (strchr($1,'@'))
									ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("@ can't be allowed in username")));
								$$ = CreateDolphinIdent(pstrdup($1), false);
							}
					| RoleId SET_USER_IDENT
							{
								$$ = CreateDolphinIdent(GetValidUserHostId($1, $2), false);
							}
		;

DolphinRoleId:		DolphinRoleIdWithOutCurrentUser			{ $$ = $1; }
					| CURRENT_USER  opt_bracket				{ $$ = CreateDolphinIdent(GetUserNameFromId(GetUserId()), false); }
		;

DolphinRoleIdWithOutCurrentUser:		DOLPHINIDENT						{ $$ = $1; }
										| unreserved_keyword		{ $$ = CreateDolphinIdent(pstrdup($1), false); }
										| col_name_keyword			{ $$ = CreateDolphinIdent(pstrdup($1), false); }
 		;

RoleId:		RoleIdWithOutCurrentUser			{ $$ = $1; }
			| CURRENT_USER  opt_bracket			{ $$ = GetUserNameFromId(GetUserId()); }
		;

RoleIdWithOutCurrentUser:		DOLPHINIDENT						{ $$ = GetDolphinObjName($1->str, $1->is_quoted); }
								| unreserved_keyword		{ $$ = GetDolphinObjName(pstrdup($1), false); }
								| col_name_keyword			{ $$ = GetDolphinObjName(pstrdup($1), false); }
		;

SignedIconst: Iconst								{ $$ = $1; }
			| '+' Iconst							{ $$ = + $2; }
			| '-' Iconst							{ $$ = - $2; }
		;

/*
 * Name classification hierarchy.
 *
 * IDENT is the lexeme returned by the lexer for identifiers that match
 * no known keyword.  In most cases, we can accept certain keywords as
 * names, not only IDENTs.	We prefer to accept as many such keywords
 * as possible to minimize the impact of "reserved words" on programmers.
 * So, we divide names into several possible classes.  The classification
 * is chosen in part to make keywords acceptable as names wherever possible.
 */

/* Column identifier --- names that can be column, table, etc names.
 */
ColId:		DOLPHINIDENT									{ $$ = downcase_str($1->str, $1->is_quoted); }
			| unreserved_keyword					{ $$ = downcase_str(pstrdup($1), false); }
			| col_name_keyword						{ $$ = downcase_str(pstrdup($1), false); }
		;

DolphinColId:		DOLPHINIDENT							{ $$ = MakeDolphinStringByChar($1->str, $1->is_quoted); }
					| unreserved_keyword %prec IDENT { $$ = MakeDolphinStringByChar(pstrdup($1), false); }
					| col_name_keyword	 			{ $$ = MakeDolphinStringByChar(pstrdup($1), false); }
		;

DolphinColColId:
			DOLPHINIDENT								{ $$ = $1->str; }
					| unreserved_keyword			{ $$ = pstrdup($1); }
					| col_name_keyword				{ $$ = pstrdup($1); }
			;

PrivilegeColId:         normal_ident                                                    { $$ = $1; }
                        | unreserved_keyword_without_proxy                              { $$ = downcase_str(pstrdup($1), false); }
                        | col_name_keyword                                              { $$ = downcase_str(pstrdup($1), false); }
		;

/* Type/function identifier --- names that can be type or function names.
 */
type_function_name:	normal_ident					{ $$ = $1; }
			| unreserved_keyword					{ $$ = downcase_str(pstrdup($1), false); }
			| type_func_name_keyword            	{ $$ = downcase_str(pstrdup($1), false); }
		;

/* Column label --- allowed labels in "AS" clauses.
 * This presently includes *all* Postgres keywords.
 */
ColLabel:	normal_ident							{ $$ = $1; }
			| unreserved_keyword					{ $$ = downcase_str(pstrdup($1), false); }
			| col_name_keyword						{ $$ = downcase_str(pstrdup($1), false); }
			| type_func_name_keyword				{ $$ = downcase_str(pstrdup($1), false); }
			| reserved_keyword
				{
					$$ = downcase_str(pstrdup($1), false);
				}
		;

DelimiterStmt: DELIMITER delimiter_str_names END_OF_INPUT
			   {
					VariableSetStmt *n = makeNode(VariableSetStmt);
					setDelimiterName(yyscanner, $2, n);
					$$ = (Node *)n;
				}
			|	DELIMITER delimiter_str_names END_OF_INPUT_COLON
				{
					VariableSetStmt *n = makeNode(VariableSetStmt);
					setDelimiterName(yyscanner, $2, n);
					$$ = (Node *)n;
				}
			;

delimiter_str_names: delimiter_str_names delimiter_str_name
					{
						$$ = $1 ;
					}
                |    delimiter_str_name
					{
						$$ = $1;
					}
				;

delimiter_str_name: ColId_or_Sconst 
					{
						$$ = $1;
					}
				|   all_Op
				    {
						$$ = $1;
					}
				|   ';'
				    {
						$$ = ";";
					}
				;

/*
 * Column lable of dolphin type
 */
DolphinColLabel:	DOLPHINIDENT									{ $$ = MakeDolphinStringByChar($1->str, $1->is_quoted); }
					| unreserved_keyword					{ $$ = MakeDolphinStringByChar(pstrdup($1), false); }
					| col_name_keyword						{ $$ = MakeDolphinStringByChar(pstrdup($1), false); }
					| type_func_name_keyword				{ $$ = MakeDolphinStringByChar(pstrdup($1), false); }
					| reserved_keyword
						{
							$$ = MakeDolphinStringByChar(pstrdup($1), false);
						}
					| SCONST
						{
							$$ = MakeDolphinStringByChar(pstrdup($1), false);
							$$->is_sconst = true;
						}
		;

FlushStmt:
		FLUSH BINARY LOGS
			{
				SelectStmt *n = makeFlushBinaryLogsQuery();
				$$ = (Node *) n;
			}
		;


/*
 * Keyword category lists.  Generally, every keyword present in
 * the Postgres grammar should appear in exactly one of these lists.
 *
 * Put a new keyword into the first list that it can go into without causing
 * shift or reduce conflicts.  The earlier lists define "less reserved"
 * categories of keywords.
 *
 * Make sure that each keyword's category in kwlist.h matches where
 * it is listed here.  (Someday we may be able to generate these lists and
 * kwlist.h's table from a common master list.)
 */

/* "Unreserved" keywords --- available for use as any kind of name.
 */
/* PGXC - added DISTRIBUTE, DIRECT, COORDINATOR, DATANODES, CLEAN, NODE, BARRIER, SLICE, DATANODE */
 unreserved_keyword:
                        unreserved_keyword_without_proxy
                        | PROXY
                        ;

unreserved_keyword_without_proxy:
                        unreserved_keyword_without_key
                        | KEY
                        ;

unreserved_keyword_without_key:
			  ABORT_P
			| ABSOLUTE_P
			| ACCESS
			| USER
			| REJECT_P
			| ACCOUNT
			| COLLATION
			| ACTION
			| RECYCLEBIN
			| ADD_P
			| ADMIN
			| AFTER
			| VERBOSE
			| AGGREGATE
			| MODIFY_P
			| ALGORITHM
			| ALSO
			| ALTER
			| FREEZE

			| ALWAYS
			| NOTNULL
			| APP
			| APPEND
			| ARCHIVE
			| ASSERTION
			| ASSIGNMENT
			| AST
			| AT
			| LESS
			| ATTRIBUTE
			| AUDIT
			| AUTOEXTEND
			| AUTOMAPPED
			| AUTOEXTEND_SIZE
			| AUTO_INCREMENT
			| AVG_ROW_LENGTH
			| BACKWARD
/* PGXC_BEGIN */
			| BARRIER
/* PGXC_END */
			| BEFORE
			| BEGIN_P
			| BEGIN_NON_ANOYBLOCK
			| BLANKS
			| BLOB_P
			| BLOCKCHAIN
			| BODY_P
			| BY
			| CACHE
			| CALL
			| CALLED
			| CANCELABLE
			| CASCADE
			| CASCADED
			| CATALOG_P
			| CHAIN
			| CHANGE
			| CHARACTERISTICS
			| CHARACTERSET
			| CHARSET
			| CHECKPOINT
			| CHECKSUM
			| CLASS
			| CLEAN
			| CLIENT
            | CLIENT_MASTER_KEY
            | CLIENT_MASTER_KEYS
			| CLOB
			| CLOSE
			| CLUSTER
            | COLUMN_ENCRYPTION_KEY
            | COLUMN_ENCRYPTION_KEYS
			| COLUMNS
			| COMMENT
			| COMMENTS
			| COMMIT
			| COMMITTED
			| COMPATIBLE_ILLEGAL_CHARS
			| COMPLETE
			| COMPLETION
			| COMPRESS
			| COMPRESSION
			| CONDITION
			| CONFIGURATION
			| CONNECT
			| CONNECTION
			| CONSTANT
			| CONSTRAINTS
			| CONTAINS
			| CONTENT_P
			| CONTINUE_P
			| CONTVIEW
			| CONVERSION_P
			| COORDINATOR
			| COORDINATORS
			| COPY
			| COST
			| CSV
			| CUBE
			| CURRENT_P
			| CURSOR
			| CYCLE
			| DATA_P
			| DATABASE
			| DATABASES
			| DATAFILE
			| DATANODE
			| DATANODES
			| DATATYPE_CL
			| DATE_FORMAT_P
			| DAY_HOUR_P
			| DAY_MICROSECOND_P
			| DAY_MINUTE_P
			| DAY_P
			| DAY_SECOND_P
			| DBCOMPATIBILITY_P
			| DEALLOCATE
			| DECLARE
			| DEFAULTS
			| DEFERRED
			| DEFINER
			| DELAY_KEY_WRITE
			| DELETE_P
			| DELIMITER
			| DELIMITERS
			| DELTA
			| DESCRIBE
			| DETERMINISTIC
			| DICTIONARY
			| DIRECT
			| DIRECTORY
			| DISABLE_P
			| DISCARD
			| DISCONNECT
			| DISK
/* PGXC_BEGIN */
			| DISTRIBUTE
			| DISTRIBUTION
/* PGXC_END */
			| DO
			| DOCUMENT_P
			| DOMAIN_P
			| DOUBLE_P
			| DROP
			| DUMPFILE
			| DUPLICATE
			| EACH
			| ELASTIC
			| ENABLE_P
			| ENCLOSED
			| ENCODING
			| ENCRYPTED       
            | ENCRYPTED_VALUE
			| ENCRYPTION
            | ENCRYPTION_TYPE
			| END_P
			| ENDS
			| ENGINE_ATTRIBUTE
			| ENGINE_P
			| ENFORCED
			| EOL
			| ERRORS
			| ESCAPE
			| ESCAPED
			| ESCAPING
			| EVENT
			| EVENTS
			| EVERY
			| EXCHANGE
			| EXCLUDE
			| EXCLUDING
			| EXCLUSIVE
			| EXECUTE
			| EXPANSION
			| EXPIRED_P
			| EXPLAIN
			| EXTENDED
			| EXTENSION
			| EXTERNAL
			| FAMILY
			| FAST
			| FEATURES 			// DB4AI
			| FENCED
			| FIELDS
			| FILEHEADER_P
			| FILLER
			| FILL_MISSING_FIELDS
			| FILTER
			| FIRST_P
			| FLUSH
			| FOLLOWING
			| FOLLOWS_P
			| FORCE
			| FORMATTER
			| FORWARD
			| FUNCTION
			| FUNCTIONS
			| GENERATED
			| GLOBAL
			| GRANTED
			| GRANTS
			| HANDLER
			| HEADER_P
			| HOSTS
			| HOUR_MICROSECOND_P
			| HOUR_MINUTE_P
			| HOUR_P
			| HOUR_SECOND_P
			| HOLD
			| IDENTIFIED
			| IDENTITY_P
			| IGNORE_EXTRA_DATA
			| IMMEDIATE
			| IMMUTABLE
			| IMPLICIT_P
			| INCLUDE
			| INCLUDING
			| INCREMENT
			| INCREMENTAL
			| INDEXES
			| INFILE
			| INHERIT
			| INHERITS
			| INITIAL_P
			| INITRANS
			| INLINE_P
			| INPLACE
			| INPUT_P
			| INSENSITIVE
			| INSERT
			| INSERT_METHOD
			| INSTEAD
			| INTERNAL
			| INVISIBLE
			| INVOKER
			| IP
			| ISNULL
			| ISOLATION
			| KEYS
			| KEY_BLOCK_SIZE
			| KEY_PATH
			| KEY_STORE
			| KILL
			| LABEL
			| LANGUAGE
			| LARGE_P
			| LAST_P
			| LC_COLLATE_P
			| LC_CTYPE_P
			| LEAKPROOF
			| LEVEL
			| LINES
			| LIST
			| LISTEN
			| LOAD
			| LOCAL
			| LOCATION
			| LOCK_P
			| LOCKED
			| LOG_P
			| LOGGING
			| LOGIN_ANY
			| LOGIN_FAILURE
			| LOGIN_SUCCESS
			| LOGOUT
			| LOGS
			| LOOP
			| MAPPING
			| MASKING
			| MASTER
			| MATCH
			| MATCHED
			| MATERIALIZED
			| MAX_ROWS
			| MAXEXTENTS
			| MAXSIZE
			| MAXTRANS
			| MEMORY
			| MERGE
			| MICROSECOND_P
			| MIN_ROWS
			| MINEXTENTS
			| MINUTE_MICROSECOND_P
			| MINUTE_P
			| MINUTE_SECOND_P
			| MINVALUE
			| MOD
			| MODE
			| MODEL      // DB4AI
			| MODIFIES
			| MONTH_P
			| MOVE
			| MOVEMENT
			| NAME_P
			| NAMES
			| NEXT
			| NGRAM
			| NO
			| NO_WRITE_TO_BINLOG
			| NOCOMPRESS
			| NODE
			| NOLOGGING
			| NOMAXVALUE
			| NOMINVALUE
			| NOTHING
			| NOTIFY
			| NOWAIT
			| NULLCOLS
			| NULLS_P
			| NUMSTR
			| OBJECT_P
			| OF
			| OFF
			| OIDS
			| OPERATOR
			| OPTIMIZATION
			| OPTIMIZE
			| OPTION
			| OPTIONALLY
			| OPTIONS
			| OVER
			| OUTFILE
			| OWNED
			| OWNER
			| PACK_KEYS
			| PACKAGE
			| PACKAGES
			| PARSER
			| PARTIAL %prec PARTIAL_EMPTY_PREC
			| PARTITION
			| PARTITIONING
			| PARTITIONS
			| PASSING
			| PASSWORD
			| PCTFREE
			| PER_P
			| PERCENT
			| PERM
			| PLAN
			| PLANS
			| POLICY
			| POOL
			| PRECEDES_P
			| PRECEDING
			| PREDICT   // DB4AI
/* PGXC_BEGIN */
			| PREFERRED
/* PGXC_END */
			| PREFIX
			| PREPARE
			| PREPARED
			| PRESERVE
			| PRIOR
			| PRIORER
			| PRIVATE
			| PRIVILEGE
			| PRIVILEGES
			| PROCEDURAL
			| PROCESSLIST
			| PROFILE
			| PUBLICATION
			| PUBLISH
			| PURGE
			| QUARTER
			| QUERY
			| QUICK
			| QUOTE
			| RANDOMIZED
			| RANGE
			| RATIO
			| RAW  '(' Iconst ')'				{	$$ = "raw";}
			| RAW  %prec UNION				{	$$ = "raw";}
			| READ
			| READS
			| REASSIGN
			| REBUILD
			| RECHECK
			| RECURSIVE
			| REDISANYVALUE
			| REF
			| REFRESH
			| REINDEX
			| RELATIVE_P
			| RELEASE
			| RELOPTIONS
			| REMOTE_P
			| REMOVE
			| RENAME
			| REORGANIZE
			| REPAIR
			| REPEAT
			| REPEATABLE
			| REPLACE
			| REPLICA
			| RESET
			| RESIZE
			| RESOURCE
			| RESTART
			| RESTRICT
			| RETURN
			| RETURNS
			| REUSE
			| REVOKE
			| ROLE
			| ROLES
			| ROLLBACK
			| ROLLUP
			| ROTATION
			| ROWTYPE_P
			| ROUTINE
			| ROWS
			| RULE
			| ROW_FORMAT
			| SAMPLE
			| SAVEPOINT
			| SCHEDULE
			| SCHEMA
			| SCHEMAS
			| SCROLL
			| SEARCH
			| SECOND_MICROSECOND_P
			| SECOND_P
			| SECONDARY_ENGINE_ATTRIBUTE
			| SECURITY
			| SEPARATOR_P
			| SEQUENCE
			| SEQUENCES
			| SERIALIZABLE
			| SERVER
			| SESSION
			| SET
			| SETS
			| SHARE
			| SHIPPABLE
			| SHOW
			| SHUTDOWN
			| SIBLINGS
			| SIMPLE
			| SIZE
			| SKIP
			| SLAVE
			| SLICE
			| SMALLDATETIME_FORMAT_P
			| SNAPSHOT
			| SOURCE_P
			| SPACE
			| SPILL
			| SPLIT
			| SQL_P
			| STABLE
			| STANDALONE_P
			| START
			| STARTING
			| STARTS
			| STATEMENT
			| STATEMENT_ID
			| STATISTICS
			| STATS_AUTO_RECALC
			| STATS_PERSISTENT
			| STATS_SAMPLE_PAGES
			| STATUS
			| STDIN
			| STDOUT
			| STORAGE
			| STORE_P
			| STORED
			| STRATIFY
			| STREAM
			| STRICT_P
			| STRIP_P
			| SUBPARTITION
			| SUBPARTITIONS
			| SUBSCRIPTION
			| SYNONYM
			| SYSID
			| SYS_REFCURSOR					{ $$ = "refcursor"; }
			| SYSTEM_P
			| TABLES
			| TABLESPACE
			| TARGET
			| TEMP
			| TEMPLATE
			| TEMPORARY
			| TEMPTABLE
			| TERMINATED
			| THAN
			| TIMESTAMP_FORMAT_P
			| TIME_FORMAT_P
			| TRANSACTION
			| TRANSFORM
			| TRIGGER
			| TRIGGERS
			| TRUNCATE
			| TRUSTED
			| TSFIELD
			| TSTAG
			| TSTIME 
			| TYPE_P
			| TYPES_P
			| UNBOUNDED
			| UNCOMMITTED
			| UNENCRYPTED
			| UNDEFINED
			| UNKNOWN
			| UNLIMITED
			| UNLISTEN
			| UNLOCK
			| UNLOGGED
			| UNTIL
			| UNUSABLE
			| UPDATE
			| USE
			| USEEOF
			| VACUUM
			| VALID
			| VALIDATE
			| VALIDATION
			| VALIDATOR
			| VALUE_P
			| VARIABLES
			| VARYING
			| VCGROUP
			| VERSION_P
			| VIEW
			| VISIBLE
			| VOLATILE
			| WAIT
			| WEAK
			| WHILE_P
			| WHITESPACE_P
			| WITHIN
			| WITHOUT
			| WORK
			| WORKLOAD
			| WRAPPER
			| WRITE
			| XML_P
			| YEAR_MONTH_P
			| YEAR_P %prec IDENT
			| YES_P
			| ZEROFILL
			| ZONE
		;

/* Column identifier --- keywords that can be column, table, etc names.
 *
 * Many of these keywords will in fact be recognized as type or function
 * names too; but they have special productions for the purpose, and so
 * can't be treated as "generic" type or function names.
 *
 * The type names appearing here are not usable as function names
 * because they can be followed by '(' in typename productions, which
 * looks too much like a function call for an LR(1) parser.
 *
 * If the new col_name_keyword is not used in func_expr_common_subexpr,
 * add it to col_name_keyword_nonambiguous!
 * 
 * We make INTERVAL's priority lower than '+' or '-' here to enbale INTERVAL to receive 
 * negtive number.
 */
col_name_keyword:
			  col_name_keyword_nonambiguous { $$ = $1; }
			| CAST
			| CHAR_P %prec IDENT
			| COALESCE
			| ONLY
			| CONVERT
			| DATE_P %prec IDENT
			| DB_B_FORMAT
			| SYSDATE
			| DB_B_JSOBJ
			| EXTRACT
			| GET_FORMAT
			| GREATEST
			| IFNULL
			| INTERVAL	%prec UNBOUNDED
			| LAST_DAY_FUNC
			| LEAST
			| LOCATE
			| MID
			| NULLIF
			| NVARCHAR %prec IDENT
			| NVL
			| OVERLAY
			| POSITION
			| SUBSTR
			| SUBSTRING
			| TEXT_P
			| TIME %prec IDENT
			| TIMESTAMP %prec IDENT
			| TIMESTAMPADD
			| TIMESTAMPDIFF
			| TREAT
			| TRIM
			| XMLCONCAT
			| XMLELEMENT
			| XMLEXISTS
			| XMLFOREST
			| XMLPARSE
			| XMLPI
			| XMLROOT
			| XMLSERIALIZE
		;

/* Column identifier --- keywords that can be column, table, etc names.
 *
 * These keywords will not be recognized as function names. These keywords
 * are used to distinguish index prefix keys from function keys.
 */
col_name_keyword_nonambiguous:
			  AUTHID
			| BETWEEN
			| BIGINT %prec IDENT
			| BINARY
			| BINARY_DOUBLE %prec IDENT
			| BINARY_INTEGER %prec IDENT
			| BIT %prec IDENT
			| BOOLEAN_P %prec IDENT
			| BUCKETCNT
			| ANY
			| BYTEAWITHOUTORDER
			| BYTEAWITHOUTORDERWITHEQUAL
			| CHARACTER %prec IDENT
			| DATETIME %prec IDENT
			| DEC %prec IDENT
			| DECIMAL_P %prec IDENT
			| DECODE
			| EXISTS
			| FIXED_P %prec IDENT
			| FLOAT_P %prec IDENT
			| GROUPING_P
			| IF_P
			| INOUT
			| INT_P %prec IDENT
			| INTEGER %prec IDENT
			| MEDIUMINT %prec IDENT
			| NATIONAL
			| NCHAR %prec IDENT
			| NONE
			| NUMBER_P %prec IDENT
			| NUMERIC %prec IDENT
			| NVARCHAR2 %prec IDENT
			| OUT_P
			| PRECISION
			| REAL %prec IDENT
			| ROW
			| SETOF
			| SIGNED
			| SMALLDATETIME %prec IDENT
			| SMALLINT %prec IDENT
			| TINYINT %prec IDENT
			| UNSIGNED
			| VALUES
			| VARBINARY
			| VARCHAR %prec IDENT
			| VARCHAR2 %prec IDENT
			| XMLATTRIBUTES
		;

/* current_schema can't be included in the rule 'type_func_name_keyword_without_current_schema sconst',
 * because of the reduction/reduction conflict. 
 * So current_schema will be used only as alias name in the scenario like 'select current_schema 'alias_name';'
 */
type_func_name_keyword_without_current_schema:
			 AGAINST
			| AUTHORIZATION
			| CONCURRENTLY
			| CROSS
			| CSN
			| DELTAMERGE
			| DIV
			| FULL
			| FULLTEXT
			| HDFSDIRECTORY
			| ILIKE
			| INDEX
			| INNER_P
			| JOIN
			| LEFT
			| LIKE
			| NATURAL
			| OUTER_P
			| OVERLAPS
			| REGEXP
			| RIGHT
			| RLIKE
			| SIMILAR
			| SOUNDS
			| TABLESAMPLE
			| TIMECAPSULE
			| XOR
		;

/* Type/function identifier --- keywords that can be type or function names.
 *
 * Most of these are keywords that are used as operators in expressions;
 * in general such keywords can't be column names because they would be
 * ambiguous with variables, but they are unambiguous as function identifiers.
 *
 * Do not include POSITION, SUBSTRING, etc here since they have explicit
 * productions in a_expr to support the goofy SQL9x argument syntax.
 * - thomas 2000-11-28
 */
type_func_name_keyword:
			type_func_name_keyword_without_current_schema
			| CURRENT_SCHEMA
		;

/* Reserved keyword --- these keywords are usable only as a ColLabel.
 *
 * Keywords appear here if they could not be distinguished from variable,
 * type, or function names in some contexts.  Don't put things here unless
 * forced to.
 */
reserved_keyword:
			  ALL
			| ANALYZE
			| AND
			| ARRAY
			| AS
			| ASC
			| ASYMMETRIC
			| BOTH
			| CASE
			| CHECK
			| COLLATE
			| COLUMN
			| CONSTRAINT
			| CREATE
			| CURRENT_CATALOG
			| CURRENT_DATE
			| CURRENT_ROLE
			| CURRENT_TIME
			| CURRENT_TIMESTAMP
			| CURRENT_USER
			| CURTIME
			| DEFAULT
			| DEFERRABLE
			| DELAYED
			| DESC
			| DISTINCT
			| DISTINCTROW
			| DUAL_P
			| ELSE
			| ENUM_P
			| EXCEPT
			| FALSE_P
			| FETCH
			| FOR
			| FOREIGN
			| FROM
			| GRANT
			| GROUP_P
			| GROUPPARENT
			| HAVING
			| IN_P
			| INITIALLY
			| INTERSECT
			| INTO
			| IS
			| LEADING
			| LIMIT
			| LOCALTIME
			| LOCALTIMESTAMP
			| LOW_PRIORITY
			| MAXVALUE
			| NOCYCLE
			| NOT
			| NOW_FUNC
			| NULL_P
			| OFFSET
			| ON
			| OR
			| ORDER
			| PERFORMANCE
			| PLACING
			| PRIMARY
			| PROCEDURE
			| REFERENCES
			| RETURNING
			| SELECT
			| SESSION_USER
			| SHRINK
			| SOME
			| SYMMETRIC
			| TABLE
			| THEN
			| TO
			| TRAILING
			| TRUE_P
			| UNION
			| UNIQUE
			| USING
			| UTC_DATE
			| UTC_TIME
			| UTC_TIMESTAMP
			| VARIADIC
			| VERIFY
			| WHEN
			| WHERE
			| WINDOW
			| WITH
		;

/* normal_ident */
normal_ident:		DOLPHINIDENT							{ $$ = downcase_str($1->str, $1->is_quoted); };

%%


static List* NakeLikeOpList() {
    if (GetSessionContext()->enableBCmptMode) {
    	return list_make1(makeString("~~*"));
    } else {
    	return list_make1(makeString("~~"));
    }
}

static List* MakeNotLikeOpList() {
    return GetSessionContext()->enableBCmptMode ? list_make1(makeString("!~~*")) : list_make1(makeString("!~~"));
}

static Node* MakeSubLinkWithOp(SubLinkType subType, Node* testExpr, char* op, Node* subSelect, int location)
{
	SubLink *n = makeNode(SubLink);
	n->subLinkType = subType;
	n->testexpr = testExpr;
	n->operName = list_make1(makeString(op));
	n->subselect = subSelect;
	n->location = location;
	return (Node*)n;
}


/*
 * The signature of this function is required by bison.  However, we
 * ignore the passed yylloc and instead use the last token position
 * available from the scanner.
 */
static void
base_yyerror(YYLTYPE *yylloc, core_yyscan_t yyscanner, const char *msg)
{
	parser_yyerror(msg);
}

static Node *
makeColumnRef(char *colname, List *indirection,
			  int location, core_yyscan_t yyscanner)
{
	/*
	 * Generate a ColumnRef node, with an A_Indirection node added if there
	 * is any subscripting in the specified indirection list.  However,
	 * any field selection at the start of the indirection list must be
	 * transposed into the "fields" part of the ColumnRef node.
	 */
	ColumnRef  *c = makeNode(ColumnRef);
	int		nfields = 0;
	int     indnum = 0;
	ListCell *l;

	c->location = location;
	c->indnum = 0;
	foreach(l, indirection)
	{
		if (IsA(lfirst(l), A_Indices))
		{
			A_Indirection *i = makeNode(A_Indirection);
			indnum++;

			if (nfields == 0)
			{
				/* easy case - all indirection goes to A_Indirection */
				c->fields = list_make1(makeString(colname));
				i->indirection = check_indirection(indirection, yyscanner);
			}
			else
			{
				/* got to split the list in two */
				i->indirection = check_indirection(list_copy_tail(indirection,
																  nfields),
												   yyscanner);
				indirection = list_truncate(indirection, nfields);
				c->fields = lcons(makeString(colname), indirection);
			}
			c->indnum = indnum;
			i->arg = (Node *) c;
			return (Node *) i;
		}
		else if (IsA(lfirst(l), A_Star))
		{
			/* We only allow '*' at the end of a ColumnRef */
			if (lnext(l) != NULL)
				parser_yyerror("improper use of \"*\"");
		}
		else if (IsA(lfirst(l), String) && strncmp(strVal(lfirst(l)), "(+)", 3) == 0)
		{
			u_sess->parser_cxt.stmt_contains_operator_plus = true;
		}
		nfields++;
	}
	/* No subscripting, so all indirection gets added to field list */
	c->fields = lcons(makeString(colname), indirection);
	return (Node *) c;
}

static Node *
makeTypeCast(Node *arg, TypeName *typname, int location)
{
	TypeCast *n = makeNode(TypeCast);
	n->arg = arg;
	n->typname = typname;
	n->location = location;
	return (Node *) n;
}

static void StrCopy(char *dst, char *src) 
{
    char *p = src;
    char *q = dst;
    int len = strlen(src);
	int i = 0;
    while (*p != '\"' && *p != ' ' && i < len)
    {
        *(q++) = *(p++);
		i++;
    }
    *(q++)='\0'; 
}

static char*
GetPkgName(char* pkgName) 
{
	if (pkgName == NULL) {
		return NULL;
	}
	int begin = 0;
	char* destName = (char *) palloc(strlen(pkgName) + 1);
	while ((isspace(*pkgName) || isquote(*pkgName)) && begin < strlen(pkgName)) {
		pkgName++;
		begin++;
	}
	StrCopy(destName, pkgName);
	return destName;
}

static Node *
makeStringConst(char *str, int location)
{
	A_Const *n = makeNode(A_Const);


	if (u_sess->attr.attr_sql.sql_compatibility == A_FORMAT)
	{
		if (NULL == str || (0 == strlen(str) && !ACCEPT_EMPTY_STR))
		{
			n->val.type = T_Null;
			n->val.val.str = str;
			n->location = location;
		}
		else
		{
			n->val.type = T_String;
			n->val.val.str = str;
			n->location = location;
		}
	}
	else
	{
		n->val.type = T_String;
		n->location = location;
		if (NULL == str) {
			n->val.val.str = str;
		} else {
			n->val.val.str = pg_server_to_any(str, strlen(str), GetCharsetConnection());
		}
	}

	return (Node *)n;
}

static Node *
makeStringConstCast(char *str, int location, TypeName *typname)
{
	Node *s = makeStringConst(str, location);

	return makeTypeCast(s, typname, -1);
}

static Node *
makeIntConst(int val, int location)
{
	A_Const *n = makeNode(A_Const);

	n->val.type = T_Integer;
	n->val.val.ival = val;
	n->location = location;

	return (Node *)n;
}

static Node *
makeFloatConst(char *str, int location)
{
	A_Const *n = makeNode(A_Const);

	n->val.type = T_Float;
	n->val.val.str = str;
	n->location = location;

	return (Node *)n;
}

static Node *
makeBitStringConst(char *str, int location)
{
	A_Const *n = makeNode(A_Const);

	n->val.type = T_BitString;
	n->val.val.str = str;
	n->location = location;

	return (Node *)n;
}

Node *
makeAConst(Value *v, int location)
{
	Node *n;

	switch (v->type)
	{
		case T_Float:
			n = makeFloatConst(v->val.str, location);
			break;

		case T_Integer:
			n = makeIntConst(v->val.ival, location);
			break;

		case T_String:
		default:
			n = makeStringConst(v->val.str, location);
			break;
	}

	return n;
}

/* makeBoolAConst()
 * Create an A_Const string node and put it inside a boolean cast.
 */
Node *
makeBoolAConst(bool state, int location)
{
	A_Const *n = makeNode(A_Const);

	n->val.type = T_String;
	n->val.val.str = (char *)(state ? "t" : "f");
	n->location = location;

	return makeTypeCast((Node *)n, SystemTypeName("bool"), -1);
}

/* check_qualified_name --- check the result of qualified_name production
 *
 * It's easiest to let the grammar production for qualified_name allow
 * subscripts and '*', which we then must reject here.
 */
static void
check_qualified_name(List *names, core_yyscan_t yyscanner)
{
	ListCell   *i;

	foreach(i, names)
	{
		if (!IsA(lfirst(i), String))
			parser_yyerror("syntax error");
	}
}

static void check_dolphin_qualified_name(List *names, core_yyscan_t yyscanner)
{
	ListCell   *i;

	foreach(i, names)
	{
		DolphinString* elem = (DolphinString*)lfirst(i);
		if (!IsA(elem->node, String))
			parser_yyerror("syntax error");
	}
}

/* check_func_name --- check the result of func_name production
 *
 * It's easiest to let the grammar production for func_name allow subscripts
 * and '*', which we then must reject here.
 */
static List *
check_func_name(List *names, core_yyscan_t yyscanner)
{
	ListCell   *i;

	foreach(i, names)
	{
		if (!IsA(lfirst(i), String))
			parser_yyerror("syntax error");
	}
	return names;
}

bool
IsValidIdentClientKey(const char *input)
{
	if (input == NULL || strlen(input) <= 0) {
		return false;
	}
	char c = input[0];
	/*The first character id numbers or dollar or point*/
	if ((c >= '0' && c <= '9') || c == '$' || c == '.')
	{
		return false;
	}

	int len = strlen(input);
	for (int i = 0; i < len; i++)
	{
		c = input[i];
		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_' || c == '$'|| c=='.')
		{
			continue;
		}
		else
		{
			return false;
		}
	}
	return true;
}

static List *
check_setting_name(List *names, core_yyscan_t yyscanner)
{
	ListCell   *i;

	foreach(i, names)
	{
		Value* v = (Value *)lfirst(i);
		if (v == NULL || v->type != T_String) {
			const char* message = "invalid name";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("invalid name")));
		}
		if (!IsValidIdentClientKey(v->val.str)) {
			const char* message = "invalid name";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("invalid name")));
		}
	}
	return names;
}

/* check_indirection --- check the result of indirection production
 *
 * We only allow '*' at the end of the list, but it's hard to enforce that
 * in the grammar, so do it here.
 */
static List *
check_indirection(List *indirection, core_yyscan_t yyscanner)
{
	ListCell *l;

	foreach(l, indirection)
	{
		if (IsA(lfirst(l), A_Star))
		{
			if (lnext(l) != NULL)
				parser_yyerror("improper use of \"*\"");
		}
	}
	return indirection;
}

/* extractArgTypes()
 * Given a list of FunctionParameter nodes, extract a list of just the
 * argument types (TypeNames) for input parameters only.  This is what
 * is needed to look up an existing function, which is what is wanted by
 * the productions that use this call.
 */
static List *
extractArgTypes(List *parameters)
{
    List *result = NIL;
    ListCell *i;

    foreach(i, parameters)
    {
        FunctionParameter *p = (FunctionParameter *) lfirst(i);
#ifndef ENABLE_MULTIPLE_NODES
        if ((p->mode == FUNC_PARAM_OUT && enable_out_param_override())
                || p->mode == FUNC_PARAM_IN
                || p->mode == FUNC_PARAM_INOUT
                || p->mode == FUNC_PARAM_VARIADIC) {
#else
        if (p->mode == FUNC_PARAM_IN
                || p->mode == FUNC_PARAM_INOUT
                || p->mode == FUNC_PARAM_VARIADIC) {
#endif
            result = lappend(result, p->argType);
        }
    }
    return result;
}

/* insertSelectOptions()
 * Insert ORDER BY, etc into an already-constructed SelectStmt.
 *
 * This routine is just to avoid duplicating code in SelectStmt productions.
 */
static void
insertSelectOptions(SelectStmt *stmt,
					List *sortClause, List *lockingClause,
					Node *limitOffset, Node *limitCount,
					WithClause *withClause,
					core_yyscan_t yyscanner)
{
	AssertEreport(IsA(stmt, SelectStmt), MOD_OPT, "Node type inconsistant");

	/*
	 * Tests here are to reject constructs like
	 *	(SELECT foo ORDER BY bar) ORDER BY baz
	 */
	if (sortClause)
	{
		if (stmt->sortClause) {
			const char* message = "multiple ORDER BY clauses not allowed";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("multiple ORDER BY clauses not allowed"),
					 parser_errposition(exprLocation((Node *) sortClause))));
		}
		stmt->sortClause = sortClause;
	}
	/* We can handle multiple locking clauses, though */
	stmt->lockingClause = list_concat(stmt->lockingClause, lockingClause);
	if (limitOffset)
	{
		if (stmt->limitOffset) {
			const char* message = "multiple OFFSET clauses not allowed";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("multiple OFFSET clauses not allowed"),
					 parser_errposition(exprLocation(limitOffset))));
		}
		stmt->limitOffset = limitOffset;
	}
	if (limitCount)
	{
		if (stmt->limitCount) {
			const char* message = "multiple OFFSET clauses not allowed";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("multiple LIMIT clauses not allowed"),
					 parser_errposition(exprLocation(limitCount))));
		}
		stmt->limitCount = limitCount;
	}
	if (withClause)
	{
		if (stmt->withClause) {
			const char* message = "multiple OFFSET clauses not allowed";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("multiple WITH clauses not allowed"),
					 parser_errposition(exprLocation((Node *) withClause))));
		}
		stmt->withClause = withClause;
	}
}

static Node *
makeSetOp(SetOperation op, bool all, Node *larg, Node *rarg)
{
	SelectStmt *n = makeNode(SelectStmt);

	n->op = op;
	n->all = all;
	n->larg = (SelectStmt *) larg;
	n->rarg = (SelectStmt *) rarg;
	return (Node *) n;
}

/* SystemFuncName()
 * Build a properly-qualified reference to a built-in function.
 */
List *
SystemFuncName(char *name)
{
	return list_make2(makeString("pg_catalog"), makeString(name));
}

/* SystemTypeName()
 * Build a properly-qualified reference to a built-in type.
 *
 * typmod is defaulted, but may be changed afterwards by caller.
 * Likewise for the location.
 */
TypeName *
SystemTypeName(char *name)
{
	return makeTypeNameFromNameList(list_make2(makeString("pg_catalog"),
											   makeString(name)));
}

/* doNegate()
 * Handle negation of a numeric constant.
 *
 * Formerly, we did this here because the optimizer couldn't cope with
 * indexquals that looked like "var = -4" --- it wants "var = const"
 * and a unary minus operator applied to a constant didn't qualify.
 * As of Postgres 7.0, that problem doesn't exist anymore because there
 * is a constant-subexpression simplifier in the optimizer.  However,
 * there's still a good reason for doing this here, which is that we can
 * postpone committing to a particular internal representation for simple
 * negative constants.	It's better to leave "-123.456" in string form
 * until we know what the desired type is.
 */
static Node *
doNegate(Node *n, int location)
{
	if (IsA(n, A_Const))
	{
		A_Const *con = (A_Const *)n;

		/* report the constant's location as that of the '-' sign */
		con->location = location;

		if (con->val.type == T_Integer)
		{
			con->val.val.ival = -con->val.val.ival;
			return n;
		}
		if (con->val.type == T_Float)
		{
			doNegateFloat(&con->val);
			return n;
		}
	}

	return (Node *) makeSimpleA_Expr(AEXPR_OP, "-", NULL, n, location);
}

static void
doNegateFloat(Value *v)
{
	char   *oldval = v->val.str;

	AssertEreport(IsA(v, Float), MOD_OPT, "Node Type inconsistant");
	if (*oldval == '+')
		oldval++;
	if (*oldval == '-')
		v->val.str = oldval+1;	/* just strip the '-' */
	else
	{
		char   *newval = (char *) palloc(strlen(oldval) + 2);

		*newval = '-';
		strcpy(newval+1, oldval);
		v->val.str = newval;
	}
}

static Node *
makeAArrayExpr(List *elements, int location)
{
	A_ArrayExpr *n = makeNode(A_ArrayExpr);

	n->elements = elements;
	n->location = location;
	return (Node *) n;
}

static Node *
makeXmlExpr(XmlExprOp op, char *name, List *named_args, List *args,
			int location)
{
	XmlExpr		*x = makeNode(XmlExpr);

	x->op = op;
	x->name = name;
	/*
	 * named_args is a list of ResTarget; it'll be split apart into separate
	 * expression and name lists in transformXmlExpr().
	 */
	x->named_args = named_args;
	x->arg_names = NIL;
	x->args = args;
	/* xmloption, if relevant, must be filled in by caller */
	/* type and typmod will be filled in during parse analysis */
	x->type = InvalidOid;			/* marks the node as not analyzed */
	x->location = location;
	return (Node *) x;
}

/*
 * Merge the input and output parameters of a table function.
 */
static List *
mergeTableFuncParameters(List *func_args, List *columns)
{
	ListCell   *lc;

	/* Explicit OUT and INOUT parameters shouldn't be used in this syntax */
	foreach(lc, func_args)
	{
		FunctionParameter *p = (FunctionParameter *) lfirst(lc);

		if (p->mode != FUNC_PARAM_IN && p->mode != FUNC_PARAM_VARIADIC) {
			const char* message = "OUT and INOUT arguments aren't allowed in TABLE functions";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("OUT and INOUT arguments aren't allowed in TABLE functions")));
		}
	}

	return list_concat(func_args, columns);
}

/*
 * Determine return type of a TABLE function.  A single result column
 * returns setof that column's type; otherwise return setof record.
 */
static TypeName *
TableFuncTypeName(List *columns)
{
	TypeName *result;

	if (list_length(columns) == 1)
	{
		FunctionParameter *p = (FunctionParameter *) linitial(columns);

		result = (TypeName *) copyObject(p->argType);
	}
	else
		result = SystemTypeName("record");

	result->setof = true;

	return result;
}

/*
 * Convert a list of (dotted) names to a RangeVar (like
 * makeRangeVarFromNameList, but with position support).  The
 * "AnyName" refers to the any_name production in the grammar.
 */
static RangeVar *
makeRangeVarFromAnyName(List *names, int position, core_yyscan_t yyscanner)
{
	RangeVar *r = makeNode(RangeVar);
	const char* message = "improper qualified name (too many dotted names)";
	switch (list_length(names))
	{
		case 1:
			r->catalogname = NULL;
			r->schemaname = NULL;
			r->relname = strVal(linitial(names));
			break;
		case 2:
			r->catalogname = NULL;
			r->schemaname = strVal(linitial(names));
			r->relname = strVal(lsecond(names));
			break;
		case 3:
			r->catalogname = strVal(linitial(names));
			r->schemaname = strVal(lsecond(names));
			r->relname = strVal(lthird(names));
			break;
		default:
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					 errmsg("improper qualified name (too many dotted names): %s",
							NameListToString(names)),
					 parser_errposition(position)));
			break;
	}

	r->relpersistence = RELPERSISTENCE_PERMANENT;
	r->location = position;
	r->ispartition = false;
	r->isbucket = false;
	r->buckets = NIL;

	return r;
}

/* Separate Constraint nodes from COLLATE clauses in a ColQualList */
static void
SplitColQualList(List *qualList,
				 List **constraintList, CollateClause **collClause, List **columnOptions,
				 core_yyscan_t yyscanner)
{
	ListCell   *cell;
	ListCell   *prev;
	ListCell   *next;

	*collClause = NULL;
	prev = NULL;
	for (cell = list_head(qualList); cell; cell = next)
	{
		Node   *n = (Node *) lfirst(cell);

		next = lnext(cell);
		if (IsA(n, Constraint))
		{
			/* keep it in list */
			prev = cell;
			continue;
		}
		if (IsA(n, CollateClause))
		{
			CollateClause *c = (CollateClause *) n;

			if (*collClause) {
				const char* message = "multiple COLLATE clauses not allowed";
				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						 errmsg("multiple COLLATE clauses not allowed"),
						 parser_errposition(c->location)));
			}
			*collClause = c;
		}
		else if (IsA(n, ClientLogicColumnRef))
		{
			const char* message = "unsupported syntax: ENCRYPTED WITH in this operation";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate, (errmodule(MOD_SEC), errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("unsupported syntax: ENCRYPTED WITH in this operation"), errdetail("N/A"),
					errcause("client encryption feature is not supported this operation."),
						erraction("Check client encryption feature whether supported this operation.")));
		}
		else if (IsA(n, CommentStmt) && columnOptions != NULL)
		{
			*columnOptions = lcons(n, *columnOptions);
		}
		else {
			const char* message = "unexpected node type";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE),
						errmsg("unexpected node type %d", (int) n->type)));
		}
		/* remove non-Constraint nodes from qualList */
		qualList = list_delete_cell(qualList, cell, prev);
	}
	*constraintList = qualList;
}

/* Separate Constraint nodes from COLLATE clauses in a ColQualList */
static void
SplitColQualList(List *qualList,
				 List **constraintList, CollateClause **collClause,ClientLogicColumnRef **clientLogicColumnRef, List **columnOptions,
				 core_yyscan_t yyscanner)
{
	ListCell   *cell;
	ListCell   *prev;
	ListCell   *next;

	*collClause = NULL;
	*clientLogicColumnRef =NULL;
	prev = NULL;
	for (cell = list_head(qualList); cell; cell = next)
	{
		Node   *n = (Node *) lfirst(cell);

		next = lnext(cell);
		if (IsA(n, Constraint))
		{
			/* keep it in list */
			prev = cell;
			continue;
		}
		if (IsA(n, CollateClause))
		{
			CollateClause *c = (CollateClause *) n;

			if (*collClause) {
				const char* message = "multiple COLLATE clauses not allowed";
				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						 errmsg("multiple COLLATE clauses not allowed"),
						 parser_errposition(c->location)));
			}
			*collClause = c;
		}
		else if (IsA(n, ClientLogicColumnRef))
		{
			ClientLogicColumnRef *e = (ClientLogicColumnRef *) n;

			if (*clientLogicColumnRef) {
				const char* message = "multiple encrypted columns are not allowed";
				InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
				ereport(errstate,
						(errcode(ERRCODE_SYNTAX_ERROR),
						 errmsg("multiple encrypted columns are not allowed"),
						 parser_errposition(e->location)));
			}
			*clientLogicColumnRef = e;
		}
		else if (IsA(n, CommentStmt))
		{
			*columnOptions = lcons(n, *columnOptions);
		}
		else {
			const char* message = "unexpected node type";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE),
						errmsg("unexpected node type %d", (int) n->type)));
		}
		/* remove non-Constraint nodes from qualList */
		qualList = list_delete_cell(qualList, cell, prev);
	}
	*constraintList = qualList;
}

/*
 * Process result of ConstraintAttributeSpec, and set appropriate bool flags
 * in the output command node.  Pass NULL for any flags the particular
 * command doesn't support.
 */
static void
processCASbits(int cas_bits, int location, const char *constrType,
			   bool *deferrable, bool *initdeferred, bool *not_valid,
			   bool *no_inherit, core_yyscan_t yyscanner)
{
	/* defaults */
	if (deferrable)
		*deferrable = false;
	if (initdeferred)
		*initdeferred = false;
	if (not_valid)
		*not_valid = false;

	if (cas_bits & (CAS_DEFERRABLE | CAS_INITIALLY_DEFERRED))
	{
		if (deferrable)
			*deferrable = true;
		else {
			const char* message = "constraints cannot be marked DEFERRABLE";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 /* translator: %s is CHECK, UNIQUE, or similar */
					 errmsg("%s constraints cannot be marked DEFERRABLE",
							constrType),
					 parser_errposition(location)));
		}
	}

	if (cas_bits & CAS_INITIALLY_DEFERRED)
	{
		if (initdeferred)
			*initdeferred = true;
		else {
			const char* message = "constraints cannot be marked DEFERRABLE";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 /* translator: %s is CHECK, UNIQUE, or similar */
					 errmsg("%s constraints cannot be marked DEFERRABLE",
							constrType),
					 parser_errposition(location)));
		}
	}

	if (cas_bits & CAS_NOT_VALID)
	{
		if (not_valid)
			*not_valid = true;
		else {
			const char* message = "constraints cannot be marked NOT VALID";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 /* translator: %s is CHECK, UNIQUE, or similar */
					 errmsg("%s constraints cannot be marked NOT VALID",
							constrType),
					 parser_errposition(location)));
		}
	}

	if (cas_bits & CAS_NO_INHERIT)
	{
		if (no_inherit)
			*no_inherit = true;
		else {
			const char* message = "constraints cannot be marked NO INHERIT";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					 /* translator: %s is CHECK, UNIQUE, or similar */
					 errmsg("%s constraints cannot be marked NO INHERIT",
							constrType),
					 parser_errposition(location)));
		}
	}
}

/* parser_init()
 * Initialize to parse one query string
 */
void
parser_init(base_yy_extra_type *yyext)
{
	yyext->parsetree = NIL;		/* in case grammar forgets to set it */
	yyext->core_yy_extra.query_string_locationlist = NIL;
	yyext->core_yy_extra.paren_depth = 0;
	GetSessionContext()->isUpsert = false;
	GetSessionContext()->upSertAliasName = (Alias*)NULL;
	GetSessionContext()->is_schema_name = false;
	GetSessionContext()->is_create_alter_stmt = false;
}

static Expr *
makeNodeDecodeCondtion(Expr* firstCond,Expr* secondCond)
{
	A_Expr   *equal_oper	= makeSimpleA_Expr(AEXPR_OP, "=", (Node*)copyObject( firstCond), (Node*)copyObject(secondCond), -1);
	NullTest *isnull_oper1	= makeNode(NullTest);
	NullTest *isnull_oper2	= makeNode(NullTest);
	A_Expr   *and_oper	= makeA_Expr(AEXPR_AND,NIL,(Node*)isnull_oper1, (Node*)isnull_oper2, -1);
	CaseExpr *c		= makeNode(CaseExpr);
	CaseWhen *w		= makeNode(CaseWhen);

	isnull_oper1->arg = (Expr*) copyObject( firstCond);
	isnull_oper1->nulltesttype = IS_NULL;
	isnull_oper2->arg = (Expr*) copyObject(secondCond);
	isnull_oper2->nulltesttype = IS_NULL;

	w->expr  = (Expr*)and_oper;
	w->result = (Expr*)makeBoolAConst(TRUE, -1);

	c->casetype = InvalidOid;
	c->arg = NULL;
	c->args = NULL;
	c->args = lappend(c->args,w);
	c->defresult = (Expr*)equal_oper;
	c->fromDecode = true;

	return (Expr*)c;
}

// make function infomation to kill the session
// make "ResTarget" for invoking function "pg_terminate_backend",
// only the first cell of arguments is effective, it is treated as pid
static List*
make_action_func(List *arguments)
{
	FuncCall		*func = NULL;
	ResTarget	*restarget = NULL;

	func = (FuncCall*)makeNode(FuncCall);
	func->funcname = list_make1(makeString("pg_terminate_backend"));
	func->args = arguments;
	func->agg_star = FALSE;
	func->agg_distinct = FALSE;
	func->location = -1;
	func->call_func = false;

	restarget = makeNode(ResTarget);
	restarget->name = NULL;
	restarget->indirection = NIL;
	restarget->val = (Node *)func;
	restarget->location = -1;

	return (list_make1(restarget));
}

/*
 * @Description:  get arguments of function "pg_terminate_backend" from a string.
 * @in sid : the pid and serial info which need be terminated.
 * @return : the list include pid and serial information.
 */
static List *
get_func_args(char *sid)
{
	char *token = NULL;
	List *sidlist = NIL;
	long long pid = 0;
	long long serial = 0;
	const char *sep = ",";

	/*
	 * split the string with denotation 'sep'.
	 */
	while ((token = pg_strsep(&sid, sep)))
		sidlist = lappend(sidlist, token);

	/*
	 * it is incorrect unless the number of parameter equals 2
	 */
	if (2 != sidlist->length)
	{
		const char* message = "missing or invalid session ID";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_OBJECT),
				errmsg("missing or invalid session ID")));
		return NIL;
	}

	pid = get_pid((const char *)linitial(sidlist));
	serial= get_pid((const char *)lsecond(sidlist));

	/*
	 * negative is illegal for session id
	 */
	if (pid < 0 || serial < 0)
	{
		const char* message = "missing or invalid session ID";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_OBJECT),
				errmsg("missing or invalid session ID")));
		return NIL;
	}

	return list_make1(makeStringConst((char *)linitial(sidlist), -1));
}

// transform a string to a Oid
static long long
get_pid(const char *strsid)
{
	char cur_char = 0;
	int counter = 0;
	bool start =false;
	bool end = false;

	/*
	 * it is illegal format if the string is null
	 */
	if (!strsid)
	{
		const char* message = "missing or invalid session ID";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_OBJECT),
				errmsg("missing or invalid session ID")));
		return 0;
	}

	cur_char = strsid[counter];
	while (cur_char)
	{
		/*
		 * it is illegal if the string has a character that it is not a alphanumeric
		 */
		if (!isdigit(cur_char) && !isspace(cur_char))
		{
			const char* message = "missing or invalid session ID";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_OBJECT),
				errmsg("missing or invalid session ID")));
			return 0;
		}

		if (!start && isdigit(cur_char))
			start = true;

		if (!end && isspace(cur_char) && start)
			end = true;
		/*
		 * it is illegal if the string is aplited by a space
		 */
		if (start && end && !isspace(cur_char))
		{
			const char* message = "missing or invalid session ID";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_OBJECT),
				errmsg("missing or invalid session ID")));
			return 0;
		}
		cur_char = strsid[++counter];
	}

	if (!start)
	{
		const char* message = "missing or invalid session ID";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_UNDEFINED_OBJECT),
			errmsg("missing or invalid session ID")));
		return 0;
	}

	return atoll(strsid);
}

// Get next token from string *stringp, where tokens are
// possibly-empty strings separated by characters from delim.
// Writes NULs into the string at *stringp to end tokens,
// delim need not remain constant from call to call.
// On return, *stringp points past the last NUL written (if there
// might be further tokens), or is NULL (if there are definitely no
// moretokens).
// If *stringp is NULL, strsep returns NULL
static char *
pg_strsep(char **stringp, const char *delim)
{
	char	 *s = NULL;
	const char *spanp = NULL;
	int c = 0;
	int sc = 0;
	char	 *tok = NULL;

	if (NULL == (s = *stringp))
		return NULL;

	for (tok = s;;)
	{
		c = *s++;
		spanp = delim;
		do
		{
			if ((sc =*spanp++) == c)
			{
				if (0 == c)
					s = NULL;
				else
					s[-1] = 0;
				*stringp = s;
				return (tok);
			}
		} while (0 != sc);
	}
}

static int
get_outarg_num (List *fun_args)
{
	int count = 0;
	FunctionParameter *arg = NULL;
	ListCell* cell = NULL;

	if (NIL == fun_args)
		return 0;

	foreach (cell, fun_args)
	{
		arg = (FunctionParameter*) lfirst(cell);
		if ( FUNC_PARAM_OUT == arg->mode || FUNC_PARAM_INOUT == arg->mode )
			count++;
	}
	return count;
}
/* To Transform expr stirng into an ANONYMOUS BLOCK*/
static char* DoStmtPreformGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra)
{
	int length = end_pos - start_pos + 1;
	char* delimiter_str = u_sess->attr.attr_common.delimiter_name;
	int delimiter_len = strlen(delimiter_str);
	char* block_str = (char *)palloc0(length + 1 + 21 + delimiter_len);
	strncpy(block_str, " begin perform ", 15);
	strncpy(block_str + 15,yyextra->core_yy_extra.scanbuf + start_pos - 1, length);
	strncpy(block_str + 15 + length, delimiter_str, delimiter_len);
	strncpy(block_str + length + 15 + delimiter_len,"  end; ", 6);
	block_str[length + 21 + delimiter_len] = '\0';
	return block_str;
}

// To make a node for anonymous block
static Node *
MakeAnonyBlockFuncStmt(int flag, const char *str)
{
	DoStmt *n = makeNode(DoStmt);
	char *str_body	= NULL;
	DefElem * body	= NULL;
	errno_t		rc = EOK;

	if (BEGIN_P == flag)
	{
		int len1 = strlen("DECLARE \nBEGIN ");
		int len2 = strlen(str);
		str_body = (char *)palloc(len1 + len2 + 1);
		rc = strncpy_s(str_body, len1 + len2 + 1, "DECLARE \nBEGIN ",len1);
		securec_check(rc, "\0", "\0");
		rc = strcpy_s(str_body + len1, len2 + 1, str);
		securec_check(rc, "\0", "\0");
	}
	else
	{
		int len1 = strlen("DECLARE ");
		int len2 = strlen(str);
		str_body = (char *)palloc(len1 + len2 + 1);
		rc = strncpy_s(str_body, len1 + len2 + 1, "DECLARE ", len1);
		securec_check(rc, "\0", "\0");
		rc = strcpy_s(str_body + len1, len2 + 1, str);
		securec_check(rc, "\0", "\0");
	}

	body = makeDefElem("as", (Node*)makeString(str_body));
	n->args = list_make1(makeDefElem("language", (Node *)makeString("plpgsql")));
	n->args = lappend( n->args, body);

	return (Node*)n;
}

// get arg info with arg position or arg name
static void
get_arg_mode_by_name(const char *argname, const char * const *argnames,
			const char *argmodes,const int proargnum, bool *have_assigend, char *argmode)
{
	int	curpos = 0;
	const char *paraname= NULL;

	if (argnames == NULL) {
		const char* message = "No function matches the given arguments names.";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
			errmsg("No function matches the given arguments names. "
			"You might need to add explicit declare arguments names.")));
	}

	if (unlikely(argname == NULL)) {
		const char* message = "argname should not be null";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate, 
			(errcode(ERRCODE_INVALID_PARAMETER_VALUE), 
			errmsg("argname should not be null")));
	}

	for (curpos = 0; curpos < proargnum; curpos++)
	{
		paraname = argnames[curpos];

		if (paraname && !strcmp(paraname, argname))
		{
			if (!argmodes)
				*argmode = FUNC_PARAM_IN;
			else
				*argmode = argmodes[curpos];

			break;
		}
	}

	if (curpos < proargnum && have_assigend[curpos])
	{
		const char* message = "aparameter is assigned more than once";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_DUPLICATE_OBJECT),
			errmsg("parameter \"%s\" is assigned more than once", argname)));
		return;
	}

	if (curpos == proargnum)
	{
		const char* message = "parameter is undefined";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_PARAMETER),
				errmsg("parameter \"%s\" is undefined", argname)));
		return;
	}

	have_assigend[curpos] = true;
}

// get arg info with arg position or arg position
static void
get_arg_mode_by_pos(const int pos, const char *argmodes,
			const int narg, bool *have_assigend, char *argmode)
{
	AssertEreport(pos >= 0, MOD_OPT, "para should not be negative");

	if (have_assigend[pos])
	{
		const char* message = "the parameter located have been assigned";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_DUPLICATE_OBJECT),
			errmsg("the parameter located \"%d\" have been assigned", pos + 1)));
		return;
	}

	if (argmodes)
		*argmode = argmodes[pos];
	else
		*argmode = FUNC_PARAM_IN;

	have_assigend[pos] = true;
}

// return count of table function output column
static int get_table_modes(int narg, const char *p_argmodes)
{
	int count = 0;
	if (p_argmodes == NULL)
		return 0;
	for (; narg > 0; narg--, p_argmodes++)
		if (*p_argmodes == FUNC_PARAM_TABLE)
			count++;
	return count;
}

// check and append a cell to a list
static List *
append_inarg_list(const char argmode,const ListCell *cell,List *in_parameters)
{
	const char* message = "parameter mode doesn't exist";
	switch(argmode)
	{
		case FUNC_PARAM_IN:
			in_parameters = lappend(in_parameters,lfirst(cell));
			break;
		case FUNC_PARAM_INOUT:
			in_parameters = lappend(in_parameters,lfirst(cell));
			break;
		case FUNC_PARAM_OUT:
			break;
		// get the all "in" parameters, except "out" or "table_colums" parameters
		case FUNC_PARAM_TABLE:
			break;
		default:
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_UNRECOGNIZED_NODE_TYPE),
					errmsg("parameter mode %c doesn't exist",argmode)));
			break;
	}

	return in_parameters;
}

// check wheather all the out parameters have been assigned
static void
check_outarg_info(const bool *have_assigend, const char *argmodes,const int proargnum)
{
	int counter = 0;

	if (!argmodes)
		return;

	for (counter = 0; counter < proargnum; counter++)
	{
		if (!have_assigend[counter] && (FUNC_PARAM_OUT == argmodes[counter]))
		{
			const char* message = "output argument located does not assigned";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				errmsg("output argument located \"%d\" doesnot assigned",
				counter + 1)));
			return;
		}
	}
}

static bool HasVariadic(int nargs, const char* argmodes)
{
	if (!argmodes) {
		return false;
	}

	for (int i = nargs - 1; i >= 0; --i) {
		if (argmodes[i] == FUNC_PARAM_VARIADIC) {
			return true;
		}
	}
	return false;
}

// Added CALL for procedure and function
static Node *
makeCallFuncStmt(List* funcname,List* parameters, bool is_call)
{
	SelectStmt *newm = NULL;
	ColumnRef *column = NULL;
	ResTarget *resTarget = NULL;
	FuncCall *funcCall = NULL;
	List *userVarList = NIL;
	RangeFunction *rangeFunction = NULL;
	char *schemaname = NULL;
	char *name = NULL;
	char *pkgname = NULL;
	Oid pkgoid = InvalidOid;
	FuncCandidateList clist = NULL;
	HeapTuple proctup = NULL;
	Form_pg_proc procStruct;
	Oid *p_argtypes = NULL;
	char **p_argnames = NULL;
	char *p_argmodes = NULL;
	List *in_parameters = NULL;
	int i = 0;
	ListCell *cell = NULL;
	int narg = 0;
	int ndefaultargs = 0;
	int ntable_colums = 0;
	bool *have_assigend = NULL;
	bool	has_overload_func = false;
	Datum package_oid_datum;
	/* deconstruct the name list */
	DeconstructQualifiedName(funcname, &schemaname, &name, &pkgname);

	/* search the function */
	clist = FuncnameGetCandidates(funcname, -1, NIL, false, false, false);
	if (!clist)
	{
		const char* message = "function doesn't exist ";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_UNDEFINED_FUNCTION),
				errmsg("function \"%s\" doesn't exist ", name)));
		return NULL;
	}

	if (clist->next)
	{
		has_overload_func = true;
		if (IsPackageFunction(funcname) == false && IsPackageSchemaOid(SchemaNameGetSchemaOid(schemaname, true)) == false)
		{
			const char* message = "function isn't exclusive ";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
					(errcode(ERRCODE_DUPLICATE_FUNCTION),
					errmsg("function \"%s\" isn't exclusive ", name)));
			return NULL;
		}
	}

	proctup = SearchSysCache(PROCOID,
							ObjectIdGetDatum(clist->oid),
							0, 0, 0);
	/*
	 * function may be deleted after clist be searched.
	 */
	if (!HeapTupleIsValid(proctup))
	{
		const char* message = "function doesn't exist";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_FUNCTION),
					errmsg("function \"%s\" doesn't exist ", name)));
		return NULL;
	}

	/* get the all args informations, only "in" parameters if p_argmodes is null */
	narg = get_func_arg_info(proctup, &p_argtypes, &p_argnames, &p_argmodes);
	bool hasVariadic = HasVariadic(narg, p_argmodes);

#ifndef ENABLE_MULTIPLE_NODES
	if (!hasVariadic && !has_overload_func && !enable_out_param_override())
#else
        if (!hasVariadic && !has_overload_func)
#endif
	{
		/* get the all "in" parameters, except "out" or "table_colums" parameters */
		ntable_colums = get_table_modes(narg, p_argmodes);
		narg -= ntable_colums;

		procStruct = (Form_pg_proc) GETSTRUCT(proctup);
		ndefaultargs = procStruct->pronargdefaults;

		/* check the parameters' count*/
		if (narg - ndefaultargs > (parameters ? parameters->length : 0) )
		{
			const char* message = "function with %d parameters doesn't exist";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_FUNCTION),
				errmsg("function \"%s\" with %d parameters doesn't exist ",
					name,parameters? parameters->length : 0)));
		}

		if (parameters && (narg < parameters->length))
		{
			const char* message = "function with %d parameters doesn't exist";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_UNDEFINED_FUNCTION),
				errmsg("function \"%s\" with %d parameters doesn't exist ",
					name, parameters->length)));
		}

		/* analyse all parameters */
		i = 0;
		have_assigend = (bool *)palloc(sizeof(bool) * narg);
		memset(have_assigend, 0, sizeof(bool) * narg);

		foreach(cell,parameters)
		{
			Node	*arg = (Node *)lfirst(cell);
			char *argname = NULL;
			char	argmode = 0;

			if (IsA(arg, NamedArgExpr))
			{
				NamedArgExpr *na = (NamedArgExpr *) arg;

				argname = na->name;
				get_arg_mode_by_name(argname, p_argnames,
							p_argmodes, narg, have_assigend,&argmode);
				in_parameters = append_inarg_list(argmode, cell, in_parameters);
			}
			else
			{
				get_arg_mode_by_pos(i, p_argmodes, narg, have_assigend, &argmode);
				in_parameters = append_inarg_list(argmode, cell, in_parameters);

				if (argmode == FUNC_PARAM_OUT || argmode == FUNC_PARAM_INOUT) {
					if (IsA(arg, TypeCast)) {
						arg = (*(TypeCast *)arg).arg;
					}
					if (IsA(arg, UserVar)) {
						userVarList = lappend(userVarList,arg);
					}
				}
			}

			i++;
		}

		check_outarg_info(have_assigend, p_argmodes, narg);
	}
	else
	{
		in_parameters = parameters;
	}
	ReleaseSysCache(proctup);

	column = makeNode(ColumnRef);
	column->fields = list_make1(makeNode(A_Star));
	column->location = -1;
	column->indnum = 0;

	resTarget = makeNode(ResTarget);
	resTarget->name = NULL;
	resTarget->indirection = NIL;
	resTarget->val = (Node *)column;
	resTarget->location = -1;

	funcCall = (FuncCall*)makeNode(FuncCall);
	funcCall->funcname = funcname;
	funcCall->args = in_parameters;
	funcCall->agg_star = FALSE;
	funcCall->func_variadic = false;
	funcCall->agg_distinct = FALSE;
	funcCall->agg_order = NIL;
	funcCall->over = NULL;
	funcCall->location = -1;

	/*funcCall->pkgoid = pkgoid;*/
#ifndef ENABLE_MULTIPLE_NODES
	if (has_overload_func || is_call)
#else
        if (has_overload_func)
#endif
            funcCall->call_func = true;
	else
            funcCall->call_func = false;

	rangeFunction = makeNode(RangeFunction);
	rangeFunction->funccallnode = (Node*)funcCall;
	rangeFunction->coldeflist = NIL;

	newm =  (SelectStmt*)makeNode(SelectStmt);
	newm->distinctClause = NIL;
	newm->intoClause  = NULL;
	newm->targetList  = list_make1(resTarget);
	newm->fromClause  = list_make1(rangeFunction);
	newm->whereClause = NULL;
	newm->havingClause= NULL;
    newm->groupClause = NIL;
	if (userVarList != NIL) {
		IntoClause *n = makeNode(IntoClause);
		n->userVarList = userVarList;
		newm->intoClause  = n;
	}
	return (Node*)newm;
}

/* judge if ident is valid
 * Only letters, numbers, dollar signs ($) and the underscore are allowed in name
 * and The first character must be letter or underscore
*/
bool
IsValidIdent(char *input)
{
	char c = input[0];
	/*The first character id numbers or dollar*/
	if ((c >= '0' && c <= '9') || c == '$')
	{
		const char* message = "invalid name";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_SYNTAX_ERROR),
			errmsg("invalid name: %s", input)));
		return false;
	}

	int len = strlen(input);
	for (int i = 0; i < len; i++)
	{
		c = input[i];
		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_' || c == '$')
		{
			continue;
		}
		else
		{
			const char* message = "invalid name";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("invalid name: %s", input)));
			return false;
		}
	}
	return true;
}

/* judge if username is valid
 * Only letters, numbers, dollar signs ($), number signs (#) and the underscore are allowed in name
 * and The first character must be letter or underscore
*/
bool
IsValidIdentUsername(char *input)
{
	char c = input[0];
	/*The first character id numbers or dollar*/
	if ((c >= '0' && c <= '9') || c == '$')
	{
		ereport(ERROR,
			(errcode(ERRCODE_SYNTAX_ERROR),
			errmsg("invalid name: %s", input)));
		return false;
	}

	int len = strlen(input);
	for (int i = 0; i < len; i++)
	{
		c = input[i];
		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_' || c == '$' || c == '#')
		{
			continue;
		}
		else
		{
			ereport(ERROR,
				(errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("invalid name: %s", input)));
			return false;
		}
	}
	return true;
}

/* judge if node group name is valid
 * Only ASCII character set is allowed in group name
*/
bool
IsValidGroupname(const char *input)
{
	int len = strlen(input);
	for (int i = 0; i < len; i++)
	{
		if (IS_HIGHBIT_SET(input[i]))
		{
			const char* message = "node group name is not allowed to contain multibyte characters";
			InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
			ereport(errstate,
				(errcode(ERRCODE_SYNTAX_ERROR),
				errmsg("node group name is not allowed to contain multibyte characters")));
		}	
	}
	return true;
}

static void ParseUpdateMultiSet(List *set_target_list, SelectStmt *stmt, core_yyscan_t yyscanner)
{
	/*
	 * Here we transfrom the original sql to handle multicolumn update, we transform the
	 * original sql like this:
	 * the original sql:      UPDATE t1 SET (c1,c2) = (SELECT AVG(d1), 154 a2 FROM t2 GROUP BY a2);
	 * after transformed sql: UPDATE t1 SET (c1,c2) =
								(SELECT s1,s2 FROM (SELECT AVG(d1), 154 a2 FROM t2 GROUP BY a2) as S(s1,s2));
	 */
	List *col_names = NIL;
	ListCell *col_cell = NULL;
	int loop = 1;
	StringInfoData buf;

	initStringInfo(&buf);
	appendStringInfoChar(&buf, 's');

	/* we need construct complete alias at first */
	foreach(col_cell, set_target_list) {
		pg_ltoa(loop++, &buf.data[1]);
		col_names = lappend(col_names, makeString(pstrdup(buf.data)));
	}

	RangeSubselect *rsubselect = makeNode(RangeSubselect);
	rsubselect->subquery = (Node*)stmt;
	rsubselect->alias = makeAlias(pstrdup("S"), col_names);

	/* now we can separate the multi columns. */
	ListCell* colName = list_head(col_names);

	foreach(col_cell, set_target_list) {
		ResTarget *res_col = (ResTarget *) lfirst(col_cell);

		/* create a new selectstmt as : */
		SelectStmt *stmt_new = makeNode(SelectStmt);
		ResTarget *res_new = makeNode(ResTarget);
		SubLink *res_val = makeNode(SubLink);

		/* we need assign the column for each set_target according to the sequence of column name in alias */
		res_new->val = makeColumnRef(pstrdup(strVal(lfirst(colName))), NIL, res_col->location, yyscanner);
		res_new->location = res_col->location;

		stmt_new->targetList = list_make1(res_new);
		stmt_new->fromClause = list_make1(
			(res_col == linitial(set_target_list)) ? rsubselect : copyObject(rsubselect));

		res_val->subLinkType = EXPR_SUBLINK;
		res_val->testexpr = NULL;
		res_val->operName = NIL;
		res_val->subselect = (Node*)stmt_new;
		res_col->val = (Node*)res_val;

		colName = lnext(colName);
	}
	pfree_ext(buf.data);
}

/* get proc header sting len and start pos in scanbuffer */
static int GetProcHeaderLen(core_yyscan_t yyscanner, int *startPos)
{
	int param_pos_b = 0;
	int param_pos_e = 0;
	int proc_header_len = 0;
	base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);

	param_pos_b = yyextra->core_yy_extra.func_param_begin;
	param_pos_e = yyextra->core_yy_extra.func_param_end;
	/* exclude left parenthesis at beginning of param */
	param_pos_b++;
	/* exclude right parenthesis at end of param */
	proc_header_len = param_pos_e - param_pos_b;

	*startPos = param_pos_b;

	return proc_header_len;
}

/* get pg_dump type name by input name */
static char *GetTargetFuncArgTypeName(char *typeString, TypeName* t)
{
	char *target = NULL;

	if (t->pct_type)
	{
		Type typtup;
		Oid toid;
		typtup = LookupTypeName(NULL, t, NULL, false);
		if (typtup)
		{
			toid = typeTypeId(typtup);
			target = format_type_be(toid);
			ReleaseSysCache(typtup);
		}
	}
	else
	{
		if (t->end_location - t->location == DATE_LEN
			&& (u_sess->attr.attr_sql.sql_compatibility == A_FORMAT)
			&& pg_strncasecmp(typeString, "date", DATE_LEN) == 0)
		{
			target = pstrdup("timestamp without time zone");
		}
	}

	return target;
}

/* covert input type name into pg_dump type name */
static char *FormatFuncArgType(core_yyscan_t yyscanner, char *argsString, List* parameters)
{
	ListCell* x = NULL;
	char *tmp_pos = argsString;
	int param_pos_b = 0;
	int proc_header_len = 0;
	base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
	StringInfoData buf;
	char *target = NULL;
	int token_offset = 0;

	if (argsString == NULL)
	{
		return NULL;
	}

	proc_header_len = GetProcHeaderLen(yyscanner, &param_pos_b);
	initStringInfo(&buf);

	foreach (x, parameters)
	{
		FunctionParameter* fp = (FunctionParameter*)lfirst(x);
		TypeName* t = fp->argType;

		if (t->end_location > 0)
		{
			token_offset = t->location - param_pos_b;
			target = GetTargetFuncArgTypeName(argsString + token_offset, t);
			if (target != NULL)
			{
				*(argsString + token_offset) = '\0';
				appendStringInfoString(&buf, tmp_pos);
				appendStringInfoString(&buf, target);
				tmp_pos = argsString + (t->end_location - param_pos_b);
				pfree(target);
			}
		}
	}
	appendStringInfoString(&buf, tmp_pos);
	pfree(argsString);
	proc_header_len = proc_header_len;

	yyextra->core_yy_extra.func_param_begin = 0;
	yyextra->core_yy_extra.func_param_end = 0;

	return buf.data;
}

/*
 * get function and procedure args input string
 */
static char *ParseFunctionArgSrc(core_yyscan_t yyscanner)
{
	base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
	int param_pos_b = 0;
	int proc_header_len = 0;
	char *proc_header_str = NULL;

	if (yyextra->core_yy_extra.include_ora_comment == false)
	{
		return NULL;
	}

	/* exclude right parenthesis at end of param */
	proc_header_len = GetProcHeaderLen(yyscanner, &param_pos_b);
	if (proc_header_len > 0)
	{
		proc_header_str = (char *)palloc0(proc_header_len + 1);
		strncpy_s(proc_header_str, (proc_header_len + 1), yyextra->core_yy_extra.scanbuf + param_pos_b, proc_header_len);
		proc_header_str[proc_header_len] = '\0';
	}

	yyextra->core_yy_extra.include_ora_comment = false;

	return proc_header_str;
}

static void parameter_check_execute_direct(const char* query)
{
#ifndef ENABLE_MULTIPLE_NODES					
    if (IS_SINGLE_NODE) {
		const char* message = "Un-support feature";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
				errmsg("Un-support feature"),
				errdetail("The distributed capability is not supported currently.")));
	}
#endif
	/*
	 * when enable_nonsysadmin_execute_direct is off, only system admin can use EXECUTE DIRECT;
	 * when enable_nonsysadmin_execute_direct is on, any user can use EXECUTE DIRECT;
	*/
	if (!g_instance.attr.attr_security.enable_nonsysadmin_execute_direct &&
		!CheckExecDirectPrivilege(query)) {
		const char* message = "must be system admin or monitor admin to use EXECUTE DIRECT";
		InsertErrorMessage(message, u_sess->plsql_cxt.plpgsql_yylloc);
		ereport(errstate,
			(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
				errmsg("must be system admin or monitor admin to use EXECUTE DIRECT")));
	}
}

static TypeName* parseFloatTypeByPrecision(int ival, int location, core_yyscan_t yyscanner, bool is_byprecision)
{
    TypeName *typnam = NULL;
	int max = is_byprecision ? 53 : 255;
    if (ival < 1) {
        ereport(ERROR,
            (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
             errmsg("precision for type float must be at least 1 bit"),
             parser_errposition(location)));
    } else if (ival <= 24) {
        typnam = SystemTypeName("float4");
    } else if (ival <= max) {
        typnam = SystemTypeName("float8");
    } else {
        ereport(ERROR,
            (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
             errmsg("precision for type float must be less than %d bits", max + 1),
             parser_errposition(location)));
    }
    return typnam;
}

static TypeName* transferFloat4TypeInBFormat(char *typnam, List* list, int location, core_yyscan_t yyscanner)
{
    TypeName *transResult = NULL;
    if (list == NULL) {
        transResult = SystemTypeName("float4");
        return transResult;
    }
    if (list->length == 1) {
        Node *node = (Node*)(list->head->data.ptr_value);
        if (node->type == T_A_Const) {
            A_Const aConst = *(A_Const*)(list->head->data.ptr_value);
            if (aConst.val.type == T_Integer) {
                int ival = aConst.val.val.ival;
                transResult = parseFloatTypeByPrecision(ival, location, yyscanner);
                transResult->typmods = NIL;
                list_free_ext(list);
                return transResult;
            }
        }
    }else if (list->length == 2) {
        transResult = SystemTypeName("numeric");
        transResult->typmods = list;
        return transResult;
    }
    /* exception */
    transResult = SystemTypeName("float4");
    transResult->typmods = list;
    return transResult;
}

static Node *make_node_from_scanbuf(int start_pos, int end_pos, core_yyscan_t yyscanner)
{
	base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
	int len = end_pos - 1;

	/* trim trailing blanks */
	while (yyextra->core_yy_extra.scanbuf[len] == ' ')
		len--;

	len = len - start_pos + 1;
	char *str = (char *)palloc0(len + 1);
	strncpy(str, yyextra->core_yy_extra.scanbuf + start_pos, len);
	str[len] = '\0';
	return makeStringConst(str, start_pos);
}

static int64 SequenceStrGetInt64(const char *str)
{
    const char *ptr = str;

    while (*ptr && isspace((unsigned char)*ptr)) {
        ptr++;
    }

    /* handle sign */
    if (*ptr == '-') {
        ereport(errstate,
                (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg("Sequence args %s is negative number\n", str)));
    } else if (*ptr == '+') {
        ptr++;
    }

    while (*ptr) {
        if (!isdigit((unsigned char)*ptr)) {
            ereport(errstate, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg("Sequence args %s is invalid\n", str)));
        }
        ptr++;
    }

    return strtol(str, NULL, 10);
}

static int GetLoadType(int load_type_f, int load_type_s)
{
	if (load_type_s != LOAD_DATA_UNKNOWN) {
		return load_type_s;
	} else if (load_type_f != LOAD_DATA_UNKNOWN) {
		return load_type_f;
	}

	return LOAD_DATA_INSERT;
}

static Node *MakeSqlLoadNode(char *colname)
{
	SqlLoadColExpr* n = makeNode(SqlLoadColExpr);
	n->colname = colname;
	n->const_info = NULL;
	n->sequence_info = NULL;
	n->is_filler = false;
	n->scalar_spec = NULL;

	return (Node *)n;
}

static bool IsConnectByRootIdent(Node* node)
{
    if (!IsA(node, ColumnRef)) {
        return false;
    }
    ColumnRef* cr = (ColumnRef*) node;
    List* l = (cr != NULL) ? cr->fields : NULL;
    Node* sn = list_length(l) > 0 ? linitial_node(Node, l) : NULL;
    if (sn != NULL && !IsA(sn, String)){
        return false;
    }
    char* colname = strVal(sn);
    return (strcasecmp("connect_by_root", colname) == 0);
}

static void ValidateTripleTuple(Node* node, core_yyscan_t yyscanner, int location, char* token)
{
    if (!IsConnectByRootIdent(node)) {
        ereport(ERROR,
            (errmodule(MOD_PARSER), errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                errmsg("Invalid use of identifiers."),
                parser_errposition(location),
                errdetail("Syntax error found near token \"%s\"", token),
                errcause("Unsupported expression found in SELECT statement"),
                erraction("Check and revise your query or contact Huawei engineers.")));
    }
}

static void FilterStartWithUseCases(SelectStmt* stmt, List* locking_clause, core_yyscan_t yyscanner, int location)
{
    if (stmt->startWithClause != NULL && locking_clause != NULL) {
        ereport(ERROR,
            (errmodule(MOD_PARSER), errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                errmsg("Syntax error found."),
                parser_errposition(location),
                errdetail("FOR UPDATE/SHARE cannot be used with START WITH CONNECT BY clauses"),
                errcause("Unsupported expression found in SELECT statement"),
                erraction("Check and revise your query or contact Huawei engineers.")));
    }
}

static Node *processIntoClauseInSelectStmt(SelectStmt *stmt, IntoClause *itc)
{
	if (itc != NULL) {
		if (stmt->intoClause != NULL) {
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					errmsg("select statement can contain only one into_clause")));
		}
		if (itc->rel != NULL && u_sess->attr.attr_sql.sql_compatibility != B_FORMAT) {
			ereport(errstate,
					(errcode(ERRCODE_SYNTAX_ERROR),
					errmsg("select statement can contain only one into_clause")));	}
		stmt->intoClause = itc;
	}
	return (Node *)stmt;
}

static Node* MakeConnectByRootNode(ColumnRef* cr, int location)
{
    FuncCall *n = makeNode(FuncCall);
    n->funcname = list_make1(makeString("connect_by_root"));
    n->args = list_make1(cr);
    n->agg_order = NIL;
    n->agg_star = FALSE;
    n->agg_distinct = FALSE;
    n->func_variadic = FALSE;
    n->over = NULL;
    n->location = location;
    n->call_func = false;
    return (Node*) n;
}

static char* MakeConnectByRootColName(char* tabname, char* colname)
{
    char* ret = NULL;
    if (tabname != NULL) {
        int max_len = strlen("connect_by_root") + strlen(tabname) + 1 + strlen(colname) + 1;
        ret = (char *)palloc(max_len);
        strcpy_s(ret, max_len, "connect_by_root");
        strcat_s(ret, max_len, tabname);
        strcat_s(ret, max_len, ".");
        strcat_s(ret, max_len,colname);
    } else {
        int max_len = strlen("connect_by_root") + strlen(colname) + 1;
        ret = (char *)palloc(max_len);
        strcpy_s(ret, max_len, "connect_by_root");
        strcat_s(ret, max_len, colname);
    }
    return ret;
}

#ifndef ENABLE_MULTIPLE_NODES
static bool CheckWhetherInColList(char *colname, List *col_list)
{
	ListCell* lc = NULL;
	char *colname_l = pg_strtolower(colname);

	if (col_list == NULL) {
		return true;
	}

	foreach (lc, col_list) {
		char* name = strVal(lfirst(lc));
		if (strcmp(name, colname_l) == 0) {
			return true;
		}
	}

	return false;
}
#endif

static void BCompatibilityOptionSupportCheck(const char* keyword)
{
#ifdef ENABLE_MULTIPLE_NODES
    ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("%s is not yet supported.", keyword)));
#endif
    if (DB_IS_CMPT(B_FORMAT)) {
        return;
    }
    ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
        errmsg("%s is supported only in B compatible database.", keyword)));
}

static int GetFillerColIndex(char *filler_col_name, List *col_list)
{
	ListCell* lc = NULL;
	int index = 0;

	if (col_list == NULL) {
		ereport(errstate, (errcode(ERRCODE_INVALID_COLUMN_REFERENCE),
			errmsg("Column list cannot be empty for \"FILLER\"")));
		return InvalidAttrNumber;
	}

	foreach (lc, col_list) {
		index++;
		char* colname = strVal(lfirst(lc));
		if (strcmp(colname, filler_col_name) == 0) {
			return index;
		}
	}

	ereport(errstate, (errcode(ERRCODE_INVALID_COLUMN_REFERENCE),
			errmsg("Filler col \"%s\" is not in the col list", filler_col_name)));
	return InvalidAttrNumber;
}

static void RemoveFillerCol(List *filler_list, List *col_list)
{
	ListCell* filler_cell = NULL;
	ListCell* col_cell = NULL;
	ListCell* prev = NULL;
	SqlLoadFillerInfo *fillerInfo = NULL;
	char* colname = NULL;

	if (filler_list == NULL || col_list == NULL) {
		return;
	}

	foreach (filler_cell, filler_list) {
		fillerInfo = (SqlLoadFillerInfo *)lfirst(filler_cell);
		prev = NULL;
		foreach (col_cell, col_list) {
			colname = strVal(lfirst(col_cell));
			if (strcmp(fillerInfo->colname, colname) == 0) {
				list_delete_cell(col_list, col_cell, prev);
				break;
			}
			prev = col_cell;
		}
	}

	return;
}

static void setDelimiterName(core_yyscan_t yyscanner, char*input, VariableSetStmt*n)
{
	errno_t rc = 0;
	base_yy_extra_type *yyextra = pg_yyget_extra(yyscanner);
	if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT) {
		if(strlen(input) == 0) {
			parser_yyerror("DELIMITER must be followed by a 'delimiter' character or string");
		}
		if (strlen(input) >= DELIMITER_LENGTH) {
			parser_yyerror("'delimiter' length should less than 16");
		}
		n->is_local = false;
		n->kind = VAR_SET_VALUE;
		n->name = "delimiter_name";
		n->args = list_make1(makeStringConst(input, -1));
	}
}


static FuncCall* MakePriorAsFunc()
{
    List *funcName = list_make1(makeString("prior"));
    FuncCall *n = makeNode(FuncCall);
    n->funcname = funcName;
    n->args = NIL;
    n->agg_order = NIL;
    n->agg_star = FALSE;
    n->agg_distinct = FALSE;
    n->func_variadic = FALSE;
    n->over = NULL;
    n->call_func = false;
    return n;
}

static void checkDeleteRelationError()
{
#ifdef ENABLE_MULTIPLE_NODES
	ereport(errstate, 
			(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
				errmsg("multi-relation delete is not yet supported.")));
#endif
	if (u_sess->attr.attr_sql.sql_compatibility != B_FORMAT)						
		ereport(errstate, 
				(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
					errmsg("multi-relation delete only support in B-format database")));
}

#ifndef MAX_SUPPORTED_FUNC_FOR_PART_EXPR
#define MAX_SUPPORTED_FUNC_FOR_PART_EXPR 25
#endif
static void CheckPartitionExpr(Node* expr, int* colCount)
{
	if (expr == NULL)
		ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("The expr can't be NULL")));
	if (expr->type == T_A_Expr) {
		A_Expr* a_expr = (A_Expr*)expr;
		if (a_expr->name == NULL) {
			ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("The expr is not supported for Partition Expr")));
		}
		char* name = strVal(linitial(a_expr->name));
		if (strcmp(name, "+") != 0 && strcmp(name, "-") != 0 && strcmp(name, "*") != 0)
			ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("The %s operator is not supported for Partition Expr", name)));
		CheckPartitionExpr(a_expr->lexpr, colCount);
		CheckPartitionExpr(a_expr->rexpr, colCount);
	} else if (expr->type == T_FuncCall) {
		char* validFuncName[MAX_SUPPORTED_FUNC_FOR_PART_EXPR] = {"abs","ceiling","datediff","day","dayofmonth","dayofweek","dayofyear","extract","floor","hour",
		"microsecond","minute","mod","month","quarter","second","time_to_sec","to_days","to_seconds","unix_timestamp","weekday","year","yearweek","date_part","div"};
		char* funcname = strVal(llast(((FuncCall*)expr)->funcname));
		int count = 0;
		for (;count < MAX_SUPPORTED_FUNC_FOR_PART_EXPR;count++) {
			if (strcmp(funcname, validFuncName[count]) == 0)
				break;
			else
				continue;
		}
		if (count == MAX_SUPPORTED_FUNC_FOR_PART_EXPR)
			ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("The %s func is not supported for Partition Expr", funcname)));
		ListCell* cell = NULL;
		foreach (cell, ((FuncCall*)expr)->args) {
			CheckPartitionExpr((Node*)(lfirst(cell)),colCount);
		}
	} else if (expr->type == T_ColumnRef) {
		(*colCount)++;
	} else if (expr->type == T_A_Const) {
		return;
	} else {
		ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("The Partition Expr can't be %d type", expr->type)));
	}
}

static CreateTableOptions* MakeCreateTableOptions(CreateTableOptions *tableOptions, SingleTableOption *tableOption)
{
	if (tableOptions == NULL) {
		/* Initialize struct*/
		tableOptions = (CreateTableOptions*)palloc0(sizeof(CreateTableOptions));
		tableOptions->oncommit = ONCOMMIT_NOOP;
		tableOptions->row_compress = REL_CMPRS_PAGE_PLAIN;
		tableOptions->relkind = OBJECT_TABLE;
	}

	switch (tableOption->option_type) {
	case OPT_INHERIT:
		tableOptions->inhRelations = tableOption->option.list_content;
		break;
	case OPT_WITH:
		if (tableOptions->options != NIL) {
			ereport(ERROR,
				(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg("can't use \"option\" with more than once")));
		}
		tableOptions->options = tableOption->option.list_content;
		break;
	case OPT_ONCOMMIT:
		tableOptions->oncommit = tableOption->option.oncommit;
		break;
	case OPT_COMPRESS:
		tableOptions->row_compress = tableOption->option.row_compress;
		tableOptions->is_row_compress_modified = true;
		break;
	/* PGXC_BEGIN */
	case OPT_DISTRIBUTEBY:
		tableOptions->distributeby = tableOption->option.distributeby;
		break;
	case OPT_SUBCLUSTER:
		tableOptions->subcluster = tableOption->option.subcluster;
		break;
	/* PGXC_END */
	case OPT_TABLE_PARTITIONING_CLAUSE:
		tableOptions->partTableState = (PartitionState *)(tableOption)->option.partTableState;
		break;
	case OPT_INTERNAL_DATA:
		tableOptions->internalData = tableOption->option.char_content;
		break;
	case OPT_KIND:
		tableOptions->relkind = tableOption->option.relkind;
		break;
	case OPT_COMPRESSION:
		tableOptions->compress_type = tableOption->option.compress_type;
		break;
	case OPT_TABLESPACE:
		tableOptions->tablespacename = tableOption->option.char_content;
		break;
    case OPT_AUTO_INC:
        tableOptions->autoIncStart = tableOption->option.autoIncStart;
        break;
    case OPT_COMMENT_TAB:
        tableOptions->comment = tableOption->option.comment;
        break;
	case OPT_DOLPHIN_COLLATE:
        tableOptions->collate = tableOption->option.collate;
        break;
	case OPT_DOLPHIN_CHARSET:
        tableOptions->charset = tableOption->option.charset;
        break;
	case OPT_ROW_FORMAT:
		break;
	case OPT_AUTOEXTEND_SIZE:
		{
			if(!tableOptions->autoextend_size_option) {
				tableOptions->autoextend_size_option = true;
				ereport(WARNING, (errmsg("AUTOEXTEND_SIZE for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_AVG_ROW_LENGTH:
		{
			if(!tableOptions->avg_row_length_option) {
				tableOptions->avg_row_length_option = true;
				ereport(WARNING, (errmsg("AVG_ROW_LENGTH for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_CHECKSUM:
		{
			if(!tableOptions->checksum_option) {
				tableOptions->checksum_option = true;
				ereport(WARNING, (errmsg("CHECKSUM for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_CONNECTION:
		{
			if(!tableOptions->connection_option) {
				tableOptions->connection_option = true;
				ereport(WARNING, (errmsg("CONNECTION for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_DIRECTORY:
		{
			if(!tableOptions->directory_option) {
				tableOptions->directory_option = true;
				ereport(WARNING, (errmsg("DIRECTORY for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_DELAY_KEY_WRITE:
		{
			if(!tableOptions->delay_key_write_option) {
				tableOptions->delay_key_write_option = true;
				ereport(WARNING, (errmsg("DELAY_KEY_WRITE for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_ENCRYPTION:
		{
			if(!tableOptions->encryption_option) {
				tableOptions->encryption_option = true;
				ereport(WARNING, (errmsg("ENCRYPTION for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_ENGINE_ATTRIBUTE:
		{
			if(!tableOptions->engine_attribute_option) {
				tableOptions->engine_attribute_option = true;
				ereport(WARNING, (errmsg("ENGINE_ATTRIBUTE for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_INSERT_METHOD:
		{
			if(!tableOptions->insert_method_option) {
				tableOptions->insert_method_option = true;
				ereport(WARNING, (errmsg("INSERT_METHOD for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_KEY_BLOCK_SIZE:
		{
			if(!tableOptions->key_block_size_option) {
				tableOptions->key_block_size_option = true;
				ereport(WARNING, (errmsg("KEY_BLOCK_SIZE for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_MAX_ROWS:
		{
			if(!tableOptions->max_rows_option) {
				tableOptions->max_rows_option = true;
				ereport(WARNING, (errmsg("MAX_ROWS for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_MIN_ROWS:
		{
			if(!tableOptions->min_rows_option) {
				tableOptions->min_rows_option = true;
				ereport(WARNING, (errmsg("MIN_ROWS for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_PACK_KEYS:
		{
			if(!tableOptions->pack_keys_option) {
				tableOptions->pack_keys_option = true;
				ereport(WARNING, (errmsg("PACK_KEYS for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_PASSWORD:
		{
			if(!tableOptions->password_option) {
				tableOptions->password_option = true;
				ereport(WARNING, (errmsg("PASSWORD for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_START_TRANSACTION:
		{
			if(!tableOptions->start_transaction_option) {
				tableOptions->start_transaction_option = true;
				ereport(WARNING, (errmsg("START_TRANSACTION for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_SECONDARY_ENGINE_ATTRIBUTE:
		{
			if(!tableOptions->secondary_engine_attribute_option) {
				tableOptions->secondary_engine_attribute_option = true;
				ereport(WARNING, (errmsg("SECONDARY_ENGINE_ATTRIBUTE for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_STATS_AUTO_RECALC:
		{
			if(!tableOptions->stats_auto_recalc_option) {
				tableOptions->stats_auto_recalc_option = true;
				ereport(WARNING, (errmsg("STATS_AUTO_RECALC for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_STATS_PERSISTENT:
		{
			if(!tableOptions->stats_persistent_option) {
				tableOptions->stats_persistent_option = true;
				ereport(WARNING, (errmsg("STATS_PERSISTENT for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_STATS_SAMPLE_PAGES:
		{
			if(!tableOptions->stats_sample_pages_option) {
				tableOptions->stats_sample_pages_option = true;
				ereport(WARNING, (errmsg("STATS_SAMPLE_PAGES for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_UNION:
		{
			if(!tableOptions->union_option) {
				tableOptions->union_option = true;
				ereport(WARNING, (errmsg("UNION for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	case OPT_TABLESPACE_STORAGE:
		{
			if(!tableOptions->tablespace_option) {
				tableOptions->tablespace_option = true;
				ereport(WARNING, (errmsg("TABLESPACE_OPTION for TABLE is not supported for current version. skipped")));
			}
		}
		break;
	default:
		break;
	}
	return tableOptions;
}

static CreateTableOptions* MergeCreateTableOptions(CreateTableOptions *frontTableOptions, CreateTableOptions *rearTableOptions) {
	if (rearTableOptions->inhRelations == NULL) {
		rearTableOptions->inhRelations = frontTableOptions->inhRelations;
	}

	if (rearTableOptions->options == NULL) {
		rearTableOptions->options = frontTableOptions->options;
	}

	if (rearTableOptions->oncommit == ONCOMMIT_NOOP) {
		rearTableOptions->oncommit = frontTableOptions->oncommit;
	}

	if (rearTableOptions->tablespacename == NULL) {
		rearTableOptions->tablespacename = frontTableOptions->tablespacename;
	}

	if (rearTableOptions->row_compress == REL_CMPRS_PAGE_PLAIN && !rearTableOptions->is_row_compress_modified) {
		rearTableOptions->row_compress = frontTableOptions->row_compress;
	}

	if (rearTableOptions->partTableState == NULL) {
		rearTableOptions->partTableState = frontTableOptions->partTableState;
	}

	if (rearTableOptions->compress_type == NULL) {
		rearTableOptions->compress_type = frontTableOptions->compress_type;
	}

	/* PGXC_BEGIN */
	if (rearTableOptions->distributeby == NULL) {
		rearTableOptions->distributeby = frontTableOptions->distributeby; 
	}

	if (rearTableOptions->subcluster == NULL) {
		rearTableOptions->subcluster = frontTableOptions->subcluster;
	}
	/* PGXC_END */
	if (rearTableOptions->internalData == NULL) {
		rearTableOptions->internalData = frontTableOptions->internalData;
	}

	if (rearTableOptions->relkind == OBJECT_TABLE) {
		rearTableOptions->relkind = frontTableOptions->relkind;
	}

	if (rearTableOptions->autoIncStart == NULL) {
		rearTableOptions->autoIncStart = frontTableOptions->autoIncStart;
	}

	if (rearTableOptions->comment == NULL) {
		rearTableOptions->comment = frontTableOptions->comment;
	}

	if (rearTableOptions->charset == 0) {
		rearTableOptions->charset = frontTableOptions->charset;
	}

	if (rearTableOptions->collate == NULL) {
		rearTableOptions->collate = frontTableOptions->collate;
	}

	if (!rearTableOptions->is_row_compress_modified) {
		rearTableOptions->is_row_compress_modified = frontTableOptions->is_row_compress_modified;
	}

	return rearTableOptions;
}

static CreateIndexOptions *MakeCreateIndexOptions(CreateIndexOptions *indexOptions, SingleIndexOption *indexOption)
{
    if (indexOptions == NULL) {
        /* Initialize struct*/
        indexOptions = (CreateIndexOptions *)palloc0(sizeof(CreateIndexOptions));
    }
    indexOptions->visible = true;
    switch (indexOption->option_type) {
        case OPT_INCLUDE:
            if (indexOptions->indexIncludingParams != NIL) {
                ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                                errmsg("can't use option \"include\" more than once")));
            }
            indexOptions->indexIncludingParams = indexOption->option.list_content;
            break;
        case OPT_RELOPTIONS:
            if (indexOptions->options != NIL) {
                ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                                errmsg("can't use option \"with\" more than once")));
            }
            indexOptions->options = indexOption->option.list_content;
            break;
        case OPT_TABLESPACE_INDEX:
            indexOptions->tableSpace = indexOption->option.char_content;
            break;
        case OPT_COMMENT_INDEX:
            indexOptions->comment = indexOption->option.comment;
            break;
        case OPT_VISIBLE_INDEX:
            indexOptions->visible = indexOption->option.visible;
            break;
        default:
            break;
    }
    return indexOptions;
}

static Node* MakeSetPasswdStmt(char* user, char* passwd, char* replace_passwd)
{
	List *list = NULL;

	AlterRoleStmt *n = makeNode(AlterRoleStmt);
	n->role = user;
	n->action = +1;
	if (replace_passwd) {
		list = list_make2(makeStringConst(passwd, -1), makeStringConst(replace_passwd, -1));
	} else {
		list = list_make1(makeStringConst(passwd, -1));
	}
	n->options = list_make1(makeDefElem("password", (Node *)list));
	n->lockstatus = DO_NOTHING;
	return (Node *)n;
}

/*
 * Under thread pool mode, Use this SQL statement to process internal threads,
 * such as WorkloadMonitor, statement flush thread, JobScheduler etc.
 *
 * SELECT pg_terminate_session(coalesce((select pid from pg_stat_activity where sessionid = pid and sessionid = expr limit 1), 0), expr);
 *
 * Under non thread pool mode:
 *
 * SELECT pg_terminate_session(expr, expr);
 */
static Node* MakeKillStmt(int kill_opt, Node *expr)
{
	FuncCall* func = (FuncCall*)makeNode(FuncCall);
	func->funcname = list_make1(makeString((char *)(kill_opt ? "pg_terminate_session" : "pg_cancel_session")));
	func->agg_star = FALSE;
	func->agg_distinct = FALSE;
	func->location = -1;
	func->call_func = false;

	if (ENABLE_THREAD_POOL) {
		RangeVar* rv = makeRangeVar(NULL, "pg_stat_activity", -1);
		List* fl = (List*)list_make1(rv);

		ColumnRef* cr = makeNode(ColumnRef);
		cr->fields = lcons(makeString("pid"), NIL);
		cr->location = -1;
		ResTarget* rt = makeNode(ResTarget);
		rt->name = NULL;
		rt->indirection = NIL;
		rt->val = (Node*)cr;
		rt->location = -1;

		Node* cond1 = (Node*)makeSimpleA_Expr(AEXPR_OP, "=", makeColumnRef("sessionid", NIL, -1, NULL), expr, -1);
		Node* cond2 = (Node*)makeSimpleA_Expr(AEXPR_OP, "=", makeColumnRef("sessionid", NIL, -1, NULL), makeColumnRef("pid", NIL, -1, NULL), -1);
		Node* wc = (Node*)makeA_Expr(AEXPR_AND, NIL, cond1, cond2, -1);

		SelectStmt* stmt = makeNode(SelectStmt);
		stmt->distinctClause = NIL;
		stmt->targetList = list_make1(rt);
		stmt->intoClause = NULL;
		stmt->fromClause = fl;
		stmt->whereClause = wc;
		stmt->groupClause = NIL;
		stmt->havingClause = NULL;
		stmt->windowClause = NIL;
		stmt->limitCount = makeIntConst(1, -1);

		SubLink* sublink = makeNode(SubLink);
		sublink->subLinkType = EXPR_SUBLINK;
		sublink->testexpr = NULL;
		sublink->operName = NIL;
		sublink->subselect = (Node*)stmt;
		sublink->location = -1;

		CoalesceExpr* cexpr = makeNode(CoalesceExpr);
		cexpr->args = list_make2(sublink, makeIntConst(0, -1));
		cexpr->isnvl = true;

		func->args = list_make2((Node*)cexpr, expr);
	} else {
		func->args = list_make2(expr, expr);
	}

	ResTarget* rt = makeNode(ResTarget);
	rt->name = "result";
	rt->indirection = NIL;
	rt->val = (Node*)func;
	rt->location = -1;

	SelectStmt* n = makeNode(SelectStmt);
	n->distinctClause = NIL;
	n->targetList = list_make1(rt);
	n->intoClause = NULL;
	n->fromClause = NIL;
	n->whereClause = NULL;
	n->groupClause = NIL;
	n->havingClause = NULL;
	n->windowClause = NIL;
	return (Node*)n;
}

static Node* makeAnalyzeTableList(List *rangeVars)
{
	Datum* datums = NULL;
	ListCell *cell = NULL;
	StringInfoData res;
	bool first = true;

	initStringInfo(&res);
	appendStringInfoChar(&res, '{');

	foreach (cell, rangeVars) {
		RangeVar* rangeVar = (RangeVar*)lfirst(cell);
		char* schemaName = rangeVar->schemaname ? rangeVar->schemaname :
			DatumGetCString(DirectFunctionCall1(current_schema, PointerGetDatum(NULL)));

		if (first) {
			appendStringInfo(&res, "%s.%s", schemaName, rangeVar->relname);
			first = false;
		} else {
			appendStringInfo(&res, ", %s.%s", schemaName, rangeVar->relname);
		}
	}
	appendStringInfoChar(&res, '}');

	return makeStringConst(res.data, -1);
}

static char* downcase_str(char* ident, bool is_quoted)
{
	if (ident == NULL || is_quoted) {
		return ident;
	}
	int i;
	bool enc_is_single_byte = (pg_database_encoding_max_length() == 1);
	int len = strlen(ident);
	for (i = 0; i < len; i++) {
		ident[i] = (char)GetLowerCaseChar((unsigned char)ident[i], enc_is_single_byte);
	}

	return ident;
}

static DolphinString* MakeDolphinString(char* str, Node* node, bool is_quoted)
{
	DolphinString* result = (DolphinString*)palloc0(sizeof(DolphinString));
	result->str = str;
	result->node = node;
	result->is_quoted = is_quoted;
	return result;
}

static inline DolphinString* MakeDolphinStringByChar(char* str, bool is_quoted)
{
	return MakeDolphinString(str, (Node*)makeString(str), is_quoted);
}

static inline DolphinString* MakeDolphinStringByNode(Node* node, bool is_quoted)
{
	return MakeDolphinString(IsA(node, Value) ? strVal(node) : NULL, node, is_quoted);
}


static List* GetNameListFromDolphinString(List* dolphinStringList)
{
	List* result = NIL;
	ListCell* cell = NULL;
	foreach (cell, dolphinStringList) {
		DolphinString* element = (DolphinString*)lfirst(cell);
		element->str = downcase_str(element->str, element->is_quoted);
		result = lappend(result, element->node);
	}
	return result;
}

/*
 * Check numbers of elements in a_expr from WITH ROLLUP clause, which is declared in group_by_list.
 * If the input expr is valid, directly return. Otherwise raise ERROR.
 */
static void with_rollup_check_elems_count(Node* expr)
{
	/* check if expr has multiple column with parenthesis */
	if (!IsA(expr, ColumnRef)) {
		if (IsA(expr, RowExpr)) {
			if (((RowExpr *)expr)->args->length > 1) {
				ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("Operand should contain 1 column(s) fro WITH ROLLUP")));
			}
		} else {
			/* Should not be here */
			ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("Unexpected syntax error for WITH ROLLUP.")));
		}
	}
}

static inline char* GetDolphinObjName(char* string, bool is_quoted)
{
	return (GetSessionContext()->lower_case_table_names == 0) ? string : downcase_str(string, is_quoted);
}

static inline char* GetDolphinSchemaName(char* string, bool is_quoted)
{
	/* public is a special schema, if it's not quoted, public is lowercase  */
	for (const char* sys_schema : sys_schemas) {
		if (DolphinObjNameCmp(string, sys_schema, false)) {
			return downcase_str(string, is_quoted);
		}
	}
	return GetDolphinObjName(string, is_quoted);
}

static void CheckIconstType(Node* node) 
{
	// Check whether the input parameter is of type Iconst. If not, report an error.
	if (!IsA(node, A_Const) || ((A_Const*)node)->val.type != T_Integer) {
		ereport(ERROR,
			(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
			errmsg("Un-support feature"),
			errdetail("The parameter type should be an integer constant")));
	}
}

/**
 * select grant_sql from funcCall('arg')
 * @param funcCall function name
 * @param args args of function
 * @param yyscanner used for makeColumnRef
 * @return return select stmt which fromClause is a function call
 */
static SelectStmt *MakeFunctionSelect(char *funcCall, List *args, core_yyscan_t yyscanner)
{
    SelectStmt *objectSelect = makeNode(SelectStmt);

    FuncCall *objectFunc = makeNode(FuncCall);
    objectFunc->funcname = list_make1(makeString(funcCall));
    objectFunc->args = args;
    objectFunc->agg_distinct = FALSE;
    objectFunc->func_variadic = FALSE;
    objectFunc->over = NULL;
    objectFunc->call_func = false;

    RangeFunction *rangeFunc = makeNode(RangeFunction);
    rangeFunc->funccallnode = (Node *)objectFunc;

    objectSelect->fromClause = list_make1(rangeFunc);
    ResTarget *resTarget = makeNode(ResTarget);
    resTarget->val = makeColumnRef("grant_sql", NIL, 0, yyscanner);
    resTarget->name = "Grants";
    objectSelect->targetList = list_make1(resTarget);
    return objectSelect;
}

/**
 * select grant_sql from show_object_grants('arg') union select grant_sql('arg') union select grant_sql from
 * show_any_privileges('arg');
 * @param arg args(user_name) of functionCalL
 * @param location arg location
 * @param yyscanner used for MakeFunctionSelect
 * @return select stmt
 */
static SelectStmt *MakeShowGrantStmt(char *arg, int location, core_yyscan_t yyscanner)
{
    List *args = list_make1(makeStringConst(arg, location));
    SelectStmt *selectStmt = makeNode(SelectStmt);
    SelectStmt *subSelect = makeNode(SelectStmt);
    subSelect->larg = MakeFunctionSelect("show_object_grants", args, yyscanner);
    subSelect->rarg = MakeFunctionSelect("show_role_privilege", args, yyscanner);
    subSelect->op = SETOP_UNION;
    selectStmt->larg = subSelect;
    selectStmt->rarg = MakeFunctionSelect("show_any_privileges", args, yyscanner);
    selectStmt->op = SETOP_UNION;
    return selectStmt;
}

static unsigned char GetLowerCaseChar(unsigned char ch, bool enc_is_single_byte)
{
	unsigned char result = ch;
	if (result >= 'A' && result <= 'Z') {
		result += 'a' - 'A';
	} else if (enc_is_single_byte && IS_HIGHBIT_SET(result) && isupper(result)) {
		result = tolower(result);
	}
	return result;
}

static bool DolphinObjNameCmp(const char* s1, const char* s2, bool is_quoted)
{
	if (strlen(s1) != strlen(s2)) {
		return false;
	}
	if (is_quoted) {
		return strcmp(s1, s2) == 0;
	}
	int i;
	bool enc_is_single_byte = (pg_database_encoding_max_length() == 1);
	int len = strlen(s1);
	for (i = 0; i < len; i++) {
		unsigned char ch1 = GetLowerCaseChar((unsigned char)s1[i], enc_is_single_byte);
		unsigned char ch2 = GetLowerCaseChar((unsigned char)s2[i], enc_is_single_byte);
		if (ch1 != ch2) {
			return false;
		}
	}
	return true;
}

static char* SingleLineProcedureQueryGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra)
{
	char* delimiter_str = u_sess->attr.attr_common.delimiter_name;
	StringInfoData select_query;
	initStringInfo(&select_query);
	appendStringInfo(&select_query, "\n");
	appendBinaryStringInfo(&select_query, yyextra->core_yy_extra.scanbuf + start_pos - 1, end_pos - start_pos + 1);
	if (delimiter_str == NULL)
		appendStringInfo(&select_query, ";");
	else
		appendStringInfoString(&select_query, delimiter_str);
	appendStringInfo(&select_query, "\n");

	return select_query.data;
}

DolphinIdent* CreateDolphinIdent(char* ident, bool is_quoted)
{
    DolphinIdent* dolphinIdent = (DolphinIdent*)palloc(sizeof(DolphinIdent));
    dolphinIdent->str = ident;
    dolphinIdent->is_quoted = is_quoted;
    return dolphinIdent;
}

DolphinProcBodyInfo* InitDolphinProcBodyInfo()
{
	DolphinProcBodyInfo* binfo = (DolphinProcBodyInfo*)palloc(sizeof(DolphinProcBodyInfo));
	binfo->m_begin_b = binfo->m_begin_e = binfo->m_declare_len = binfo->m_block_level = 0;
	binfo->m_begin_len = binfo->m_declare_b = binfo->m_declare_e = 0;
	return binfo;
}

void DolphinDealProcBodyStr(char* target, char* scanbuf, List* infol, int begin, int len)
{
	ListCell* lc;
	DolphinProcBodyInfo* preinfo = NULL;
	DolphinProcBodyInfo* info = NULL;
	int offset = 0;
	int rc;
	foreach (lc, infol) {
		preinfo = info;
		info = (DolphinProcBodyInfo*)lfirst(lc);
		if (info->m_block_level == 1) {
			rc = strncpy_s(target, len, scanbuf + begin - 1, info->m_declare_len + 1);
			securec_check(rc, "", "");
			offset += info->m_declare_len + 1;
			rc = strncpy_s(target + offset, len - offset, " begin ", 7);
			securec_check(rc, "", "");
			offset += 7;
		}
		if (preinfo != NULL)
		{
			rc = strncpy_s(target + offset, len - offset, scanbuf + preinfo->m_declare_e + 1,
				info->m_begin_b - preinfo->m_declare_e - 1);
			securec_check(rc, "", "");
			offset += info->m_begin_b - preinfo->m_declare_e - 1;
			if (info->m_declare_len != 0) {
				rc = strncpy_s(target + offset, len - offset, scanbuf + info->m_declare_b,
					info->m_declare_len + 1);
				securec_check(rc, "", "");
				offset += info->m_declare_len + 1;
			}
			if (info->m_begin_len > 2)
			{
				rc = strncpy_s(target + offset, len - offset, scanbuf + info->m_begin_b ,
                                info->m_begin_len - 2);
				securec_check(rc, "", "");
				offset += info->m_begin_len - 2;
			}
		}
	}
	/*
	 * If the last begin-end stmt contains no DECLARE clause, info->m_declare_e will locate at the next token after BEGIN.
	 * If the last begin-end stmt contains DECLAURE clause, info->m_declare_e will be at ";" at the end of DECLARE clause,
	 * which means in this case, we need to copy the rest of scanbuf with cursor starting at info->mdeclare_e + 1 to ensure
	 * the cursor will be at the next token after DECLARE clause.
	 */
	if (info->m_declare_len == 0) {
		rc = strncpy_s(target + offset, len - offset, scanbuf + info->m_declare_e, len - offset - 2);
	} else {
		rc = strncpy_s(target + offset, len - offset, scanbuf + info->m_declare_e + 1, len - offset - 1);
	}
	securec_check(rc, "", "");
}

static char* TriggerBodyGet(int& start_pos, int& end_pos, base_yy_extra_type* yyextra)
{
	StringInfoData select_query;
	char* delimiter_str = u_sess->attr.attr_common.delimiter_name;
	initStringInfo(&select_query);
	appendStringInfo(&select_query, "begin");
	appendStringInfo(&select_query, "\n ");
	int copy_len = end_pos - start_pos + 1;
	bool append_delimiter = false;
	if (yyextra->core_yy_extra.scanbuf[end_pos] == '\0')
	{
		append_delimiter = true;
		copy_len--;
	}
	appendBinaryStringInfo(&select_query, yyextra->core_yy_extra.scanbuf + start_pos, copy_len);
	if (strncasecmp(yyextra->core_yy_extra.scanbuf + start_pos, "call ", 5) == 0 || append_delimiter)
	{
		if (delimiter_str == NULL)
			appendStringInfo(&select_query, ";");
		else
			appendStringInfo(&select_query, "%s", delimiter_str);
	}
	appendStringInfo(&select_query, "\n");
	appendStringInfo(&select_query, "end");

	return select_query.data;
}

static SingleTableOption* CreateSingleTableOption(TableOptionType tableOptionType)
{
    SingleTableOption *n = (SingleTableOption*)palloc0(sizeof(SingleTableOption));
    n->option_type = tableOptionType;
    return n;
}

static void setAccessMethod(Constraint *n)
{
	char* method = transformIndexOptions(n->constraintOptions);
	if (method != NULL) {
		/* check current index access method name is exist? If not, return error */
		if (n->access_method == NULL) {
			n->access_method = method;
		} else {
			get_am_oid(n->access_method, false);
			n->access_method = method;
		}
	}
}

static CharsetCollateOptions* MakeCharsetCollateOptions(CharsetCollateOptions *options, CharsetCollateOptions *option)
{
	if (options == NULL) {
		options = makeNode(CharsetCollateOptions);
		options->cctype = OPT_CHARSETCOLLATE;
		options->charset = PG_INVALID_ENCODING;
		options->collate = NULL;
	}
	switch (option->cctype) {
		case OPT_CHARSET:
			options->charset = option->charset;
			break;
		case OPT_COLLATE:
			options->collate = option->collate;
			break;
		default:
			break;
	}
	return options;
}

static char* GetValidUserHostId(char* userName, char* hostId)
{
	CheckUserHostIsValid();
	if (strchr(userName,'@'))
		ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("@ can't be allowed in username")));
	char* userHostId = NULL;
	if (*hostId == '\'' || *hostId == '`') {
		userHostId = hostId + 1;
		hostId[strlen(hostId)-1] = '\0';
	} else {
		userHostId = hostId;
	}
	if (strcasecmp("localhost", userHostId) != 0)
		CheckHostId(userHostId);
	StringInfoData buf;
	initStringInfo(&buf);
	appendStringInfoString(&buf, userName);
	appendStringInfoString(&buf, "@");
	appendStringInfoString(&buf, userHostId);
	if (strlen(buf.data) >= NAMEDATALEN) {
		ereport(ERROR,(errcode(ERRCODE_INVALID_NAME),errmsg("String %s is too long for user name (should be no longer than 64)", buf.data)));
	}
	return buf.data;
}

static void CheckHostId(char* hostId)
{
	char* tmp = hostId;
	for (; *tmp != '\0'; tmp++) {
		if (((*tmp < '0') || (*tmp > '9')) && (*tmp != '%') && (*tmp != '.'))
			ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("The hostname %s is not supported, it only support IP.", hostId)));
	}
}

static void CheckUserHostIsValid()
{
	if (u_sess->attr.attr_sql.sql_compatibility == B_FORMAT && u_sess->attr.attr_common.b_compatibility_user_host_auth)
		return;
	ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg("user@host is only supported in b database when the b_compatibility_user_host_auth is on")));
}

static Node *checkNullNode(Node *n)
{
	A_Const *c = (A_Const *)n;
	A_Const *r = makeNode(A_Const);
	if (c->val.val.str == NULL || strlen(c->val.val.str) == 0)
	{
		r->val.type = T_Null;
		r->val.val.str = c->val.val.str;
		r->location = c->location;
		return (Node *)r;
	}
	return n;
}

/* return a function option list that is filtered. */
static List* handleCreateDolphinFuncOptions(List* input_options)
{
	ListCell *cell = NULL;
	DefElem* comment_option = NULL;
	DefElem* determination_option = NULL;
	DefElem* sql_opt_option = NULL;
	DefElem* security_option = NULL;
	foreach (cell, input_options) {
		void* pointer = lfirst(cell);
		if (!IsA(pointer, DefElem)) {
			/* should never happen */
			ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				errmsg("Type error for function options. Please ensure function option is type DefElem.")));
		}
		DefElem* defel = (DefElem*)lfirst(cell);
		if (strcmp(defel->defname, "as") == 0) {
			/* we don't allow as option. just prevent duplicate here . we will add this option later.*/
			ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("invalid function options \"AS\" provided.")));
		} else if (strcmp(defel->defname, "language") == 0) {
			/* ignore language option. we will set it in caller */
		} else if (strcmp(defel->defname, "comment") == 0) {
			comment_option = defel;
		} else if (strcmp(defel->defname, "deterministic") == 0) {
			determination_option = defel;
		} else if (strcmp(defel->defname, "sql_opt") == 0) {
			sql_opt_option = defel;
		} else if (strcmp(defel->defname, "security") == 0) {
			security_option = defel;
                } else {
                	ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg("invalid option input")));
                }
	}
	List* result_options = NIL;
	if (comment_option != NULL) {
		result_options = lappend(result_options, comment_option);
	}
	if (determination_option != NULL) {
		result_options = lappend(result_options, determination_option);
	}
	if (sql_opt_option != NULL) {
		result_options = lappend(result_options, sql_opt_option);
	}
	if (security_option != NULL) {
		result_options = lappend(result_options, security_option);
	}
	return result_options;
}

/* append source string to target string with offset */
static char* appendString(char* source, char* target, int offset)
{
	int source_len = strlen(source);
	int target_len = strlen(target);
	errno_t rc = 0;
	Assert(offset <= target_len);
	StringInfoData result_info;
	initStringInfo(&result_info);
	appendBinaryStringInfo(&result_info, target, offset);
	appendStringInfo(&result_info, "%s%s", source, target + offset);
	return result_info.data;
}

static inline void ChangeBpcharCastType(TypeName* typname)
{
	if (!ENABLE_B_CMPT_MODE) {
		return;
	}

	if (lnext(list_head(typname->names)) != NULL &&
		strcmp(((Value*)lsecond(typname->names))->val.str, "bpchar") == 0) {
		((Value*)lsecond(typname->names))->val.str = "varchar";
	}
}

static inline SortByNulls GetNullOrderRule(SortByDir sortBy, SortByNulls nullRule)
{
	if (!ENABLE_B_CMPT_MODE) {
		return nullRule;
	}
	if (sortBy == SORTBY_DESC && nullRule == SORTBY_NULLS_DEFAULT) {
		return SORTBY_NULLS_LAST;
	} else if ((sortBy == SORTBY_ASC || sortBy == SORTBY_DEFAULT) && nullRule == SORTBY_NULLS_DEFAULT) {
		return SORTBY_NULLS_FIRST;
	}
	return nullRule;
}


/*
 * Must undefine this stuff before including scan.c, since it has different
 * definitions for these macros.
 */
#undef yyerror
#undef yylval
#undef yylloc
#undef yylex

#undef yylex
#include "scan.inc"

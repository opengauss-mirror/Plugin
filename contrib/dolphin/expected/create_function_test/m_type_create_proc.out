create schema m_create_proc_type;
set current_schema to 'm_create_proc_type';
DROP ROLE if EXISTS us2;
NOTICE:  role "us2" does not exist, skipping
CREATE ROLE us2 IDENTIFIED BY 'Aa@123456';
NOTICE:  The iteration value of password is not recommended.Setting the iteration value too small reduces the security of the password, and setting it too large results in performance degradation.
GRANT ALL ON SCHEMA m_create_proc_type TO us2;
SET ROLE us2 PASSWORD 'Aa@123456';
set dolphin.sql_mode = 'sql_mode_strict,pipes_as_concat,ansi_quotes,no_zero_date,error_for_division_by_zero';
--test create procedure 
delimiter //
CREATE PROCEDURE p()
  BEGIN
  DECLARE v INT DEFAULT 1;
  CASE v
  WHEN 2 THEN SELECT v;
  WHEN 3 THEN SELECT 0;
  ELSE
  BEGIN
  END;
  END CASE;
END;
//
DROP PROCEDURE IF EXISTS p//
CREATE PROCEDURE p()
  BEGIN
  END;
//
CREATE PROCEDURE proc1 ()
       BEGIN
         SELECT 1;
       END;
//
delimiter ;
-- test proc call
create table item(c1 int, c2 int);
create procedure procedure_1(a int, b int)
as
begin
   insert into item values(a, b);
end;
/
call procedure_1(1,2);
 procedure_1 
-------------
 
(1 row)

delimiter //
CREATE PROCEDURE procedure_1_m (c1 int, c2 int)
       BEGIN
         insert into item values(c1, c2);
       END;
//
delimiter ;
call procedure_1_m(6,9);
 procedure_1_m 
---------------
 
(1 row)

select * from item;
 c1 | c2 
----+----
  1 |  2
  6 |  9
(2 rows)

select procedure_1_m(6,9);
 procedure_1_m 
---------------
 
(1 row)

select * from procedure_1_m(6,9);
 procedure_1_m 
---------------
 
(1 row)

select * from item;
 c1 | c2 
----+----
  1 |  2
  6 |  9
  6 |  9
  6 |  9
(4 rows)

-- test declare
create table test (a int);
CREATE PROCEDURE testpro(a int) as
declare
b int;
begin
b  := 5;
insert into test values (a + b);
end;
/
call testpro (2);
 testpro 
---------
 
(1 row)

--error
delimiter //
CREATE PROCEDURE testpro_m() 
declare
b int;
begin
b  := 5;
insert into test values (a + b);
end;
//
ERROR:  syntax error at or near "declare
b int"
LINE 2: declare
        ^
delimiter ;
--success
delimiter //
CREATE PROCEDURE testpro_m(a int)
begin
declare 
b int;
b  := 5;
insert into test values (a + b);
end;
//
delimiter ;
call testpro_m (5);
 testpro_m 
-----------
 
(1 row)

select * from test;
 a  
----
  7
 10
(2 rows)

--testmulti declare
 delimiter //
 DROP PROCEDURE IF EXISTS testpro_m6//
NOTICE:  function testpro_m6() does not exist, skipping
 CREATE PROCEDURE testpro_m6(a int)
 begin
 declare b int;
 declare c int;
 b:= 9;
 insert into test values (a + b);
    begin 
    declare d int;
    insert into test values (a + b);
    end;
 end;
 //
DROP PROCEDURE IF EXISTS testpro_m6//
CREATE PROCEDURE testpro_m6(a int)
    begin
        declare b int;
        declare c int;
        b:= 9;
        insert into test values (a + b);
        begin
            insert into test values (a + b);
        end;
end//
 delimiter ;
show create procedure testpro_m6;
 Procedure  |                          Create Procedure                           |                                      sql_mode                                       | character_set_client | collation_connection | Database Collation 
------------+---------------------------------------------------------------------+-------------------------------------------------------------------------------------+----------------------+----------------------+--------------------
 testpro_m6 | CREATE DEFINER = us2 PROCEDURE m_create_proc_type.testpro_m6(a int)+| sql_mode_strict,pipes_as_concat,ansi_quotes,no_zero_date,error_for_division_by_zero | UTF8                 | en_US.UTF-8          | en_US.UTF-8
            |     BEGIN      declare b int;                                      +|                                                                                     |                      |                      | 
            |         declare c int;                                             +|                                                                                     |                      |                      | 
            |         b:= 9;                                                     +|                                                                                     |                      |                      | 
            |         insert into test values (a + b);                           +|                                                                                     |                      |                      | 
            |         begin                                                      +|                                                                                     |                      |                      | 
            |             insert into test values (a + b);                       +|                                                                                     |                      |                      | 
            |         end;                                                       +|                                                                                     |                      |                      | 
            | end;                                                               +|                                                                                     |                      |                      | 
            |                                                                     |                                                                                     |                      |                      | 
(1 row)

 delimiter //
 CREATE PROCEDURE testpro_m7(a int)
 begin
 declare b int;
 declare c int;
 b := 9;
 insert into test values (a + b);
    begin 
    declare d int;
    insert into test values (a + b);
          begin
         declare e int;
         insert into test values (a + b);
         end;
         end;
 end;
 //
delimiter ;
call testpro_m6(10);
 testpro_m6 
------------
 
(1 row)

call testpro_m7(11);
 testpro_m7 
------------
 
(1 row)

select * from test;
 a  
----
  7
 10
 19
 19
 20
 20
 20
(7 rows)

-- test options 
delimiter //
CREATE PROCEDURE procedure_1_m_o (c1 int, c2 int) LANGUAGE SQL
       BEGIN
         insert into item values(88,88);
       END;
//
delimiter ;
delimiter //
CREATE PROCEDURE procedure_2_m_o() NO SQL READS SQL DATA LANGUAGE SQL
       BEGIN
         insert into item values(99, 99);
       END;
//
delimiter ;
-- issue fix 
-- test while
drop table if exists test9;
NOTICE:  table "test9" does not exist, skipping
create table test9(
id int(11) unsigned not null auto_increment,
sname varchar(255) not null,
  primary key (id)
)engine=innodb default charset=utf8;
NOTICE:  CREATE TABLE will create implicit sequence "test9_id_seq" for serial column "test9.id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test9_pkey" for table "test9"
drop procedure if exists test_proc;
NOTICE:  function test_proc() does not exist, skipping
delimiter //
create procedure test_proc()
begin
    declare i int;
	i := 1;
    while i<=10 do
        insert into test9 values(null,rand()*10);
        i := i+1;
    end while;
end;
//
delimiter ;
call test_proc();
 test_proc 
-----------
 
(1 row)

--test loop,if
delimiter //
create or replace procedure doiterate(p1 int)
begin
LABEL1:loop
p1 := p1+1;
if p1 < 10 then
raise notice '123';
end if;
exit LABEL1;
end loop LABEL1;
end;
//
delimiter ;
call doiterate(2);
NOTICE:  123
 doiterate 
-----------
 
(1 row)

--test repeat
delimiter //
CREATE or replace PROCEDURE dorepeat(p1 INT)
BEGIN
declare
i int = 0;
<<label>>
repeat
i = i + 1;
until i >p1 end repeat label;
raise notice '%',i;
end;
//
delimiter ;
select dorepeat(5);
NOTICE:  6
CONTEXT:  referenced column: dorepeat
 dorepeat 
----------
 
(1 row)

-- test  case
delimiter //
CREATE or replace PROCEDURE docase(p1 INT)
BEGIN
declare
i int = p1;
<<label>>
case 
when i > 10 then raise notice '%','big';
when i < 1 then raise notice '%','small';
else  raise notice '%','good';
end case;
end;
//
delimiter ;
select docase(4);
NOTICE:  good
CONTEXT:  referenced column: docase
 docase 
--------
 
(1 row)

select docase(0);
NOTICE:  small
CONTEXT:  referenced column: docase
 docase 
--------
 
(1 row)

select docase(100);
NOTICE:  big
CONTEXT:  referenced column: docase
 docase 
--------
 
(1 row)

--test empty 
drop procedure  if exists doempty;
NOTICE:  function doempty() does not exist, skipping
delimiter //
CREATE or replace PROCEDURE doempty()
BEGIN
end;
//
delimiter ;
call doempty();
 doempty 
---------
 
(1 row)

-- test declare continue handler
set enable_set_variable_b_format = on;
delimiter //
CREATE or replace PROCEDURE proc_set_test(a int, b int)
begin
declare result int;
DECLARE CONTINUE HANDLER FOR SQLEXCEPTION set @sum = 1;
set @x1 = 1;
result := a/b;
set @x1 = 2;
end;
//
delimiter ;
set @sum = 0;
set @x1 = 0;
call proc_set_test(1,0);
 proc_set_test 
---------------
 
(1 row)

select @sum;
 @sum 
------
    1
(1 row)

select @x1;
 @x1 
-----
   2
(1 row)

delimiter //
CREATE or replace PROCEDURE proc_set_test(a int, b int)
begin
declare result int;
declare DIVISION_ZERO condition for SQLSTATE "22012";
DECLARE CONTINUE HANDLER FOR DIVISION_ZERO set @sum = 1;
set @x1 = 1;
result := a/b;
set @x1 = 2;
end;
//
delimiter ;
set @sum = 0;
set @x1 = 0;
call proc_set_test(1,0);
 proc_set_test 
---------------
 
(1 row)

select @sum;
 @sum 
------
    1
(1 row)

select @x1;
 @x1 
-----
   2
(1 row)

create table company(name varchar(100), loc varchar(100), no integer PRIMARY KEY);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "company_pkey" for table "company"
insert into company values ('macrosoft',    'usa',          001);
insert into company values ('oracle',       'usa',          002);
insert into company values ('backberry',    'canada',       003);
delimiter //
create or replace procedure test_cursor_handler() 
begin
  declare company_name    varchar(100);
  declare company_loc varchar(100);
  declare company_no  integer;
  DECLARE CONTINUE HANDLER FOR unique_violation set @x = 1;
  declare c1_all cursor is --cursor without args 
      select name, loc, no from company order by 1, 2, 3;
  if not c1_all%isopen then
      open c1_all;
  end if;
  loop
      fetch c1_all into company_name, company_loc, company_no;
      exit when c1_all%notfound;
      insert into company values (company_name,company_loc,company_no);
      raise notice '% : % : %',company_name,company_loc,company_no;
  end loop;
  if c1_all%isopen then
      close c1_all;
  end if;
end;
//
delimiter ;
set @x=0;
call test_cursor_handler();
NOTICE:  backberry : canada : 3
NOTICE:  macrosoft : usa : 1
NOTICE:  oracle : usa : 2
 test_cursor_handler 
---------------------
 
(1 row)

select @x;
 @x 
----
  1
(1 row)

create table declare_handler_t_continue (i INT PRIMARY KEY, j INT);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "declare_handler_t_continue_pkey" for table "declare_handler_t_continue"
CREATE OR REPLACE PROCEDURE proc_continue_sqlexception()  IS
BEGIN
    DECLARE CONTINUE HANDLER FOR unique_violation set @x1 = 1;
    DECLARE CONTINUE HANDLER FOR not found set @x2 = 2;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION set @x3 = 3;

    create table t_rowcompress_pglz_compresslevel(id int) with (compresstype=1,compress_level=2);
    INSERT INTO declare_handler_t_continue VALUES (1, 1);
    INSERT INTO declare_handler_t_continue VALUES (1, 1);
    INSERT INTO declare_handler_t_continue VALUES (3, 1);
    set @x4 = 4;
END;
/
set @x1=0;
set @x2=0;
set @x3=0;
set @x4=0;
call proc_continue_sqlexception();
WARNING:  The compressed relation you are using is an unofficial supported extended feature.
CONTEXT:  SQL statement "create table t_rowcompress_pglz_compresslevel(id int) with (compresstype=1,compress_level=2)"
PL/pgSQL function proc_continue_sqlexception() line 6 at SQL statement
 proc_continue_sqlexception 
----------------------------
 
(1 row)

select * from declare_handler_t_continue;
 i | j 
---+---
 1 | 1
 3 | 1
(2 rows)

select @x1;
 @x1 
-----
   1
(1 row)

select @x2;
 @x2 
-----
   2
(1 row)

select @x3;
 @x3 
-----
   0
(1 row)

select @x4;
 @x4 
-----
   4
(1 row)

drop schema m_create_proc_type cascade;
NOTICE:  drop cascades to 23 other objects
DETAIL:  drop cascades to function p()
drop cascades to function proc1()
drop cascades to table item
drop cascades to function procedure_1(integer,integer)
drop cascades to function procedure_1_m(integer,integer)
drop cascades to table test
drop cascades to function testpro(integer)
drop cascades to function testpro_m(integer)
drop cascades to function testpro_m6(integer)
drop cascades to function testpro_m7(integer)
drop cascades to function procedure_1_m_o(integer,integer)
drop cascades to function procedure_2_m_o()
drop cascades to table test9
drop cascades to function test_proc()
drop cascades to function doiterate(integer)
drop cascades to function dorepeat(integer)
drop cascades to function docase(integer)
drop cascades to function doempty()
drop cascades to function proc_set_test(integer,integer)
drop cascades to table company
drop cascades to function test_cursor_handler()
drop cascades to table declare_handler_t_continue
drop cascades to function proc_continue_sqlexception()
reset current_schema;
reset role;
drop role us2;

create schema db_b_plpgsql_test;
set current_schema to 'db_b_plpgsql_test';
create table tb_b_grammar_0038(a text(10)) engine = 表1;
create or replace procedure proc_01()
as
begin
insert tb_b_grammar_0038 values('tom') ;
end;
/
create or replace procedure PEOC_165()
as
begin
CREATE TABLE t1 (a binary) engine INNODB;
end;
/
CREATE TABLE J1_TBL (
i integer,
j integer,
t text
);
CREATE TABLE J2_TBL (
i integer,
k integer
);
INSERT INTO J1_TBL VALUES (1, 4, 'one');
INSERT INTO J1_TBL VALUES (2, 3, 'two');
INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
INSERT INTO J2_TBL VALUES (1, -1);
INSERT INTO J2_TBL VALUES (NULL, 0);
create or replace procedure PEOC_165()
as
begin
SELECT '' AS "xxx", * FROM J1_TBL JOIN J2_TBL;
end;
/
SELECT * from proc_01();
 proc_01 
---------
 
(1 row)

SELECT * from tb_b_grammar_0038;
  a  
-----
 tom
(1 row)

-- test "set"
create procedure proc1(x int) as
v int;
begin
set x=x+1;
set v=x+1;
raise notice '%',v;
end;
/
call proc1(1);
NOTICE:  3
 proc1 
-------
 
(1 row)

call proc1(2);
NOTICE:  4
 proc1 
-------
 
(1 row)

drop procedure proc1;
declare
i int;
begin
set j=1;
raise notice '%',j;
end;
/
ERROR:  unrecognized configuration parameter "j"
CONTEXT:  SQL statement "set j=1"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
i int;
begin
set j=1;
raise notice '%',j;
end;
/
ERROR:  unrecognized configuration parameter "j"
CONTEXT:  SQL statement "set j=1"
PL/pgSQL function inline_code_block line 3 at SQL statement
begin
set enable_set_variable_b_format = on;
end;
/
show enable_set_variable_b_format;
 enable_set_variable_b_format 
------------------------------
 on
(1 row)

begin
set @i=0;
end;
/
select @i;
 @i 
----
  0
(1 row)

set dolphin.b_compatibility_mode to on;
create table t1(c1 varchar(20));
DO $$ 
DECLARE
   hs_sql text;
BEGIN
   
   SELECT 'ALTER TABLE t1 MODIFY COLUMN c1 varchar(40) DEFAULT ''b'' NOT NULL;'
    INTO hs_sql
   FROM dual
   WHERE (
     SELECT COUNT(1)
     FROM information_schema.columns
     WHERE 
      table_name = 't1'
     AND column_name = 'c1'
	 AND DATA_TYPE = 'character varying'
     AND replace(COLUMN_DEFAULT,'::character varying','') = 'b'
     AND character_maximum_length=40
     AND IS_NULLABLE='NO'
    ) = 0;
    
   if hs_sql is not null then 
     RAISE NOTICE '执行SQL：%', hs_sql;
     EXECUTE hs_sql;
   end if; 
END $$;
NOTICE:  执行SQL：ALTER TABLE t1 MODIFY COLUMN c1 varchar(40) DEFAULT 'b' NOT NULL;
drop table t1;
reset enable_set_variable_b_format;
drop table if exists t_abort_050;
NOTICE:  table "t_abort_050" does not exist, skipping
create table t_abort_050(a int);
create or replace function fun_abort_050
return  int
as
begin
    insert into t_abort_050 values (100);
    commit;
    return 1;
end;
/
create or replace procedure proc_abort_050_01
as
begin
    insert into t_abort_050 values (200);
    commit;
    fun_abort_050();
end;
/
create or replace procedure proc_abort_050_02
as
begin
    insert into t_abort_050 values (300);
    abort;
    proc_abort_050_01();
end;
/
call proc_abort_050_02();
ERROR:  only support commit/rollback transaction statements.
HINT:  Use a BEGIN block with an EXCEPTION clause instead of begin/end transaction.
CONTEXT:  PL/pgSQL function proc_abort_050_02() line 3 at SQL statement
delimiter //
create or replace procedure test_set(out res int)
begin
declare a int;
declare b int;
declare c int;
set a=1, b=2, c=3;
set res=a+b+c;
end;
//
delimiter ;
call test_set(@res);
 res 
-----
   6
(1 row)

drop procedure test_set;
drop schema db_b_plpgsql_test cascade;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table tb_b_grammar_0038
drop cascades to function proc_01()
drop cascades to table j1_tbl
drop cascades to table j2_tbl
drop cascades to function peoc_165()
drop cascades to table t_abort_050
drop cascades to function fun_abort_050()
drop cascades to function proc_abort_050_01()
drop cascades to function proc_abort_050_02()
reset current_schema;

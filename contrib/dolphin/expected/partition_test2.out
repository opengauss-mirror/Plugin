create schema partition_test2;
set current_schema to 'partition_test2';
set dolphin.b_compatibility_mode to off;
CREATE TABLE IF NOT EXISTS test_part1
(
a int,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (300)
);
CREATE TABLE IF NOT EXISTS test_subpart
(
a int,
b int
) 
PARTITION BY RANGE(a) SUBPARTITION BY RANGE(b)
(
		PARTITION p0 VALUES LESS THAN (100)
		(
			SUBPARTITION p0_0 VALUES LESS THAN (1000),
			SUBPARTITION p0_1 VALUES LESS THAN (2000),
			SUBPARTITION p0_2 VALUES LESS THAN (10000)
		),
		PARTITION p1 VALUES LESS THAN (200)
		(
			SUBPARTITION p1_0 VALUES LESS THAN (1000),
			SUBPARTITION p1_1 VALUES LESS THAN (2000),
			SUBPARTITION p1_2 VALUES LESS THAN (10000)
		),
		PARTITION p2 VALUES LESS THAN (300)
		(
			SUBPARTITION p2_0 VALUES LESS THAN (1000),
			SUBPARTITION p2_1 VALUES LESS THAN (2000),
			SUBPARTITION p2_2 VALUES LESS THAN (10000)
		)
);
--alter partition table
drop table if exists tab1;
NOTICE:  table "tab1" does not exist, skipping
create table tab1 (a datetime ,b varchar(100))
partition by range (to_days(a))
(partition p1 values less than (to_days('20240330')),
partition p2 values less than (to_days('20240930'))
);
--插入数据
insert into tab1 values('20240130','one');
insert into tab1 values('20240330','one');
insert into tab1 values('20240412','two');
insert into tab1 values('20240430','two');--这个值，在分裂分区的时候作为了键值
insert into tab1 values('20240512','two');
insert into tab1 values('20240630','three');
--切割分区，指定切割点
alter table tab1 split partition p2 at (to_days('20240430')) into (partition p3 ,partition pdefault);
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from tab1 partition (p1);
          a          |  b  
---------------------+-----
 2024-01-30 00:00:00 | one
(1 row)

select * from tab1 partition (p3);
          a          |  b  
---------------------+-----
 2024-03-30 00:00:00 | one
 2024-04-12 00:00:00 | two
(2 rows)

select * from tab1 partition (pdefault);
          a          |   b   
---------------------+-------
 2024-04-30 00:00:00 | two
 2024-05-12 00:00:00 | two
 2024-06-30 00:00:00 | three
(3 rows)

drop table if exists tab1;
create table tab1 (a datetime ,b varchar(100))
partition by range (to_days(a))
(partition p1 values less than (to_days('20240330')),
partition p2 values less than (to_days('20240930'))
);
--插入数据
insert into tab1 values('20240130','one');
insert into tab1 values('20240330','one');
insert into tab1 values('20240412','two');
insert into tab1 values('20240430','two');--这个值，在分裂分区的时候作为了键值
insert into tab1 values('20240512','two');
insert into tab1 values('20240630','three');
--切割分区，不指定切割点
alter table tab1 split partition p2 into (
    partition p3 values less than (to_days('20240430')),
     partition pdefault values less than (to_days('20240930'))
);
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from tab1 partition (p1);
          a          |  b  
---------------------+-----
 2024-01-30 00:00:00 | one
(1 row)

select * from tab1 partition (p3);
          a          |  b  
---------------------+-----
 2024-03-30 00:00:00 | one
 2024-04-12 00:00:00 | two
(2 rows)

select * from tab1 partition (pdefault);
          a          |   b   
---------------------+-------
 2024-04-30 00:00:00 | two
 2024-05-12 00:00:00 | two
 2024-06-30 00:00:00 | three
(3 rows)

drop table if exists tab1;
drop table if exists abs_tab;
NOTICE:  table "abs_tab" does not exist, skipping
CREATE TABLE abs_tab
( prod_id NUMBER(6)
    , cust_id NUMBER
    , time_id double precision
    , channel_id CHAR(1)
    , promo_id NUMBER(6)
    , quantity_sold NUMBER(3)
    , amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (abs(time_id))
( PARTITION p0 VALUES LESS THAN (abs('-5')),
  PARTITION p1 VALUES LESS THAN (abs('-20'))
);
insert into abs_tab values(1, 1, '1', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-2', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-3', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '4', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-9', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '11', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-19', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-18', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '-15', 'a', 1, 1, 1);
insert into abs_tab values(1, 1, '5', 'a', 1, 1, 1);
alter table abs_tab split partition p1 at (abs('-10')) into (partition p1_1, partition p1_2);
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from abs_tab partition (p0);
 prod_id | cust_id | time_id | channel_id | promo_id | quantity_sold | amount_sold 
---------+---------+---------+------------+----------+---------------+-------------
       1 |       1 |       1 | a          |        1 |             1 |        1.00
       1 |       1 |      -2 | a          |        1 |             1 |        1.00
       1 |       1 |      -3 | a          |        1 |             1 |        1.00
       1 |       1 |       4 | a          |        1 |             1 |        1.00
(4 rows)

select * from abs_tab partition (p1_1);
 prod_id | cust_id | time_id | channel_id | promo_id | quantity_sold | amount_sold 
---------+---------+---------+------------+----------+---------------+-------------
       1 |       1 |      -9 | a          |        1 |             1 |        1.00
       1 |       1 |       5 | a          |        1 |             1 |        1.00
(2 rows)

select * from abs_tab partition (p1_2);
 prod_id | cust_id | time_id | channel_id | promo_id | quantity_sold | amount_sold 
---------+---------+---------+------------+----------+---------------+-------------
       1 |       1 |      11 | a          |        1 |             1 |        1.00
       1 |       1 |     -19 | a          |        1 |             1 |        1.00
       1 |       1 |     -18 | a          |        1 |             1 |        1.00
       1 |       1 |     -15 | a          |        1 |             1 |        1.00
(4 rows)

drop table abs_tab;
create table test_no_part1(a int, b int);
insert into test_part1 values(99,1),(199,1),(299,1);
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

insert into test_subpart values(99,199),(199,1999),(299,2999);
select * from test_subpart;
  a  |  b   
-----+------
  99 |  199
 199 | 1999
 299 | 2999
(3 rows)

--test b database truncate partition syntax
ALTER TABLE test_part1 truncate PARTITION p0, p1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

insert into test_part1 (with RECURSIVE t_r(i,j) as(values(0,1) union all select i+1,j+2 from t_r where i < 20) select * from t_r);
select * from test_part1;
  a  | b  
-----+----
   0 |  1
   1 |  3
   2 |  5
   3 |  7
   4 |  9
   5 | 11
   6 | 13
   7 | 15
   8 | 17
   9 | 19
  10 | 21
  11 | 23
  12 | 25
  13 | 27
  14 | 29
  15 | 31
  16 | 33
  17 | 35
  18 | 37
  19 | 39
  20 | 41
 299 |  1
(22 rows)

ALTER TABLE test_part1 truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
 a | b 
---+---
(0 rows)

ALTER TABLE test_subpart truncate PARTITION p0, p1, p2_2, p2_1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_subpart;
 a | b 
---+---
(0 rows)

insert into test_subpart (with RECURSIVE t_r(i,j) as(values(0,1) union all select i+1,j+2 from t_r where i < 20) select * from t_r);
select * from test_subpart;
 a  | b  
----+----
  0 |  1
  1 |  3
  2 |  5
  3 |  7
  4 |  9
  5 | 11
  6 | 13
  7 | 15
  8 | 17
  9 | 19
 10 | 21
 11 | 23
 12 | 25
 13 | 27
 14 | 29
 15 | 31
 16 | 33
 17 | 35
 18 | 37
 19 | 39
 20 | 41
(21 rows)

ALTER TABLE test_subpart truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_subpart;
 a | b 
---+---
(0 rows)

--test opengauss truncate partition syntax
insert into test_part1 values(99,1),(199,1);
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

ALTER TABLE test_part1 truncate PARTITION p0, truncate PARTITION p1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
 a | b 
---+---
(0 rows)

insert into test_subpart values(99,1),(199,1);
select * from test_subpart;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

ALTER TABLE test_subpart truncate PARTITION p0, truncate PARTITION p1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_subpart;
 a | b 
---+---
(0 rows)

--test b database exchange partition syntax
insert into test_part1 values(99,1),(199,1),(299,1);
alter table test_part1 exchange partition p2 with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

select * from test_no_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part1 exchange partition p2 with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

select * from test_no_part1;
 a | b 
---+---
(0 rows)

alter table test_part1 exchange partition p2 with table test_no_part1 with validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

select * from test_no_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part1 exchange partition p2 with table test_no_part1 with validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

select * from test_no_part1;
 a | b 
---+---
(0 rows)

--test opengauss exchange partition syntax
alter table test_part1 exchange partition (p2) with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

select * from test_no_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part1 exchange partition (p2) with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

select * from test_no_part1;
 a | b 
---+---
(0 rows)

alter table test_part1 exchange partition (p2) with table test_no_part1 with validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

select * from test_no_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part1 exchange partition (p2) with table test_no_part1 with validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part1;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

select * from test_no_part1;
 a | b 
---+---
(0 rows)

--test b database exchange partition syntax
insert into test_subpart values(99,199),(199,1999),(299,2999);
alter table test_subpart exchange partition p2 with table test_no_part1 without validation;
ERROR:  Un-support feature
DETAIL:  For subpartition table, exchange partition is not yet supported.
--test opengauss exchange partition syntax
alter table test_subpart exchange partition (p2) with table test_no_part1 without validation;
ERROR:  Un-support feature
DETAIL:  For subpartition table, exchange partition is not yet supported.
--test b database analyze partition syntax
alter table test_part1 analyze partition p0,p1;
alter table test_part1 analyze partition all;
alter table test_subpart analyze partition p0,p1;
alter table test_subpart analyze partition all;
alter table test_subpart analyze partition perror;
ERROR:  The partition perror can't be found in table test_subpart
--test opengauss analyze partition syntax
analyze test_part1 partition (p1);
analyze test_subpart partition (p1);
-------test USTORE table
CREATE TABLE IF NOT EXISTS test_part_ustore
(
a int,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (300)
) with(STORAGE_TYPE = USTORE);
create table test_no_part2(a int, b int) with(STORAGE_TYPE = USTORE);
insert into test_part_ustore (with RECURSIVE t_r(i,j) as(values(0,1) union all select i+1,j+2 from t_r where i < 20) select * from t_r);
select * from test_part_ustore;
 a  | b  
----+----
  0 |  1
  1 |  3
  2 |  5
  3 |  7
  4 |  9
  5 | 11
  6 | 13
  7 | 15
  8 | 17
  9 | 19
 10 | 21
 11 | 23
 12 | 25
 13 | 27
 14 | 29
 15 | 31
 16 | 33
 17 | 35
 18 | 37
 19 | 39
 20 | 41
(21 rows)

ALTER TABLE test_part_ustore truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_ustore;
 a | b 
---+---
(0 rows)

insert into test_part_ustore values(99,1),(199,1),(299,1);
alter table test_part_ustore exchange partition p2 with table test_no_part2 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_ustore;
  a  | b 
-----+---
  99 | 1
 199 | 1
(2 rows)

select * from test_no_part2;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part_ustore analyze partition p0,p1;
alter table test_part_ustore analyze partition all;
-------test segment table
CREATE TABLE IF NOT EXISTS test_part_segment
(
a int,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (300)
) with(segment = on);
insert into test_part_segment (with RECURSIVE t_r(i,j) as(values(0,1) union all select i+1,j+2 from t_r where i < 20) select * from t_r);
select * from test_part_segment;
 a  | b  
----+----
  0 |  1
  1 |  3
  2 |  5
  3 |  7
  4 |  9
  5 | 11
  6 | 13
  7 | 15
  8 | 17
  9 | 19
 10 | 21
 11 | 23
 12 | 25
 13 | 27
 14 | 29
 15 | 31
 16 | 33
 17 | 35
 18 | 37
 19 | 39
 20 | 41
(21 rows)

ALTER TABLE test_part_segment truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_segment;
 a | b 
---+---
(0 rows)

insert into test_part_segment values(99,1),(199,1),(299,1);
alter table test_part_segment exchange partition p2 with table test_no_part1 without validation;
ERROR:  ALTER TABLE EXCHANGE requires both ordinary table and partitioned table to have the same storage type
select * from test_part_segment;
  a  | b 
-----+---
  99 | 1
 199 | 1
 299 | 1
(3 rows)

select * from test_no_part1;
 a | b 
---+---
(0 rows)

alter table test_part_segment analyze partition p0,p1;
alter table test_part_segment analyze partition all;
-------test list partition tables
CREATE TABLE test_part_list (a int, b int)
PARTITION BY list(a)
(
PARTITION p1 VALUES (2000,2001,2002,2003),
PARTITION p2 VALUES (3000,3001,3002,3003),
PARTITION p3 VALUES (4000,4001,4002,4003),
PARTITION p4 VALUES (5000,5001,5002,5003)
);
insert into test_part_list values(2000,1),(3000,2),(4000,3),(5000,4);
select * from test_part_list order by 1,2;
  a   | b 
------+---
 2000 | 1
 3000 | 2
 4000 | 3
 5000 | 4
(4 rows)

ALTER TABLE test_part_list truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_list order by 1,2;
 a | b 
---+---
(0 rows)

insert into test_part_list values(2000,1),(3000,2),(4000,3),(5000,4);
alter table test_part_list exchange partition p2 with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_list order by 1,2;
  a   | b 
------+---
 2000 | 1
 4000 | 3
 5000 | 4
(3 rows)

select * from test_no_part1;
  a   | b 
------+---
 3000 | 2
(1 row)

alter table test_part_list analyze partition p1,p2;
alter table test_part_list analyze partition all;
-------test hash partition tables
CREATE TABLE IF NOT EXISTS test_part_hash
(
a int,
b int
) 
PARTITION BY HASH(a)
(
    PARTITION p0,
    PARTITION p1,
    PARTITION p2
);
insert into test_part_hash (with RECURSIVE t_r(i,j) as(values(0,1) union all select i+1,j+2 from t_r where i < 20) select * from t_r);
select * from test_part_hash order by 1,2;
 a  | b  
----+----
  0 |  1
  1 |  3
  2 |  5
  3 |  7
  4 |  9
  5 | 11
  6 | 13
  7 | 15
  8 | 17
  9 | 19
 10 | 21
 11 | 23
 12 | 25
 13 | 27
 14 | 29
 15 | 31
 16 | 33
 17 | 35
 18 | 37
 19 | 39
 20 | 41
(21 rows)

ALTER TABLE test_part_hash truncate PARTITION all;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_hash order by 1,2;
 a | b 
---+---
(0 rows)

insert into test_part_hash values(99,1),(199,1),(299,1);
alter table test_part_hash exchange partition p2 with table test_no_part1 without validation;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select * from test_part_hash order by 1,2;
  a   | b 
------+---
   99 | 1
  199 | 1
 3000 | 2
(3 rows)

select * from test_no_part1;
  a  | b 
-----+---
 299 | 1
(1 row)

alter table test_part_hash analyze partition p0,p1;
alter table test_part_hash analyze partition all;
-- test partition key upper and lower case
DROP TABLE IF EXISTS sales_range;
NOTICE:  table "sales_range" does not exist, skipping
CREATE TABLE sales_range (
    sale_date int,
    PRIMARY KEY (SALE_DATE)
)
PARTITION BY RANGE (SALE_DATE) (
    PARTITION p202401 VALUES LESS THAN (1000),
    PARTITION p202402 VALUES LESS THAN (2000),
    PARTITION p202403 VALUES LESS THAN (3000),
    PARTITION p_others VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "sales_range_pkey" for table "sales_range"
\d sales_range
Table "partition_test2.sales_range"
  Column   |  Type   | Modifiers 
-----------+---------+-----------
 sale_date | integer | not null
Indexes:
    "sales_range_pkey" PRIMARY KEY, btree (sale_date) LOCAL TABLESPACE pg_default
Partition By RANGE(sale_date)
Number of partitions: 4 (View pg_partition to check each partition range.)

DROP TABLE IF EXISTS sales_range;
CREATE TABLE sales_range (
    sale_date DATE,
    PRIMARY KEY (sale_date)
)
PARTITION BY RANGE (sale_date) (
    PARTITION p202401 VALUES LESS THAN ('2024-02-01'),
    PARTITION p202402 VALUES LESS THAN ('2024-03-01'),
    PARTITION p202403 VALUES LESS THAN ('2024-04-01'),
    PARTITION p_others VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "sales_range_pkey" for table "sales_range"
\d sales_range
Table "partition_test2.sales_range"
  Column   | Type | Modifiers 
-----------+------+-----------
 sale_date | date | not null
Indexes:
    "sales_range_pkey" PRIMARY KEY, btree (sale_date) LOCAL TABLESPACE pg_default
Partition By RANGE(sale_date)
Number of partitions: 4 (View pg_partition to check each partition range.)

DROP TABLE IF EXISTS sales_range;
drop schema partition_test2 cascade;
NOTICE:  drop cascades to 8 other objects
DETAIL:  drop cascades to table test_part1
drop cascades to table test_subpart
drop cascades to table test_no_part1
drop cascades to table test_part_ustore
drop cascades to table test_no_part2
drop cascades to table test_part_segment
drop cascades to table test_part_list
drop cascades to table test_part_hash
reset current_schema;

create schema db_alter_table;
set current_schema to 'db_alter_table';
create table alter_table_tbl1 (a int primary key, b int);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "alter_table_tbl1_pkey" for table "alter_table_tbl1"
create table alter_table_tbl2 (c int primary key, d int);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "alter_table_tbl2_pkey" for table "alter_table_tbl2"
alter table alter_table_tbl2 add constraint alter_table_tbl_fk foreign key (d) references alter_table_tbl1 (a);
create index alter_table_tbl_b_ind on alter_table_tbl1(b);
-- disbale/enable keys
alter table alter_table_tbl1 disable keys;
alter table alter_table_tbl1 enable keys;
-- drop index/key index_name
alter table alter_table_tbl1 drop index alter_table_tbl_b_ind;
create index alter_table_tbl_b_ind on alter_table_tbl1(b);
alter table alter_table_tbl1 drop key alter_table_tbl_b_ind;
-- drop primary key
alter table alter_table_tbl2 drop primary key;
-- drop foreign key fk_name
alter table alter_table_tbl2 drop foreign key alter_table_tbl_fk;
-- force
alter table alter_table_tbl1 force;
-- rename index/key old_index_name to new_index_name
create index alter_table_tbl_b_ind on alter_table_tbl1(b);
alter table alter_table_tbl1 rename index alter_table_tbl_b_ind to new_alter_table_tbl_b_ind;
-- rename [ TO | AS ] new_table_name
alter table alter_table_tbl1 rename to new_alter_table_tbl1;
alter table new_alter_table_tbl1 rename as new_new_alter_table_tbl1;
alter table new_new_alter_table_tbl1 rename new_new_new_alter_table_tbl1;
alter table if exists new_new_new_alter_table_tbl1 rename alter_table_tbl1;
alter table if exists not_exists_tbl rename new_not_exists_tbl;
NOTICE:  relation "not_exists_tbl" does not exist, skipping
-- test multi-cmd
alter table alter_table_tbl1 add column key int, rename index new_alter_table_tbl_b_ind to alter_table_tbl_b_ind;
alter table alter_table_tbl1 drop column key, drop key alter_table_tbl_b_ind;
-- alter table - rename column
ALTER TABLE alter_table_tbl1 RENAME COLUMN a TO AB;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 AB     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("AB") TABLESPACE pg_default

ALTER TABLE alter_table_tbl1 RENAME COLUMN ab TO Ab;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 Ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("Ab") TABLESPACE pg_default

ALTER TABLE alter_table_tbl1 RENAME AB TO AB;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 AB     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("AB") TABLESPACE pg_default

ALTER TABLE alter_table_tbl1 RENAME ab TO ab;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree (ab) TABLESPACE pg_default

ALTER TABLE if exists alter_table_tbl1 RENAME COLUMN AB TO Ab;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 Ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("Ab") TABLESPACE pg_default

ALTER TABLE if exists alter_table_tbl1 RENAME COLUMN Ab TO ab;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree (ab) TABLESPACE pg_default

ALTER TABLE if exists alter_table_tbl1 RENAME AB TO ab;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree (ab) TABLESPACE pg_default

ALTER TABLE if exists alter_table_tbl1 RENAME Ab TO AB;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 AB     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("AB") TABLESPACE pg_default

ALTER TABLE alter_table_tbl1 CHANGE AB ab int;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 ab     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree (ab) TABLESPACE pg_default

ALTER TABLE alter_table_tbl1 CHANGE COLUMN AB AB int;
\d alter_table_tbl1
Table "db_alter_table.alter_table_tbl1"
 Column |  Type   | Modifiers 
--------+---------+-----------
 AB     | integer | not null
 b      | integer | 
Indexes:
    "alter_table_tbl1_pkey" PRIMARY KEY, btree ("AB") TABLESPACE pg_default

drop table alter_table_tbl1, alter_table_tbl2;
set dolphin.sql_mode='pipes_as_concat,pad_char_to_full_length';
create table table_ddl_0030_01(col1 int primary key,col2 varchar(20));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "table_ddl_0030_01_pkey" for table "table_ddl_0030_01"
create table table_ddl_0030_02(col1 int,col2 int);
ALTER TABLE table_ddl_0030_02 ADD CONSTRAINT FOREIGN KEY idx_ddl_0030(col1) REFERENCES table_ddl_0030_01(col1);
show dolphin.sql_mode;
            dolphin.sql_mode             
-----------------------------------------
 pipes_as_concat,pad_char_to_full_length
(1 row)

create table foreign_key_table_001(
COL_1 smallint primary key,
COL_2 char(30),
COL_3 int,
COL_4 TIMESTAMP WITH TIME ZONE ,
COL_5 boolean,
COL_6 nchar(30),
COL_7 float
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "foreign_key_table_001_pkey" for table "foreign_key_table_001"
create table foreign_key_table_002(
COL_1 smallint default 3,
COL_2 char(30),
COL_3 int,
COL_4 TIMESTAMP WITH TIME ZONE ,
COL_5 boolean,
COL_6 nchar(30),
COL_7 float,
foreign key(COL_1) REFERENCES foreign_key_table_001 on delete set default
);
insert into foreign_key_table_001 values(1,'aaaa',1,'2020-07-20',true,'aaaa',1.1);
insert into foreign_key_table_001 values(2,'bbbb',2,'2020-07-20',true,'bbbb',1.1);
insert into foreign_key_table_001 values(3,'cccc',3,'2020-07-20',true,'cccc',1.1);
insert into foreign_key_table_002 values(1,'dddd',1,'2020-07-20',true,'dddd',2.2);
insert into foreign_key_table_002 values(2,'eeee',2,'2020-07-20',true,'eeee',2.2);
delete from foreign_key_table_001 where COL_1=1;
select * from foreign_key_table_002 order by 1,2,3;
 COL_1 |             COL_2              | COL_3 |         COL_4          | COL_5 |             COL_6              | COL_7 
-------+--------------------------------+-------+------------------------+-------+--------------------------------+-------
     2 | eeee                           |     2 | 2020-07-20 00:00:00-07 | t     | eeee                           |   2.2
     3 | dddd                           |     1 | 2020-07-20 00:00:00-07 | t     | dddd                           |   2.2
(2 rows)

-- alter table - rename column
ALTER FOREIGN TABLE foreign_key_table_002 RENAME COLUMN COL_1 TO col_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 col_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (col_1) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE foreign_key_table_002 RENAME COLUMN COL_1 TO Col_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 Col_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (`Col_1`) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE foreign_key_table_002 RENAME col_1 TO col_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 col_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (col_1) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE foreign_key_table_002 RENAME COL_1 TO COL_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 COL_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (`COL_1`) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE if exists foreign_key_table_002 RENAME COLUMN cOL_1 TO cOL_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 cOL_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (`cOL_1`) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE if exists foreign_key_table_002 RENAME COLUMN col_1 TO Col_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 Col_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (`Col_1`) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE if exists foreign_key_table_002 RENAME COL_1 TO COL_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 COL_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (`COL_1`) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

ALTER FOREIGN TABLE if exists foreign_key_table_002 RENAME Col_1 TO col_1;
\d foreign_key_table_002
 Table "db_alter_table.foreign_key_table_002"
 Column |           Type           | Modifiers 
--------+--------------------------+-----------
 col_1  | smallint                 | default 3
 COL_2  | character(30)            | 
 COL_3  | integer                  | 
 COL_4  | timestamp with time zone | 
 COL_5  | boolean                  | 
 COL_6  | character(30)            | 
 COL_7  | real                     | 
Foreign-key constraints:
    "foreign_key_table_002_col_1_fkey" FOREIGN KEY (col_1) REFERENCES foreign_key_table_001(`COL_1`) ON DELETE SET DEFAULT

drop table foreign_key_table_001,foreign_key_table_002;
show dolphin.sql_mode;
            dolphin.sql_mode             
-----------------------------------------
 pipes_as_concat,pad_char_to_full_length
(1 row)

reset dolphin.sql_mode;
\d+ table_ddl_0030_02
              Table "db_alter_table.table_ddl_0030_02"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 col1   | integer |           | plain   |              | 
 col2   | integer |           | plain   |              | 
Foreign-key constraints:
    "idx_ddl_0030" FOREIGN KEY (col1) REFERENCES table_ddl_0030_01(col1)
Has OIDs: no
Options: orientation=row, compression=no

drop table table_ddl_0030_01,table_ddl_0030_02;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key (f11 desc, f12 asc) comment 'primary key' using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool);
alter table test_primary add primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree using btree;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique using btree(f31) comment 'unique index' using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique (f31) comment 'unique index' using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20));
alter table test_unique add unique using btree(f31) comment 'unique index' using btree using btree;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique_f31_key" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_key" UNIQUE CONSTRAINT, btree (f31) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using btree(f31, f32) comment 'unique index' using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32) comment 'unique index' using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32) comment 'unique index' using btree using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                         Table "db_alter_table.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key (f11 desc, f12 asc) comment 'primary key' using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                        Table "db_alter_table.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
--new add column grammar
create table add_col_test(a int);
ALTER TABLE add_col_test ADD KEY f2k(f2), ADD COLUMN(f1 INT, f3 int), ADD COLUMN (f2 INT);
ALTER TABLE if EXISTS add_col_test ADD COLUMN (f11 INT, f31 int), ADD COLUMN (f21 INT), ADD KEY f1k(f1);
ALTER TABLE if EXISTS add_col_test ADD (f12 INT, f32 int), ADD COLUMN (f22 INT);
ALTER TABLE if EXISTS add_col_test ADD COLUMN (f13 INT, f33 int), ADD COLUMN (f23 INT);
ALTER TABLE if EXISTS does_not_exists_table_test ADD COLUMN (f1 INT, f3 int), ADD COLUMN (f2 INT), ADD KEY f2k(f2);
NOTICE:  relation "does_not_exists_table_test" does not exist, skipping
--original grammar
ALTER TABLE add_col_test ADD (f14 INT, f34 int);
ALTER TABLE if EXISTS add_col_test ADD (f15 INT, f35 int);
ALTER TABLE if EXISTS does_not_exists_table_test ADD (f13 INT, f33 int);
NOTICE:  relation "does_not_exists_table_test" does not exist, skipping
\d+ add_col_test
                 Table "db_alter_table.add_col_test"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 f1     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f11    | integer |           | plain   |              | 
 f31    | integer |           | plain   |              | 
 f21    | integer |           | plain   |              | 
 f12    | integer |           | plain   |              | 
 f32    | integer |           | plain   |              | 
 f22    | integer |           | plain   |              | 
 f13    | integer |           | plain   |              | 
 f33    | integer |           | plain   |              | 
 f23    | integer |           | plain   |              | 
 f14    | integer |           | plain   |              | 
 f34    | integer |           | plain   |              | 
 f15    | integer |           | plain   |              | 
 f35    | integer |           | plain   |              | 
Indexes:
    "f1k" btree (f1) TABLESPACE pg_default
    "f2k" btree (f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table add_col_test;
drop type lockmodes;
ERROR:  type "lockmodes" does not exist
create type lockmodes as enum (
 'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
drop view my_locks;
ERROR:  view "my_locks" does not exist
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
-- test column table with alter table drop index
drop table if exists t_grammar0029;
NOTICE:  table "t_grammar0029" does not exist, skipping
create table t_grammar0029(id int unique, sex text)
with(orientation=column);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_grammar0029_id_key" for table "t_grammar0029"
drop index if exists id_grammar0029;
NOTICE:  index "id_grammar0029" does not exist, skipping
create index id_grammar0029 on t_grammar0029 using psort(id) tablespace pg_default;
alter table t_grammar0029 drop key id_grammar0029;
drop schema db_alter_table cascade;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to type lockmodes
drop cascades to view my_locks
drop cascades to table t_grammar0029
reset current_schema;

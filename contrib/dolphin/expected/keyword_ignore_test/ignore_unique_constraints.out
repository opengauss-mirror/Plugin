create schema sql_ignore_unique_test;
set current_schema to 'sql_ignore_unique_test';
drop table if exists t_ignore;
NOTICE:  table "t_ignore" does not exist, skipping
create table t_ignore(col1 int, col2 int unique, col3 int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_ignore_col2_key" for table "t_ignore"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_ignore_col3_key" for table "t_ignore"
-- sqlbypass
set enable_opfusion = on;
insert into t_ignore values(1,1,1);
insert into t_ignore values(2,2,2);
update t_ignore set col2 = 1 where col1 = 2;
ERROR:  duplicate key value violates unique constraint "t_ignore_col2_key"
DETAIL:  Key (col2)=(1) already exists.
insert ignore into t_ignore values (2,1,2);
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    2 |    2 |    2
(2 rows)

update ignore t_ignore set col2 = 1 where col1 = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    2 |    2 |    2
(2 rows)

-- insert ignore from other tables with duplicate keys
create table t_from (col1 int, col2 int, col3 int);
insert into t_from values(9,9,9);
insert into t_from values(1,1,1);
insert into t_from values(2,2,2);
insert into t_ignore select * from t_from;
ERROR:  duplicate key value violates unique constraint "t_ignore_col2_key"
DETAIL:  Key (col2)=(1) already exists.
select * from t_ignore;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    2 |    2 |    2
(2 rows)

-- no sqlbypass
set enable_opfusion = off;
insert into t_ignore values(2,1,2);
ERROR:  duplicate key value violates unique constraint "t_ignore_col2_key"
DETAIL:  Key (col2)=(1) already exists.
update t_ignore set col2 = 1 where col1 = 2;
ERROR:  duplicate key value violates unique constraint "t_ignore_col2_key"
DETAIL:  Key (col2)=(1) already exists.
insert ignore into t_ignore values(2,1,2);
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
update ignore t_ignore set col2 = 1 where col1 = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    2 |    2 |    2
(2 rows)

-- insert ignore from other tables with duplicate keys
insert into t_ignore select * from t_from;
ERROR:  duplicate key value violates unique constraint "t_ignore_col2_key"
DETAIL:  Key (col2)=(1) already exists.
select * from t_ignore;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    2 |    2 |    2
(2 rows)

drop table t_ignore;
set enable_opfusion = on;
drop table t_from;
-- test for integrity of UPSERT
drop table if exists t_unique_upsert;
NOTICE:  table "t_unique_upsert" does not exist, skipping
create table t_unique_upsert(id int unique, cont text);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_unique_upsert_id_key" for table "t_unique_upsert"
set enable_opfusion = on;
insert into t_unique_upsert values(1, 'a');
insert into t_unique_upsert values(2, 'b');
insert ignore into t_unique_upsert values(1, 'x') on duplicate key update cont = 'on dup';
select * from t_unique_upsert;
 id |  cont  
----+--------
  2 | b
  1 | on dup
(2 rows)

delete from t_unique_upsert;
set enable_opfusion = off;
insert into t_unique_upsert values(1, 'a');
insert into t_unique_upsert values(2, 'b');
insert ignore into t_unique_upsert values(1, 'x') on duplicate key update cont = 'on dup';
select * from t_unique_upsert;
 id |  cont  
----+--------
  2 | b
  1 | on dup
(2 rows)

-- test for partition table with unique key
-- opfusion: on
set enable_opfusion = on;
set enable_partition_opfusion = on;
drop table if exists t_unique_key_partition;
NOTICE:  table "t_unique_key_partition" does not exist, skipping
CREATE TABLE t_unique_key_partition
(
    num     integer UNIQUE NOT NULL,
    ca_city character varying(60)
) PARTITION BY RANGE (num)
(
    PARTITION P1 VALUES LESS THAN(5000),
    PARTITION P2 VALUES LESS THAN(10000),
    PARTITION P3 VALUES LESS THAN(15000),
    PARTITION P4 VALUES LESS THAN(20000),
    PARTITION P5 VALUES LESS THAN(25000),
    PARTITION P6 VALUES LESS THAN(30000),
    PARTITION P7 VALUES LESS THAN(40000)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_unique_key_partition_num_key" for table "t_unique_key_partition"
insert into t_unique_key_partition values(1, 'shenzhen');
insert into t_unique_key_partition values(2, 'beijing');
select * from t_unique_key_partition;
 num | ca_city  
-----+----------
   1 | shenzhen
   2 | beijing
(2 rows)

explain(costs off) insert ignore into  t_unique_key_partition values (1);
            QUERY PLAN            
----------------------------------
 [Bypass]
 Insert on t_unique_key_partition
   ->  Result
(3 rows)

insert ignore into  t_unique_key_partition values (1);
WARNING:  duplicate key value violates unique constraint in table "t_unique_key_partition"
select * from t_unique_key_partition;
 num | ca_city  
-----+----------
   1 | shenzhen
   2 | beijing
(2 rows)

update ignore t_unique_key_partition set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_unique_key_partition"
select * from t_unique_key_partition;
 num | ca_city  
-----+----------
   1 | shenzhen
   2 | beijing
(2 rows)

-- opfusion: off
set enable_opfusion = off;
set enable_partition_opfusion = off;
explain(costs off) insert ignore into  t_unique_key_partition values (1);
            QUERY PLAN            
----------------------------------
 Insert on t_unique_key_partition
   ->  Result
(2 rows)

insert ignore into  t_unique_key_partition values (1);
WARNING:  duplicate key value violates unique constraint in table "t_unique_key_partition"
select * from t_unique_key_partition;
 num | ca_city  
-----+----------
   1 | shenzhen
   2 | beijing
(2 rows)

update ignore t_unique_key_partition set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_unique_key_partition"
select * from t_unique_key_partition;
 num | ca_city  
-----+----------
   1 | shenzhen
   2 | beijing
(2 rows)

-- test for subpartition table
drop table if exists ignore_range_range;
NOTICE:  table "ignore_range_range" does not exist, skipping
CREATE TABLE ignore_range_range
(
    month_code VARCHAR2 ( 30 ) NOT NULL ,
    dept_code  VARCHAR2 ( 30 ) UNIQUE ,
    user_no    VARCHAR2 ( 30 ) NOT NULL ,
    sales_amt  int
)
    PARTITION BY RANGE (month_code) SUBPARTITION BY RANGE (dept_code)
(
  PARTITION p_201901 VALUES LESS THAN( '201901' )
  (
    SUBPARTITION p_201901_a VALUES LESS THAN( '2' ),
    SUBPARTITION p_201901_b VALUES LESS THAN( '3' )
  ),
  PARTITION p_201902 VALUES LESS THAN( '201902' )
  (
    SUBPARTITION p_201902_a VALUES LESS THAN( '2' ),
    SUBPARTITION p_201902_b VALUES LESS THAN( '3' )
  )
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "ignore_range_range_dept_code_tableoid_key" for table "ignore_range_range"
set enable_opfusion = on;
set enable_partition_opfusion = on;
insert ignore into ignore_range_range values('201901', '1', '1', 1);
insert ignore  into ignore_range_range values('201901', '1', '1', 1);
WARNING:  duplicate key value violates unique constraint in table "ignore_range_range"
select * from ignore_range_range;
 month_code | dept_code | user_no | sales_amt 
------------+-----------+---------+-----------
 201901     | 1         | 1       |         1
(1 row)

insert into ignore_range_range values('201901', '2', '1', 1);
update ignore ignore_range_range set dept_code = '1' where dept_code = '2';
WARNING:  duplicate key value violates unique constraint in table "ignore_range_range"
select * from ignore_range_range;
 month_code | dept_code | user_no | sales_amt 
------------+-----------+---------+-----------
 201901     | 1         | 1       |         1
 201901     | 2         | 1       |         1
(2 rows)

delete from ignore_range_range;
set enable_opfusion = off;
set enable_partition_opfusion = off;
insert ignore  into ignore_range_range values('201901', '1', '1', 1);
insert ignore  into ignore_range_range values('201901', '1', '1', 1);
WARNING:  duplicate key value violates unique constraint in table "ignore_range_range"
select * from ignore_range_range;
 month_code | dept_code | user_no | sales_amt 
------------+-----------+---------+-----------
 201901     | 1         | 1       |         1
(1 row)

insert into ignore_range_range values('201901', '2', '1', 1);
update ignore ignore_range_range set dept_code = '1' where dept_code = '2';
WARNING:  duplicate key value violates unique constraint in table "ignore_range_range"
select * from ignore_range_range;
 month_code | dept_code | user_no | sales_amt 
------------+-----------+---------+-----------
 201901     | 1         | 1       |         1
 201901     | 2         | 1       |         1
(2 rows)

-- test for ustore table
drop table if exists t_ignore;
NOTICE:  table "t_ignore" does not exist, skipping
create table t_ignore(num int unique) with(storage_type=ustore);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_ignore_num_key" for table "t_ignore"
-- test for ustore table, opfusion: on
set enable_opfusion = on;
insert into t_ignore values(1);
explain(costs off) insert ignore into t_ignore values(1);
     QUERY PLAN     
--------------------
 [Bypass]
 Insert on t_ignore
   ->  Result
(3 rows)

select * from t_ignore;
 num 
-----
   1
(1 row)

insert into t_ignore values(2);
update ignore t_ignore set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
   2
(2 rows)

-- test for ustore table, opfusion: off
set enable_opfusion = off;
delete from t_ignore;
insert into t_ignore values(1);
explain(costs off) insert ignore into t_ignore values(1);
     QUERY PLAN     
--------------------
 Insert on t_ignore
   ->  Result
(2 rows)

insert ignore into t_ignore values(1);
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
(1 row)

insert into t_ignore values(2);
update ignore t_ignore set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
   2
(2 rows)

-- test for segment table
drop table if exists t_ignore;
create table t_ignore(num int unique) with(segment = on);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t_ignore_num_key" for table "t_ignore"
-- test for segment table, opfusion: on
set enable_opfusion = on;
insert into t_ignore values(1);
insert ignore into t_ignore values(1);
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
(1 row)

insert into t_ignore values(2);
update ignore t_ignore set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
   2
(2 rows)

-- test for segment table, opfusion: off
delete from t_ignore;
set enable_opfusion = off;
insert into t_ignore values(1);
insert ignore into t_ignore values(1);
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
(1 row)

insert into t_ignore values(2);
update ignore t_ignore set num = 1 where num = 2;
WARNING:  duplicate key value violates unique constraint in table "t_ignore"
select * from t_ignore;
 num 
-----
   1
   2
(2 rows)

-- test for procedure/function using INSERT/UPDATE IGNORE, to check whether IGNORE is valid for plpgsql
-- procedure
create table ignore_proc_test(id int unique, name text);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "ignore_proc_test_id_key" for table "ignore_proc_test"
create or replace procedure insert_ignore_unique_proc()
as
begin
insert ignore into ignore_proc_test values(1,'aaa'),(2,'ccc');
end;
/
select insert_ignore_unique_proc();
 insert_ignore_unique_proc 
---------------------------
 
(1 row)

select * from ignore_proc_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

select insert_ignore_unique_proc();
WARNING:  duplicate key value violates unique constraint in table "ignore_proc_test"
CONTEXT:  SQL statement "insert ignore into ignore_proc_test values(1,'aaa'),(2,'ccc')"
PL/pgSQL function insert_ignore_unique_proc() line 3 at SQL statement
referenced column: insert_ignore_unique_proc
WARNING:  duplicate key value violates unique constraint in table "ignore_proc_test"
CONTEXT:  SQL statement "insert ignore into ignore_proc_test values(1,'aaa'),(2,'ccc')"
PL/pgSQL function insert_ignore_unique_proc() line 3 at SQL statement
referenced column: insert_ignore_unique_proc
 insert_ignore_unique_proc 
---------------------------
 
(1 row)

select * from ignore_proc_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

create or replace procedure update_ignore_unique_proc()
as
begin
update ignore ignore_proc_test set id = 1 where id = 2;
end;
/
select update_ignore_unique_proc();
WARNING:  duplicate key value violates unique constraint in table "ignore_proc_test"
CONTEXT:  SQL statement "update ignore ignore_proc_test set id = 1 where id = 2"
PL/pgSQL function update_ignore_unique_proc() line 3 at SQL statement
referenced column: update_ignore_unique_proc
 update_ignore_unique_proc 
---------------------------
 
(1 row)

select * from ignore_proc_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

-- function
create table ignore_func_test(id int unique, name text);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "ignore_func_test_id_key" for table "ignore_func_test"
delimiter |
create or replace function insert_ignore_unique_func() returns int
begin
insert ignore into ignore_func_test values(1,'aaa'),(2,'ccc');
return 1;
end|
delimiter ;
select insert_ignore_unique_func();
 insert_ignore_unique_func 
---------------------------
                         1
(1 row)

select * from ignore_func_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

select insert_ignore_unique_func();
WARNING:  duplicate key value violates unique constraint in table "ignore_func_test"
CONTEXT:  SQL statement "insert ignore into ignore_func_test values(1,'aaa'),(2,'ccc')"
PL/pgSQL function insert_ignore_unique_func() line 2 at SQL statement
referenced column: insert_ignore_unique_func
WARNING:  duplicate key value violates unique constraint in table "ignore_func_test"
CONTEXT:  SQL statement "insert ignore into ignore_func_test values(1,'aaa'),(2,'ccc')"
PL/pgSQL function insert_ignore_unique_func() line 2 at SQL statement
referenced column: insert_ignore_unique_func
 insert_ignore_unique_func 
---------------------------
                         1
(1 row)

select * from ignore_func_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

delimiter |
create or replace function update_ignore_unique_func() returns int
begin
update ignore ignore_func_test set id = 1 where id = 2;
return 1;
end|
delimiter ;
select update_ignore_unique_func();
WARNING:  duplicate key value violates unique constraint in table "ignore_func_test"
CONTEXT:  SQL statement "update ignore ignore_func_test set id = 1 where id = 2"
PL/pgSQL function update_ignore_unique_func() line 2 at SQL statement
referenced column: update_ignore_unique_func
 update_ignore_unique_func 
---------------------------
                         1
(1 row)

select * from ignore_func_test;
 id | name 
----+------
  1 | aaa
  2 | ccc
(2 rows)

drop schema sql_ignore_unique_test cascade;
NOTICE:  drop cascades to 10 other objects
DETAIL:  drop cascades to table t_unique_upsert
drop cascades to table t_unique_key_partition
drop cascades to table ignore_range_range
drop cascades to table t_ignore
drop cascades to table ignore_proc_test
drop cascades to function insert_ignore_unique_proc()
drop cascades to function update_ignore_unique_proc()
drop cascades to table ignore_func_test
drop cascades to function insert_ignore_unique_func()
drop cascades to function update_ignore_unique_func()
reset current_schema;

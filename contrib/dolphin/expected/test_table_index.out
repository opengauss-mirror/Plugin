---- b compatibility case
drop database if exists test_table_index;
NOTICE:  database "test_table_index" does not exist, skipping
create database test_table_index dbcompatibility 'b';
\c test_table_index
-- test crate normal table
create table t1(f1 int , index(f1));
create table t2(f1 int , index idx_f2(f1));
create table t3(f1 int , index idx_f3 using btree (f1));
create table t4(f1 int , index idx_f4 using btree (f1 desc));
create table t5(f1 int , key idx_f5 using btree (f1 asc));
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "t1_f1_idx" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t2
                          Table "public.t2"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f2" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t3
                          Table "public.t3"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f3" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t4
                          Table "public.t4"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f4" btree (f1 DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t5
                          Table "public.t5"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f5" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
drop table if exists t2;
drop table if exists t3;
drop table if exists t4;
drop table if exists t5;
create table test_expr1(f1 int, f2 int, f3 int, index tbl_idx1 using btree(f1 desc, f2 asc));
create table test_expr2(f1 int, f2 int, f3 int, index tbl_idx2 using btree((abs(f1)) desc, f2 asc));
create table test_expr3(f1 int, f2 int, f3 int, index tbl_idx3 using btree((abs(f1)+10) desc, f2 asc));
\d+ test_expr1
                      Table "public.test_expr1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx1" btree (f1 DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_expr2
                      Table "public.test_expr2"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx2" btree (abs(f1) DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_expr3
                      Table "public.test_expr3"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx3" btree ((abs(f1) + 10) DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_expr1;
drop table if exists test_expr2;
drop table if exists test_expr3;
create table test_hash(f1 int, f2 int, f3 int, index tbl_idx4 using hash(f1 desc, f2 asc));
ERROR:  access method "hash" does not support multicolumn indexes
create table test_ubtree(f1 int, f2 int, f3 int, index using ubtree(f1 desc, f2 asc)) with (STORAGE_TYPE=USTORE);
create table text_column_table(f11 int, f12 varchar(20), f13 bool, index (f11)) with (orientation=column);
create table test_gist (t tsquery, s tsvector,index using gist(t));
create table test_gin (t tsquery, s tsvector,index using gin(s));
create table text_column_table(f1 int, index(f1)) with (orientation=column);
ERROR:  relation "text_column_table" already exists in schema "public"
DETAIL:  creating new table with existing name in the same schema
create table text_column_table_expr(f1 int, unique((f1+1))) with (orientation=column);
ERROR:  access method "cbtree" does not support index expressions
\d+ test_ubtree
                     Table "public.test_ubtree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_ubtree_f1_f2_idx" ubtree (f1 DESC, f2) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

\d+ test_gist
                       Table "public.test_gist"
 Column |   Type   | Modifiers | Storage  | Stats target | Description 
--------+----------+-----------+----------+--------------+-------------
 t      | tsquery  |           | plain    |              | 
 s      | tsvector |           | extended |              | 
Indexes:
    "test_gist_t_idx" gist (t) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_gin
                        Table "public.test_gin"
 Column |   Type   | Modifiers | Storage  | Stats target | Description 
--------+----------+-----------+----------+--------------+-------------
 t      | tsquery  |           | plain    |              | 
 s      | tsvector |           | extended |              | 
Indexes:
    "test_gin_s_idx" gin (s) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ text_column_table
                          Table "public.text_column_table"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "text_column_table_f11_idx" psort (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists test_ubtree;
drop table if exists test_gist;
drop table if exists test_gin;
drop table if exists text_column_table;
drop table if exists text_column_table_expr;
NOTICE:  table "text_column_table_expr" does not exist, skipping
-- test crate partition table
CREATE TABLE test_partition_btree
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_btree_idx using btree(f1)	
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_btree
                 Table "public.test_partition_btree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_btree_idx" btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_btree;
CREATE TABLE test_partition_index
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_btree_idx2 using btree(f1 desc, f2 asc)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_index
                 Table "public.test_partition_index"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_btree_idx2" btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_index;
CREATE TABLE test_partition_func
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_expr_idx using btree((abs(f1)))
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_func
                 Table "public.test_partition_func"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_expr_idx" btree (abs(f1)) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_func;
CREATE TABLE test_partition_expr
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_expr_idx using btree((abs(f1)+1))
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_expr
                 Table "public.test_partition_expr"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_expr_idx" btree ((abs(f1) + 1)) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_expr;
CREATE TABLE test_partition_column
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_column(f1)
) with (ORIENTATION = COLUMN)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_column
                Table "public.test_partition_column"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_column" psort (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists test_partition_column;
-- test crate subpartition table
CREATE TABLE test_subpartition_btree
(
month_code VARCHAR2 ( 30 ) NOT NULL ,
dept_code VARCHAR2 ( 30 ) NOT NULL ,
user_no VARCHAR2 ( 30 ) NOT NULL ,
sales_amt int,
index subpart_btree_idx using btree(month_code desc, dept_code)
)
PARTITION BY LIST (month_code) SUBPARTITION BY LIST (dept_code)
(
PARTITION p_201901 VALUES ( '201902' )
(
SUBPARTITION p_201901_a VALUES ( '1' ),
SUBPARTITION p_201901_b VALUES ( '2' )
),
PARTITION p_201902 VALUES ( '201903' )
(
SUBPARTITION p_201902_a VALUES ( '1' ),
SUBPARTITION p_201902_b VALUES ( '2' )
)
);
\d+ test_subpartition_btree
                         Table "public.test_subpartition_btree"
   Column   |         Type          | Modifiers | Storage  | Stats target | Description 
------------+-----------------------+-----------+----------+--------------+-------------
 month_code | character varying(30) | not null  | extended |              | 
 dept_code  | character varying(30) | not null  | extended |              | 
 user_no    | character varying(30) | not null  | extended |              | 
 sales_amt  | integer               |           | plain    |              | 
Indexes:
    "subpart_btree_idx" btree (month_code DESC, dept_code) LOCAL TABLESPACE pg_default
Partition By LIST(month_code) Subpartition By LIST(dept_code)
Number of partitions: 2 (View pg_partition to check each partition range.)
Number of subpartitions: 4 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_subpartition_btree;
CREATE TABLE test_subpartition_btree
(
month_code VARCHAR2 ( 30 ) NOT NULL ,
dept_code VARCHAR2 ( 30 ) NOT NULL ,
user_no VARCHAR2 ( 30 ) NOT NULL ,
sales_amt int,
index subpart_btree_idx using btree((sales_amt+1) desc, (dept_code))
)
PARTITION BY LIST (month_code) SUBPARTITION BY LIST (dept_code)
(
PARTITION p_201901 VALUES ( '201902' )
(
SUBPARTITION p_201901_a VALUES ( '1' ),
SUBPARTITION p_201901_b VALUES ( '2' )
),
PARTITION p_201902 VALUES ( '201903' )
(
SUBPARTITION p_201902_a VALUES ( '1' ),
SUBPARTITION p_201902_b VALUES ( '2' )
)
);
\d+ test_subpartition_btree
                         Table "public.test_subpartition_btree"
   Column   |         Type          | Modifiers | Storage  | Stats target | Description 
------------+-----------------------+-----------+----------+--------------+-------------
 month_code | character varying(30) | not null  | extended |              | 
 dept_code  | character varying(30) | not null  | extended |              | 
 user_no    | character varying(30) | not null  | extended |              | 
 sales_amt  | integer               |           | plain    |              | 
Indexes:
    "subpart_btree_idx" btree ((sales_amt + 1) DESC, dept_code) LOCAL TABLESPACE pg_default
Partition By LIST(month_code) Subpartition By LIST(dept_code)
Number of partitions: 2 (View pg_partition to check each partition range.)
Number of subpartitions: 4 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_subpartition_btree;
-- test crate temporary table
create temporary table test_temporary_index1(f1 int, f2 int, f3 int, index using btree(f1 desc, f2 asc));
create local temporary table test_temporary_index2(f1 int, f2 int, f3 int, index  using btree(f1 desc, f2 asc));
create global temporary table test_temporary_index3(f1 int, f2 int, f3 int, index  using btree(f1 desc, f2 asc));
create global temporary table test_temporary_index4(f1 int, f2 int, f3 int, index  using hash(f1 desc, f2 asc));
ERROR:  access method "hash" does not support multicolumn indexes
drop table if exists test_temporary_index1;
drop table if exists test_temporary_index2;
drop table if exists test_temporary_index3;
drop table if exists test_temporary_index4;
NOTICE:  table "test_temporary_index4" does not exist, skipping
--fail example
create table t1(a int , index idx_a (b));
ERROR:  column "b" does not exist
create table t1(a int , index using btree idx_a(a));
ERROR:  syntax error at or near "idx_a"
LINE 1: create table t1(a int , index using btree idx_a(a));
                                                  ^
create table t1(a int , index idx_a (a) using btree);
ERROR:  syntax error at or near "using"
LINE 1: create table t1(a int , index idx_a (a) using btree);
                                                ^
create table t1(a int , b int, index idx_a (a,a));
ERROR:  duplicate column name
create table t1(a int , b int, index idx_a (a,b,a));
ERROR:  duplicate column name
create table t1(a int , index idx_a (abs(a)));
ERROR:  syntax error at or near "a"
LINE 1: create table t1(a int , index idx_a (abs(a)));
                                                 ^
create table t1(a int , index idx_a ((abs(a)),(abs(a))));
ERROR:  duplicate column name
create table t1(a int , index idx_a ((abs(a)+1),(abs(a)+1)));
ERROR:  duplicate column name
-- alter table add index
create table t1(a int , b int, index (a, b));
alter table  t1 add index (a);
alter table  t1 add index idx_a_1(a);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_1" btree (a) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
    "t1_a_idx" btree (a) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
create table t1(a int , b int, index (a, b));
alter table  t1 add index using btree(a), add index (b desc);
alter table  t1 add index idx_a_t1 using btree(a);
alter table  t1 add index idx_a_b_t1 using btree(a, b desc);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_b_t1" btree (a, b DESC) TABLESPACE pg_default
    "idx_a_t1" btree (a) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
    "t1_a_idx" btree (a) TABLESPACE pg_default
    "t1_b_idx" btree (b DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
create table t1(a int , b int, index (a, b));
alter table  t1 add key idx_a_b_t1 using btree(a, b desc);
alter table  t1 add key idx_a_b_expr_t1 using btree((abs(a+b) + a) desc);
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_b_expr_t1" btree ((abs(a + b) + a) DESC) TABLESPACE pg_default
    "idx_a_b_t1" btree (a, b DESC) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
-- fail example
create table t1(a int , b int);
alter table  t1 add index (c);
ERROR:  column "c" does not exist
alter table  t1 add index using btree idx1 (a);
ERROR:  syntax error at or near "idx1"
LINE 1: alter table  t1 add index using btree idx1 (a);
                                              ^
alter table  t1 add index idx2 (a) using btree;
ERROR:  syntax error at or near "using"
LINE 1: alter table  t1 add index idx2 (a) using btree;
                                           ^
\d+ t1
                          Table "public.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
-- test normal table : alter table add
-- normal row table
create table test_normal_index(f11 int, f12 varchar(20), f13 bool);
alter table test_normal_index add key using btree(f11, f12);
alter table test_normal_index add key using hash(f11);
alter table test_normal_index add key idx_f11_f12 using btree(f11, f12);
alter table test_normal_index add key((abs(f11)));
alter table test_normal_index add key((f11 * 2 + 1));
alter table test_normal_index add key(f11 desc, f12 asc);
alter table test_normal_index add key using btree(f11, f12),add unique(f11, f12),add primary key(f11, f12);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_normal_index_pkey" for table "test_normal_index"
\d+ test_normal_index
                          Table "public.test_normal_index"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_normal_index_pkey" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default
    "idx_f11_f12" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_abs_idx" btree (abs(f11)) TABLESPACE pg_default
    "test_normal_index_expr_idx" btree ((f11 * 2 + 1)) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx1" btree (f11 DESC, f12) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx2" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_f11_idx" hash (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_normal_index;
-- not support
alter table test_normal_index add key using hash(f11, f12);
ERROR:  relation "test_normal_index" does not exist
-- normal column table
create table text_column_table(f11 int, f12 varchar(20), f13 bool, index (f11)) with (orientation=column);
alter table text_column_table add key (f11);
alter table text_column_table add key (f11,f12);
alter table text_column_table add key using btree(f11);
alter table text_column_table add key using cbtree(f11);
\d+ text_column_table
                          Table "public.text_column_table"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "text_column_table_f11_f12_idx" psort (f11, f12) TABLESPACE pg_default
    "text_column_table_f11_idx" psort (f11) TABLESPACE pg_default
    "text_column_table_f11_idx1" psort (f11) TABLESPACE pg_default
    "text_column_table_f11_idx2" cbtree (f11) TABLESPACE pg_default
    "text_column_table_f11_idx3" cbtree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists text_column_table;
-- not support
alter table text_column_table add key using hash(f11);
ERROR:  relation "text_column_table" does not exist
alter table text_column_table add key ((abs(f11)));
ERROR:  relation "text_column_table" does not exist
-- test partition table
CREATE TABLE test_partition_btree
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_partition_btree add index (f1 desc);
alter table test_partition_btree add key using btree(f1 desc, f2 asc, f3);
alter table test_partition_btree add key using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
\d+ test_partition_btree
                 Table "public.test_partition_btree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_partition_btree_abs_expr_f3_idx" btree (abs(f1) DESC, (f2 * 2 + 1), f3) LOCAL TABLESPACE pg_default
    "test_partition_btree_f1_f2_f3_idx" btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
    "test_partition_btree_f1_idx" btree (f1 DESC) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_btree;
-- test temporary table
create temporary table test_temporary_index1(f11 int, f12 int, f13 int);
alter table test_temporary_index1 add key using btree(f11, f12);
alter table test_temporary_index1 add key using hash(f11);
alter table test_temporary_index1 add key idx_f11_f12 using btree(f11, f12);
alter table test_temporary_index1 add key((abs(f11)));
alter table test_temporary_index1 add key((f11 * 2 + 1));
alter table test_temporary_index1 add key(f11 desc, f12 asc);
alter table test_temporary_index1 add key using btree(f11, f12),add unique(f11, f12),add primary key(f11, f12);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_temporary_index1_pkey" for table "test_temporary_index1"
drop table if exists test_temporary_index1;
\c contrib_regression
DROP DATABASE test_table_index;

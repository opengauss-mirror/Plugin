create schema test_table_index;
set current_schema to 'test_table_index';
-- test crate normal table
create table t1(f1 int , index(f1));
create table t2(f1 int , index idx_f2(f1));
create table t3(f1 int , index idx_f3 using btree (f1));
create table t4(f1 int , index idx_f4 using btree (f1 desc));
create table t5(f1 int , key idx_f5 using btree (f1 asc));
\d+ t1
                     Table "test_table_index.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "t1_f1_idx" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t2
                     Table "test_table_index.t2"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f2" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t3
                     Table "test_table_index.t3"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f3" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t4
                     Table "test_table_index.t4"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f4" btree (f1 DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ t5
                     Table "test_table_index.t5"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
Indexes:
    "idx_f5" btree (f1) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
drop table if exists t2;
drop table if exists t3;
drop table if exists t4;
drop table if exists t5;
create table test_expr1(f1 int, f2 int, f3 int, index tbl_idx1 using btree(f1 desc, f2 asc));
create table test_expr2(f1 int, f2 int, f3 int, index tbl_idx2 using btree((abs(f1)) desc, f2 asc));
create table test_expr3(f1 int, f2 int, f3 int, index tbl_idx3 using btree((abs(f1)+10) desc, f2 asc));
\d+ test_expr1
                 Table "test_table_index.test_expr1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx1" btree (f1 DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_expr2
                 Table "test_table_index.test_expr2"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx2" btree (abs(f1) DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_expr3
                 Table "test_table_index.test_expr3"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "tbl_idx3" btree ((abs(f1) OPERATOR(dolphin_catalog.+) 10) DESC, f2) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_expr1;
drop table if exists test_expr2;
drop table if exists test_expr3;
create table test_hash(f1 int, f2 int, f3 int, index tbl_idx4 using hash(f1 desc, f2 asc));
ERROR:  access method "hash" does not support multicolumn indexes
create table test_ubtree(f1 int, f2 int, f3 int, index using ubtree(f1 desc, f2 asc)) with (STORAGE_TYPE=USTORE);
create table text_column_table(f11 int, f12 varchar(20), f13 bool, index (f11)) with (orientation=column);
create table test_gist (t tsquery, s tsvector,index using gist(t));
create table test_gin (t tsquery, s tsvector,index using gin(s));
create table text_column_table(f1 int, index(f1)) with (orientation=column);
ERROR:  relation "text_column_table" already exists in schema "test_table_index"
DETAIL:  creating new table with existing name in the same schema
create table text_column_table_expr(f1 int, unique((f1+1))) with (orientation=column);
ERROR:  access method "cbtree" does not support index expressions
\d+ test_ubtree
                Table "test_table_index.test_ubtree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_ubtree_f1_f2_idx" ubtree (f1 DESC, f2) WITH (storage_type=USTORE) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, storage_type=ustore, compression=no

\d+ test_gist
                  Table "test_table_index.test_gist"
 Column |   Type   | Modifiers | Storage  | Stats target | Description 
--------+----------+-----------+----------+--------------+-------------
 t      | tsquery  |           | plain    |              | 
 s      | tsvector |           | extended |              | 
Indexes:
    "test_gist_t_idx" gist (t) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ test_gin
                   Table "test_table_index.test_gin"
 Column |   Type   | Modifiers | Storage  | Stats target | Description 
--------+----------+-----------+----------+--------------+-------------
 t      | tsquery  |           | plain    |              | 
 s      | tsvector |           | extended |              | 
Indexes:
    "test_gin_s_idx" gin (s) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\d+ text_column_table
                     Table "test_table_index.text_column_table"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "text_column_table_f11_idx" psort (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists test_ubtree;
drop table if exists test_gist;
drop table if exists test_gin;
drop table if exists text_column_table;
drop table if exists text_column_table_expr;
NOTICE:  table "text_column_table_expr" does not exist, skipping
-- test crate partition table
CREATE TABLE test_partition_btree
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_btree_idx using btree(f1)	
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_btree
            Table "test_table_index.test_partition_btree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_btree_idx" btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_btree;
CREATE TABLE test_partition_index
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_btree_idx2 using btree(f1 desc, f2 asc)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_index
            Table "test_table_index.test_partition_index"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_btree_idx2" btree (f1 DESC, f2) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_index;
CREATE TABLE test_partition_func
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_expr_idx using btree((abs(f1)))
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_func
            Table "test_table_index.test_partition_func"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_expr_idx" btree (abs(f1)) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_func;
CREATE TABLE test_partition_expr
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_expr_idx using btree((abs(f1)+1))
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_expr
            Table "test_table_index.test_partition_expr"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_expr_idx" btree ((abs(f1) OPERATOR(dolphin_catalog.+) 1)) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_expr;
CREATE TABLE test_partition_column
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key part_column(f1)
) with (ORIENTATION = COLUMN)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_partition_column
           Table "test_table_index.test_partition_column"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "part_column" psort (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists test_partition_column;
-- test crate subpartition table
CREATE TABLE test_subpartition_btree
(
month_code VARCHAR2 ( 30 ) NOT NULL ,
dept_code VARCHAR2 ( 30 ) NOT NULL ,
user_no VARCHAR2 ( 30 ) NOT NULL ,
sales_amt int,
index subpart_btree_idx using btree(month_code desc, dept_code)
)
PARTITION BY LIST (month_code) SUBPARTITION BY LIST (dept_code)
(
PARTITION p_201901 VALUES ( '201902' )
(
SUBPARTITION p_201901_a VALUES ( '1' ),
SUBPARTITION p_201901_b VALUES ( '2' )
),
PARTITION p_201902 VALUES ( '201903' )
(
SUBPARTITION p_201902_a VALUES ( '1' ),
SUBPARTITION p_201902_b VALUES ( '2' )
)
);
\d+ test_subpartition_btree
                    Table "test_table_index.test_subpartition_btree"
   Column   |         Type          | Modifiers | Storage  | Stats target | Description 
------------+-----------------------+-----------+----------+--------------+-------------
 month_code | character varying(30) | not null  | extended |              | 
 dept_code  | character varying(30) | not null  | extended |              | 
 user_no    | character varying(30) | not null  | extended |              | 
 sales_amt  | integer               |           | plain    |              | 
Indexes:
    "subpart_btree_idx" btree (month_code DESC, dept_code) LOCAL TABLESPACE pg_default
Partition By LIST(month_code) Subpartition By LIST(dept_code)
Number of partitions: 2 (View pg_partition to check each partition range.)
Number of subpartitions: 4 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_subpartition_btree;
CREATE TABLE test_subpartition_btree
(
month_code VARCHAR2 ( 30 ) NOT NULL ,
dept_code VARCHAR2 ( 30 ) NOT NULL ,
user_no VARCHAR2 ( 30 ) NOT NULL ,
sales_amt int,
index subpart_btree_idx using btree((sales_amt+1) desc, (dept_code))
)
PARTITION BY LIST (month_code) SUBPARTITION BY LIST (dept_code)
(
PARTITION p_201901 VALUES ( '201902' )
(
SUBPARTITION p_201901_a VALUES ( '1' ),
SUBPARTITION p_201901_b VALUES ( '2' )
),
PARTITION p_201902 VALUES ( '201903' )
(
SUBPARTITION p_201902_a VALUES ( '1' ),
SUBPARTITION p_201902_b VALUES ( '2' )
)
);
\d+ test_subpartition_btree
                    Table "test_table_index.test_subpartition_btree"
   Column   |         Type          | Modifiers | Storage  | Stats target | Description 
------------+-----------------------+-----------+----------+--------------+-------------
 month_code | character varying(30) | not null  | extended |              | 
 dept_code  | character varying(30) | not null  | extended |              | 
 user_no    | character varying(30) | not null  | extended |              | 
 sales_amt  | integer               |           | plain    |              | 
Indexes:
    "subpart_btree_idx" btree ((sales_amt OPERATOR(dolphin_catalog.+) 1) DESC, dept_code) LOCAL TABLESPACE pg_default
Partition By LIST(month_code) Subpartition By LIST(dept_code)
Number of partitions: 2 (View pg_partition to check each partition range.)
Number of subpartitions: 4 (View pg_partition to check each subpartition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_subpartition_btree;
-- test crate temporary table
create temporary table test_temporary_index1(f1 int, f2 int, f3 int, index using btree(f1 desc, f2 asc));
create local temporary table test_temporary_index2(f1 int, f2 int, f3 int, index  using btree(f1 desc, f2 asc));
create global temporary table test_temporary_index3(f1 int, f2 int, f3 int, index  using btree(f1 desc, f2 asc));
create global temporary table test_temporary_index4(f1 int, f2 int, f3 int, index  using hash(f1 desc, f2 asc));
ERROR:  access method "hash" does not support multicolumn indexes
drop table if exists test_temporary_index1;
drop table if exists test_temporary_index2;
drop table if exists test_temporary_index3;
drop table if exists test_temporary_index4;
NOTICE:  table "test_temporary_index4" does not exist, skipping
--fail example
create table t1(a int , index idx_a (b));
ERROR:  column "b" does not exist
create table t1(a int , index using btree idx_a(a));
ERROR:  syntax error at or near "idx_a"
LINE 1: create table t1(a int , index using btree idx_a(a));
                                                  ^
create table t1(a int , b int, index idx_a (a,a));
ERROR:  duplicate column name
create table t1(a int , b int, index idx_a (a,b,a));
ERROR:  duplicate column name
create table t1(a int , index idx_a (abs(a)));
ERROR:  syntax error at or near "a"
LINE 1: create table t1(a int , index idx_a (abs(a)));
                                                 ^
create table t1(a int , index idx_a ((abs(a)),(abs(a))));
ERROR:  duplicate column name
create table t1(a int , index idx_a ((abs(a)+1),(abs(a)+1)));
ERROR:  duplicate column name
-- alter table add index
create table t1(a int , b int, index (a, b));
alter table  t1 add index (a);
alter table  t1 add index idx_a_1(a);
\d+ t1
                     Table "test_table_index.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_1" btree (a) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
    "t1_a_idx" btree (a) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
create table t1(a int , b int, index (a, b));
alter table  t1 add index using btree(a), add index (b desc);
alter table  t1 add index idx_a_t1 using btree(a);
alter table  t1 add index idx_a_b_t1 using btree(a, b desc);
\d+ t1
                     Table "test_table_index.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_b_t1" btree (a, b DESC) TABLESPACE pg_default
    "idx_a_t1" btree (a) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
    "t1_a_idx" btree (a) TABLESPACE pg_default
    "t1_b_idx" btree (b DESC) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
create table t1(a int , b int, index (a, b));
alter table  t1 add key idx_a_b_t1 using btree(a, b desc);
alter table  t1 add key idx_a_b_expr_t1 using btree((abs(a+b) + a) desc);
\d+ t1
                     Table "test_table_index.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_a_b_expr_t1" btree ((abs(a OPERATOR(dolphin_catalog.+) b) OPERATOR(dolphin_catalog.+) a) DESC) TABLESPACE pg_default
    "idx_a_b_t1" btree (a, b DESC) TABLESPACE pg_default
    "t1_a_b_idx" btree (a, b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
-- fail example
create table t1(a int , b int);
alter table  t1 add index (c);
ERROR:  column "c" does not exist
alter table  t1 add index using btree idx1 (a);
ERROR:  syntax error at or near "idx1"
LINE 1: alter table  t1 add index using btree idx1 (a);
                                              ^
\d+ t1
                     Table "test_table_index.t1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists t1;
-- test normal table : alter table add
-- normal row table
create table test_normal_index(f11 int, f12 varchar(20), f13 bool);
alter table test_normal_index add key using btree(f11, f12);
alter table test_normal_index add key using hash(f11);
alter table test_normal_index add key idx_f11_f12 using btree(f11, f12);
alter table test_normal_index add key((abs(f11)));
alter table test_normal_index add key((f11 * 2 + 1));
alter table test_normal_index add key(f11 desc, f12 asc);
alter table test_normal_index add key using btree(f11, f12),add unique(f11, f12),add primary key(f11, f12);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_normal_index_pkey" for table "test_normal_index"
\d+ test_normal_index
                     Table "test_table_index.test_normal_index"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_normal_index_pkey" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default
    "idx_f11_f12" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_abs_idx" btree (abs(f11)) TABLESPACE pg_default
    "test_normal_index_expr_idx" btree (((f11 OPERATOR(dolphin_catalog.*) 2) OPERATOR(dolphin_catalog.+) 1)) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx1" btree (f11 DESC, f12) TABLESPACE pg_default
    "test_normal_index_f11_f12_idx2" btree (f11, f12) TABLESPACE pg_default
    "test_normal_index_f11_idx" hash (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_normal_index;
-- not support
alter table test_normal_index add key using hash(f11, f12);
ERROR:  relation "test_normal_index" does not exist
-- normal column table
create table text_column_table(f11 int, f12 varchar(20), f13 bool, index (f11)) with (orientation=column);
alter table text_column_table add key (f11);
alter table text_column_table add key (f11,f12);
alter table text_column_table add key using btree(f11);
alter table text_column_table add key using cbtree(f11);
\d+ text_column_table
                     Table "test_table_index.text_column_table"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               |           | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "text_column_table_f11_f12_idx" psort (f11, f12) TABLESPACE pg_default
    "text_column_table_f11_idx" psort (f11) TABLESPACE pg_default
    "text_column_table_f11_idx1" psort (f11) TABLESPACE pg_default
    "text_column_table_f11_idx2" cbtree (f11) TABLESPACE pg_default
    "text_column_table_f11_idx3" cbtree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=column, compression=low

drop table if exists text_column_table;
-- not support
alter table text_column_table add key using hash(f11);
ERROR:  relation "text_column_table" does not exist
alter table text_column_table add key ((abs(f11)));
ERROR:  relation "text_column_table" does not exist
-- test partition table
CREATE TABLE test_partition_btree
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
alter table test_partition_btree add index (f1 desc);
alter table test_partition_btree add key using btree(f1 desc, f2 asc, f3);
alter table test_partition_btree add key using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3);
\d+ test_partition_btree
            Table "test_table_index.test_partition_btree"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_partition_btree_abs_expr_f3_idx" btree (abs(f1) DESC, ((f2 OPERATOR(dolphin_catalog.*) 2) OPERATOR(dolphin_catalog.+) 1), f3) LOCAL TABLESPACE pg_default
    "test_partition_btree_f1_f2_f3_idx" btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
    "test_partition_btree_f1_idx" btree (f1 DESC) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table if exists test_partition_btree;
-- test temporary table
create temporary table test_temporary_index1(f11 int, f12 int, f13 int);
alter table test_temporary_index1 add key using btree(f11, f12);
alter table test_temporary_index1 add key using hash(f11);
alter table test_temporary_index1 add key idx_f11_f12 using btree(f11, f12);
alter table test_temporary_index1 add key((abs(f11)));
alter table test_temporary_index1 add key((f11 * 2 + 1));
alter table test_temporary_index1 add key(f11 desc, f12 asc);
alter table test_temporary_index1 add key using btree(f11, f12),add unique(f11, f12),add primary key(f11, f12);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_temporary_index1_pkey" for table "test_temporary_index1"
drop table if exists test_temporary_index1;
-- test index_options
create table test_option1(a int, b int, index idx_op1 using btree(a) comment 'yy');
alter table test_option1 add key ixd_at1 (b) comment 'aa';
\d+ test_option1
                Table "test_table_index.test_option1"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_op1" btree (a) TABLESPACE pg_default
    "ixd_at1" btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\di+ idx_op1
--?.*
--?.*
--?.*
--? public | idx_op1 | index | .*     | test_option1 | .* | .* | yy
(1 row)

\di+ ixd_at1
--?.*
--?.*
--?.*
--? public | ixd_at1 | index | .*     | test_option1 | .* | .* | aa
(1 row)

create table test_option2(a int, b int, key idx_op2 using hash(a) comment 'yy' comment 'xx');
alter table test_option2 add index ixd_at2 using hash(b) comment 'aa' comment 'bb';
\di+ idx_op2
--?.*
--?.*
--?.*
--? public | idx_op2 | index | .*     | test_option2 | .* | .* | xx
(1 row)

\di+ ixd_at2
--?.*
--?.*
--?.*
--? public | ixd_at2 | index | .*     | test_option2 | .* | .* | bb
(1 row)

create table test_option3(a int, b int, index idx_op3 (a) using btree);
alter table test_option3 add index ixd_at3(b) using btree;
\d+ test_option3
                Table "test_table_index.test_option3"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_op3" btree (a) TABLESPACE pg_default
    "ixd_at3" btree (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

create table test_option4(a int, b int, c int, key idx_op4 using hash(a) using btree using hash);
alter table test_option4 add index ixd_at4 using hash (b) using btree using hash, add unique(a), add primary key (c);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_option4_pkey" for table "test_option4"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_option4_a_key" for table "test_option4"
\d+ test_option4
                Table "test_table_index.test_option4"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
 c      | integer | not null  | plain   |              | 
Indexes:
    "test_option4_pkey" PRIMARY KEY, btree (c) TABLESPACE pg_default
    "test_option4_a_key" UNIQUE CONSTRAINT, btree (a) TABLESPACE pg_default
    "idx_op4" hash (a) TABLESPACE pg_default
    "ixd_at4" hash (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

create table test_option5(a int, b int, c int, index idx_op5 (a) using btree comment 'yy' using hash);
alter table test_option5 add index ixd_at5 using hash (b) using btree comment 'yy' using hash, add unique(a), add primary key (c);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_option5_pkey" for table "test_option5"
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_option5_a_key" for table "test_option5"
\d+ test_option5
                Table "test_table_index.test_option5"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
 c      | integer | not null  | plain   |              | 
Indexes:
    "test_option5_pkey" PRIMARY KEY, btree (c) TABLESPACE pg_default
    "test_option5_a_key" UNIQUE CONSTRAINT, btree (a) TABLESPACE pg_default
    "idx_op5" hash (a) TABLESPACE pg_default
    "ixd_at5" hash (b) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\di+ idx_op5
--?.*
--?.*
--?.*
--? public | idx_op5 | index | .*     | test_option5 | .* | .* | yy
(1 row)

\di+ ixd_at5
--?.*
--?.*
--?.*
--? public | ixd_at5 | index | .*     | test_option5 | .* | .* | yy
(1 row)

create table test_option6(a int, b int, key idx_op6 using hash(a) using btree comment 'yy' using hash comment 'xx');
\d+ test_option6
                Table "test_table_index.test_option6"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_op6" hash (a) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

\di+ idx_op6
--?.*
--?.*
--?.*
--? public | idx_op6 | index | .*     | test_option6 | .* | .* | xx
(1 row)

create table test_option7(a int, b int, index idx_op7 (a) using btree comment 'yy' using hash comment 'xx');
\d+ test_option7
                Table "test_table_index.test_option7"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
Indexes:
    "idx_op7" hash (a) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

create table test_option8(a int, b int, c int, key idx_op8_a (a) using btree comment 'yy' using hash comment 'xx', index idx_op8_b (b) using btree comment 'yy' using hash comment 'xx');
alter table test_option8 add index ixd_at8_b(b) using btree comment 'yy' using hash comment 'xx', add index ixd_at8_c (c) using btree comment 'yy' using hash comment 'xx';
\d+ test_option8
                Table "test_table_index.test_option8"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 a      | integer |           | plain   |              | 
 b      | integer |           | plain   |              | 
 c      | integer |           | plain   |              | 
Indexes:
    "idx_op8_a" hash (a) TABLESPACE pg_default
    "idx_op8_b" hash (b) TABLESPACE pg_default
    "ixd_at8_b" hash (b) TABLESPACE pg_default
    "ixd_at8_c" hash (c) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

CREATE TABLE test_option9
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key idx_op9 (f1) using btree comment 'yy'
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_option9
                Table "test_table_index.test_option9"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_op9" btree (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

\di+ idx_op9
--?.*
--?.*
--?.*
--? public | idx_op9 | index | .*     | test_option9 | .* | .* | yy
(1 row)

CREATE TABLE test_option10
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    key idx_op10 (f1) using btree comment 'yy' using hash comment 'xx'
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_option10
               Table "test_table_index.test_option10"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "idx_op10" hash (f1) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

\di+ idx_op10
--?.*
--?.*
--?.*
--? public | idx_op10 | index | .*     | test_option10 | .* | .* | xx
(1 row)

create global temporary table test_option11(f1 int, f2 int, f3 int, index idx_op11 using btree(f1) using btree comment 'yy' using hash comment 'xx');
create local temporary table test_option12(f1 int, f2 int, f3 int, index idx_op12 using btree(f1) using btree comment 'yy' using hash comment 'xx');
-- fail example
create table test_option13(a int, b int, index idx_op13 using aaa (a) using btree);
ERROR:  access method "aaa" does not exist
create table test_option14(a int, b int, index idx_op14 using btree (a) using aaa);
ERROR:  access method "aaa" does not exist
create table test_option15(a int, b int, index idx_op15 using btree (a) using aaa using btree);
ERROR:  access method "aaa" does not exist
create table test_option16(a int, b int, index idx_op16 using btree (a) using aaa using btree comment 'xx');
ERROR:  access method "aaa" does not exist
alter table test_option1 add key ixd_at11 using aaa (b) using btree;
ERROR:  access method "aaa" does not exist
alter table test_option1 add key ixd_at12 using btree (b) using aaa;
ERROR:  access method "aaa" does not exist
alter table test_option1 add key ixd_at13 using btree (b) using aaa using btree;
ERROR:  access method "aaa" does not exist
alter table test_option1 add key ixd_at14 using btree (b) comment 'xx' using aaa using btree;
ERROR:  access method "aaa" does not exist
drop schema test_table_index cascade;
NOTICE:  drop cascades to 11 other objects
DETAIL:  drop cascades to table test_option1
drop cascades to table test_option2
drop cascades to table test_option3
drop cascades to table test_option4
drop cascades to table test_option5
drop cascades to table test_option6
drop cascades to table test_option7
drop cascades to table test_option8
drop cascades to table test_option9
drop cascades to table test_option10
drop cascades to table test_option11
reset current_schema;
-- B_FORMAT Database non-unique index create foreign key.
create table t1(id int, name varchar);
create table t2(id int, a_id int);
-- create non-unique index on table t1.
create index a_index_1 on t1(id);
-- create foreign key on non-unique index
alter table t2 add constraint t2_fk foreign key (a_id) references t1(id);
\d t1
           Table "public.t1"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 id     | integer           | 
 name   | character varying | 
Indexes:
    "a_index_1" btree (id) TABLESPACE pg_default
Referenced by:
    TABLE "t2" CONSTRAINT "t2_fk" FOREIGN KEY (a_id) REFERENCES t1(id)

\d t2
      Table "public.t2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 id     | integer | 
 a_id   | integer | 
Foreign-key constraints:
    "t2_fk" FOREIGN KEY (a_id) REFERENCES t1(id)

insert into t1 values(1,'a'),(2,'b');
select * from t1;
 id | name 
----+------
  1 | a
  2 | b
(2 rows)

insert into t2 values(1,1);
select * from t2;
 id | a_id 
----+------
  1 |    1
(1 row)

insert into t2 values(1,3);
ERROR:  insert or update on table "t2" violates foreign key constraint "t2_fk"
DETAIL:  Key (a_id)=(3) is not present in table "t1".
select * from t2;
 id | a_id 
----+------
  1 |    1
(1 row)

alter table t2 drop constraint t2_fk;
alter table t2 add constraint t2_fk foreign key (a_id) references t1(id) on update cascade;
select * from t1;
 id | name 
----+------
  1 | a
  2 | b
(2 rows)

insert into t1 values(1,'s');
select * from t1;
 id | name 
----+------
  1 | a
  2 | b
  1 | s
(3 rows)

insert into t2 values(2,1);
select * from t2;
 id | a_id 
----+------
  1 |    1
  2 |    1
(2 rows)

update t1 set id = 11 where name = 'a';
select * from t1;
 id | name 
----+------
  2 | b
  1 | s
 11 | a
(3 rows)

select * from t2;
 id | a_id 
----+------
  1 |   11
  2 |   11
(2 rows)

update t1 set id =1 where name = 'a';
alter table t2 drop constraint t2_fk;
alter table t2 add constraint t2_fk foreign key (a_id) references t1(id) on delete cascade;
select * from t1;
 id | name 
----+------
  2 | b
  1 | s
  1 | a
(3 rows)

select * from t2;
 id | a_id 
----+------
  1 |    1
  2 |    1
(2 rows)

delete from t1 where name = 's';
select * from t1;
 id | name 
----+------
  2 | b
  1 | a
(2 rows)

select * from t2;
 id | a_id 
----+------
(0 rows)


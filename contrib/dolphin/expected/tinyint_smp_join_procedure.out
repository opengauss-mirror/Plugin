create schema tinyint_smp;
set current_schema to 'tinyint_smp';
set enable_opfusion = on;
set opfusion_debug_mode = log;
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
drop table if exists t2;
NOTICE:  table "t2" does not exist, skipping
create table t1(a int1);
create table t2(a int4);
insert into t2 select generate_series(0, 1000000);
insert into t1 select a % 128 from t2;
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on tinyint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: tinyint_smp.t2.a
   ->  Seq Scan on tinyint_smp.t2
         Output: tinyint_smp.t2.a
         Filter: ((tinyint_smp.t2.a = 2) AND (tinyint_smp.t2.a > 500))
   ->  Materialize
         Output: tinyint_smp.t2.a
         ->  Seq Scan on tinyint_smp.t2
               Output: tinyint_smp.t2.a
               Filter: ((tinyint_smp.t2.a > 500) AND (tinyint_smp.t2.a = 2))
(11 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on tinyint_smp.t2
         Output: a
         Filter: (t2.a = 2)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: tinyint_smp.t2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: tinyint_smp.t2.a
         ->  Seq Scan on tinyint_smp.t2
               Output: tinyint_smp.t2.a
               Filter: ((tinyint_smp.t2.a = 2) AND (tinyint_smp.t2.a > 500))
   ->  Materialize
         Output: tinyint_smp.t2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/4)
               Output: tinyint_smp.t2.a
               ->  Seq Scan on tinyint_smp.t2
                     Output: tinyint_smp.t2.a
                     Filter: ((tinyint_smp.t2.a > 500) AND (tinyint_smp.t2.a = 2))
(15 rows)

set query_dop = 1;
set opfusion_debug_mode = off;
create table join_1(a int1);
create table join_2(a int1);
insert into join_1 select a % 128 from t2;
insert into join_2 select a % 128 from t2;
set query_dop = 2;
explain(costs off, verbose) select * from join_1 join join_2;
                    QUERY PLAN                    
--------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Nested Loop
         Output: join_1.a, join_2.a
         ->  Streaming(type: BROADCAST dop: 2/2)
               Output: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Materialize
               Output: join_2.a
               ->  Seq Scan on tinyint_smp.join_2
                     Output: join_2.a
(12 rows)

explain(costs off, verbose) select * from join_1 join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Hash
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

explain(costs off, verbose) select * from join_1 left join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Left Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Hash
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

explain(costs off, verbose) select * from join_1 right join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Left Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_2.a = join_1.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_2.a
               Distribute Key: join_2.a
               ->  Seq Scan on tinyint_smp.join_2
                     Output: join_2.a
         ->  Hash
               Output: join_1.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_1.a
                     Distribute Key: join_1.a
                     ->  Seq Scan on tinyint_smp.join_1
                           Output: join_1.a
(17 rows)

explain(costs off, verbose) select * from join_1 inner join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Hash
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

explain(costs off, verbose) select /*+ nestloop(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Nested Loop Left Join
         Output: join_1.a, join_2.a
         Join Filter: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Materialize
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

explain(costs off, verbose) select /*+ hashjoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Left Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Hash
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

explain(costs off, verbose) select /*+ mergejoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   Output: join_1.a, join_2.a
   ->  Hash Left Join
         Output: join_1.a, join_2.a
         Hash Cond: (join_1.a = join_2.a)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               Output: join_1.a
               Distribute Key: join_1.a
               ->  Seq Scan on tinyint_smp.join_1
                     Output: join_1.a
         ->  Hash
               Output: join_2.a
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     Output: join_2.a
                     Distribute Key: join_2.a
                     ->  Seq Scan on tinyint_smp.join_2
                           Output: join_2.a
(17 rows)

create procedure test_p1(int1, tinyint)
SHIPPABLE VOLATILE
as
begin
    insert into test1 values($1 + $2);
end;
/
create table test1(a int1);
select test_p1(1, 3);
 test_p1 
---------
 
(1 row)

select test_p1(-1, -3);
 test_p1 
---------
 
(1 row)

select * from test1;
 a  
----
 4
 -4
(2 rows)

drop schema tinyint_smp cascade;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table t1
drop cascades to table t2
drop cascades to table join_1
drop cascades to table join_2
drop cascades to function test_p1(tinyint,tinyint)
drop cascades to table test1
reset current_schema;

create schema test_bit_xor;
set current_schema to 'test_bit_xor';
set dolphin.b_compatibility_mode to on;
-- test datetime
create table test_datetime (t datetime);
select bit_xor(t) from test_datetime;
 bit_xor 
---------
       0
(1 row)

insert into test_datetime values ('1000-01-01 00:00:00');
select bit_xor(t) from test_datetime;
    bit_xor     
----------------
 10000101000000
(1 row)

insert into test_datetime values ('9999-12-31 23:59:59');
select bit_xor(t) from test_datetime;
    bit_xor     
----------------
 92261562336311
(1 row)

insert into test_datetime values ('2000-01-30 -01:-10:-59');
select bit_xor(t) from test_datetime;
    bit_xor     
----------------
 72404374342532
(1 row)

insert into test_datetime values (null);
select bit_xor(t) from test_datetime;
    bit_xor     
----------------
 72404374342532
(1 row)

create table test_timestamp (t timestamp);
select bit_xor(t) from test_timestamp;
 bit_xor 
---------
       0
(1 row)

insert into test_timestamp values ('1979-01-01 00:00:00');
select bit_xor(t) from test_timestamp;
    bit_xor     
----------------
 19790101000000
(1 row)

insert into test_timestamp values ('2038-01-19 03:14:08');
select bit_xor(t) from test_timestamp;
    bit_xor    
---------------
 3808028651824
(1 row)

insert into test_timestamp values ('2000-01-30 -23:-59:-59');
select bit_xor(t) from test_timestamp;
    bit_xor     
----------------
 18992422555399
(1 row)

insert into test_timestamp values (null);
select bit_xor(t) from test_timestamp;
    bit_xor     
----------------
 18992422555399
(1 row)

drop table test_datetime;
drop table test_timestamp;
--test int
CREATE TABLE bit_xor_int1(a TINYINT);
INSERT INTO bit_xor_int1(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_int1;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_int1(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_int1;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_int1(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_int1;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_int1;
-- test smallint
CREATE TABLE bit_xor_int2(a SMALLINT);
INSERT INTO bit_xor_int2(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_int2;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_int2(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_int2;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_int2(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_int2;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_int2;
--test mediumint
CREATE TABLE bit_xor_int3(a MEDIUMINT);
INSERT INTO bit_xor_int3(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_int3;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_int3(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_int3;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_int3(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_int3;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_int3;
-- test int
CREATE TABLE bit_xor_int4(a INT);
INSERT INTO bit_xor_int4(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_int4;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_int4(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_int4;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_int4(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_int4;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_int4;
-- test bigint
CREATE TABLE bit_xor_int8(a BIGINT);
INSERT INTO bit_xor_int8(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_int8;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_int8(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_int8;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_int8(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_int8;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_int8;
-- test float
CREATE TABLE bit_xor_float(a FLOAT);
INSERT INTO bit_xor_float(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_float;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_float(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_float;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_float(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_float;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_float;
-- test double
CREATE TABLE bit_xor_double(a DOUBLE);
INSERT INTO bit_xor_double(a) values(-1.11);
SELECT BIT_XOR(a) from bit_xor_double;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_double(a) values(1.11);
SELECT BIT_XOR(a) from bit_xor_double;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_double(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_double;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_double;
-- test decimal
CREATE TABLE bit_xor_dec(a DECIMAL(5,2));
INSERT INTO bit_xor_dec(a) values(-1.11);
INSERT INTO bit_xor_dec(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_dec;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

DROP TABLE if exists bit_xor_dec;
-- test char
CREATE TABLE bit_xor_char(a CHAR(5));
INSERT INTO bit_xor_char(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_char;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_char(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_char;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_char(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_char;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_char;
--test varchar
CREATE TABLE bit_xor_varchar(a VARCHAR(5));
INSERT INTO bit_xor_varchar(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_varchar;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_varchar(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_varchar;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_varchar(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_varchar;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_varchar;
-- test tinyblob
CREATE TABLE bit_xor_tinyblob(a TINYBLOB);
INSERT INTO bit_xor_tinyblob(a) values('111');
SELECT BIT_XOR(a) from bit_xor_tinyblob;
 bit_xor 
---------
 111
(1 row)

INSERT INTO bit_xor_tinyblob(a) values('101');
SELECT BIT_XOR(a) from bit_xor_tinyblob;
 bit_xor 
---------
 10
(1 row)

INSERT INTO bit_xor_tinyblob(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_tinyblob;
 bit_xor 
---------
 10
(1 row)

DROP TABLE if exists bit_xor_tinyblob;
-- test tinytext
CREATE TABLE bit_xor_tinytext(a TINYTEXT);
INSERT INTO bit_xor_tinytext(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_tinytext;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_tinytext(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_tinytext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_tinytext(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_tinytext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_tinytext;
-- test text
CREATE TABLE bit_xor_text(a TEXT);
INSERT INTO bit_xor_text(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_text;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_text(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_text;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

delete from bit_xor_text;
INSERT INTO bit_xor_text(a) values('1.999');
SELECT BIT_XOR(a) from bit_xor_text;
 bit_xor 
---------
 1
(1 row)

INSERT INTO bit_xor_text(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_text;
 bit_xor 
---------
 1
(1 row)

DROP TABLE if exists bit_xor_text;
CREATE TABLE bit_xor_text(a TEXT);
INSERT INTO bit_xor_text(a) values('111111111111111111111111111111111111111111111111');
SELECT BIT_XOR(a) from bit_xor_text;
       bit_xor       
---------------------
 9223372036854775807
(1 row)

delete from bit_xor_text;
INSERT INTO bit_xor_text(a) values('-111111111111111111111111111111111111111111111111');
SELECT BIT_XOR(a) from bit_xor_text;
       bit_xor       
---------------------
 9223372036854775808
(1 row)

INSERT INTO bit_xor_text(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_text;
       bit_xor       
---------------------
 9223372036854775808
(1 row)

DROP TABLE if exists bit_xor_text;
CREATE TABLE bit_xor_mediumtext(a MEDIUMTEXT);
INSERT INTO bit_xor_mediumtext(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_mediumtext;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_mediumtext(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_mediumtext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_mediumtext(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_mediumtext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_mediumtext;
CREATE TABLE bit_xor_longtext(a LONGTEXT);
INSERT INTO bit_xor_longtext(a) values('-1.11');
SELECT BIT_XOR(a) from bit_xor_longtext;
       bit_xor        
----------------------
 18446744073709551615
(1 row)

INSERT INTO bit_xor_longtext(a) values('1.11');
SELECT BIT_XOR(a) from bit_xor_longtext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

INSERT INTO bit_xor_longtext(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_longtext;
       bit_xor        
----------------------
 18446744073709551614
(1 row)

DROP TABLE if exists bit_xor_longtext;
-- test blob
CREATE TABLE bit_xor_blob(a BLOB);
INSERT INTO bit_xor_blob(a) values('111');
SELECT BIT_XOR(a) from bit_xor_blob;
 bit_xor 
---------
 111
(1 row)

INSERT INTO bit_xor_blob(a) values('101');
SELECT BIT_XOR(a) from bit_xor_blob;
 bit_xor 
---------
 10
(1 row)

INSERT INTO bit_xor_blob(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_blob;
 bit_xor 
---------
 10
(1 row)

DROP TABLE if exists bit_xor_blob;
CREATE TABLE bit_xor_mediumblob(a MEDIUMBLOB);
INSERT INTO bit_xor_mediumblob(a) values('111');
SELECT BIT_XOR(a) from bit_xor_mediumblob;
 bit_xor 
---------
 111
(1 row)

INSERT INTO bit_xor_mediumblob(a) values('101');
SELECT BIT_XOR(a) from bit_xor_mediumblob;
 bit_xor 
---------
 10
(1 row)

INSERT INTO bit_xor_mediumblob(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_mediumblob;
 bit_xor 
---------
 10
(1 row)

DROP TABLE if exists bit_xor_mediumblob;
CREATE TABLE bit_xor_longblob(a LONGBLOB);
INSERT INTO bit_xor_longblob(a) values('111');
SELECT BIT_XOR(a) from bit_xor_longblob;
 bit_xor 
---------
 111
(1 row)

INSERT INTO bit_xor_longblob(a) values('101');
SELECT BIT_XOR(a) from bit_xor_longblob;
 bit_xor 
---------
 10
(1 row)

INSERT INTO bit_xor_longblob(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_longblob;
 bit_xor 
---------
 10
(1 row)

DROP TABLE if exists bit_xor_longblob;
-- test raw
CREATE TABLE bit_xor_raw(a raw);
INSERT INTO bit_xor_raw(a) values('111');
SELECT BIT_XOR(a) from bit_xor_raw;
 bit_xor 
---------
 111
(1 row)

INSERT INTO bit_xor_raw(a) values('101');
SELECT BIT_XOR(a) from bit_xor_raw;
 bit_xor 
---------
 10
(1 row)

INSERT INTO bit_xor_raw(a) values(NULL);
SELECT BIT_XOR(a) from bit_xor_raw;
 bit_xor 
---------
 10
(1 row)

DROP TABLE if exists bit_xor_raw;
create table test_time (t time);
insert into test_time values('-00:00:01');
insert into test_time values('-01:00:00');
insert into test_time values('-01:00:01');
select bit_xor(t) from test_time;
       bit_xor        
----------------------
 18446744073709551584
(1 row)

insert into test_time values('12:59:59.999');
insert into test_time values('00:00:01');
insert into test_time values('838:59:59');
-- 表中数据为
select * from test_time;
     t     
-----------
 -00:00:01
 -01:00:00
 -01:00:01
 13:00:00
 00:00:01
 838:59:59
(6 rows)

-- 测试不含时区的time类型
select bit_xor(t) from test_time;
       bit_xor        
----------------------
 18446744073701290390
(1 row)

create table test_time_with_zone (t time with time zone);
insert into test_time_with_zone values('00:00:01 UTC');
insert into test_time_with_zone values('00:00:02 PST');
insert into test_time_with_zone values('00:10:00 CST');
insert into test_time_with_zone values('10:00:01 JST');
insert into test_time_with_zone values('23:59:59 CCT');
-- 表中数据为
select * from test_time_with_zone;
      t      
-------------
 00:00:01+00
 00:00:02-08
 00:10:00-06
 10:00:01+09
 23:59:59+08
(5 rows)

-- 测试含时区的time类型
select bit_xor(t) from test_time_with_zone;
 bit_xor 
---------
  138493
(1 row)

-- 测试空值
create table test_time_with_null (t time);
insert into test_time_with_null values(NULL);
insert into test_time_with_null values('12:34:56');
insert into test_time_with_null values(NULL);
select * from test_time_with_null;
    t     
----------
 
 12:34:56
 
(3 rows)

select bit_xor(t) from test_time_with_null;
 bit_xor 
---------
  123456
(1 row)

create table test_time_with_zone_with_null (t time with time zone);
insert into test_time_with_zone_with_null values(NULL);
insert into test_time_with_zone_with_null values('12:34:56 UTC');
insert into test_time_with_zone_with_null values(NULL);
select * from test_time_with_zone_with_null;
      t      
-------------
 
 12:34:56+00
 
(3 rows)

select bit_xor(t) from test_time_with_zone_with_null;
 bit_xor 
---------
  123456
(1 row)

-- test date
create table test_date(col date);
insert into test_date values('2022-01-01');
select bit_xor(col) from test_date;
 bit_xor  
----------
 20220101
(1 row)

insert into test_date values('2022-01-02');
select bit_xor(col) from test_date;
 bit_xor 
---------
       3
(1 row)

insert into test_date values(null);
select bit_xor(col) from test_date;
 bit_xor 
---------
       3
(1 row)

drop table test_date;
create table test_date(col date);
insert into test_date values('22-01-01');
select bit_xor(col) from test_date;
 bit_xor  
----------
 20220101
(1 row)

insert into test_date values('22-01-02');
select bit_xor(col) from test_date;
 bit_xor 
---------
       3
(1 row)

-- test year
create table test_year(col year);
insert into test_year values('2022');
select bit_xor(col) from test_year;
 bit_xor 
---------
    2022
(1 row)

insert into test_year values('2021');
select bit_xor(col) from test_year;
 bit_xor 
---------
       3
(1 row)

insert into test_year values(null);
select bit_xor(col) from test_year;
 bit_xor 
---------
       3
(1 row)

drop table test_year;
create table test_year(col year);
insert into test_year values('22');
select bit_xor(col) from test_year;
 bit_xor 
---------
    2022
(1 row)

insert into test_year values('21');
select bit_xor(col) from test_year;
 bit_xor 
---------
       3
(1 row)

drop table test_year;
-- test bit
create table test_bit(col bit);
insert into test_bit values(b'1');
select bit_xor(col) from test_bit;
 bit_xor 
---------
       1
(1 row)

insert into test_bit values(b'0');
select bit_xor(col) from test_bit;
 bit_xor 
---------
       1
(1 row)

insert into test_bit values(null);
select bit_xor(col) from test_bit;
 bit_xor 
---------
       1
(1 row)

drop table test_bit;
create table test_bit(col bit(8));
insert into test_bit values(b'11');
select bit_xor(col) from test_bit;
 bit_xor 
---------
       3
(1 row)

insert into test_bit values(b'101');
select bit_xor(col) from test_bit;
 bit_xor 
---------
       6
(1 row)

-- test varbit
create table test_varbit(col varbit);
insert into test_varbit values(b'1');
select bit_xor(col) from test_varbit;
 bit_xor 
---------
       1
(1 row)

insert into test_varbit values(b'0');
select bit_xor(col) from test_varbit;
 bit_xor 
---------
       1
(1 row)

insert into test_varbit values(null);
select bit_xor(col) from test_varbit;
 bit_xor 
---------
       1
(1 row)

drop table test_varbit;
create table test_varbit(col bit(8));
insert into test_varbit values(b'11');
select bit_xor(col) from test_varbit;
 bit_xor 
---------
       3
(1 row)

insert into test_varbit values(b'101');
select bit_xor(col) from test_varbit;
 bit_xor 
---------
       6
(1 row)

drop table test_varbit;
drop table if exists test_type_table cascade;
NOTICE:  table "test_type_table" does not exist, skipping
create table test_type_table
(
    `int1` tinyint,
    `uint1` tinyint unsigned,
    `int2` smallint,
    `uint2` smallint unsigned,
    `int4` integer,
    `uint4` integer unsigned,
    `int8` bigint,
    `uint8` bigint unsigned,
    `float4` float4,
    `float8` float8,
    `numeric` decimal(20, 6),
    `bit1` bit(1),
    `bit64` bit(64),
    `boolean` boolean,
    `date` date,
    `time` time,
    `time(4)` time(4),
    `datetime` datetime,
    `datetime(4)` datetime(4) default '2022-11-11 11:11:11',
    `timestamp` timestamp,
    `timestamp(4)` timestamp(4) default '2022-11-11 11:11:11',
    `year` year,
    `char` char(100),
    `varchar` varchar(100),
    `binary` binary(100),
    `varbinary` varbinary(100),
    `tinyblob` tinyblob,
    `blob` blob,
    `mediumblob` mediumblob,
    `longblob` longblob,
    `text` text,
    `nullvalue` bit(1),
    `bignumber` bigint,
    `bigstring` text
);
drop table if exists test_type_table_2 cascade;
NOTICE:  table "test_type_table_2" does not exist, skipping
create table test_type_table_2
(
    `int1` tinyint,
    `uint1` tinyint unsigned,
    `int2` smallint,
    `uint2` smallint unsigned,
    `int4` integer,
    `uint4` integer unsigned,
    `int8` bigint,
    `uint8` bigint unsigned,
    `float4` float4,
    `float8` float8,
    `numeric` decimal(20, 6),
    `bit1` bit(1),
    `bit64` bit(64),
    `boolean` boolean,
    `date` date,
    `time` time,
    `time(4)` time(4),
    `datetime` datetime,
    `datetime(4)` datetime(4) default '2022-11-11 11:11:11',
    `timestamp` timestamp,
    `timestamp(4)` timestamp(4) default '2022-11-11 11:11:11',
    `year` year,
    `char` char(100),
    `varchar` varchar(100),
    `binary` binary(100),
    `varbinary` varbinary(100),
    `tinyblob` tinyblob,
    `blob` blob,
    `mediumblob` mediumblob,
    `longblob` longblob,
    `text` text,
    `nullvalue` bit(1),
    `bignumber` bigint,
    `bigstring` text
);
insert into test_type_table values (
	1, 1, 1, 1, 
	1, 1, 1, 1, 
	1, 1, 1, b'1', 
	b'111', true, '2023-02-05', '19:10:50', 
	'19:10:50.3456', '2023-02-05 19:10:50', '2023-02-05 19:10:50.456', '2023-02-05 19:10:50', 
	'2023-02-05 19:10:50.456', '2023', '123a', '123a', 
	'123a', '123a', '123a', '123a',
	'123a', '123a', '123a', null, 
    9223372036854775807, 'openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。'
);
insert into test_type_table_2 values (
	2, 2, 2, 2,
	2, 2, 2, 2,
	2, 2, 2, b'0',
	b'100', false, '2023-02-06', '20:11:51',
	'19:11:51.3457', '2023-02-06 19:10:51', '2023-02-06 19:10:50.457', '2023-02-06 19:10:51',
	'2023-02-06 19:10:50.457', '2024', '124b', '124b',
	'124b', '124b', '124b', '124b',
	'124b', '124b', '124b', null, 
    -9223372036854775808, 'openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。'
);
drop view if exists res_view;
NOTICE:  view "res_view" does not exist, skipping
create view res_view as select
 a.`int1` ^ b.`int1` as 'a.`int1` ^ b.`int1`',
 a.`uint1` ^ b.`uint1` as 'a.`uint1` ^ b.`uint1`',
 a.`int2` ^ b.`int2` as 'a.`int2` ^ b.`int2`',
 a.`uint2` ^ b.`uint2` as 'a.`uint2` ^ b.`uint2`',
 a.`int4` ^ b.`int4` as 'a.`int4` ^ b.`int4`',
 a.`uint4` ^ b.`uint4` as 'a.`uint4` ^ b.`uint4`',
 a.`int8` ^ b.`int8` as 'a.`int8` ^ b.`int8`',
 a.`uint8` ^ b.`uint8` as 'a.`uint8` ^ b.`uint8`',
 a.`float4` ^ b.`float4` as 'a.`float4` ^ b.`float4`',
 a.`float8` ^ b.`float8` as 'a.`float8` ^ b.`float8`',
 a.`numeric` ^ b.`numeric` as 'a.`numeric` ^ b.`numeric`',
 a.`bit1` ^ b.`bit1` as 'a.`bit1` ^ b.`bit1`',
 a.`bit64` ^ b.`bit64` as 'a.`bit64` ^ b.`bit64`',
 a.`boolean` ^ b.`boolean` as 'a.`boolean` ^ b.`boolean`',
 a.`date` ^ b.`date` as 'a.`date` ^ b.`date`',
 a.`time` ^ b.`time` as 'a.`time` ^ b.`time`',
 a.`time(4)` ^ b.`time(4)` as 'a.`time(4)` ^ b.`time(4)`',
 a.`datetime` ^ b.`datetime` as 'a.`datetime` ^ b.`datetime`',
 a.`datetime(4)` ^ b.`datetime(4)` as 'a.`datetime(4)` ^ b.`datetime(4)`',
 a.`timestamp` ^ b.`timestamp` as 'a.`timestamp` ^ b.`timestamp`',
 a.`timestamp(4)` ^ b.`timestamp(4)` as 'a.`timestamp(4)` ^ b.`timestamp(4)`',
 a.`year` ^ b.`year` as 'a.`year` ^ b.`year`',
 a.`char` ^ b.`char` as 'a.`char` ^ b.`char`',
 a.`varchar` ^ b.`varchar` as 'a.`varchar` ^ b.`varchar`',
 a.`binary` ^ b.`binary` as 'a.`binary` ^ b.`binary`',
 a.`varbinary` ^ b.`varbinary` as 'a.`varbinary` ^ b.`varbinary`',
 a.`tinyblob` ^ b.`tinyblob` as 'a.`tinyblob` ^ b.`tinyblob`',
 a.`blob` ^ b.`blob` as 'a.`blob` ^ b.`blob`',
 a.`mediumblob` ^ b.`mediumblob` as 'a.`mediumblob` ^ b.`mediumblob`',
 a.`longblob` ^ b.`longblob` as 'a.`longblob` ^ b.`longblob`',
 a.`text` ^ b.`text` as 'a.`text` ^ b.`text`'
 from test_type_table as a, test_type_table_2 as b;
\x
select * from res_view;
-[ RECORD 1 ]-----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
a.`int1` ^ b.`int1`                 | 3
a.`uint1` ^ b.`uint1`               | 3
a.`int2` ^ b.`int2`                 | 3
a.`uint2` ^ b.`uint2`               | 3
a.`int4` ^ b.`int4`                 | 3
a.`uint4` ^ b.`uint4`               | 3
a.`int8` ^ b.`int8`                 | 3
a.`uint8` ^ b.`uint8`               | 3
a.`float4` ^ b.`float4`             | 3
a.`float8` ^ b.`float8`             | 3
a.`numeric` ^ b.`numeric`           | 3
a.`bit1` ^ b.`bit1`                 | 1
a.`bit64` ^ b.`bit64`               | 3
a.`boolean` ^ b.`boolean`           | 1
a.`date` ^ b.`date`                 | 3
a.`time` ^ b.`time`                 | 130037
a.`time(4)` ^ b.`time(4)`           | 229
a.`datetime` ^ b.`datetime`         | 7423553
a.`datetime(4)` ^ b.`datetime(4)`   | 7423552
a.`timestamp` ^ b.`timestamp`       | 7423553
a.`timestamp(4)` ^ b.`timestamp(4)` | 7423552
a.`year` ^ b.`year`                 | 15
a.`char` ^ b.`char`                 | 7
a.`varchar` ^ b.`varchar`           | 7
a.`binary` ^ b.`binary`             | \x00000703000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
a.`varbinary` ^ b.`varbinary`       | \x00000703
a.`tinyblob` ^ b.`tinyblob`         | \x00000703
a.`blob` ^ b.`blob`                 | \x00000703
a.`mediumblob` ^ b.`mediumblob`     | \x00000703
a.`longblob` ^ b.`longblob`         | \x00000703
a.`text` ^ b.`text`                 | 7

\x
desc res_view;
                Field                |    Type     | Null | Key | Default | Extra 
-------------------------------------+-------------+------+-----+---------+-------
 a.`int1` ^ b.`int1`                 | uint8       | YES  |     | NULL    | 
 a.`uint1` ^ b.`uint1`               | uint8       | YES  |     | NULL    | 
 a.`int2` ^ b.`int2`                 | uint8       | YES  |     | NULL    | 
 a.`uint2` ^ b.`uint2`               | uint8       | YES  |     | NULL    | 
 a.`int4` ^ b.`int4`                 | uint8       | YES  |     | NULL    | 
 a.`uint4` ^ b.`uint4`               | uint8       | YES  |     | NULL    | 
 a.`int8` ^ b.`int8`                 | uint8       | YES  |     | NULL    | 
 a.`uint8` ^ b.`uint8`               | uint8       | YES  |     | NULL    | 
 a.`float4` ^ b.`float4`             | uint8       | YES  |     | NULL    | 
 a.`float8` ^ b.`float8`             | uint8       | YES  |     | NULL    | 
 a.`numeric` ^ b.`numeric`           | uint8       | YES  |     | NULL    | 
 a.`bit1` ^ b.`bit1`                 | uint8       | YES  |     | NULL    | 
 a.`bit64` ^ b.`bit64`               | uint8       | YES  |     | NULL    | 
 a.`boolean` ^ b.`boolean`           | uint8       | YES  |     | NULL    | 
 a.`date` ^ b.`date`                 | uint8       | YES  |     | NULL    | 
 a.`time` ^ b.`time`                 | uint8       | YES  |     | NULL    | 
 a.`time(4)` ^ b.`time(4)`           | uint8       | YES  |     | NULL    | 
 a.`datetime` ^ b.`datetime`         | uint8       | YES  |     | NULL    | 
 a.`datetime(4)` ^ b.`datetime(4)`   | uint8       | YES  |     | NULL    | 
 a.`timestamp` ^ b.`timestamp`       | uint8       | YES  |     | NULL    | 
 a.`timestamp(4)` ^ b.`timestamp(4)` | uint8       | YES  |     | NULL    | 
 a.`year` ^ b.`year`                 | uint8       | YES  |     | NULL    | 
 a.`char` ^ b.`char`                 | uint8       | YES  |     | NULL    | 
 a.`varchar` ^ b.`varchar`           | uint8       | YES  |     | NULL    | 
 a.`binary` ^ b.`binary`             | "varbinary" | YES  |     | NULL    | 
 a.`varbinary` ^ b.`varbinary`       | "varbinary" | YES  |     | NULL    | 
 a.`tinyblob` ^ b.`tinyblob`         | "varbinary" | YES  |     | NULL    | 
 a.`blob` ^ b.`blob`                 | blob        | YES  |     | NULL    | 
 a.`mediumblob` ^ b.`mediumblob`     | mediumblob  | YES  |     | NULL    | 
 a.`longblob` ^ b.`longblob`         | longblob    | YES  |     | NULL    | 
 a.`text` ^ b.`text`                 | uint8       | YES  |     | NULL    | 
(31 rows)

drop view if exists res_view;
-- strict mode test
set dolphin.sql_mode='sql_mode_strict,pad_char_to_full_length,auto_recompile_function';
-- Abnormal arguments (null、large number、long string、different input types)
select `nullvalue` ^ `bit1` from test_type_table;
 ?column? 
----------
 
(1 row)

select `bit1` ^ `nullvalue` from test_type_table;
 ?column? 
----------
 
(1 row)

select `nullvalue` ^ `nullvalue` from test_type_table;
 ?column? 
----------
 
(1 row)

select `bignumber` ^ `bignumber` from test_type_table;
 ?column? 
----------
 0
(1 row)

select `bigstring` ^ `bigstring` from test_type_table;
 ?column? 
----------
 0
(1 row)

select `bit1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int2` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint2` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `float4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `float8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `numeric` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `date` ^ `bit64` from test_type_table;
 ?column? 
----------
 20230202
(1 row)

select `time` ^ `bit64` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `time(4)` ^ `bit64` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `datetime` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `datetime(4)` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `timestamp` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `timestamp(4)` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `year` ^ `bit64` from test_type_table;
 ?column? 
----------
 2016
(1 row)

select `char` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a                                                                                                "
 ?column? 
----------
 124
(1 row)

select `varchar` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `binary` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `varbinary` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `tinyblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `blob` ^ `bit64` from test_type_table;
 ?column? 
----------
 124
(1 row)

select `mediumblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `longblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `text` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `bit1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int2` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint2` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `float4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `float8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `numeric` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `date` from test_type_table;
 ?column? 
----------
 20230202
(1 row)

select `bit64` ^ `time` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `bit64` ^ `time(4)` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `bit64` ^ `datetime` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `datetime(4)` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `timestamp` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `timestamp(4)` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `year` from test_type_table;
 ?column? 
----------
 2016
(1 row)

select `bit64` ^ `char` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a                                                                                                "
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `varchar` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `binary` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `varbinary` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `tinyblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `blob` from test_type_table;
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `mediumblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `longblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `text` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

-- IUD
insert into test_type_table(`int1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int1`) values(b'1' ^ b'0');
insert into test_type_table(`uint1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint1`) values(b'1' ^ b'0');
insert into test_type_table(`int2`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int2`) values(b'1' ^ b'0');
insert into test_type_table(`uint2`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint2`) values(b'1' ^ b'0');
insert into test_type_table(`int4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int4`) values(b'1' ^ b'0');
insert into test_type_table(`uint4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint4`) values(b'1' ^ b'0');
insert into test_type_table(`int8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int8`) values(b'1' ^ b'0');
insert into test_type_table(`uint8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint8`) values(b'1' ^ b'0');
insert into test_type_table(`float4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`float4`) values(b'1' ^ b'0');
insert into test_type_table(`float8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`float8`) values(b'1' ^ b'0');
insert into test_type_table(`numeric`) values(b'1' ^ b'0');
insert ignore into test_type_table(`numeric`) values(b'1' ^ b'0');
insert into test_type_table(`bit1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bit1`) values(b'1' ^ b'0');
insert into test_type_table(`bit64`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bit64`) values(b'1' ^ b'0');
insert into test_type_table(`boolean`) values(b'1' ^ b'0');
insert ignore into test_type_table(`boolean`) values(b'1' ^ b'0');
insert into test_type_table(`date`) values(b'1' ^ b'0');
ERROR:  Out of range value for date
CONTEXT:  referenced column: date
insert ignore into test_type_table(`date`) values(b'1' ^ b'0');
WARNING:  Out of range value for date
CONTEXT:  referenced column: date
insert into test_type_table(`time`) values(b'1' ^ b'0');
insert ignore into test_type_table(`time`) values(b'1' ^ b'0');
insert into test_type_table(`time(4)`) values(b'1' ^ b'0');
insert ignore into test_type_table(`time(4)`) values(b'1' ^ b'0');
insert into test_type_table(`datetime`) values(b'1' ^ b'0');
ERROR:  column "datetime" is of type timestamp without time zone but expression is of type uint8
LINE 1: insert into test_type_table(`datetime`) values(b'1' ^ b'0');
                                                       ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: datetime
insert ignore into test_type_table(`datetime`) values(b'1' ^ b'0');
WARNING:  column "datetime" is of type timestamp without time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: datetime
insert into test_type_table(`datetime(4)`) values(b'1' ^ b'0');
ERROR:  column "datetime(4)" is of type timestamp without time zone but expression is of type uint8
LINE 1: insert into test_type_table(`datetime(4)`) values(b'1' ^ b'0...
                                                          ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: datetime(4)
insert ignore into test_type_table(`datetime(4)`) values(b'1' ^ b'0');
WARNING:  column "datetime(4)" is of type timestamp without time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: datetime(4)
insert into test_type_table(`timestamp`) values(b'1' ^ b'0');
ERROR:  column "timestamp" is of type timestamp with time zone but expression is of type uint8
LINE 1: insert into test_type_table(`timestamp`) values(b'1' ^ b'0')...
                                                        ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: timestamp
insert ignore into test_type_table(`timestamp`) values(b'1' ^ b'0');
WARNING:  column "timestamp" is of type timestamp with time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: timestamp
insert into test_type_table(`timestamp(4)`) values(b'1' ^ b'0');
ERROR:  column "timestamp(4)" is of type timestamp with time zone but expression is of type uint8
LINE 1: ...nsert into test_type_table(`timestamp(4)`) values(b'1' ^ b'0...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: timestamp(4)
insert ignore into test_type_table(`timestamp(4)`) values(b'1' ^ b'0');
WARNING:  column "timestamp(4)" is of type timestamp with time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: timestamp(4)
insert into test_type_table(`year`) values(b'1' ^ b'0');
insert ignore into test_type_table(`year`) values(b'1' ^ b'0');
insert into test_type_table(`char`) values(b'1' ^ b'0');
insert ignore into test_type_table(`char`) values(b'1' ^ b'0');
insert into test_type_table(`varchar`) values(b'1' ^ b'0');
insert ignore into test_type_table(`varchar`) values(b'1' ^ b'0');
insert into test_type_table(`binary`) values(b'1' ^ b'0');
insert ignore into test_type_table(`binary`) values(b'1' ^ b'0');
insert into test_type_table(`varbinary`) values(b'1' ^ b'0');
insert ignore into test_type_table(`varbinary`) values(b'1' ^ b'0');
insert into test_type_table(`tinyblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`tinyblob`) values(b'1' ^ b'0');
insert into test_type_table(`blob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`blob`) values(b'1' ^ b'0');
insert into test_type_table(`mediumblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`mediumblob`) values(b'1' ^ b'0');
insert into test_type_table(`longblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`longblob`) values(b'1' ^ b'0');
insert into test_type_table(`text`) values(b'1' ^ b'0');
insert ignore into test_type_table(`text`) values(b'1' ^ b'0');
insert into test_type_table(`nullvalue`) values(b'1' ^ b'0');
insert ignore into test_type_table(`nullvalue`) values(b'1' ^ b'0');
insert into test_type_table(`bignumber`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bignumber`) values(b'1' ^ b'0');
insert into test_type_table(`bigstring`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bigstring`) values(b'1' ^ b'0');
-- default value in create table
drop table if exists test_type_table_3 cascade;
NOTICE:  table "test_type_table_3" does not exist, skipping
create table test_type_table_3(a int default 1^0);
show create table test_type_table_3;
       Table       |              Create Table               
-------------------+-----------------------------------------
 test_type_table_3 | SET search_path = test_bit_xor;        +
                   | CREATE TABLE test_type_table_3 (       +
                   |     a integer DEFAULT (1 ^ 0)          +
                   | )                                      +
                   | WITH (orientation=row, compression=no);
(1 row)

insert into test_type_table_3 default values;
select * from test_type_table_3;
 a 
---
 1
(1 row)

reset dolphin.sql_mode;
-- none strict mode
set dolphin.sql_mode='pad_char_to_full_length,auto_recompile_function';
truncate table test_type_table cascade;
insert into test_type_table values (
	1, 1, 1, 1, 
	1, 1, 1, 1, 
	1, 1, 1, b'1', 
	b'111', true, '2023-02-05', '19:10:50', 
	'19:10:50.3456', '2023-02-05 19:10:50', '2023-02-05 19:10:50.456', '2023-02-05 19:10:50', 
	'2023-02-05 19:10:50.456', '2023', '123a', '123a', 
	'123a', '123a', '123a', '123a',
	'123a', '123a', '123a', null, 
    9223372036854775807, 'openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。openGauss是一款提供面向多核的极致性能、全链路的业务和数据安全，基于AI的调优和高效运维的能力，全面友好开放，携手伙伴共同打造全球领先的企业级开源关系型数据库，采用木兰宽松许可证v2发行。openGauss深度融合华为在数据库领域多年的研发经验，结合企业级场景需求，持续构建竞争力特性。'
);
-- Abnormal arguments (null、large number、long string、different input types)
select `nullvalue` ^ `bit1` from test_type_table;
 ?column? 
----------
 
(1 row)

select `bit1` ^ `nullvalue` from test_type_table;
 ?column? 
----------
 
(1 row)

select `nullvalue` ^ `nullvalue` from test_type_table;
 ?column? 
----------
 
(1 row)

select `bignumber` ^ `bignumber` from test_type_table;
 ?column? 
----------
 0
(1 row)

select `bigstring` ^ `bigstring` from test_type_table;
 ?column? 
----------
 0
(1 row)

select `bit1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint1` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int2` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint2` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `int8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `uint8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `float4` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `float8` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `numeric` ^ `bit64` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `date` ^ `bit64` from test_type_table;
 ?column? 
----------
 20230202
(1 row)

select `time` ^ `bit64` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `time(4)` ^ `bit64` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `datetime` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `datetime(4)` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `timestamp` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `timestamp(4)` ^ `bit64` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `year` ^ `bit64` from test_type_table;
 ?column? 
----------
 2016
(1 row)

select `char` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a                                                                                                "
 ?column? 
----------
 124
(1 row)

select `varchar` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `binary` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `varbinary` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `tinyblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `blob` ^ `bit64` from test_type_table;
 ?column? 
----------
 124
(1 row)

select `mediumblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `longblob` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `text` ^ `bit64` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `bit1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint1` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int2` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint2` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `int8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `uint8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `float4` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `float8` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `numeric` from test_type_table;
 ?column? 
----------
 6
(1 row)

select `bit64` ^ `date` from test_type_table;
 ?column? 
----------
 20230202
(1 row)

select `bit64` ^ `time` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `bit64` ^ `time(4)` from test_type_table;
 ?column? 
----------
   191053
(1 row)

select `bit64` ^ `datetime` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `datetime(4)` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `timestamp` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `timestamp(4)` from test_type_table;
    ?column?    
----------------
 20230205191053
(1 row)

select `bit64` ^ `year` from test_type_table;
 ?column? 
----------
 2016
(1 row)

select `bit64` ^ `char` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a                                                                                                "
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `varchar` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `binary` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `varbinary` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `tinyblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `blob` from test_type_table;
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `mediumblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `longblob` from test_type_table;
WARNING:  invalid input syntax for type double precision: "123a"
 ?column? 
----------
 124
(1 row)

select `bit64` ^ `text` from test_type_table;
WARNING:  invalid input syntax for type numeric: "123a"
 ?column? 
----------
 124
(1 row)

-- IUD
insert into test_type_table(`int1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int1`) values(b'1' ^ b'0');
insert into test_type_table(`uint1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint1`) values(b'1' ^ b'0');
insert into test_type_table(`int2`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int2`) values(b'1' ^ b'0');
insert into test_type_table(`uint2`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint2`) values(b'1' ^ b'0');
insert into test_type_table(`int4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int4`) values(b'1' ^ b'0');
insert into test_type_table(`uint4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint4`) values(b'1' ^ b'0');
insert into test_type_table(`int8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`int8`) values(b'1' ^ b'0');
insert into test_type_table(`uint8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`uint8`) values(b'1' ^ b'0');
insert into test_type_table(`float4`) values(b'1' ^ b'0');
insert ignore into test_type_table(`float4`) values(b'1' ^ b'0');
insert into test_type_table(`float8`) values(b'1' ^ b'0');
insert ignore into test_type_table(`float8`) values(b'1' ^ b'0');
insert into test_type_table(`numeric`) values(b'1' ^ b'0');
insert ignore into test_type_table(`numeric`) values(b'1' ^ b'0');
insert into test_type_table(`bit1`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bit1`) values(b'1' ^ b'0');
insert into test_type_table(`bit64`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bit64`) values(b'1' ^ b'0');
insert into test_type_table(`boolean`) values(b'1' ^ b'0');
insert ignore into test_type_table(`boolean`) values(b'1' ^ b'0');
insert into test_type_table(`date`) values(b'1' ^ b'0');
WARNING:  Out of range value for date
CONTEXT:  referenced column: date
insert ignore into test_type_table(`date`) values(b'1' ^ b'0');
WARNING:  Out of range value for date
CONTEXT:  referenced column: date
insert into test_type_table(`time`) values(b'1' ^ b'0');
insert ignore into test_type_table(`time`) values(b'1' ^ b'0');
insert into test_type_table(`time(4)`) values(b'1' ^ b'0');
insert ignore into test_type_table(`time(4)`) values(b'1' ^ b'0');
insert into test_type_table(`datetime`) values(b'1' ^ b'0');
ERROR:  column "datetime" is of type timestamp without time zone but expression is of type uint8
LINE 1: insert into test_type_table(`datetime`) values(b'1' ^ b'0');
                                                       ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: datetime
insert ignore into test_type_table(`datetime`) values(b'1' ^ b'0');
WARNING:  column "datetime" is of type timestamp without time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: datetime
insert into test_type_table(`datetime(4)`) values(b'1' ^ b'0');
ERROR:  column "datetime(4)" is of type timestamp without time zone but expression is of type uint8
LINE 1: insert into test_type_table(`datetime(4)`) values(b'1' ^ b'0...
                                                          ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: datetime(4)
insert ignore into test_type_table(`datetime(4)`) values(b'1' ^ b'0');
WARNING:  column "datetime(4)" is of type timestamp without time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: datetime(4)
insert into test_type_table(`timestamp`) values(b'1' ^ b'0');
ERROR:  column "timestamp" is of type timestamp with time zone but expression is of type uint8
LINE 1: insert into test_type_table(`timestamp`) values(b'1' ^ b'0')...
                                                        ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: timestamp
insert ignore into test_type_table(`timestamp`) values(b'1' ^ b'0');
WARNING:  column "timestamp" is of type timestamp with time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: timestamp
insert into test_type_table(`timestamp(4)`) values(b'1' ^ b'0');
ERROR:  column "timestamp(4)" is of type timestamp with time zone but expression is of type uint8
LINE 1: ...nsert into test_type_table(`timestamp(4)`) values(b'1' ^ b'0...
                                                             ^
HINT:  You will need to rewrite or cast the expression.
CONTEXT:  referenced column: timestamp(4)
insert ignore into test_type_table(`timestamp(4)`) values(b'1' ^ b'0');
WARNING:  column "timestamp(4)" is of type timestamp with time zone but expression is of type uint8. Data truncated automatically.
CONTEXT:  referenced column: timestamp(4)
insert into test_type_table(`year`) values(b'1' ^ b'0');
insert ignore into test_type_table(`year`) values(b'1' ^ b'0');
insert into test_type_table(`char`) values(b'1' ^ b'0');
insert ignore into test_type_table(`char`) values(b'1' ^ b'0');
insert into test_type_table(`varchar`) values(b'1' ^ b'0');
insert ignore into test_type_table(`varchar`) values(b'1' ^ b'0');
insert into test_type_table(`binary`) values(b'1' ^ b'0');
insert ignore into test_type_table(`binary`) values(b'1' ^ b'0');
insert into test_type_table(`varbinary`) values(b'1' ^ b'0');
insert ignore into test_type_table(`varbinary`) values(b'1' ^ b'0');
insert into test_type_table(`tinyblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`tinyblob`) values(b'1' ^ b'0');
insert into test_type_table(`blob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`blob`) values(b'1' ^ b'0');
insert into test_type_table(`mediumblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`mediumblob`) values(b'1' ^ b'0');
insert into test_type_table(`longblob`) values(b'1' ^ b'0');
insert ignore into test_type_table(`longblob`) values(b'1' ^ b'0');
insert into test_type_table(`text`) values(b'1' ^ b'0');
insert ignore into test_type_table(`text`) values(b'1' ^ b'0');
insert into test_type_table(`nullvalue`) values(b'1' ^ b'0');
insert ignore into test_type_table(`nullvalue`) values(b'1' ^ b'0');
insert into test_type_table(`bignumber`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bignumber`) values(b'1' ^ b'0');
insert into test_type_table(`bigstring`) values(b'1' ^ b'0');
insert ignore into test_type_table(`bigstring`) values(b'1' ^ b'0');
-- default value in create table
drop table if exists test_type_table_3 cascade;
create table test_type_table_3(a int default 1^0);
show create table test_type_table_3;
       Table       |              Create Table               
-------------------+-----------------------------------------
 test_type_table_3 | SET search_path = test_bit_xor;        +
                   | CREATE TABLE test_type_table_3 (       +
                   |     a integer DEFAULT (1 ^ 0)          +
                   | )                                      +
                   | WITH (orientation=row, compression=no);
(1 row)

insert into test_type_table_3 default values;
select * from test_type_table_3;
 a 
---
 1
(1 row)

-- bit ^ bit (different length)
set dolphin.sql_mode='sql_mode_strict,pad_char_to_full_length,auto_recompile_function';
create table bit_t(`bit1` bit(1), `bit18` bit(18), `bit45` bit(45), `bit64` bit(64));
insert into bit_t values(1, 244520, 4564685412, 1565646212555);
select `bit1` ^ `bit18`, `bit1` ^ `bit45`, `bit1` ^ `bit64` from bit_t;
 ?column? |  ?column?  |   ?column?    
----------+------------+---------------
 244521   | 4564685413 | 1565646212554
(1 row)

select `bit18` ^ `bit1`, `bit18` ^ `bit45`, `bit18` ^ `bit64` from bit_t;
 ?column? |  ?column?  |   ?column?    
----------+------------+---------------
 244521   | 4564461900 | 1565646321379
(1 row)

select `bit45` ^ `bit1`, `bit45` ^ `bit18`, `bit45` ^ `bit64` from bit_t;
  ?column?  |  ?column?  |   ?column?    
------------+------------+---------------
 4564685413 | 4564461900 | 1570210766767
(1 row)

select `bit64` ^ `bit1`, `bit64` ^ `bit18`, `bit64` ^ `bit45` from bit_t;
   ?column?    |   ?column?    |   ?column?    
---------------+---------------+---------------
 1565646212554 | 1565646321379 | 1570210766767
(1 row)

drop table bit_t;
reset dolphin.sql_mode;
drop table if exists test_type_table cascade;
drop table if exists test_type_table_2 cascade;
drop table if exists test_type_table_3 cascade;
drop schema test_bit_xor cascade;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table test_time
drop cascades to table test_time_with_zone
drop cascades to table test_time_with_null
drop cascades to table test_time_with_zone_with_null
drop cascades to table test_date
drop cascades to table test_bit
reset current_schema;

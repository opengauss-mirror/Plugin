drop DATABASE if exists partition_test4;
NOTICE:  database "partition_test4" does not exist, skipping
CREATE DATABASE partition_test4 dbcompatibility 'B';
\c partition_test4;
CREATE TABLE test_range_subpart
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)
(
    PARTITION p1 VALUES LESS THAN (200)
    (
        SUBPARTITION s11,
        SUBPARTITION s12,
        SUBPARTITION s13,
        SUBPARTITION s14
    ),
    PARTITION p2 VALUES LESS THAN (500)
    (
        SUBPARTITION s21,
        SUBPARTITION s22
    ),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
    (
        SUBPARTITION s41
    )
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_subpart_pkey" for table "test_range_subpart"
CREATE TABLE test_range_part
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_part_pkey" for table "test_range_part"
create table test_list_part (a int PRIMARY KEY, b int)
partition by list (a)
(
    partition p1 values (1, 2, 3, 4),
    partition p2 values (5, 6, 7, 8),
    partition p3 values (9, 10, 11, 12)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_part_pkey" for table "test_list_part"
create table test_list_subpart (a int PRIMARY KEY, b int)
partition by list (a) SUBPARTITION BY HASH (b)
(
    partition p1 values (1, 2, 3, 4) (subpartition p11),
    partition p2 values (5, 6, 7, 8) (subpartition p12),
    partition p3 values (9, 10, 11, 12) (subpartition p13)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_subpart_pkey" for table "test_list_subpart"
insert into test_range_subpart values(199,1),(499,1),(799,1),(1199,1);
insert into test_range_part values(199,1),(499,1),(799,1),(1199,1);
insert into test_list_part values(1,1),(5,1),(9,1);
insert into test_list_subpart values(1,1),(5,1),(9,1);
/*test test_range_subpart*/
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500)(subpartition m21,subpartition m22));
select pg_get_tabledef('test_range_subpart');
                                                    pg_get_tabledef                                                     
------------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                             +
 CREATE TABLE test_range_subpart (                                                                                     +
     a integer NOT NULL,                                                                                               +
     b integer                                                                                                         +
 )                                                                                                                     +
 WITH (orientation=row, compression=no)                                                                                +
 PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)                                                                       +
 (                                                                                                                     +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION m1_subpartdefault1 TABLESPACE pg_default                                                         +
     ),                                                                                                                +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION m21 TABLESPACE pg_default,                                                                       +
         SUBPARTITION m22 TABLESPACE pg_default                                                                        +
     ),                                                                                                                +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION p3_subpartdefault1 TABLESPACE pg_default                                                         +
     ),                                                                                                                +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                                        +
     (                                                                                                                 +
         SUBPARTITION s41 TABLESPACE pg_default                                                                        +
     )                                                                                                                 +
 )                                                                                                                     +
 ENABLE ROW MOVEMENT;                                                                                                  +
 ALTER TABLE test_range_subpart ADD CONSTRAINT test_range_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_range_subpart subpartition(m22);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_subpart subpartition(m21);
 a | b 
---+---
(0 rows)

select * from test_range_subpart partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_subpart test_range_subpart_pkey) */ * from test_range_subpart where a > 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Index Scan using test_range_subpart_pkey on test_range_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_range_subpart;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_range_part*/
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_range_part');
                                        pg_get_tabledef                                        
-----------------------------------------------------------------------------------------------
 SET search_path = public;                                                                    +
 CREATE TABLE test_range_part (                                                               +
     a integer NOT NULL,                                                                      +
     b integer                                                                                +
 )                                                                                            +
 WITH (orientation=row, compression=no)                                                       +
 PARTITION BY RANGE (a)                                                                       +
 (                                                                                            +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                               +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                               +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                               +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                               +
 )                                                                                            +
 ENABLE ROW MOVEMENT;                                                                         +
 ALTER TABLE test_range_part ADD CONSTRAINT test_range_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_range_part partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_part partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_part test_range_part_pkey) */ * from test_range_part where a > 0;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_range_part_pkey on test_range_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_range_part;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_list_part*/
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_part');
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = public;                                                                  +
 CREATE TABLE test_list_part (                                                              +
     a integer NOT NULL,                                                                    +
     b integer                                                                              +
 )                                                                                          +
 WITH (orientation=row, compression=no)                                                     +
 PARTITION BY LIST (a)                                                                      +
 (                                                                                          +
     PARTITION m2 VALUES (1,4,7) TABLESPACE pg_default,                                     +
     PARTITION m1 VALUES (2,3,5,13) TABLESPACE pg_default,                                  +
     PARTITION p3 VALUES (9,10,11,12) TABLESPACE pg_default                                 +
 )                                                                                          +
 ENABLE ROW MOVEMENT;                                                                       +
 ALTER TABLE test_list_part ADD CONSTRAINT test_list_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_list_part partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_part partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_part test_list_part_pkey) */ * from test_list_part where a > 0;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 3
   ->  Partitioned Index Scan using test_list_part_pkey on test_list_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..3
(5 rows)

select * from test_list_part where a > 0;
 a | b 
---+---
 1 | 1
 5 | 1
 9 | 1
(3 rows)

/*test test_list_subpart*/
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13)(subpartition m11,subpartition m12),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_subpart');
                                                   pg_get_tabledef                                                    
----------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                           +
 CREATE TABLE test_list_subpart (                                                                                    +
     a integer NOT NULL,                                                                                             +
     b integer                                                                                                       +
 )                                                                                                                   +
 WITH (orientation=row, compression=no)                                                                              +
 PARTITION BY LIST (a) SUBPARTITION BY HASH (b)                                                                      +
 (                                                                                                                   +
     PARTITION m2 VALUES (1,4,7) TABLESPACE pg_default                                                               +
     (                                                                                                               +
         SUBPARTITION m2_subpartdefault1 TABLESPACE pg_default                                                       +
     ),                                                                                                              +
     PARTITION m1 VALUES (2,3,5,13) TABLESPACE pg_default                                                            +
     (                                                                                                               +
         SUBPARTITION m11 TABLESPACE pg_default,                                                                     +
         SUBPARTITION m12 TABLESPACE pg_default                                                                      +
     ),                                                                                                              +
     PARTITION p3 VALUES (9,10,11,12) TABLESPACE pg_default                                                          +
     (                                                                                                               +
         SUBPARTITION p13 TABLESPACE pg_default                                                                      +
     )                                                                                                               +
 )                                                                                                                   +
 ENABLE ROW MOVEMENT;                                                                                                +
 ALTER TABLE test_list_subpart ADD CONSTRAINT test_list_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_list_subpart partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_subpart partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

select * from test_list_subpart subpartition(m11);
 a | b 
---+---
(0 rows)

select * from test_list_subpart subpartition(m12);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_subpart test_list_subpart_pkey) */ * from test_list_subpart where a > 0;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Index Scan using test_list_subpart_pkey on test_list_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_list_subpart where a > 0;
 a | b 
---+---
 9 | 1
 5 | 1
 1 | 1
(3 rows)

-------test no-partitioned table
create table test_no_part(a int,b int);
alter table test_no_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  can not Reorganize partition against NON-PARTITIONED table
-------test ustore table
CREATE TABLE IF NOT EXISTS test_part_ustore
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(STORAGE_TYPE = USTORE);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_ustore_pkey" for table "test_part_ustore"
insert into test_part_ustore values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_ustore');
                                                       pg_get_tabledef                                                       
-----------------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                                  +
 CREATE TABLE test_part_ustore (                                                                                            +
     a integer NOT NULL,                                                                                                    +
     b integer                                                                                                              +
 )                                                                                                                          +
 WITH (orientation=row, storage_type=ustore, compression=no)                                                                +
 PARTITION BY RANGE (a)                                                                                                     +
 (                                                                                                                          +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                                                             +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                                                             +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                                                             +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                                             +
 )                                                                                                                          +
 ENABLE ROW MOVEMENT;                                                                                                       +
 ALTER TABLE test_part_ustore ADD CONSTRAINT test_part_ustore_pkey PRIMARY KEY USING ubtree  (a) WITH (storage_type=USTORE);
(1 row)

select * from test_part_ustore partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_ustore partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_ustore test_part_ustore_pkey) */ * from test_part_ustore where a > 0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_ustore_pkey on test_part_ustore  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_ustore;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

-------test segment table
CREATE TABLE IF NOT EXISTS test_part_segment
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(segment = on);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_segment_pkey" for table "test_part_segment"
insert into test_part_segment values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_segment');
                                          pg_get_tabledef                                          
---------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                        +
 CREATE TABLE test_part_segment (                                                                 +
     a integer NOT NULL,                                                                          +
     b integer                                                                                    +
 )                                                                                                +
 WITH (orientation=row, segment=on, compression=no)                                               +
 PARTITION BY RANGE (a)                                                                           +
 (                                                                                                +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                                   +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                                   +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                                   +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                   +
 )                                                                                                +
 ENABLE ROW MOVEMENT;                                                                             +
 ALTER TABLE test_part_segment ADD CONSTRAINT test_part_segment_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_part_segment partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_segment partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_segment test_part_segment_pkey) */ * from test_part_segment where a > 0;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_segment_pkey on test_part_segment  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_segment;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

-------test table with local index
drop table if exists b_range_hash_t01;
NOTICE:  table "b_range_hash_t01" does not exist, skipping
create table b_range_hash_t01(c1 int primary key,c2 int,c3 text)
partition by range(c1) subpartition by hash(c2)
(
partition p1 values less than (100)
(
subpartition p1_1,
subpartition p1_2
),
partition p2 values less than (200)
(
subpartition p2_1,
subpartition p2_2
),
partition p3 values less than (300)
(
subpartition p3_1,
subpartition p3_2
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_hash_t01_pkey" for table "b_range_hash_t01"
create index on b_range_hash_t01 (c1) global;
create index on b_range_hash_t01 (c2) local;
insert into b_range_hash_t01 values(1,2,3),(51,3,4);
select pg_get_tabledef('b_range_hash_t01');
                                                   pg_get_tabledef                                                   
---------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                          +
 CREATE TABLE b_range_hash_t01 (                                                                                    +
     c1 integer NOT NULL,                                                                                           +
     c2 integer,                                                                                                    +
     c3 text                                                                                                        +
 )                                                                                                                  +
 WITH (orientation=row, compression=no)                                                                             +
 PARTITION BY RANGE (c1) SUBPARTITION BY HASH (c2)                                                                  +
 (                                                                                                                  +
     PARTITION p1 VALUES LESS THAN (100) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION p1_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION p1_2 TABLESPACE pg_default                                                                    +
     ),                                                                                                             +
     PARTITION p2 VALUES LESS THAN (200) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION p2_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION p2_2 TABLESPACE pg_default                                                                    +
     ),                                                                                                             +
     PARTITION p3 VALUES LESS THAN (300) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION p3_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION p3_2 TABLESPACE pg_default                                                                    +
     )                                                                                                              +
 )                                                                                                                  +
 ENABLE ROW MOVEMENT;                                                                                               +
 CREATE INDEX b_range_hash_t01_c2_idx ON b_range_hash_t01 USING btree (c2) LOCAL(                                   +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p1_2_c2_idx,                                                                                  +
         SUBPARTITION p1_1_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p2_2_c2_idx,                                                                                  +
         SUBPARTITION p2_1_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p3_2_c2_idx,                                                                                  +
         SUBPARTITION p3_1_c2_idx                                                                                   +
     )                                                                                                              +
 )  TABLESPACE pg_default;                                                                                          +
 CREATE INDEX b_range_hash_t01_c1_tableoid_idx ON b_range_hash_t01 USING btree (c1) TABLESPACE pg_default;          +
 ALTER TABLE b_range_hash_t01 ADD CONSTRAINT b_range_hash_t01_pkey PRIMARY KEY USING btree  (c1) INCLUDE (tableoid);
(1 row)

alter table b_range_hash_t01 reorganize partition p1 into (partition m1 values less than(50) (subpartition m1_1,subpartition m1_2,subpartition m1_3),partition m2 values less than(100));
select pg_get_tabledef('b_range_hash_t01');
                                                   pg_get_tabledef                                                   
---------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                          +
 CREATE TABLE b_range_hash_t01 (                                                                                    +
     c1 integer NOT NULL,                                                                                           +
     c2 integer,                                                                                                    +
     c3 text                                                                                                        +
 )                                                                                                                  +
 WITH (orientation=row, compression=no)                                                                             +
 PARTITION BY RANGE (c1) SUBPARTITION BY HASH (c2)                                                                  +
 (                                                                                                                  +
     PARTITION m1 VALUES LESS THAN (50) TABLESPACE pg_default                                                       +
     (                                                                                                              +
         SUBPARTITION m1_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION m1_2 TABLESPACE pg_default,                                                                   +
         SUBPARTITION m1_3 TABLESPACE pg_default                                                                    +
     ),                                                                                                             +
     PARTITION m2 VALUES LESS THAN (100) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION m2_subpartdefault1 TABLESPACE pg_default                                                      +
     ),                                                                                                             +
     PARTITION p2 VALUES LESS THAN (200) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION p2_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION p2_2 TABLESPACE pg_default                                                                    +
     ),                                                                                                             +
     PARTITION p3 VALUES LESS THAN (300) TABLESPACE pg_default                                                      +
     (                                                                                                              +
         SUBPARTITION p3_1 TABLESPACE pg_default,                                                                   +
         SUBPARTITION p3_2 TABLESPACE pg_default                                                                    +
     )                                                                                                              +
 )                                                                                                                  +
 ENABLE ROW MOVEMENT;                                                                                               +
 CREATE INDEX b_range_hash_t01_c2_idx ON b_range_hash_t01 USING btree (c2) LOCAL(                                   +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION m1_3_c2_idx,                                                                                  +
         SUBPARTITION m1_2_c2_idx,                                                                                  +
         SUBPARTITION m1_1_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION m2_subpartdefault1_c2_idx                                                                     +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p2_2_c2_idx,                                                                                  +
         SUBPARTITION p2_1_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p3_2_c2_idx,                                                                                  +
         SUBPARTITION p3_1_c2_idx                                                                                   +
     )                                                                                                              +
 )  TABLESPACE pg_default;                                                                                          +
 CREATE INDEX b_range_hash_t01_c1_tableoid_idx ON b_range_hash_t01 USING btree (c1) TABLESPACE pg_default;          +
 ALTER TABLE b_range_hash_t01 ADD CONSTRAINT b_range_hash_t01_pkey PRIMARY KEY USING btree  (c1) INCLUDE (tableoid);
(1 row)

select * from b_range_hash_t01 partition(m1);
 c1 | c2 | c3 
----+----+----
  1 |  2 | 3
(1 row)

select * from b_range_hash_t01 partition(m2);
 c1 | c2 | c3 
----+----+----
 51 |  3 | 4
(1 row)

--test some error cases
create table b_range_hash_t05(c1 int primary key,c2 int,c3 text)
with (segment=on)
partition by range(c1) subpartition by hash(c2)
(
partition p1 values less than (100)
(
subpartition p1_1,
subpartition p1_2
),
partition p2 values less than (200)
(
subpartition p2_1,
subpartition p2_2
),
partition p3 values less than (300)
(
subpartition p3_1,
subpartition p3_2
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_hash_t05_pkey" for table "b_range_hash_t05"
create index on b_range_hash_t05 (c1) global;
create index on b_range_hash_t05 (c2) local;
alter table b_range_hash_t05 reorganize partition p1 into 
(
	partition m1 values less than(50) 
	(subpartition m1_1 tablespace pg_global,subpartition m1_2,subpartition m1_3),
	partition m2 values less than(100) 
	(subpartition m2_1)
);
ERROR:  only shared relations can be placed in pg_global tablespace
alter table b_range_hash_t01 reorganize partition m1 into (partition k1 values less than(2) (subpartition k1_1 values less than(2)));
ERROR:  The subpartition def type must be HASH
alter table b_range_hash_t01 reorganize partition m1 into (partition k1 values less than(2) (subpartition k1_1 values (1)));
ERROR:  The subpartition def type must be HASH
drop table if exists b_interval_t1;
NOTICE:  table "b_interval_t1" does not exist, skipping
create table b_interval_t1(c1 int primary key,c2 timestamp)
partition by range(c2)
interval('1 day')
(
partition p1 values less than ('1990-01-01 00:00:00'),
partition p2 values less than ('1990-01-02 00:00:00'),
partition p3 values less than ('1990-01-03 00:00:00'),
partition p4 values less than ('1990-01-04 00:00:00'),
partition p5 values less than ('1990-01-05 00:00:00'),
partition p6 values less than ('1990-01-06 00:00:00'),
partition p7 values less than ('1990-01-07 00:00:00'),
partition p8 values less than ('1990-01-08 00:00:00'),
partition p9 values less than ('1990-01-09 00:00:00'),
partition p10 values less than ('1990-01-10 00:00:00')
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_interval_t1_pkey" for table "b_interval_t1"
alter table b_interval_t1 reorganize partition p2,p3 into (partition m1 values less than('1990-01-03 00:00:00'));
ERROR:  can not reorganize partition against interval partitioned table
alter table b_interval_t1 reorganize partition p4 into (partition m2 values less than('1990-01-03 12:00:00'),partition m3 values less than('1990-01-04 00:00:00'));
ERROR:  can not reorganize partition against interval partitioned table
drop table if exists b_range_range_t01;
NOTICE:  table "b_range_range_t01" does not exist, skipping
create table b_range_range_t01(c1 int primary key,c2 int,c3 int)
partition by range(c1) subpartition by range(c2)
(
partition p1 values less than (100)
(
subpartition p1_1 values less than (50),
subpartition p1_2 values less than (100)
),
partition p2 values less than (200)
(
subpartition p2_1 values less than (150),
subpartition p2_2 values less than (200)
),
partition p3 values less than (300)
(
subpartition p3_1 values less than (250),
subpartition p3_2 values less than (300)
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_range_t01_pkey" for table "b_range_range_t01"
alter table b_range_range_t01 reorganize partition p1 into (partition m1 values less than(100) (subpartition m1_1 values less than(50),subpartition m1_2 values less than(100)));
ERROR:  The subpartition def type must be HASH
alter table b_range_range_t01 reorganize partition p1 into (partition m1 values less than(100) (subpartition m1_1));
ERROR:  The subpart type must be HASH for REORGANIZE PARTITION
drop table if exists b_range_mt1;
NOTICE:  table "b_range_mt1" does not exist, skipping
create table b_range_mt1(c1 int primary key,c2 int)
partition by range(c1) (
partition p0 start (0) end (100),
partition p1 start (100) end (200),
partition p2 start (200) end (300),
partition p3 start (300) end (maxvalue)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_mt1_pkey" for table "b_range_mt1"
alter table b_range_mt1 reorganize partition p3 into (partition m1 start(300) end(400),partition m2 start(400) end(maxvalue));
ERROR:  Reorganize Partition not support start_end_def syntax
\c postgres;
drop DATABASE if exists partition_test4;

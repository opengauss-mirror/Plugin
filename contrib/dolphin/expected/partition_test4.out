drop DATABASE if exists partition_test4;
NOTICE:  database "partition_test4" does not exist, skipping
CREATE DATABASE partition_test4 dbcompatibility 'B';
\c partition_test4;
CREATE TABLE test_range_subpart
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)
(
    PARTITION p1 VALUES LESS THAN (200)
    (
        SUBPARTITION s11,
        SUBPARTITION s12,
        SUBPARTITION s13,
        SUBPARTITION s14
    ),
    PARTITION p2 VALUES LESS THAN (500)
    (
        SUBPARTITION s21,
        SUBPARTITION s22
    ),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
    (
        SUBPARTITION s41
    )
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_subpart_pkey" for table "test_range_subpart"
CREATE TABLE test_range_part
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_part_pkey" for table "test_range_part"
create table test_list_part (a int PRIMARY KEY, b int)
partition by list (a)
(
    partition p1 values (1, 2, 3, 4),
    partition p2 values (5, 6, 7, 8),
    partition p3 values (9, 10, 11, 12)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_part_pkey" for table "test_list_part"
create table test_list_subpart (a int PRIMARY KEY, b int)
partition by list (a) SUBPARTITION BY HASH (b)
(
    partition p1 values (1, 2, 3, 4) (subpartition p11),
    partition p2 values (5, 6, 7, 8) (subpartition p12),
    partition p3 values (9, 10, 11, 12) (subpartition p13)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_subpart_pkey" for table "test_list_subpart"
insert into test_range_subpart values(199,1),(499,1),(799,1),(1199,1);
insert into test_range_part values(199,1),(499,1),(799,1),(1199,1);
insert into test_list_part values(1,1),(5,1),(9,1);
insert into test_list_subpart values(1,1),(5,1),(9,1);
/*test test_range_subpart*/
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500)(subpartition m21,subpartition m22));
select pg_get_tabledef('test_range_subpart');
                                                    pg_get_tabledef                                                     
------------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                             +
 CREATE TABLE test_range_subpart (                                                                                     +
     a integer NOT NULL,                                                                                               +
     b integer                                                                                                         +
 )                                                                                                                     +
 WITH (orientation=row, compression=no)                                                                                +
 PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)                                                                       +
 (                                                                                                                     +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION m1_subpartdefault1 TABLESPACE pg_default                                                         +
     ),                                                                                                                +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION m21 TABLESPACE pg_default,                                                                       +
         SUBPARTITION m22 TABLESPACE pg_default                                                                        +
     ),                                                                                                                +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default                                                         +
     (                                                                                                                 +
         SUBPARTITION p3_subpartdefault1 TABLESPACE pg_default                                                         +
     ),                                                                                                                +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                                        +
     (                                                                                                                 +
         SUBPARTITION s41 TABLESPACE pg_default                                                                        +
     )                                                                                                                 +
 )                                                                                                                     +
 ENABLE ROW MOVEMENT;                                                                                                  +
 ALTER TABLE test_range_subpart ADD CONSTRAINT test_range_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_range_subpart subpartition(m22);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_subpart subpartition(m21);
 a | b 
---+---
(0 rows)

select * from test_range_subpart partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_subpart test_range_subpart_pkey) */ * from test_range_subpart where a > 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Index Scan using test_range_subpart_pkey on test_range_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_range_subpart;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_range_part*/
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_range_part');
                                        pg_get_tabledef                                        
-----------------------------------------------------------------------------------------------
 SET search_path = public;                                                                    +
 CREATE TABLE test_range_part (                                                               +
     a integer NOT NULL,                                                                      +
     b integer                                                                                +
 )                                                                                            +
 WITH (orientation=row, compression=no)                                                       +
 PARTITION BY RANGE (a)                                                                       +
 (                                                                                            +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                               +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                               +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                               +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                               +
 )                                                                                            +
 ENABLE ROW MOVEMENT;                                                                         +
 ALTER TABLE test_range_part ADD CONSTRAINT test_range_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_range_part partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_part partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_part test_range_part_pkey) */ * from test_range_part where a > 0;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_range_part_pkey on test_range_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_range_part;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_list_part*/
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_part');
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = public;                                                                  +
 CREATE TABLE test_list_part (                                                              +
     a integer NOT NULL,                                                                    +
     b integer                                                                              +
 )                                                                                          +
 WITH (orientation=row, compression=no)                                                     +
 PARTITION BY LIST (a)                                                                      +
 (                                                                                          +
     PARTITION m2 VALUES (1,4,7) TABLESPACE pg_default,                                     +
     PARTITION m1 VALUES (2,3,5,13) TABLESPACE pg_default,                                  +
     PARTITION p3 VALUES (9,10,11,12) TABLESPACE pg_default                                 +
 )                                                                                          +
 ENABLE ROW MOVEMENT;                                                                       +
 ALTER TABLE test_list_part ADD CONSTRAINT test_list_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_list_part partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_part partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_part test_list_part_pkey) */ * from test_list_part where a > 0;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 3
   ->  Partitioned Index Scan using test_list_part_pkey on test_list_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..3
(5 rows)

select * from test_list_part where a > 0;
 a | b 
---+---
 1 | 1
 5 | 1
 9 | 1
(3 rows)

/*test test_list_subpart*/
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13)(subpartition m11,subpartition m12),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_subpart');
                                                   pg_get_tabledef                                                    
----------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                           +
 CREATE TABLE test_list_subpart (                                                                                    +
     a integer NOT NULL,                                                                                             +
     b integer                                                                                                       +
 )                                                                                                                   +
 WITH (orientation=row, compression=no)                                                                              +
 PARTITION BY LIST (a) SUBPARTITION BY HASH (b)                                                                      +
 (                                                                                                                   +
     PARTITION m2 VALUES (1,4,7) TABLESPACE pg_default                                                               +
     (                                                                                                               +
         SUBPARTITION m2_subpartdefault1 TABLESPACE pg_default                                                       +
     ),                                                                                                              +
     PARTITION m1 VALUES (2,3,5,13) TABLESPACE pg_default                                                            +
     (                                                                                                               +
         SUBPARTITION m11 TABLESPACE pg_default,                                                                     +
         SUBPARTITION m12 TABLESPACE pg_default                                                                      +
     ),                                                                                                              +
     PARTITION p3 VALUES (9,10,11,12) TABLESPACE pg_default                                                          +
     (                                                                                                               +
         SUBPARTITION p13 TABLESPACE pg_default                                                                      +
     )                                                                                                               +
 )                                                                                                                   +
 ENABLE ROW MOVEMENT;                                                                                                +
 ALTER TABLE test_list_subpart ADD CONSTRAINT test_list_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_list_subpart partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_subpart partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

select * from test_list_subpart subpartition(m11);
 a | b 
---+---
(0 rows)

select * from test_list_subpart subpartition(m12);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_subpart test_list_subpart_pkey) */ * from test_list_subpart where a > 0;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Index Scan using test_list_subpart_pkey on test_list_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_list_subpart where a > 0;
 a | b 
---+---
 9 | 1
 5 | 1
 1 | 1
(3 rows)

-------test no-partitioned table
create table test_no_part(a int,b int);
alter table test_no_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  can not Reorganize partition against NON-PARTITIONED table
-------test ustore table
CREATE TABLE IF NOT EXISTS test_part_ustore
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(STORAGE_TYPE = USTORE);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_ustore_pkey" for table "test_part_ustore"
insert into test_part_ustore values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_ustore');
                                                       pg_get_tabledef                                                       
-----------------------------------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                                                  +
 CREATE TABLE test_part_ustore (                                                                                            +
     a integer NOT NULL,                                                                                                    +
     b integer                                                                                                              +
 )                                                                                                                          +
 WITH (orientation=row, storage_type=ustore, compression=no)                                                                +
 PARTITION BY RANGE (a)                                                                                                     +
 (                                                                                                                          +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                                                             +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                                                             +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                                                             +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                                             +
 )                                                                                                                          +
 ENABLE ROW MOVEMENT;                                                                                                       +
 ALTER TABLE test_part_ustore ADD CONSTRAINT test_part_ustore_pkey PRIMARY KEY USING ubtree  (a) WITH (storage_type=USTORE);
(1 row)

select * from test_part_ustore partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_ustore partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_ustore test_part_ustore_pkey) */ * from test_part_ustore where a > 0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_ustore_pkey on test_part_ustore  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_ustore;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

-------test segment table
CREATE TABLE IF NOT EXISTS test_part_segment
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(segment = on);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_segment_pkey" for table "test_part_segment"
insert into test_part_segment values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_segment');
                                          pg_get_tabledef                                          
---------------------------------------------------------------------------------------------------
 SET search_path = public;                                                                        +
 CREATE TABLE test_part_segment (                                                                 +
     a integer NOT NULL,                                                                          +
     b integer                                                                                    +
 )                                                                                                +
 WITH (orientation=row, segment=on, compression=no)                                               +
 PARTITION BY RANGE (a)                                                                           +
 (                                                                                                +
     PARTITION m1 VALUES LESS THAN (100) TABLESPACE pg_default,                                   +
     PARTITION m2 VALUES LESS THAN (500) TABLESPACE pg_default,                                   +
     PARTITION p3 VALUES LESS THAN (800) TABLESPACE pg_default,                                   +
     PARTITION p4 VALUES LESS THAN (1200) TABLESPACE pg_default                                   +
 )                                                                                                +
 ENABLE ROW MOVEMENT;                                                                             +
 ALTER TABLE test_part_segment ADD CONSTRAINT test_part_segment_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_part_segment partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_segment partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_segment test_part_segment_pkey) */ * from test_part_segment where a > 0;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_segment_pkey on test_part_segment  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_segment;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

\c postgres;
drop DATABASE if exists partition_test4;

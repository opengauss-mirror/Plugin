create schema partition_test4;
set current_schema to 'partition_test4';
CREATE TABLE test_range_subpart
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)
(
    PARTITION p1 VALUES LESS THAN (200)
    (
        SUBPARTITION s11,
        SUBPARTITION s12,
        SUBPARTITION s13,
        SUBPARTITION s14
    ),
    PARTITION p2 VALUES LESS THAN (500)
    (
        SUBPARTITION s21,
        SUBPARTITION s22
    ),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
    (
        SUBPARTITION s41
    )
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_subpart_pkey" for table "test_range_subpart"
CREATE TABLE test_range_part
(
    a INT4 PRIMARY KEY,
    b INT4
)
PARTITION BY RANGE (a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_range_part_pkey" for table "test_range_part"
create table test_list_part (a int PRIMARY KEY, b int)
partition by list (a)
(
    partition p1 values (1, 2, 3, 4),
    partition p2 values (5, 6, 7, 8),
    partition p3 values (9, 10, 11, 12)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_part_pkey" for table "test_list_part"
create table test_list_subpart (a int PRIMARY KEY, b int)
partition by list (a) SUBPARTITION BY HASH (b)
(
    partition p1 values (1, 2, 3, 4) (subpartition p11),
    partition p2 values (5, 6, 7, 8) (subpartition p12),
    partition p3 values (9, 10, 11, 12) (subpartition p13)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_list_subpart_pkey" for table "test_list_subpart"
insert into test_range_subpart values(199,1),(499,1),(799,1),(1199,1);
insert into test_range_part values(199,1),(499,1),(799,1),(1199,1);
insert into test_list_part values(1,1),(5,1),(9,1);
insert into test_list_subpart values(1,1),(5,1),(9,1);
/*test test_range_subpart*/
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400)(subpartition m21,subpartition m22));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_subpart reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500)(subpartition m21,subpartition m22));
select pg_get_tabledef('test_range_subpart');
                                                    pg_get_tabledef                                                     
------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                                                    +
 CREATE TABLE test_range_subpart (                                                                                     +
     a integer NOT NULL,                                                                                               +
     b integer                                                                                                         +
 )                                                                                                                     +
 WITH (orientation=row, compression=no)                                                                                +
 PARTITION BY RANGE (a) SUBPARTITION BY HASH (b)                                                                       +
 (                                                                                                                     +
     PARTITION m1 VALUES LESS THAN (100)                                                                               +
     (                                                                                                                 +
         SUBPARTITION m1_subpartdefault1                                                                               +
     ),                                                                                                                +
     PARTITION m2 VALUES LESS THAN (500)                                                                               +
     (                                                                                                                 +
         SUBPARTITION m21,                                                                                             +
         SUBPARTITION m22                                                                                              +
     ),                                                                                                                +
     PARTITION p3 VALUES LESS THAN (800)                                                                               +
     (                                                                                                                 +
         SUBPARTITION p3_subpartdefault1                                                                               +
     ),                                                                                                                +
     PARTITION p4 VALUES LESS THAN (1200)                                                                              +
     (                                                                                                                 +
         SUBPARTITION s41                                                                                              +
     )                                                                                                                 +
 )                                                                                                                     +
 ENABLE ROW MOVEMENT;                                                                                                  +
 ALTER TABLE test_range_subpart ADD CONSTRAINT test_range_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_range_subpart subpartition(m22);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_subpart subpartition(m21);
 a | b 
---+---
(0 rows)

select * from test_range_subpart partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_subpart test_range_subpart_pkey) */ * from test_range_subpart where a > 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Index Scan using test_range_subpart_pkey on test_range_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_range_subpart;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_range_part*/
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_range_part reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_range_part');
                                        pg_get_tabledef                                        
-----------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                           +
 CREATE TABLE test_range_part (                                                               +
     a integer NOT NULL,                                                                      +
     b integer                                                                                +
 )                                                                                            +
 WITH (orientation=row, compression=no)                                                       +
 PARTITION BY RANGE (a)                                                                       +
 (                                                                                            +
     PARTITION m1 VALUES LESS THAN (100),                                                     +
     PARTITION m2 VALUES LESS THAN (500),                                                     +
     PARTITION p3 VALUES LESS THAN (800),                                                     +
     PARTITION p4 VALUES LESS THAN (1200)                                                     +
 )                                                                                            +
 ENABLE ROW MOVEMENT;                                                                         +
 ALTER TABLE test_range_part ADD CONSTRAINT test_range_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_range_part partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_range_part partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_range_part test_range_part_pkey) */ * from test_range_part where a > 0;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_range_part_pkey on test_range_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_range_part;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

/*test test_list_part*/
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_part reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_part');
                                       pg_get_tabledef                                       
---------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                         +
 CREATE TABLE test_list_part (                                                              +
     a integer NOT NULL,                                                                    +
     b integer                                                                              +
 )                                                                                          +
 WITH (orientation=row, compression=no)                                                     +
 PARTITION BY LIST (a)                                                                      +
 (                                                                                          +
     PARTITION m2 VALUES (1,4,7),                                                           +
     PARTITION m1 VALUES (2,3,5,13),                                                        +
     PARTITION p3 VALUES (9,10,11,12)                                                       +
 )                                                                                          +
 ENABLE ROW MOVEMENT;                                                                       +
 ALTER TABLE test_list_part ADD CONSTRAINT test_list_part_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_list_part partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_part partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_part test_list_part_pkey) */ * from test_list_part where a > 0;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 3
   ->  Partitioned Index Scan using test_list_part_pkey on test_list_part  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..3
(5 rows)

select * from test_list_part where a > 0 order by a;
 a | b 
---+---
 1 | 1
 5 | 1
 9 | 1
(3 rows)

/*test test_list_subpart*/
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3),partition m2 values(4));
ERROR:  inserted partition key does not map to any table partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5),partition m2 values(1,2,4));
ERROR:  list partition m1 and m2 has overlapped value
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13),partition m2 values(1,4,9));
ERROR:  list boundary of adding partition MUST NOT overlap with existing partition
alter table test_list_subpart reorganize partition p1,p2 into (partition m1 values(2,3,5,13)(subpartition m11,subpartition m12),partition m2 values(1,4,7));
select pg_get_tabledef('test_list_subpart');
                                                   pg_get_tabledef                                                    
----------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                                                  +
 CREATE TABLE test_list_subpart (                                                                                    +
     a integer NOT NULL,                                                                                             +
     b integer                                                                                                       +
 )                                                                                                                   +
 WITH (orientation=row, compression=no)                                                                              +
 PARTITION BY LIST (a) SUBPARTITION BY HASH (b)                                                                      +
 (                                                                                                                   +
     PARTITION m2 VALUES (1,4,7)                                                                                     +
     (                                                                                                               +
         SUBPARTITION m2_subpartdefault1                                                                             +
     ),                                                                                                              +
     PARTITION m1 VALUES (2,3,5,13)                                                                                  +
     (                                                                                                               +
         SUBPARTITION m11,                                                                                           +
         SUBPARTITION m12                                                                                            +
     ),                                                                                                              +
     PARTITION p3 VALUES (9,10,11,12)                                                                                +
     (                                                                                                               +
         SUBPARTITION p13                                                                                            +
     )                                                                                                               +
 )                                                                                                                   +
 ENABLE ROW MOVEMENT;                                                                                                +
 ALTER TABLE test_list_subpart ADD CONSTRAINT test_list_subpart_pkey PRIMARY KEY USING btree  (a) INCLUDE (tableoid);
(1 row)

select * from test_list_subpart partition(m2);
 a | b 
---+---
 1 | 1
(1 row)

select * from test_list_subpart partition(m1);
 a | b 
---+---
 5 | 1
(1 row)

select * from test_list_subpart subpartition(m11);
 a | b 
---+---
(0 rows)

select * from test_list_subpart subpartition(m12);
 a | b 
---+---
 5 | 1
(1 row)

explain select /*+ indexscan(test_list_subpart test_list_subpart_pkey) */ * from test_list_subpart where a > 0;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Index Scan using test_list_subpart_pkey on test_list_subpart  (cost=0.00..64.78 rows=716 width=8)
   Index Cond: (a > 0)
(2 rows)

select * from test_list_subpart where a > 0 order by a desc;
 a | b 
---+---
 9 | 1
 5 | 1
 1 | 1
(3 rows)

-------test no-partitioned table
create table test_no_part(a int,b int);
alter table test_no_part reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  can not Reorganize partition against NON-PARTITIONED table
-------test ustore table
CREATE TABLE IF NOT EXISTS test_part_ustore
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(STORAGE_TYPE = USTORE);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_ustore_pkey" for table "test_part_ustore"
insert into test_part_ustore values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_ustore reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_ustore');
                                                               pg_get_tabledef                                                               
---------------------------------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                                                                         +
 CREATE TABLE test_part_ustore (                                                                                                            +
     a integer NOT NULL,                                                                                                                    +
     b integer                                                                                                                              +
 )                                                                                                                                          +
 WITH (orientation=row, storage_type=ustore, compression=no)                                                                                +
 PARTITION BY RANGE (a)                                                                                                                     +
 (                                                                                                                                          +
     PARTITION m1 VALUES LESS THAN (100),                                                                                                   +
     PARTITION m2 VALUES LESS THAN (500),                                                                                                   +
     PARTITION p3 VALUES LESS THAN (800),                                                                                                   +
     PARTITION p4 VALUES LESS THAN (1200)                                                                                                   +
 )                                                                                                                                          +
 ENABLE ROW MOVEMENT;                                                                                                                       +
 ALTER TABLE test_part_ustore ADD CONSTRAINT test_part_ustore_pkey PRIMARY KEY USING ubtree  (a) WITH (storage_type=ustore, index_type=rcr);
(1 row)

select * from test_part_ustore partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_ustore partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_ustore test_part_ustore_pkey) */ * from test_part_ustore where a > 0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_ustore_pkey on test_part_ustore  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_ustore;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

-------test segment table
CREATE TABLE IF NOT EXISTS test_part_segment
(
a int primary key not null,
b int
) 
PARTITION BY RANGE(a)
(
    PARTITION p1 VALUES LESS THAN (200),
    PARTITION p2 VALUES LESS THAN (500),
    PARTITION p3 VALUES LESS THAN (800),
    PARTITION p4 VALUES LESS THAN (1200)
) with(segment = on);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_part_segment_pkey" for table "test_part_segment"
insert into test_part_segment values(199,1),(499,1),(799,1),(1199,1);
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(600));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(300),partition m2 values less than(400));
ERROR:  the bound of the last resulting partition is not equal with specified partition bound
alter table test_part_segment reorganize partition p1,p2 into (partition m1 values less than(100),partition m2 values less than(500));
select pg_get_tabledef('test_part_segment');
                                          pg_get_tabledef                                          
---------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                               +
 CREATE TABLE test_part_segment (                                                                 +
     a integer NOT NULL,                                                                          +
     b integer                                                                                    +
 )                                                                                                +
 WITH (orientation=row, segment=on, compression=no)                                               +
 PARTITION BY RANGE (a)                                                                           +
 (                                                                                                +
     PARTITION m1 VALUES LESS THAN (100),                                                         +
     PARTITION m2 VALUES LESS THAN (500),                                                         +
     PARTITION p3 VALUES LESS THAN (800),                                                         +
     PARTITION p4 VALUES LESS THAN (1200)                                                         +
 )                                                                                                +
 ENABLE ROW MOVEMENT;                                                                             +
 ALTER TABLE test_part_segment ADD CONSTRAINT test_part_segment_pkey PRIMARY KEY USING btree  (a);
(1 row)

select * from test_part_segment partition(m2);
  a  | b 
-----+---
 199 | 1
 499 | 1
(2 rows)

select * from test_part_segment partition(m1);
 a | b 
---+---
(0 rows)

explain select /*+ indexscan(test_part_segment test_part_segment_pkey) */ * from test_part_segment where a > 0;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Partition Iterator  (cost=0.00..84.78 rows=716 width=8)
   Iterations: 4
   ->  Partitioned Index Scan using test_part_segment_pkey on test_part_segment  (cost=0.00..84.78 rows=716 width=8)
         Index Cond: (a > 0)
         Selected Partitions:  1..4
(5 rows)

select * from test_part_segment;
  a   | b 
------+---
  199 | 1
  499 | 1
  799 | 1
 1199 | 1
(4 rows)

-------test table with local index
drop table if exists b_range_hash_t01;
NOTICE:  table "b_range_hash_t01" does not exist, skipping
create table b_range_hash_t01(c1 int primary key,c2 int,c3 text)
partition by range(c1) subpartition by hash(c2)
(
partition p1 values less than (100)
(
subpartition p1_1,
subpartition p1_2
),
partition p2 values less than (200)
(
subpartition p2_1,
subpartition p2_2
),
partition p3 values less than (300)
(
subpartition p3_1,
subpartition p3_2
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_hash_t01_pkey" for table "b_range_hash_t01"
create index on b_range_hash_t01 (c1) global;
create index on b_range_hash_t01 (c2) local;
insert into b_range_hash_t01 values(1,2,3),(51,3,4);
select pg_get_tabledef('b_range_hash_t01');
                                                   pg_get_tabledef                                                   
---------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                                                 +
 CREATE TABLE b_range_hash_t01 (                                                                                    +
     c1 integer NOT NULL,                                                                                           +
     c2 integer,                                                                                                    +
     c3 text                                                                                                        +
 )                                                                                                                  +
 WITH (orientation=row, compression=no)                                                                             +
 PARTITION BY RANGE (c1) SUBPARTITION BY HASH (c2)                                                                  +
 (                                                                                                                  +
     PARTITION p1 VALUES LESS THAN (100)                                                                            +
     (                                                                                                              +
         SUBPARTITION p1_1,                                                                                         +
         SUBPARTITION p1_2                                                                                          +
     ),                                                                                                             +
     PARTITION p2 VALUES LESS THAN (200)                                                                            +
     (                                                                                                              +
         SUBPARTITION p2_1,                                                                                         +
         SUBPARTITION p2_2                                                                                          +
     ),                                                                                                             +
     PARTITION p3 VALUES LESS THAN (300)                                                                            +
     (                                                                                                              +
         SUBPARTITION p3_1,                                                                                         +
         SUBPARTITION p3_2                                                                                          +
     )                                                                                                              +
 )                                                                                                                  +
 ENABLE ROW MOVEMENT;                                                                                               +
 CREATE INDEX b_range_hash_t01_c2_idx ON b_range_hash_t01 USING btree (c2) LOCAL(                                   +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p1_1_c2_idx,                                                                                  +
         SUBPARTITION p1_2_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p2_1_c2_idx,                                                                                  +
         SUBPARTITION p2_2_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p3_1_c2_idx,                                                                                  +
         SUBPARTITION p3_2_c2_idx                                                                                   +
     )                                                                                                              +
 )  TABLESPACE pg_default;                                                                                          +
 CREATE INDEX b_range_hash_t01_c1_tableoid_idx ON b_range_hash_t01 USING btree (c1) TABLESPACE pg_default;          +
 ALTER TABLE b_range_hash_t01 ADD CONSTRAINT b_range_hash_t01_pkey PRIMARY KEY USING btree  (c1) INCLUDE (tableoid);
(1 row)

alter table b_range_hash_t01 reorganize partition p1 into (partition m1 values less than(50) (subpartition m1_1,subpartition m1_2,subpartition m1_3),partition m2 values less than(100));
select pg_get_tabledef('b_range_hash_t01');
                                                   pg_get_tabledef                                                   
---------------------------------------------------------------------------------------------------------------------
 SET search_path = partition_test4;                                                                                 +
 CREATE TABLE b_range_hash_t01 (                                                                                    +
     c1 integer NOT NULL,                                                                                           +
     c2 integer,                                                                                                    +
     c3 text                                                                                                        +
 )                                                                                                                  +
 WITH (orientation=row, compression=no)                                                                             +
 PARTITION BY RANGE (c1) SUBPARTITION BY HASH (c2)                                                                  +
 (                                                                                                                  +
     PARTITION m1 VALUES LESS THAN (50)                                                                             +
     (                                                                                                              +
         SUBPARTITION m1_1,                                                                                         +
         SUBPARTITION m1_2,                                                                                         +
         SUBPARTITION m1_3                                                                                          +
     ),                                                                                                             +
     PARTITION m2 VALUES LESS THAN (100)                                                                            +
     (                                                                                                              +
         SUBPARTITION m2_subpartdefault1                                                                            +
     ),                                                                                                             +
     PARTITION p2 VALUES LESS THAN (200)                                                                            +
     (                                                                                                              +
         SUBPARTITION p2_1,                                                                                         +
         SUBPARTITION p2_2                                                                                          +
     ),                                                                                                             +
     PARTITION p3 VALUES LESS THAN (300)                                                                            +
     (                                                                                                              +
         SUBPARTITION p3_1,                                                                                         +
         SUBPARTITION p3_2                                                                                          +
     )                                                                                                              +
 )                                                                                                                  +
 ENABLE ROW MOVEMENT;                                                                                               +
 CREATE INDEX b_range_hash_t01_c2_idx ON b_range_hash_t01 USING btree (c2) LOCAL(                                   +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION m1_1_c2_idx,                                                                                  +
         SUBPARTITION m1_2_c2_idx,                                                                                  +
         SUBPARTITION m1_3_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION m2_subpartdefault1_c2_idx                                                                     +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p2_1_c2_idx,                                                                                  +
         SUBPARTITION p2_2_c2_idx                                                                                   +
     ),                                                                                                             +
     PARTITION partition_name(                                                                                      +
         SUBPARTITION p3_1_c2_idx,                                                                                  +
         SUBPARTITION p3_2_c2_idx                                                                                   +
     )                                                                                                              +
 )  TABLESPACE pg_default;                                                                                          +
 CREATE INDEX b_range_hash_t01_c1_tableoid_idx ON b_range_hash_t01 USING btree (c1) TABLESPACE pg_default;          +
 ALTER TABLE b_range_hash_t01 ADD CONSTRAINT b_range_hash_t01_pkey PRIMARY KEY USING btree  (c1) INCLUDE (tableoid);
(1 row)

select * from b_range_hash_t01 partition(m1);
 c1 | c2 | c3 
----+----+----
  1 |  2 | 3
(1 row)

select * from b_range_hash_t01 partition(m2);
 c1 | c2 | c3 
----+----+----
 51 |  3 | 4
(1 row)

--test some cases about partition expr key
create table part_key_range_t1(col1 date, col2 int) partition by range(year(col1))
(
    partition p1 values less than(2000),
    partition p2 values less than(3000)
);
select pg_get_tabledef('part_key_range_t1');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = partition_test4;                            +
 CREATE TABLE part_key_range_t1 (                              +
     col1 date,                                                +
     col2 integer                                              +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (year((col1)::timestamp without time zone))+
 (                                                             +
     PARTITION p1 VALUES LESS THAN (2000),                     +
     PARTITION p2 VALUES LESS THAN (3000)                      +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t1 add partition p3 values less than(4000);
select pg_get_tabledef('part_key_range_t1');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = partition_test4;                            +
 CREATE TABLE part_key_range_t1 (                              +
     col1 date,                                                +
     col2 integer                                              +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (year((col1)::timestamp without time zone))+
 (                                                             +
     PARTITION p1 VALUES LESS THAN (2000),                     +
     PARTITION p2 VALUES LESS THAN (3000),                     +
     PARTITION p3 VALUES LESS THAN (4000)                      +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t1 split partition p1 into (partition m1 values less than(1000), partition m2 values less than(2000));
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select pg_get_tabledef('part_key_range_t1');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = partition_test4;                            +
 CREATE TABLE part_key_range_t1 (                              +
     col1 date,                                                +
     col2 integer                                              +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (year((col1)::timestamp without time zone))+
 (                                                             +
     PARTITION m1 VALUES LESS THAN (1000),                     +
     PARTITION m2 VALUES LESS THAN (2000),                     +
     PARTITION p2 VALUES LESS THAN (3000),                     +
     PARTITION p3 VALUES LESS THAN (4000)                      +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t1 merge partitions m1,m2 into partition p1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select pg_get_tabledef('part_key_range_t1');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = partition_test4;                            +
 CREATE TABLE part_key_range_t1 (                              +
     col1 date,                                                +
     col2 integer                                              +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (year((col1)::timestamp without time zone))+
 (                                                             +
     PARTITION p1 VALUES LESS THAN (2000),                     +
     PARTITION p2 VALUES LESS THAN (3000),                     +
     PARTITION p3 VALUES LESS THAN (4000)                      +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t1 reorganize partition p1,p2 into (partition m1 values less than(1000),partition m2 values less than(3000));
select pg_get_tabledef('part_key_range_t1');
                        pg_get_tabledef                         
----------------------------------------------------------------
 SET search_path = partition_test4;                            +
 CREATE TABLE part_key_range_t1 (                              +
     col1 date,                                                +
     col2 integer                                              +
 )                                                             +
 WITH (orientation=row, compression=no)                        +
 PARTITION BY RANGE (year((col1)::timestamp without time zone))+
 (                                                             +
     PARTITION m1 VALUES LESS THAN (1000),                     +
     PARTITION m2 VALUES LESS THAN (3000),                     +
     PARTITION p3 VALUES LESS THAN (4000)                      +
 )                                                             +
 ENABLE ROW MOVEMENT;
(1 row)

create table part_key_range_t2(col1 date, col2 int) partition by range(to_days(col1))
(
    partition p1 values less than(60000),
    partition p2 values less than(80000)
);
select pg_get_tabledef('part_key_range_t2');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = partition_test4;                               +
 CREATE TABLE part_key_range_t2 (                                 +
     col1 date,                                                   +
     col2 integer                                                 +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (to_days((col1)::timestamp without time zone))+
 (                                                                +
     PARTITION p1 VALUES LESS THAN (60000),                       +
     PARTITION p2 VALUES LESS THAN (80000)                        +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t2 add partition p3 values less than(90000);
select pg_get_tabledef('part_key_range_t2');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = partition_test4;                               +
 CREATE TABLE part_key_range_t2 (                                 +
     col1 date,                                                   +
     col2 integer                                                 +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (to_days((col1)::timestamp without time zone))+
 (                                                                +
     PARTITION p1 VALUES LESS THAN (60000),                       +
     PARTITION p2 VALUES LESS THAN (80000),                       +
     PARTITION p3 VALUES LESS THAN (90000)                        +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t2 split partition p1 into (partition m1 values less than(50000), partition m2 values less than(60000));
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select pg_get_tabledef('part_key_range_t2');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = partition_test4;                               +
 CREATE TABLE part_key_range_t2 (                                 +
     col1 date,                                                   +
     col2 integer                                                 +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (to_days((col1)::timestamp without time zone))+
 (                                                                +
     PARTITION m1 VALUES LESS THAN (50000),                       +
     PARTITION m2 VALUES LESS THAN (60000),                       +
     PARTITION p2 VALUES LESS THAN (80000),                       +
     PARTITION p3 VALUES LESS THAN (90000)                        +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t2 merge partitions m1,m2 into partition p1;
NOTICE:  Command without UPDATE GLOBAL INDEX will disable global index
select pg_get_tabledef('part_key_range_t2');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = partition_test4;                               +
 CREATE TABLE part_key_range_t2 (                                 +
     col1 date,                                                   +
     col2 integer                                                 +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (to_days((col1)::timestamp without time zone))+
 (                                                                +
     PARTITION p1 VALUES LESS THAN (60000),                       +
     PARTITION p2 VALUES LESS THAN (80000),                       +
     PARTITION p3 VALUES LESS THAN (90000)                        +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_range_t2 reorganize partition p1,p2 into (partition m1 values less than(70000),partition m2 values less than(80000));
select pg_get_tabledef('part_key_range_t2');
                          pg_get_tabledef                          
-------------------------------------------------------------------
 SET search_path = partition_test4;                               +
 CREATE TABLE part_key_range_t2 (                                 +
     col1 date,                                                   +
     col2 integer                                                 +
 )                                                                +
 WITH (orientation=row, compression=no)                           +
 PARTITION BY RANGE (to_days((col1)::timestamp without time zone))+
 (                                                                +
     PARTITION m1 VALUES LESS THAN (70000),                       +
     PARTITION m2 VALUES LESS THAN (80000),                       +
     PARTITION p3 VALUES LESS THAN (90000)                        +
 )                                                                +
 ENABLE ROW MOVEMENT;
(1 row)

create table part_key_list_t1(col1 date, col2 int) partition by list(year(col1))
(
    partition p1 values(2000),
    partition p2 values(3000)
);
select pg_get_tabledef('part_key_list_t1');
                        pg_get_tabledef                        
---------------------------------------------------------------
 SET search_path = partition_test4;                           +
 CREATE TABLE part_key_list_t1 (                              +
     col1 date,                                               +
     col2 integer                                             +
 )                                                            +
 WITH (orientation=row, compression=no)                       +
 PARTITION BY LIST (year((col1)::timestamp without time zone))+
 (                                                            +
     PARTITION p1 VALUES (2000),                              +
     PARTITION p2 VALUES (3000)                               +
 )                                                            +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_list_t1 add partition p3 values(4000);
select pg_get_tabledef('part_key_list_t1');
                        pg_get_tabledef                        
---------------------------------------------------------------
 SET search_path = partition_test4;                           +
 CREATE TABLE part_key_list_t1 (                              +
     col1 date,                                               +
     col2 integer                                             +
 )                                                            +
 WITH (orientation=row, compression=no)                       +
 PARTITION BY LIST (year((col1)::timestamp without time zone))+
 (                                                            +
     PARTITION p1 VALUES (2000),                              +
     PARTITION p2 VALUES (3000),                              +
     PARTITION p3 VALUES (4000)                               +
 )                                                            +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_list_t1 reorganize partition p1,p2 into (partition m1 values(1000,3000),partition m2 values(2000,5000));
select pg_get_tabledef('part_key_list_t1');
                        pg_get_tabledef                        
---------------------------------------------------------------
 SET search_path = partition_test4;                           +
 CREATE TABLE part_key_list_t1 (                              +
     col1 date,                                               +
     col2 integer                                             +
 )                                                            +
 WITH (orientation=row, compression=no)                       +
 PARTITION BY LIST (year((col1)::timestamp without time zone))+
 (                                                            +
     PARTITION m1 VALUES (1000,3000),                         +
     PARTITION m2 VALUES (2000,5000),                         +
     PARTITION p3 VALUES (4000)                               +
 )                                                            +
 ENABLE ROW MOVEMENT;
(1 row)

create table part_key_list_t2(col1 date, col2 int) partition by list(to_days(col1))
(
    partition p1 values(60000),
    partition p2 values(80000)
);
select pg_get_tabledef('part_key_list_t2');
                         pg_get_tabledef                          
------------------------------------------------------------------
 SET search_path = partition_test4;                              +
 CREATE TABLE part_key_list_t2 (                                 +
     col1 date,                                                  +
     col2 integer                                                +
 )                                                               +
 WITH (orientation=row, compression=no)                          +
 PARTITION BY LIST (to_days((col1)::timestamp without time zone))+
 (                                                               +
     PARTITION p1 VALUES (60000),                                +
     PARTITION p2 VALUES (80000)                                 +
 )                                                               +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_list_t2 add partition p3 values(90000);
select pg_get_tabledef('part_key_list_t2');
                         pg_get_tabledef                          
------------------------------------------------------------------
 SET search_path = partition_test4;                              +
 CREATE TABLE part_key_list_t2 (                                 +
     col1 date,                                                  +
     col2 integer                                                +
 )                                                               +
 WITH (orientation=row, compression=no)                          +
 PARTITION BY LIST (to_days((col1)::timestamp without time zone))+
 (                                                               +
     PARTITION p1 VALUES (60000),                                +
     PARTITION p2 VALUES (80000),                                +
     PARTITION p3 VALUES (90000)                                 +
 )                                                               +
 ENABLE ROW MOVEMENT;
(1 row)

alter table part_key_list_t2 reorganize partition p1,p2 into (partition m1 values(10000,80000),partition m2 values(60000,50000));
select pg_get_tabledef('part_key_list_t2');
                         pg_get_tabledef                          
------------------------------------------------------------------
 SET search_path = partition_test4;                              +
 CREATE TABLE part_key_list_t2 (                                 +
     col1 date,                                                  +
     col2 integer                                                +
 )                                                               +
 WITH (orientation=row, compression=no)                          +
 PARTITION BY LIST (to_days((col1)::timestamp without time zone))+
 (                                                               +
     PARTITION m1 VALUES (10000,80000),                          +
     PARTITION m2 VALUES (60000,50000),                          +
     PARTITION p3 VALUES (90000)                                 +
 )                                                               +
 ENABLE ROW MOVEMENT;
(1 row)

create table part_key_t1 (col1 date, col2 date) partition by range( year(col2) )
subpartition by hash( to_days(col1) )
(
    partition p1 values less than (2000)
    (
        SUBPARTITION p1sub1,
        SUBPARTITION p1sub2
    ),
    partition p2 values less than (3000)
    (
        SUBPARTITION p2sub1,
        SUBPARTITION p2sub2
    )
);
alter table part_key_t1 add partition p3 values less than(4000);
alter table part_key_t1 reorganize partition p1,p2 into (partition m1 values less than(1000), partition m2 values less than(3000));
create table b_range_at1(c1 date,c2 int)
partition by range(TO_SECONDS(c1)) (
partition p1 values less than(63838026063),
partition p2 values less than(63838026065),
partition p3 values less than(63838026067)
);
select pg_get_tabledef('b_range_at1');
                 pg_get_tabledef                  
--------------------------------------------------
 SET search_path = partition_test4;              +
 CREATE TABLE b_range_at1 (                      +
     c1 date,                                    +
     c2 integer                                  +
 )                                               +
 WITH (orientation=row, compression=no)          +
 PARTITION BY RANGE (to_seconds(c1))             +
 (                                               +
     PARTITION p1 VALUES LESS THAN (63838026063),+
     PARTITION p2 VALUES LESS THAN (63838026065),+
     PARTITION p3 VALUES LESS THAN (63838026067) +
 )                                               +
 ENABLE ROW MOVEMENT;
(1 row)

--test some error cases
create table b_range_hash_t05(c1 int primary key,c2 int,c3 text)
with (segment=on)
partition by range(c1) subpartition by hash(c2)
(
partition p1 values less than (100)
(
subpartition p1_1,
subpartition p1_2
),
partition p2 values less than (200)
(
subpartition p2_1,
subpartition p2_2
),
partition p3 values less than (300)
(
subpartition p3_1,
subpartition p3_2
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_hash_t05_pkey" for table "b_range_hash_t05"
create index on b_range_hash_t05 (c1) global;
create index on b_range_hash_t05 (c2) local;
alter table b_range_hash_t05 reorganize partition p1 into 
(
	partition m1 values less than(50) 
	(subpartition m1_1 tablespace pg_global,subpartition m1_2,subpartition m1_3),
	partition m2 values less than(100) 
	(subpartition m2_1)
);
ERROR:  only shared relations can be placed in pg_global tablespace
alter table b_range_hash_t01 reorganize partition m1 into (partition k1 values less than(2) (subpartition k1_1 values less than(2)));
ERROR:  The subpartition def type must be HASH
alter table b_range_hash_t01 reorganize partition m1 into (partition k1 values less than(2) (subpartition k1_1 values (1)));
ERROR:  The subpartition def type must be HASH
alter table b_range_hash_t01 reorganize partition m1 into (partition m11 values (1,2,3));
ERROR:  The dest partdef type must be range
drop table if exists b_interval_t1;
NOTICE:  table "b_interval_t1" does not exist, skipping
create table b_interval_t1(c1 int primary key,c2 timestamp)
partition by range(c2)
interval('1 day')
(
partition p1 values less than ('1990-01-01 00:00:00'),
partition p2 values less than ('1990-01-02 00:00:00'),
partition p3 values less than ('1990-01-03 00:00:00'),
partition p4 values less than ('1990-01-04 00:00:00'),
partition p5 values less than ('1990-01-05 00:00:00'),
partition p6 values less than ('1990-01-06 00:00:00'),
partition p7 values less than ('1990-01-07 00:00:00'),
partition p8 values less than ('1990-01-08 00:00:00'),
partition p9 values less than ('1990-01-09 00:00:00'),
partition p10 values less than ('1990-01-10 00:00:00')
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_interval_t1_pkey" for table "b_interval_t1"
alter table b_interval_t1 reorganize partition p2,p3 into (partition m1 values less than('1990-01-03 00:00:00'));
ERROR:  can not reorganize partition against interval partitioned table
alter table b_interval_t1 reorganize partition p4 into (partition m2 values less than('1990-01-03 12:00:00'),partition m3 values less than('1990-01-04 00:00:00'));
ERROR:  can not reorganize partition against interval partitioned table
drop table if exists b_range_range_t01;
NOTICE:  table "b_range_range_t01" does not exist, skipping
create table b_range_range_t01(c1 int primary key,c2 int,c3 int)
partition by range(c1) subpartition by range(c2)
(
partition p1 values less than (100)
(
subpartition p1_1 values less than (50),
subpartition p1_2 values less than (100)
),
partition p2 values less than (200)
(
subpartition p2_1 values less than (150),
subpartition p2_2 values less than (200)
),
partition p3 values less than (300)
(
subpartition p3_1 values less than (250),
subpartition p3_2 values less than (300)
)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_range_t01_pkey" for table "b_range_range_t01"
alter table b_range_range_t01 reorganize partition p1 into (partition m1 values less than(100) (subpartition m1_1 values less than(50),subpartition m1_2 values less than(100)));
ERROR:  The subpartition def type must be HASH
alter table b_range_range_t01 reorganize partition p1 into (partition m1 values less than(100) (subpartition m1_1));
ERROR:  The subpart type must be HASH for REORGANIZE PARTITION
drop table if exists b_range_mt1;
NOTICE:  table "b_range_mt1" does not exist, skipping
create table b_range_mt1(c1 int primary key,c2 int)
partition by range(c1) (
partition p0 start (0) end (100),
partition p1 start (100) end (200),
partition p2 start (200) end (300),
partition p3 start (300) end (maxvalue)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_mt1_pkey" for table "b_range_mt1"
alter table b_range_mt1 reorganize partition p3 into (partition m1 start(300) end(400),partition m2 start(400) end(maxvalue));
ERROR:  Reorganize Partition not support start_end_def syntax
drop table if exists b_range_mt2;
NOTICE:  table "b_range_mt2" does not exist, skipping
create table b_range_mt2(c1 int primary key,c2 int)
partition by range(2 div c1) (
partition p1 values less than(200),
partition p2 values less than(300),
partition p3 values less than (maxvalue)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "b_range_mt2_pkey" for table "b_range_mt2"
CREATE TABLE slb_monitor_drop_part (
 monitor_time timestamp(6) without time zone
) PARTITION BY RANGE (to_days(monitor_time))
(PARTITION p20210801 VALUES LESS THAN (738369),
 PARTITION p20210802 VALUES LESS THAN (738370),
 PARTITION p20210803 VALUES LESS THAN (738371),
 PARTITION p20210804 VALUES LESS THAN (738372),
 PARTITION p20210805 VALUES LESS THAN (738373),
 PARTITION p20210806 VALUES LESS THAN (738374),
 PARTITION p20210807 VALUES LESS THAN (738375),
 PARTITION p20210808 VALUES LESS THAN (738376),
 PARTITION p20210809 VALUES LESS THAN (738377));
set enable_opfusion to on;
set enable_partition_opfusion to on;
insert into slb_monitor_drop_part values('2021-08-05 11:50:14.000000');
copy slb_monitor_drop_part from stdin;
select * from slb_monitor_drop_part;
    monitor_time     
---------------------
 2021-08-05 11:50:14
 2021-08-05 11:50:15
(2 rows)

reset enable_opfusion;
reset enable_partition_opfusion;
CREATE TABLE tt1 (a DATE, KEY(a))
PARTITION BY RANGE (TO_DAYS(a))
(PARTITION `pNULL` VALUES LESS THAN (0),
PARTITION `p0001-01-01` VALUES LESS THAN (366 + 1),
PARTITION `p1001-01-01` VALUES LESS THAN (TO_DAYS('1001-01-01') + 1),
PARTITION `p2001-01-01` VALUES LESS THAN (TO_DAYS('2001-01-01') + 1));
insert into tt1 values ('0001-01-01');
insert into tt1 values ('2001-01-01');
insert into tt1 values ('2001-01-02');
ERROR:  inserted partition key does not map to any table partition
drop table tt1;
drop schema partition_test4 cascade;
NOTICE:  drop cascades to 20 other objects
DETAIL:  drop cascades to table test_range_subpart
drop cascades to table test_range_part
drop cascades to table test_list_part
drop cascades to table test_list_subpart
drop cascades to table test_no_part
drop cascades to table test_part_ustore
drop cascades to table test_part_segment
drop cascades to table b_range_hash_t01
drop cascades to table part_key_range_t1
drop cascades to table part_key_range_t2
drop cascades to table part_key_list_t1
drop cascades to table part_key_list_t2
drop cascades to table part_key_t1
drop cascades to table b_range_at1
drop cascades to table b_range_hash_t05
drop cascades to table b_interval_t1
drop cascades to table b_range_range_t01
drop cascades to table b_range_mt1
drop cascades to table b_range_mt2
drop cascades to table slb_monitor_drop_part
reset current_schema;

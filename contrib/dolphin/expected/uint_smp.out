create schema uint_smp;
set current_schema to 'uint_smp';
set enable_opfusion = on;
set opfusion_debug_mode = log;
drop table if exists t2 ;
NOTICE:  table "t2" does not exist, skipping
create table t2(a uint1);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Seq Scan on uint_smp.t2
         Output: uint_smp.t2.a
         Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a > 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a > 500) AND (uint_smp.t2.a = 2))
(11 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Seq Scan on uint_smp.t2
         Output: uint_smp.t2.a
         Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a > 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a > 500) AND (uint_smp.t2.a = 2))
(11 rows)

 set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint2);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Seq Scan on uint_smp.t2
         Output: uint_smp.t2.a
         Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a > 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a > 500) AND (uint_smp.t2.a = 2))
(11 rows)

set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a > 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/4)
               Output: uint_smp.t2.a
               ->  Seq Scan on uint_smp.t2
                     Output: uint_smp.t2.a
                     Filter: ((uint_smp.t2.a > 500) AND (uint_smp.t2.a = 2))
(15 rows)

set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint4);
insert into t2 select generate_series(1,200000);
insert into t2 select generate_series(1,200000);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a < 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Seq Scan on uint_smp.t2
         Output: uint_smp.t2.a
         Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a < 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a < 500) AND (uint_smp.t2.a = 2))
(11 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on uint_smp.t2
         Output: a
         Filter: (t2.a = 2)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a < 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a = 2) AND (uint_smp.t2.a < 500))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/4)
               Output: uint_smp.t2.a
               ->  Seq Scan on uint_smp.t2
                     Output: uint_smp.t2.a
                     Filter: ((uint_smp.t2.a < 500) AND (uint_smp.t2.a = 2))
(15 rows)

 set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint8);
insert into t2 select generate_series(1,200000);
insert into t2 select generate_series(1,200000);
explain(costs off, verbose)   select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on uint_smp.t2
   Output: a
   Filter: (t2.a = 2::bigint)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a < 500);
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Seq Scan on uint_smp.t2
         Output: uint_smp.t2.a
         Filter: ((uint_smp.t2.a = 2::bigint) AND (uint_smp.t2.a < 500::bigint))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a < 500::bigint) AND (uint_smp.t2.a = 2::bigint))
(11 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on uint_smp.t2
         Output: a
         Filter: (t2.a = 2::bigint)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a < 500);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Nested Loop Semi Join
   Output: uint_smp.t2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: uint_smp.t2.a
         ->  Seq Scan on uint_smp.t2
               Output: uint_smp.t2.a
               Filter: ((uint_smp.t2.a = 2::bigint) AND (uint_smp.t2.a < 500::bigint))
   ->  Materialize
         Output: uint_smp.t2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/4)
               Output: uint_smp.t2.a
               ->  Seq Scan on uint_smp.t2
                     Output: uint_smp.t2.a
                     Filter: ((uint_smp.t2.a < 500::bigint) AND (uint_smp.t2.a = 2::bigint))
(15 rows)

 set query_dop = 1;
set opfusion_debug_mode = off;
create table join_1(a uint4);
create table join_2(a uint8);
insert into join_1 select generate_series(1, 150000);
insert into join_2 select generate_series(1, 150000);
set query_dop = 2;
explain(costs off, verbose) select * from join_1 join join_2;
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: join_1.a, join_2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Materialize
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(12 rows)

explain(costs off, verbose) select * from join_1 join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 right join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Right Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 inner join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ nestloop(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop Left Join
   Output: join_1.a, join_2.a
   Join Filter: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Materialize
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ hashjoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ mergejoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
WARNING:  unused hint: MergeJoin(join_1 join_2)
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: (join_1.a = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on uint_smp.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on uint_smp.join_2
                     Output: join_2.a
(13 rows)

drop schema uint_smp cascade;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table t2
drop cascades to table join_1
drop cascades to table join_2
reset current_schema;

drop database if exists uint_smp;
NOTICE:  database "uint_smp" does not exist, skipping
create database uint_smp dbcompatibility 'b';
\c uint_smp
set enable_opfusion = on;
set opfusion_debug_mode = log;
drop table if exists t2 ;
NOTICE:  table "t2" does not exist, skipping
create table t2(a uint1);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
insert into t2 select generate_series(1,255);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on public.t2
   Output: a
   Filter: ((t2.a)::uint4 = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Seq Scan on public.t2
         Output: public.t2.a
         Filter: (((public.t2.a)::uint4 = 2) AND ((public.t2.a)::uint4 > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Seq Scan on public.t2
                     Output: public.t2.a
                     Filter: (((public.t2.a)::uint4 > 500) AND ((public.t2.a)::uint4 = 2))
(15 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on public.t2
   Output: a
   Filter: ((t2.a)::uint4 = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Seq Scan on public.t2
         Output: public.t2.a
         Filter: (((public.t2.a)::uint4 = 2) AND ((public.t2.a)::uint4 > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Seq Scan on public.t2
                     Output: public.t2.a
                     Filter: (((public.t2.a)::uint4 > 500) AND ((public.t2.a)::uint4 = 2))
(15 rows)

 set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint2);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
insert into t2 select generate_series(1,25500);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on public.t2
   Output: a
   Filter: ((t2.a)::uint4 = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Seq Scan on public.t2
         Output: public.t2.a
         Filter: (((public.t2.a)::uint4 = 2) AND ((public.t2.a)::uint4 > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Seq Scan on public.t2
                     Output: public.t2.a
                     Filter: (((public.t2.a)::uint4 > 500) AND ((public.t2.a)::uint4 = 2))
(15 rows)

set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on public.t2
         Output: a
         Filter: ((t2.a)::uint4 = 2)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: public.t2.a
         ->  Seq Scan on public.t2
               Output: public.t2.a
               Filter: (((public.t2.a)::uint4 = 2) AND ((public.t2.a)::uint4 > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Streaming(type: LOCAL GATHER dop: 1/4)
                     Output: public.t2.a
                     ->  HashAggregate
                           Output: public.t2.a
                           Group By Key: public.t2.a
                           ->  Seq Scan on public.t2
                                 Output: public.t2.a
                                 Filter: (((public.t2.a)::uint4 > 500) AND ((public.t2.a)::uint4 = 2))
(22 rows)

set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint4);
insert into t2 select generate_series(1,2550000);
insert into t2 select generate_series(1,2550000);
explain(costs off, verbose) select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on public.t2
   Output: a
   Filter: (t2.a = 2)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Seq Scan on public.t2
         Output: public.t2.a
         Filter: ((public.t2.a = 2) AND (public.t2.a > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Seq Scan on public.t2
                     Output: public.t2.a
                     Filter: ((public.t2.a > 500) AND (public.t2.a = 2))
(15 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on public.t2
         Output: a
         Filter: (t2.a = 2)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: public.t2.a
         ->  Seq Scan on public.t2
               Output: public.t2.a
               Filter: ((public.t2.a = 2) AND (public.t2.a > 500))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Streaming(type: LOCAL GATHER dop: 1/4)
                     Output: public.t2.a
                     ->  HashAggregate
                           Output: public.t2.a
                           Group By Key: public.t2.a
                           ->  Seq Scan on public.t2
                                 Output: public.t2.a
                                 Filter: ((public.t2.a > 500) AND (public.t2.a = 2))
(22 rows)

 set query_dop = 1;
drop table if exists t2 ;
create table t2(a uint8);
insert into t2 select generate_series(1,2550000);
insert into t2 select generate_series(1,2550000);
explain(costs off, verbose)   select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on public.t2
   Output: a
   Filter: (t2.a = 2::bigint)
(4 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Seq Scan on public.t2
         Output: public.t2.a
         Filter: ((public.t2.a = 2::bigint) AND (public.t2.a > 500::bigint))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Seq Scan on public.t2
                     Output: public.t2.a
                     Filter: ((public.t2.a > 500::bigint) AND (public.t2.a = 2::bigint))
(15 rows)

 set query_dop = 4;
explain(costs off, verbose)  select * from t2 where a = 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Streaming(type: LOCAL GATHER dop: 1/4)
   Output: a
   ->  Seq Scan on public.t2
         Output: a
         Filter: (t2.a = 2::bigint)
(6 rows)

explain(costs off, verbose) select * from t2 where a = 2 and t2.a in (select a from t2 where a > 500);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join
   Output: public.t2.a
   Hash Cond: (public.t2.a = public.t2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/4)
         Output: public.t2.a
         ->  Seq Scan on public.t2
               Output: public.t2.a
               Filter: ((public.t2.a = 2::bigint) AND (public.t2.a > 500::bigint))
   ->  Hash
         Output: public.t2.a
         ->  HashAggregate
               Output: public.t2.a
               Group By Key: public.t2.a
               ->  Streaming(type: LOCAL GATHER dop: 1/4)
                     Output: public.t2.a
                     ->  HashAggregate
                           Output: public.t2.a
                           Group By Key: public.t2.a
                           ->  Seq Scan on public.t2
                                 Output: public.t2.a
                                 Filter: ((public.t2.a > 500::bigint) AND (public.t2.a = 2::bigint))
(22 rows)

 set query_dop = 1;
set opfusion_debug_mode = off;
create table join_1(a uint4);
create table join_2(a uint8);
insert into join_1 select generate_series(1, 1000000);
insert into join_2 select generate_series(1, 1000000);
set query_dop = 2;
explain(costs off, verbose) select * from join_1 join join_2;
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   Output: join_1.a, join_2.a
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Materialize
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(12 rows)

explain(costs off, verbose) select * from join_1 join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 right join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Right Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select * from join_1 inner join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ nestloop(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop Left Join
   Output: join_1.a, join_2.a
   Join Filter: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Materialize
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ hashjoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

explain(costs off, verbose) select /*+ mergejoin(join_1 join_2)*/ * from join_1 left join join_2 on join_1.a = join_2.a;
WARNING:  unused hint: MergeJoin(join_1 join_2)
                     QUERY PLAN                     
----------------------------------------------------
 Hash Left Join
   Output: join_1.a, join_2.a
   Hash Cond: ((join_1.a)::uint8 = join_2.a)
   ->  Streaming(type: LOCAL GATHER dop: 1/2)
         Output: join_1.a
         ->  Seq Scan on public.join_1
               Output: join_1.a
   ->  Hash
         Output: join_2.a
         ->  Streaming(type: LOCAL GATHER dop: 1/2)
               Output: join_2.a
               ->  Seq Scan on public.join_2
                     Output: join_2.a
(13 rows)

\c postgres
drop database uint_smp;

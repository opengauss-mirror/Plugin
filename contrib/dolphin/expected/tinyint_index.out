create schema tinyint_index;
set current_schema to 'tinyint_index';
create table t1(a int1);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
insert into t1 select generate_series(-128, 127);
create index idx1 on t1(a);
analyze t1;
explain(costs off, verbose)select * from t1 where a = 1::int1;
                QUERY PLAN                 
-------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = '1'::tinyint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = '1'::tinyint)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int2;
                QUERY PLAN                
------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1::smallint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1::smallint)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int4;
              QUERY PLAN              
--------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int8;
               QUERY PLAN               
----------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1::bigint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1::bigint)
(5 rows)

select * from t1 where a = 1::int1;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int2;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int4;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int8;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

explain(costs off, verbose)select * from t1 where a > 1::int1 and a < 3::int1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a > '1'::tinyint) AND (t1.a < '3'::tinyint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a > '1'::tinyint) AND (t1.a < '3'::tinyint))
(5 rows)

explain(costs off, verbose)select * from t1 where a > 1::int2 and a < 3::int2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a > 1::smallint) AND (t1.a < 3::smallint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a > 1::smallint) AND (t1.a < 3::smallint))
(5 rows)

explain(costs off, verbose)select * from t1 where a > 1::int4 and a < 3::int4;
                   QUERY PLAN                    
-------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a > 1) AND (t1.a < 3))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a > 1) AND (t1.a < 3))
(5 rows)

explain(costs off, verbose)select * from t1 where a > 1::int8 and a < 3::int8;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a > 1::bigint) AND (t1.a < 3::bigint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a > 1::bigint) AND (t1.a < 3::bigint))
(5 rows)

select * from t1 where a > 1::int1 and a < 3::int1;
 a 
---
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
(10 rows)

select * from t1 where a > 1::int2 and a < 3::int2;
 a 
---
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
(10 rows)

select * from t1 where a > 1::int4 and a < 3::int4;
 a 
---
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
(10 rows)

select * from t1 where a > 1::int8 and a < 3::int8;
 a 
---
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
(10 rows)

explain(costs off, verbose)select * from t1 where a >= -2::int1 and a <= -1::int1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a >= (-2)::smallint) AND (t1.a <= (-1)::smallint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a >= (-2)::smallint) AND (t1.a <= (-1)::smallint))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -2::int2 and a <= -1::int2;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a >= (-2)::smallint) AND (t1.a <= (-1)::smallint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a >= (-2)::smallint) AND (t1.a <= (-1)::smallint))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -2::int4 and a <= -1::int4;
                       QUERY PLAN                        
---------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a >= (-2)) AND (t1.a <= (-1)))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a >= (-2)) AND (t1.a <= (-1)))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -2::int8 and a <= -1::int8;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: ((t1.a >= (-2)::bigint) AND (t1.a <= (-1)::bigint))
   ->  Bitmap Index Scan on idx1
         Index Cond: ((t1.a >= (-2)::bigint) AND (t1.a <= (-1)::bigint))
(5 rows)

select * from t1 where a >= -2::int1 and a <= -1::int1;
 a  
----
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
(20 rows)

select * from t1 where a >= -2::int2 and a <= -1::int2;
 a  
----
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
(20 rows)

select * from t1 where a >= -2::int4 and a <= -1::int4;
 a  
----
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
(20 rows)

select * from t1 where a >= -2::int8 and a <= -1::int8;
 a  
----
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
 -2
 -1
(20 rows)

drop index idx1;
create index idx1 on t1 using hash (a);
analyze t1;
explain(costs off, verbose)select * from t1 where a = 1::int1;
                QUERY PLAN                 
-------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = '1'::tinyint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = '1'::tinyint)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int2;
                QUERY PLAN                
------------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1::smallint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1::smallint)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int4;
              QUERY PLAN              
--------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1)
(5 rows)

explain(costs off, verbose)select * from t1 where a = 1::int8;
               QUERY PLAN               
----------------------------------------
 Bitmap Heap Scan on tinyint_index.t1
   Output: a
   Recheck Cond: (t1.a = 1::bigint)
   ->  Bitmap Index Scan on idx1
         Index Cond: (t1.a = 1::bigint)
(5 rows)

select * from t1 where a = 1::int1;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int2;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int4;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

select * from t1 where a = 1::int8;
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

drop table t1;
create table t1(a int1) with (orientation = column);
create table t2(a int4) with (orientation = column);
insert into t2 select generate_series(0, 1000000);
insert into t1 select a % 128 from t2;
create index idx1 on t1 using btree (a);
analyze t1;
explain(costs off, verbose)select * from t1 where a >= -1::int1 and a <= 0::int1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Row Adapter
   Output: a
   ->  CStore Scan on tinyint_index.t1
         Output: a
         Filter: ((t1.a >= (-1)::smallint) AND (t1.a <= '0'::tinyint))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -1::int2 and a <= 0::int2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Row Adapter
   Output: a
   ->  CStore Index Only Scan using idx1 on tinyint_index.t1
         Output: a
         Index Cond: ((t1.a >= (-1)::smallint) AND (t1.a <= 0::smallint))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -1::int4 and a <= 0::int4;
                         QUERY PLAN                          
-------------------------------------------------------------
 Row Adapter
   Output: a
   ->  CStore Index Only Scan using idx1 on tinyint_index.t1
         Output: a
         Index Cond: ((t1.a >= (-1)) AND (t1.a <= 0))
(5 rows)

explain(costs off, verbose)select * from t1 where a >= -1::int8 and a <= 0::int8;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Row Adapter
   Output: a
   ->  CStore Index Only Scan using idx1 on tinyint_index.t1
         Output: a
         Index Cond: ((t1.a >= (-1)::bigint) AND (t1.a <= 0::bigint))
(5 rows)

drop schema tinyint_index cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table t1
drop cascades to table t2
reset current_schema;

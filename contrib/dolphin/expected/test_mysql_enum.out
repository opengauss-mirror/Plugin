create schema test_enum;
set current_schema to 'test_enum';
-- create extension dolphin;
show sql_compatibility;
 sql_compatibility 
-------------------
 B
(1 row)

CREATE TABLE test (
    age INT,
    myname anonymous_enum('a','b')
);
ERROR:  anonymous enum type can't be used elsewhere.
CREATE TABLE test (
    age INT,
    myname ttanonymous_enum('a','b')
);
ERROR:  anonymous enum type can't be used elsewhere.
CREATE TABLE test (
    age INT,
    myname ttanonymous_enumtt('a','b')
);
ERROR:  anonymous enum type can't be used elsewhere.
-- when drop a column using an auto created enum type, the created enum type will also be dropped.
CREATE TABLE test (
    age INT,
    myname enum('a','b')
);
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     1
(1 row)

ALTER TABLE test DROP myname;
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     0
(1 row)

DROP TABLE test;
-- when drop a table using an auto created enum type, the created enum type will also be dropped.
CREATE TABLE test (
    age INT,
    myname enum('a','b')
);
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     1
(1 row)

DROP TABLE test;
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     0
(1 row)

-- when drop a column using an hand created enum type, the created enum type will not be dropped.
CREATE TYPE job AS enum('x','y');
CREATE TABLE test (
    age INT,
    myjob job
);
SELECT typname FROM pg_type WHERE typname = 'job';
 typname 
---------
 job
(1 row)

ALTER TABLE test DROP myjob;
SELECT typname FROM pg_type WHERE typname = 'job';
 typname 
---------
 job
(1 row)

DROP TABLE test;
-- when alter column type to others, the created enum type will not be dropped.
CREATE TABLE test (
    age INT,
    myjob enum('x','y')
);
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     1
(1 row)

insert into test values(1, 'x');
insert into test values(2, 'y');
insert into test values(4, 'y');
alter table test alter myjob type text;
SELECT COUNT(*) FROM pg_type WHERE typname like '%anonymous_enum%';
 count 
-------
     0
(1 row)

DROP TABLE test;
-- rename a type to a type contain 'anonymous_enum' is not allowed
create type test as enum('a','b');
ALTER type test RENAME TO anonymous_enum;
ERROR:  type name "anonymous_enum" can't contain "anonymous_enum"
drop type test;
-- make name more the 64
CREATE TABLE testtttttttttttttttttttttttttttttttttt (
    age INT,
    myjobbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb enum('x','y')
);
SELECT count(*) FROM pg_type WHERE typname like '%_anonymous_enum_1';
 count 
-------
     1
(1 row)

drop table testtttttttttttttttttttttttttttttttttt;
-- when drop a table using an hand created enum type, the created enum type will not be dropped.
CREATE TABLE test (
    age INT,
    myjob job
);
SELECT typname FROM pg_type WHERE typname = 'job';
 typname 
---------
 job
(1 row)

DROP TABLE test;
SELECT typname FROM pg_type WHERE typname = 'job';
 typname 
---------
 job
(1 row)

DROP TYPE job;
-- test function
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1(c_id int, c_name varchar(20), c_age enum('20', '30'));
--插入1条数据
insert into t1 values(1, 'name+' || 1, 2);
--创建存储过程，插入10条数据
create or replace procedure p_enum1 
as 
begin 
    for i in 1..3 loop
        insert into t1 values(i, 'name+' || i, 1);
    end loop;
end;
/
--调用
call p_enum1();
 p_enum1 
---------
 
(1 row)

select * from t1;
 c_id | c_name | c_age 
------+--------+-------
    1 | name+1 | 30
    1 | name+1 | 20
    2 | name+2 | 20
    3 | name+3 | 20
(4 rows)

-- not allowed to create a type with type name contained 'anonymous_enum'
CREATE TYPE country_anonymous_enum_1 AS enum('CHINA','USA');
ERROR:  enum type name "country_anonymous_enum_1" can't contain "anonymous_enum"
-- insert with existing index
CREATE TABLE test (
    age INT,
    myname enum('a','b','c')
);
INSERT INTO test (myname) VALUES (1);
-- insert with index 0 resulting in a null value
INSERT INTO test (myname) VALUES (0);
--?.*
CONTEXT:  referenced column: myname
-- insert with out-of-range index
INSERT INTO test (myname) VALUES (4);
ERROR:  enum order 4 out of the enum value size: 3
CONTEXT:  referenced column: myname
-- query with existing index
SELECT * FROM test WHERE myname=1;
 age | myname 
-----+--------
     | a
(1 row)

-- query with index 0
SELECT * FROM test WHERE myname=0;
 age | myname 
-----+--------
(0 rows)

-- query with out-of-range index
SELECT * FROM test WHERE myname=4;
 age | myname 
-----+--------
(0 rows)

-- delete with existing index
DELETE FROM test WHERE myname=1;
-- delete with index 0
DELETE FROM test WHERE myname=0;
-- delete with out-of-range index
DELETE FROM test WHERE myname=4;
DROP TABLE test;
-- foreigh key is not allowed
drop table if exists t_enum_0011_01;
NOTICE:  table "t_enum_0011_01" does not exist, skipping
CREATE TABLE t_enum_0011_01
(
W_CITY varchar(60) PRIMARY KEY,
W_ADDRESS TEXT
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t_enum_0011_01_pkey" for table "t_enum_0011_01"
 CREATE TABLE t_enum_0011_02
(
W_WAREHOUSE_SK INTEGER NOT NULL,
W_WAREHOUSE_ID CHAR(16) NOT NULL,
W_WAREHOUSE_NAME VARCHAR(20) ,
W_WAREHOUSE_SQ_FT INTEGER ,
W_STREET_NUMBER CHAR(10) ,
W_STREET_NAME VARCHAR(60) ,
W_STREET_TYPE CHAR(15) ,
W_SUITE_NUMBER CHAR(10) ,
W_CITY ENUM('xian','gansu','yanan') REFERENCES t_enum_0011_01(W_CITY),
W_COUNTY VARCHAR(30) ,
W_STATE CHAR(2) ,
W_ZIP CHAR(10) ,
W_COUNTRY VARCHAR(20) ,
W_GMT_OFFSET DECIMAL(5,2)
);
ERROR:  anoymous enum type does not support foreign key
drop table if exists chameleon_case6;
NOTICE:  table "chameleon_case6" does not exist, skipping
create table chameleon_case6(c1 enum('男','女','无'));
insert into chameleon_case6 values('女'), ('男');
select * from chameleon_case6 order by 1;
 c1 
----
 男
 女
(2 rows)

update chameleon_case6 set c1 ='无' where c1 = '女';
select * from chameleon_case6 order by 1;
 c1 
----
 男
 无
(2 rows)

drop table if exists test_abc;
NOTICE:  table "test_abc" does not exist, skipping
create table test_abc (c1 enum('c', 'b', 'a'));
insert into test_abc values('a'), ('b'), ('c');
select c1,
c1 = 'b' AS "c1 = b", c1 <> 'b' AS "c1 <> b", c1 > 'b' AS "c1 > b", c1 >= 'b' AS "c1 >= b", c1 < 'b' AS "c1 < b", c1 <= 'b' AS "c1 <= b",
'b' = c1 AS "b = c1", 'b' <> c1 AS "b <> c1", 'b' > c1 AS "b > c1", 'b' >= c1 AS "b >= c1", 'b' < c1 AS "b < c1", 'b' <= c1 AS "b <= c1"
from test_abc order by 1;
 c1 | c1 = b | c1 <> b | c1 > b | c1 >= b | c1 < b | c1 <= b | b = c1 | b <> c1 | b > c1 | b >= c1 | b < c1 | b <= c1 
----+--------+---------+--------+---------+--------+---------+--------+---------+--------+---------+--------+---------
 c  | f      | t       | t      | t       | f      | f       | f      | t       | f      | f       | t      | t
 b  | t      | f       | f      | t       | f      | t       | t      | f       | f      | t       | f      | t
 a  | f      | t       | f      | f       | t      | t       | f      | t       | t      | t       | f      | f
(3 rows)

create table enum_test_table(a enum('a', 'b', 'c'));
insert into enum_test_table values('a'), ('b'), ('c');
select * from enum_test_table where a = 1;
 a 
---
 a
(1 row)

select * from enum_test_table where a = 2;
 a 
---
 b
(1 row)

select * from enum_test_table where a = 3;
 a 
---
 c
(1 row)

select * from enum_test_table where 1 = a;
 a 
---
 a
(1 row)

select * from enum_test_table where 2 = a;
 a 
---
 b
(1 row)

select * from enum_test_table where 3 = a;
 a 
---
 c
(1 row)

select * from enum_test_table where 1 > a;
 a 
---
(0 rows)

select * from enum_test_table where 2 > a;
 a 
---
 a
(1 row)

select * from enum_test_table where 3 > a;
 a 
---
 a
 b
(2 rows)

select * from enum_test_table where 1 >= a;
 a 
---
 a
(1 row)

select * from enum_test_table where 2 >= a;
 a 
---
 a
 b
(2 rows)

select * from enum_test_table where 3 >= a;
 a 
---
 a
 b
 c
(3 rows)

select * from enum_test_table where 1 < a;
 a 
---
 b
 c
(2 rows)

select * from enum_test_table where 2 < a;
 a 
---
 c
(1 row)

select * from enum_test_table where 3 < a;
 a 
---
(0 rows)

select * from enum_test_table where 1 <= a;
 a 
---
 a
 b
 c
(3 rows)

select * from enum_test_table where 2 <= a;
 a 
---
 b
 c
(2 rows)

select * from enum_test_table where 3 <= a;
 a 
---
 c
(1 row)

select * from enum_test_table where 1 != a;
 a 
---
 b
 c
(2 rows)

select * from enum_test_table where 2 != a;
 a 
---
 a
 c
(2 rows)

select * from enum_test_table where 3 != a;
 a 
---
 a
 b
(2 rows)

select a + 1 from enum_test_table;
 ?column? 
----------
        2
        3
        4
(3 rows)

select a - 1 from enum_test_table;
 ?column? 
----------
        0
        1
        2
(3 rows)

select a * 1 from enum_test_table;
 ?column? 
----------
        1
        2
        3
(3 rows)

select a / 1 from enum_test_table;
 ?column? 
----------
        1
        2
        3
(3 rows)

create table test_enum_d(ssl_type enum('','any','X509','SPECIFIED') not null default '');
\d test_enum_d
                                                Table "test_enum.test_enum_d"
  Column  |                     Type                     |                             Modifiers                             
--?.*
--?.*

 
\d+ test_enum_d
                                                                   Table "test_enum.test_enum_d"
  Column  |                     Type                     |                             Modifiers                             | Storage | Stats target | Description 
--?.*
--?.*
Has OIDs: no
Options: orientation=row, compression=no

-- test anonymous enum backup
create table student (
     id int not null auto_increment,
     name varchar(100),
     gender enum('male', 'female'),
     non_enum enum(),
     primary key(id)
);
--?.*
--?.*
insert into student(name,gender) values('bill','male');
select * from student;
 id | name | gender | non_enum 
----+------+--------+----------
  1 | bill | male   | 
(1 row)

create table student_bak as select * from student;
select * from student_bak;
 id | name | gender | non_enum 
----+------+--------+----------
  1 | bill | male   | 
(1 row)

alter table student drop column gender;
select * from student_bak;
 id | name | gender | non_enum 
----+------+--------+----------
  1 | bill | male   | 
(1 row)

alter table student drop column non_enum;
select * from student_bak;
 id | name | gender | non_enum 
----+------+--------+----------
  1 | bill | male   | 
(1 row)

select * from pg_get_tabledef('student_bak');
             pg_get_tabledef             
-----------------------------------------
 SET search_path = test_enum;           +
 CREATE TABLE student_bak (             +
     id integer,                        +
     name character varying(100),       +
     gender enum('male', 'female'),     +
     non_enum enum()                    +
 )                                      +
 WITH (orientation=row, compression=no);
(1 row)

drop table student, student_bak cascade;
drop schema test_enum cascade;
NOTICE:  drop cascades to 12 other objects
--?.*
drop cascades to table t1
drop cascades to function p_enum1()
drop cascades to table t_enum_0011_01
--?.*
drop cascades to table chameleon_case6
--?.*
drop cascades to table test_abc
--?.*
drop cascades to table enum_test_table
--?.*
drop cascades to table test_enum_d
reset current_schema;
create schema db_b_new_gram_test3;
set current_schema to 'db_b_new_gram_test3';
create table t_charset_enum_column(c enum('a', 'b', 'c') charset test_character_set);
WARNING:  test_character_set is not a valid encoding name. default value set
drop table t_charset_enum_column;
create table t_enum_column_drop(c1 int, c2 enum('a', 'b'));
alter table t_enum_column_drop drop c2;
drop table t_enum_column_drop;
create table t_enum_column_alter_type(c1 int, c2 enum('a', 'b'));
alter table t_enum_column_alter_type drop c2;
drop table t_enum_column_alter_type;
create table t_drop_view(c1 int, c2 enum('a'));
create view my_view as select * from t_drop_view;
drop view my_view;
drop table t_drop_view;
drop schema db_b_new_gram_test3 cascade;
reset current_schema;
--
--test tailing blank for enum value
--
--expect failure with with duplicate values
create table tabenum(a enum ('a','a ') );
ERROR:  duplicate key value violates unique constraint "pg_enum_typid_label_index"
--?.*
--expect success
create table tabenum(a enum ('a ',' a'));
drop table tabenum;
--expect failure
CREATE TYPE typenum AS ENUM ( 'a', 'a ');
ERROR:  duplicate key value violates unique constraint "pg_enum_typid_label_index"
--?.*
--expect success
CREATE TYPE typenum AS ENUM ( 'a', ' a');
DROP TYPE typenum;
